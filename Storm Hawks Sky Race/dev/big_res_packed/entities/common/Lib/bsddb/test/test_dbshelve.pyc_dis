# Embedded file name: /entities/common/Lib/bsddb/test/test_dbshelve.py
"""
TestCases for checking dbShelve objects.
"""
import sys, os, string
import tempfile, random
from pprint import pprint
from types import *
import unittest
try:
    from bsddb3 import db, dbshelve
except ImportError:
    from bsddb import db, dbshelve

from test_all import verbose

class DataClass:

    def __init__(self):
        self.value = random.random()

    def __cmp__(self, other):
        return cmp(self.value, other)


class DBShelveTestCase(unittest.TestCase):

    def setUp(self):
        self.filename = tempfile.mktemp()
        self.do_open()

    def tearDown(self):
        self.do_close()
        try:
            os.remove(self.filename)
        except os.error:
            pass

    def mk(self, key):
        """Turn key into an appropriate key type for this db"""
        return key

    def populateDB(self, d):
        for x in string.letters:
            d[self.mk('S' + x)] = 10 * x
            d[self.mk('I' + x)] = ord(x)
            d[self.mk('L' + x)] = [x] * 10
            inst = DataClass()
            inst.S = 10 * x
            inst.I = ord(x)
            inst.L = [x] * 10
            d[self.mk('O' + x)] = inst

    def do_open(self):
        self.d = dbshelve.open(self.filename)

    def do_close(self):
        self.d.close()

    def test01_basics(self):
        if verbose:
            print '\n', '-=' * 30
            print 'Running %s.test01_basics...' % self.__class__.__name__
        self.populateDB(self.d)
        self.d.sync()
        self.do_close()
        self.do_open()
        d = self.d
        l = len(d)
        k = d.keys()
        s = d.stat()
        f = d.fd()
        if verbose:
            print 'length:', l
            print 'keys:', k
            print 'stats:', s
        raise 0 == d.has_key(self.mk('bad key')) or AssertionError
        raise 1 == d.has_key(self.mk('IA')) or AssertionError
        raise 1 == d.has_key(self.mk('OA')) or AssertionError
        d.delete(self.mk('IA'))
        del d[self.mk('OA')]
        raise 0 == d.has_key(self.mk('IA')) or AssertionError
        raise 0 == d.has_key(self.mk('OA')) or AssertionError
        raise len(d) == l - 2 or AssertionError
        values = []
        for key in d.keys():
            value = d[key]
            values.append(value)
            if verbose:
                print '%s: %s' % (key, value)
            self.checkrec(key, value)

        dbvalues = d.values()
        raise len(dbvalues) == len(d.keys()) or AssertionError
        values.sort()
        dbvalues.sort()
        raise values == dbvalues or AssertionError
        items = d.items()
        raise len(items) == len(values) or AssertionError
        for key, value in items:
            self.checkrec(key, value)

        raise d.get(self.mk('bad key')) == None or AssertionError
        raise d.get(self.mk('bad key'), None) == None or AssertionError
        raise d.get(self.mk('bad key'), 'a string') == 'a string' or AssertionError
        raise d.get(self.mk('bad key'), [1, 2, 3]) == [1, 2, 3] or AssertionError
        d.set_get_returns_none(0)
        self.assertRaises(db.DBNotFoundError, d.get, self.mk('bad key'))
        d.set_get_returns_none(1)
        d.put(self.mk('new key'), 'new data')
        raise d.get(self.mk('new key')) == 'new data' or AssertionError
        raise d[self.mk('new key')] == 'new data' or AssertionError
        return

    def test02_cursors(self):
        if verbose:
            print '\n', '-=' * 30
            print 'Running %s.test02_cursors...' % self.__class__.__name__
        self.populateDB(self.d)
        d = self.d
        count = 0
        c = d.cursor()
        rec = c.first()
        while rec is not None:
            count = count + 1
            if verbose:
                print rec
            key, value = rec
            self.checkrec(key, value)
            rec = c.next()

        del c
        raise count == len(d) or AssertionError
        count = 0
        c = d.cursor()
        rec = c.last()
        while rec is not None:
            count = count + 1
            if verbose:
                print rec
            key, value = rec
            self.checkrec(key, value)
            rec = c.prev()

        raise count == len(d) or AssertionError
        c.set(self.mk('SS'))
        key, value = c.current()
        self.checkrec(key, value)
        del c
        return

    def test03_append(self):
        if verbose:
            print '\n', '-=' * 30
            print 'Running %s.test03_append...' % self.__class__.__name__
        self.assertRaises(dbshelve.DBShelveError, self.d.append, 'unit test was here')

    def checkrec(self, key, value):
        x = key[1]
        raise key[0] == 'S' and (type(value) == StringType or AssertionError)
        if not value == 10 * x:
            raise AssertionError
        else:
            raise key[0] == 'I' and (type(value) == IntType or AssertionError)
            if not value == ord(x):
                raise AssertionError
            else:
                raise key[0] == 'L' and (type(value) == ListType or AssertionError)
                if not value == [x] * 10:
                    raise AssertionError
                else:
                    raise key[0] == 'O' and (type(value) == InstanceType or AssertionError)
                    raise value.S == 10 * x or AssertionError
                    raise value.I == ord(x) or AssertionError
                    if not value.L == [x] * 10:
                        raise AssertionError
                    else:
                        raise AssertionError, 'Unknown key type, fix the test'


class BasicShelveTestCase(DBShelveTestCase):

    def do_open(self):
        self.d = dbshelve.DBShelf()
        self.d.open(self.filename, self.dbtype, self.dbflags)

    def do_close(self):
        self.d.close()


class BTreeShelveTestCase(BasicShelveTestCase):
    dbtype = db.DB_BTREE
    dbflags = db.DB_CREATE


class HashShelveTestCase(BasicShelveTestCase):
    dbtype = db.DB_HASH
    dbflags = db.DB_CREATE


class ThreadBTreeShelveTestCase(BasicShelveTestCase):
    dbtype = db.DB_BTREE
    dbflags = db.DB_CREATE | db.DB_THREAD


class ThreadHashShelveTestCase(BasicShelveTestCase):
    dbtype = db.DB_HASH
    dbflags = db.DB_CREATE | db.DB_THREAD


class BasicEnvShelveTestCase(DBShelveTestCase):

    def do_open(self):
        self.homeDir = homeDir = os.path.join(os.path.dirname(sys.argv[0]), 'db_home')
        try:
            os.mkdir(homeDir)
        except os.error:
            pass

        self.env = db.DBEnv()
        self.env.open(homeDir, self.envflags | db.DB_INIT_MPOOL | db.DB_CREATE)
        self.filename = os.path.split(self.filename)[1]
        self.d = dbshelve.DBShelf(self.env)
        self.d.open(self.filename, self.dbtype, self.dbflags)

    def do_close(self):
        self.d.close()
        self.env.close()

    def tearDown(self):
        self.do_close()
        import glob
        files = glob.glob(os.path.join(self.homeDir, '*'))
        for file in files:
            os.remove(file)


class EnvBTreeShelveTestCase(BasicEnvShelveTestCase):
    envflags = 0
    dbtype = db.DB_BTREE
    dbflags = db.DB_CREATE


class EnvHashShelveTestCase(BasicEnvShelveTestCase):
    envflags = 0
    dbtype = db.DB_HASH
    dbflags = db.DB_CREATE


class EnvThreadBTreeShelveTestCase(BasicEnvShelveTestCase):
    envflags = db.DB_THREAD
    dbtype = db.DB_BTREE
    dbflags = db.DB_CREATE | db.DB_THREAD


class EnvThreadHashShelveTestCase(BasicEnvShelveTestCase):
    envflags = db.DB_THREAD
    dbtype = db.DB_HASH
    dbflags = db.DB_CREATE | db.DB_THREAD


class RecNoShelveTestCase(BasicShelveTestCase):
    dbtype = db.DB_RECNO
    dbflags = db.DB_CREATE

    def setUp(self):
        BasicShelveTestCase.setUp(self)
        self.key_pool = list(range(1, 5000))
        self.key_map = {}
        self.intkey_map = {}

    def mk(self, key):
        if key not in self.key_map:
            self.key_map[key] = self.key_pool.pop(0)
            self.intkey_map[self.key_map[key]] = key
        return self.key_map[key]

    def checkrec(self, intkey, value):
        key = self.intkey_map[intkey]
        BasicShelveTestCase.checkrec(self, key, value)

    def test03_append(self):
        if verbose:
            print '\n', '-=' * 30
            print 'Running %s.test03_append...' % self.__class__.__name__
        self.d[1] = 'spam'
        self.d[5] = 'eggs'
        self.assertEqual(6, self.d.append('spam'))
        self.assertEqual(7, self.d.append('baked beans'))
        self.assertEqual('spam', self.d.get(6))
        self.assertEqual('spam', self.d.get(1))
        self.assertEqual('baked beans', self.d.get(7))
        self.assertEqual('eggs', self.d.get(5))


def test_suite():
    suite = unittest.TestSuite()
    suite.addTest(unittest.makeSuite(DBShelveTestCase))
    suite.addTest(unittest.makeSuite(BTreeShelveTestCase))
    suite.addTest(unittest.makeSuite(HashShelveTestCase))
    suite.addTest(unittest.makeSuite(ThreadBTreeShelveTestCase))
    suite.addTest(unittest.makeSuite(ThreadHashShelveTestCase))
    suite.addTest(unittest.makeSuite(EnvBTreeShelveTestCase))
    suite.addTest(unittest.makeSuite(EnvHashShelveTestCase))
    suite.addTest(unittest.makeSuite(EnvThreadBTreeShelveTestCase))
    suite.addTest(unittest.makeSuite(EnvThreadHashShelveTestCase))
    suite.addTest(unittest.makeSuite(RecNoShelveTestCase))
    return suite


if __name__ == '__main__':
    unittest.main(defaultTest='test_suite')