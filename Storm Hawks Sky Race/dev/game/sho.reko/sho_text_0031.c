// sho_text_0031.c
// Generated by decompiling sho.exe
// using Reko decompiler version 0.10.0.0.

#include "sho.h"

// 00711280: Register Eq_3 fn00711280(Stack Eq_3 dwArg04, Register out ptr32 edxOut)
// Called from:
//      fn00747330
//      fn00747580
Eq_3 fn00711280(Eq_3 dwArg04, ptr32 & edxOut)
{
	if (dwArg04 >= 0x00)
	{
		ptr32 edx_13;
		word32 ecx_50;
		Eq_3 eax_11 = fn007050A0(dwArg04, out ecx_50, out edx_13);
		edxOut = edx_13;
		return eax_11;
	}
	else
	{
		ptr32 edx_20;
		Eq_3 eax_17 = fn00710730(dwArg04, out edx_20);
		edxOut = edx_20;
		return eax_17;
	}
}

// 00711330: Register Eq_3 fn00711330(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08)
// Called from:
//      fn006E9BD0
Eq_3 fn00711330(Eq_3 dwArg04, Eq_3 dwArg08)
{
	Eq_3 esi_13 = dwArg04;
	Eq_3 edi_17 = dwArg08;
	Eq_3 ebx_120 = 0x00;
	word32 dwLoc04_190 = 0x00;
	if (dwArg08 <= 0x00 && (dwArg08 < 0x00 || Test(ULT,false)))
	{
		esi_13 = -dwArg04;
		edi_17 = -((word32) dwArg08 + (esi_13 == 0x00));
		dwLoc04_190 = 0x01;
	}
	Eq_3 eax_42 = esi_13;
	Eq_3 ecx_43 = edi_17;
	if ((esi_13 | edi_17) != 0x00)
	{
		do
		{
			eax_42 = __shrd(eax_42, ecx_43, 0x0F);
			ecx_43 >>= 0x0F;
			ebx_120 = (word32) ebx_120 + 1;
		} while ((eax_42 | ecx_43) != 0x00);
		if (ebx_120 > 0x7FFFFFFF)
		{
			word32 ecx_275;
			word32 edx_276;
			fn006E1210(out ecx_275, out edx_276);
			return 0x00;
		}
	}
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_3 stackArg8 = <invalid>;
	Eq_3 stackArg12 = <invalid>;
	word32 edx_274;
	word32 ecx_273;
	word32 ecx_269;
	word32 edx_270;
	Eq_3 eax_108 = fn006DDD50(fn00723860(g_dwA1F414 *s ebx_120 + 0x03 + g_dwA1F410 & ~0x03, out ecx_269, out edx_270), stackArg8, stackArg12, out ecx_273, out edx_274);
	if (eax_108 != 0x00)
	{
		word16 * eax_118 = (word32) eax_108 + 0x0C;
		if (dwLoc04_190 != 0x00)
			ebx_120 = -ebx_120;
		*((word32) eax_108 + 8) = ebx_120;
		Eq_3 ecx_124 = esi_13;
		Eq_3 edx_132 = edi_17;
		if ((esi_13 | edi_17) != 0x00)
		{
			do
			{
				ecx_124 = __shrd(ecx_124, edx_132, 0x0F);
				*eax_118 = (word16) (ecx_124 & 0x7FFF);
				edx_132 >>= 0x0F;
				++eax_118;
			} while ((ecx_124 | edx_132) != 0x00);
		}
	}
	return eax_108;
}

// 00711400: Register Eq_3 fn00711400(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08)
// Called from:
//      fn006E9BD0
Eq_3 fn00711400(Eq_3 dwArg04, Eq_3 dwArg08)
{
	Eq_3 esi_10 = dwArg04;
	Eq_3 edi_14 = dwArg08;
	Eq_3 ebx_16 = 0x00;
	Eq_3 eax_20 = dwArg04;
	Eq_3 ecx_21 = dwArg08;
	if ((dwArg04 | dwArg08) != 0x00)
	{
		do
		{
			eax_20 = __shrd(eax_20, ecx_21, 0x0F);
			ecx_21 >>= 0x0F;
			ebx_16 = (word32) ebx_16 + 1;
		} while ((eax_20 | ecx_21) != 0x00);
		if (ebx_16 > 0x7FFFFFFF)
		{
			word32 ecx_194;
			word32 edx_195;
			fn006E1210(out ecx_194, out edx_195);
			return 0x00;
		}
	}
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_3 stackArg8 = <invalid>;
	Eq_3 stackArg12 = <invalid>;
	word32 ecx_192;
	word32 edx_193;
	word32 ecx_188;
	word32 edx_189;
	Eq_3 eax_73 = fn006DDD50(fn00723860(g_dwA1F414 *s ebx_16 + 0x03 + g_dwA1F410 & ~0x03, out ecx_188, out edx_189), stackArg8, stackArg12, out ecx_192, out edx_193);
	if (eax_73 != 0x00)
	{
		*((word32) eax_73 + 8) = ebx_16;
		word16 * ecx_86 = (word32) eax_73 + 0x0C;
		if ((dwArg04 | dwArg08) != 0x00)
		{
			do
			{
				esi_10 = __shrd(esi_10, edi_14, 0x0F);
				*ecx_86 = (word16) (esi_10 & 0x7FFF);
				edi_14 >>= 0x0F;
				++ecx_86;
			} while ((esi_10 | edi_14) != 0x00);
		}
	}
	return eax_73;
}

// 007114E0: Register ui32 fn007114E0(Register Eq_3 ebx, Register Eq_3 edi, Stack Eq_3 dwArg04, Register out ptr32 edxOut)
// Called from:
//      fn006E5C60
//      fn007114E0
ui32 fn007114E0(Eq_3 ebx, Eq_3 edi, Eq_3 dwArg04, ptr32 & edxOut)
{
	if (dwArg04 == 0x00)
	{
		word32 edx_464;
		fn006E1DC0(out edx_464);
		goto l007114FE;
	}
	Eq_3 eax_12 = *((word32) dwArg04 + 4);
	if (eax_12 != 0x00A1F400)
	{
		word32 edx_466;
		word32 ecx_465;
		if (fn006D5670(eax_12, 0x00A1F400, out ecx_465, out edx_466) == 0x00)
		{
			Eq_3 eax_60 = *((word32) dwArg04 + 4);
			if (eax_60 != 10610664)
			{
				word32 ecx_471;
				word32 edx_472;
				if (fn006D5670(eax_60, 10610664, out ecx_471, out edx_472) == 0x00)
				{
					Eq_3 eax_96 = *((word32) *((word32) dwArg04 + 4) + 48);
					if (eax_96 != 0x00)
					{
						<anonymous> * eax_100 = *((word32) eax_96 + 72);
						if (eax_100 != null)
						{
							struct Eq_110998 * esp_128;
							Eq_3 eax_129;
							eax_100();
							if (eax_129 != 0x00)
							{
								ptr32 ebx_184;
								ui32 edi_182;
								Eq_3 eax_139 = *((word32) eax_129 + 4);
								esp_128->t0000 = ebx;
								esp_128->tFFFFFFFC = edi;
								if (eax_139 != 10610664)
								{
									esp_128->tFFFFFFF8.u0 = 10610664;
									esp_128->tFFFFFFF4 = eax_139;
									word32 edx_481;
									word32 ecx_480;
									if (fn006D5670(esp_128->tFFFFFFF4, esp_128->tFFFFFFF8, out ecx_480, out edx_481) == 0x00)
									{
										Eq_3 eax_207 = *((word32) eax_129 + 4);
										if (eax_207 != 0x00A1F400)
										{
											esp_128->tFFFFFFF8.u0 = 0x00A1F400;
											esp_128->tFFFFFFF4 = eax_207;
											ptr32 esp_221 = esp_128 - 0x04;
											word32 edx_484;
											word32 ecx_483;
											if (fn006D5670(esp_128->tFFFFFFF4, esp_128->tFFFFFFF8, out ecx_483, out edx_484) == 0x00)
											{
												word32 v12_271 = (word32) *eax_129 - 1;
												*eax_129 = v12_271;
												if (v12_271 == 0x00)
												{
													Eq_3 ecx_275 = *((word32) eax_129 + 4);
													<anonymous> * edx_276 = *((word32) ecx_275 + 24);
													esp_128->tFFFFFFF8 = eax_129;
													word32 esp_279;
													edx_276();
													esp_221 = esp_279 + 0x04;
												}
												Eq_3 eax_288 = g_tA16B7C;
												struct Eq_111134 * esp_290 = esp_221 - 4;
												esp_290->dw0000 = 0x008D8858;
												esp_290->tFFFFFFFC = eax_288;
												// Failed to bind call argument.
												// Please report this issue at https://github.com/uxmal/reko
												Eq_3 stackArg4 = <invalid>;
												word32 edx_487;
												word32 ecx_486;
												fn006E0F80(stackArg4, dwArg04, out ecx_486, out edx_487);
												edxOut = ~0x00;
												return ~0x00;
											}
										}
										esp_128->tFFFFFFF8 = eax_129;
										// Failed to bind call argument.
										// Please report this issue at https://github.com/uxmal/reko
										Eq_3 stackArg4 = <invalid>;
										ptr32 edx_234;
										ui32 eax_233 = fn007114E0(ebx, edi, stackArg4, out edx_234);
										word32 v15_239 = (word32) *eax_129 - 1;
										*eax_129 = v15_239;
										edi_182 = eax_233;
										ebx_184 = edx_234;
										if (v15_239 == 0x00)
										{
											Eq_3 ecx_245 = *((word32) eax_129 + 4);
											<anonymous> * edx_246 = *((word32) ecx_245 + 24);
											esp_128->tFFFFFFF8 = eax_129;
											edx_246();
										}
l00711603:
										edxOut = ebx_184;
										return edi_182;
									}
								}
								esp_128->tFFFFFFF8 = eax_129;
								// Failed to bind call argument.
								// Please report this issue at https://github.com/uxmal/reko
								Eq_3 stackArg4 = <invalid>;
								word32 edi_479;
								word32 esi_478;
								word32 edx_477;
								word32 ecx_476;
								int64 edx_eax_176 = (int64) fn007051A0(edi, stackArg4, out ecx_476, out edx_477, out esi_478, out edi_479);
								word32 v17_178 = (word32) *eax_129 - 1;
								*eax_129 = v17_178;
								ui32 eax_181 = (word32) edx_eax_176;
								ptr32 edx_183 = SLICE(edx_eax_176, word32, 32);
								edi_182 = eax_181;
								ebx_184 = edx_183;
								if (v17_178 == 0x00)
								{
									Eq_3 eax_186 = *((word32) eax_129 + 4);
									<anonymous> * ecx_187 = *((word32) eax_186 + 24);
									esp_128->tFFFFFFF8 = eax_129;
									ecx_187();
									edxOut = edx_183;
									return eax_181;
								}
								goto l00711603;
							}
l007114FE:
							edxOut = ~0x00;
							return ~0x00;
						}
					}
					word32 ecx_473;
					word32 edx_474;
					fn006E0F80(g_tA16B7C, 0x008D7510, out ecx_473, out edx_474);
					edxOut = ~0x00;
					return ~0x00;
				}
			}
			word32 esi_469;
			word32 edi_470;
			word32 edx_468;
			word32 ecx_467;
			int64 edx_eax_90 = (int64) fn007051A0(edi, dwArg04, out ecx_467, out edx_468, out esi_469, out edi_470);
			edxOut = SLICE(edx_eax_90, word32, 32);
			return (word32) edx_eax_90;
		}
	}
	if (fn00710E90(dwArg04, fp - 0x08, 0x08, 0x01, 0x01) >= 0x00)
	{
		edxOut = dwLoc04;
		return dwLoc08;
	}
	goto l007114FE;
}

// 00711700: Register Eq_3 fn00711700(Stack Eq_3 dwArg04, Register out ptr32 edxOut)
// Called from:
//      fn006E5C60
Eq_3 fn00711700(Eq_3 dwArg04, ptr32 & edxOut)
{
	if (dwArg04 != 0x00)
	{
		Eq_3 eax_11 = *((word32) dwArg04 + 4);
		if (eax_11 == 0x00A1F400)
		{
l00711725:
			Eq_3 esi_59 = *((word32) dwArg04 + 8);
			Eq_3 ecx_105 = 0x00;
			Eq_3 edi_109 = 0x00;
			word32 ebp_123 = 0x01;
			if (esi_59 < 0x00)
			{
				ebp_123 = ~0x00;
				esi_59 = -esi_59;
			}
			int32 esi_110 = esi_59 - 0x01;
			if (esi_110 >= 0x00)
			{
				word16 * ebx_100 = (word32) dwArg04 + 0x0C + esi_110 * 0x02;
				do
				{
					int64 edi_ecx_155 = edx_eax_213 + edx_eax_103;
					ecx_105 = (word32) edi_ecx_155;
					edi_109 = SLICE(edi_ecx_155, word32, 32);
					word32 edx_218;
					fn00694FE0(ecx_105, edi_109, 0x8000, 0x00, out edx_218);
					int64 edx_eax_213 = <invalid>;
					int64 edx_eax_103 = (int64) (word32) *ebx_100;
					--esi_110;
					ebx_100 -= 0x02;
				} while (esi_110 >= 0x00);
			}
			int64 edx_eax_126 = (int64) ebp_123;
			ptr32 edx_139;
			Eq_3 eax_137 = fn00694FE0((word32) edx_eax_126, SLICE(edx_eax_126, word32, 32), ecx_105, edi_109, out edx_139);
			edxOut = edx_139;
			return eax_137;
		}
		word32 ecx_216;
		word32 edx_217;
		if (fn006D5670(eax_11, 0x00A1F400, out ecx_216, out edx_217) != 0x00)
			goto l00711725;
	}
	word32 edx_215;
	fn006E1DC0(out edx_215);
	edxOut = 0x00;
	return ~0x00;
}

// 00711F50: Register Eq_3 fn00711F50(Register Eq_3 eax, Register Eq_3 ecx, Register out (ptr32 word16) edxOut)
// Called from:
//      fn007120F0
Eq_3 fn00711F50(Eq_3 eax, Eq_3 ecx, word16 & edxOut)
{
	byte * esi_16 = (word32) *eax + 1;
	int32 ebx_18 = ~0x00;
	Eq_3 eax_23 = ecx;
	if (ecx != 0x00)
	{
		do
		{
			eax_23 >>= 0x01;
			++ebx_18;
		} while (eax_23 != 0x00);
	}
	byte * esi_42;
	esi_42 = esi_16;
	if (*((const char *) g_aA1EDE0 + (word32) (*esi_16) * 0x04) < ecx)
	{
		esi_42 = esi_16;
		do
		{
			esi_42 = esi_473 + 1;
			esi_473 = esi_42;
		} while (*((const char *) g_aA1EDE0 + (word32) (*esi_473) * 0x04) < ecx);
	}
	*eax = esi_42;
	int32 edi_60 = esi_42 - esi_16;
	int32 ecx_65 = edi_60 *s ebx_18;
	if ((int32) ((int64) (ecx_65 + 0x0E) /32 ebx_18) >= edi_60)
	{
		int32 edx_79 = SLICE((ecx_65 + 0x0E) *s64 0x88888889, word32, 32) + (ecx_65 + 0x0E);
		Eq_111335 ebp_94 = (edx_79 >> 0x03 >> 0x1F) + (edx_79 >> 0x03);
		if (ebp_94 <= 0x7FFFFFFF)
		{
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg8 = <invalid>;
			Eq_3 stackArg12 = <invalid>;
			word16 * edx_127;
			word32 ecx_467;
			word32 ecx_471;
			word32 edx_468;
			Eq_3 eax_126 = fn006DDD50(fn00723860(g_dwA1F414 *s ebp_94 + 0x03 + g_dwA1F410 & ~0x03, out ecx_467, out edx_468), stackArg8, stackArg12, out ecx_471, out edx_127);
			if (eax_126 != 0x00)
			{
				byte * esi_137 = esi_42 - 0x01;
				uint32 edi_138 = 0x00;
				word16 * edx_141 = (word32) eax_126 + 0x0C;
				if (esi_137 >= esi_16)
				{
					int32 ecx_153 = 0x00;
					do
					{
						ecx_153 += ebx_18;
						uint32 edi_155 = edi_138 | *((const char *) g_aA1EDE0 + (word32) (*esi_137) * 0x04) << (byte) ecx_153;
						if (ecx_153 >= 0x0F)
						{
							*edx_141 = (word16) (edi_155 & 0x7FFF);
							++edx_141;
							ecx_153 -= 0x0F;
							edi_155 >>= 0x0F;
						}
						word16 di_178 = (word16) edi_155;
						--esi_137;
						edi_138 = edi_155;
					} while (esi_137 >= esi_16);
					if (ecx_153 != 0x00)
					{
						*edx_141 = di_178;
						++edx_141;
					}
				}
				word32 ecx_190 = edx_141 - eax_126;
				int32 ecx_191 = ecx_190 + ~0x0B;
				if (ecx_190 + ~0x0B >> 0x01 < ebp_94)
				{
					do
					{
						*edx_141 = 0x00;
						ecx_191 += 0x02;
						++edx_141;
					} while (ecx_191 >> 0x01 < ebp_94);
				}
				Eq_3 edi_219 = *((word32) eax_126 + 8);
				Eq_3 esi_222 = edi_219;
				if (edi_219 < 0x00)
					esi_222 = -edi_219;
				Eq_3 ecx_230 = esi_222;
				if (esi_222 > 0x00)
				{
					edx_141 = (word32) eax_126 + 0x0A + esi_222 * 0x02;
					while (*edx_141 == 0x00)
					{
						--ecx_230;
						edx_141 -= 0x02;
						if (ecx_230 <= 0x00)
							break;
					}
					if (ecx_230 != esi_222)
					{
						if (edi_219 < 0x00)
							ecx_230 = -ecx_230;
						*((word32) eax_126 + 8) = ecx_230;
					}
				}
				edxOut = edx_141;
				return eax_126;
			}
			else
			{
				edxOut = edx_127;
				return eax_126;
			}
		}
		else
		{
			word16 * edx_294;
			word32 ecx_472;
			fn006E1210(out ecx_472, out edx_294);
			edxOut = edx_294;
			return 0x00;
		}
	}
	else
	{
		word16 * edx_316;
		word32 ecx_466;
		fn006E0F80(g_tA17E2C, 0x008D8890, out ecx_466, out edx_316);
		edxOut = edx_316;
		return 0x00;
	}
}

// 007120F0: Register Eq_3 fn007120F0(Register (ptr16 Eq_7) es, Register (ptr16 Eq_8) ds, Stack Eq_3 dwArg04, Stack (ptr32 Eq_3) dwArg08, Stack Eq_3 dwArg0C, Register out Eq_3 edxOut)
// Called from:
//      fn0073D140
Eq_3 fn007120F0(struct Eq_7 * es, struct Eq_8 * ds, Eq_3 dwArg04, union Eq_3 * dwArg08, Eq_3 dwArg0C, union Eq_3 & edxOut)
{
	Eq_3 edi_100 = dwArg04;
	int32 dwLoc14_1168 = 0x01;
	if (dwArg0C != 0x00 && dwArg0C < 0x02 || dwArg0C > 0x24)
	{
		word32 ecx_1797;
		Eq_3 edx_1125;
		fn006E0F80(g_tA17E2C, 0x008D88E0, out ecx_1797, out edx_1125);
		edxOut = edx_1125;
		return 0x00;
	}
	byte al_25 = *dwArg04;
	if (al_25 != 0x00)
	{
		while (isspace((word32) al_25) != 0x00)
		{
			al_25 = (byte) *((word32) edi_100 + 1);
			edi_100 = (word32) edi_100 + 1;
			if (al_25 == 0x00)
				break;
		}
		dwArg04 = edi_100;
	}
	byte al_56 = *edi_100;
	if (al_56 != 0x2B)
	{
		if (al_56 != 0x2D)
		{
l00712174:
			byte al_70 = *edi_100;
			if (al_70 != 0x00)
			{
				while (isspace((word32) al_70) != 0x00)
				{
					al_70 = (byte) *((word32) edi_100 + 1);
					edi_100 = (word32) edi_100 + 1;
					if (al_70 == 0x00)
						break;
				}
				dwArg04 = edi_100;
			}
			Eq_3 ebx_107 = dwArg0C;
			if (dwArg0C == 0x00)
			{
				if (*edi_100 != 0x30)
				{
					ebx_107.u0 = 0x0A;
					dwArg0C.u0 = 0x0A;
					goto l007121EC;
				}
				byte al_118 = *((word32) edi_100 + 1);
				if (al_118 != 0x78 && al_118 != 88)
				{
					ebx_107.u0 = 0x08;
					dwArg0C.u0 = 0x08;
					goto l007121EC;
				}
				ebx_107.u0 = 0x10;
				dwArg0C.u0 = 0x10;
			}
			else if (dwArg0C != 0x10)
				goto l007121EC;
			if (*edi_100 == 0x30)
			{
				byte al_133 = *((word32) edi_100 + 1);
				if (al_133 == 0x78 || al_133 == 88)
				{
					edi_100 = (word32) edi_100 + 2;
					dwArg04 = edi_100;
				}
			}
l007121EC:
			Eq_3 edi_1070;
			Eq_3 edx_1001;
			Eq_3 ebp_321;
			if ((ebx_107 & ebx_107 - 0x01) == 0x00)
			{
				edi_1070 = dwArg04;
				ebp_321 = fn00711F50(fp + 0x04, ebx_107, out edx_1001);
			}
			else
			{
				if (!PARITY_EVEN(g_aA6D418[ebx_107 * 0x08] - 0.0))
				{
					g_aA6D418[ebx_107 * 0x08] = lg2(0.6931471805599453) * 0.6931471805599453 / (lg2(0.6931471805599453) * 0.6931471805599453);
					Eq_3 eax_217;
					Eq_3 ecx_224 = ebx_107;
					word32 edx_225 = 0x01;
					for (eax_217 = ebx_107 *s ebx_107; eax_217 <= 0x8000; eax_217 *= ebx_107)
					{
						ecx_224 = eax_217;
						++edx_225;
					}
					*((const char *) g_aA6D5D8 + ebx_107 * 0x04) = (union Eq_3 *) ecx_224;
					g_aA6D540[ebx_107 * 0x04] = edx_225;
				}
				Eq_3 esi_260 = (word32) edi_100 + 1;
				if (*((const char *) g_aA1EDE0 + (word32) (*edi_100) * 0x04) < ebx_107)
				{
					do
					{
						esi_260 = (word32) esi_1809 + 1;
						esi_1809 = esi_260;
					} while (*((const char *) g_aA1EDE0 + (word32) (*esi_1809) * 0x04) < ebx_107);
				}
				word32 eax_292 = fn00695040((real64) (esi_260 - edi_100) * g_aA6D418[ebx_107 * 0x08]);
				Eq_3 eax_316 = fn007105C0(eax_292 + 0x01, out edx_1001);
				dwArg04 = eax_292 + 0x01;
				ebp_321 = eax_316;
				struct Eq_111911 * esp_322 = fp - 44;
				if (eax_316 == 0x00)
				{
l0071257C:
					edxOut = edx_1001;
					return 0x00;
				}
				((word32) eax_316 + 8)->u0 = 0x00;
				edx_1001 = *((const char *) g_aA6D5D8 + ebx_107 * 0x04);
				edi_1070 = edi_100;
				if (edi_100 < esi_260)
				{
					edi_1070 = edi_100;
					do
					{
						int32 edx_341 = esp_322->dw001C;
						Eq_111943 esi_342 = (word32) *((const char *) g_aA1EDE0 + (word32) (*edi_1070) * 0x04);
						int32 eax_343 = 0x01;
						edi_1070 = (word32) edi_1070 + 1;
						if (edx_341 > 0x01)
						{
							while (edi_1070 != esp_322->dw0014)
							{
								esi_342 = (const char *) *((const char *) g_aA1EDE0 + (word32) (*edi_1070) * 0x04) + esi_342 *s ebx_107;
								++eax_343;
								edi_1070 = (word32) edi_1070 + 1;
								if (eax_343 >= edx_341)
									break;
							}
						}
						Eq_3 ecx_1136 = esp_322[4];
						if (eax_343 != edx_341)
						{
							ecx_1136 = ebx_107;
							if (eax_343 > 0x01)
							{
								int32 eax_375 = eax_343 + ~0x00;
								do
								{
									ecx_1136 *= ebx_107;
									--eax_375;
								} while (eax_375 != 0x00);
							}
						}
						Eq_3 eax_392 = (word32) ebp_321 + 0x0C;
						edx_1001 = (word32) eax_392 + *((word32) ebp_321 + 8) * 0x02;
						if (eax_392 < edx_1001)
						{
							do
							{
								uint32 esi_402 = (word32) esi_342 + (word32) (*eax_392) *s ecx_1136;
								*eax_392 = (word16) (esi_402 & 0x7FFF);
								eax_392 = (word32) eax_392 + 2;
								esi_342 = esi_402 >> 0x0F;
							} while (eax_392 < edx_1001);
							ebx_107 = esp_322[7];
						}
						word16 si_561 = (word16) esi_342;
						if (esi_342 != 0x00)
						{
							if (*((word32) ebp_321 + 8) < esp_322[6])
							{
								*eax_392 = si_561;
								*((word32) ebp_321 + 8) = (word32) *((word32) ebp_321 + 8) + 1;
								goto l0071249B;
							}
							struct Eq_111911 * esp_453;
							if (esp_322[2] > 0x7FFFFFFF)
							{
								word32 ecx_1803;
								fn006E1210(out ecx_1803, out edx_1001);
								esp_453 = esp_322;
l007124AF:
								word32 v35_497 = (word32) *ebp_321 - 1;
								*ebp_321 = v35_497;
								if (v35_497 != 0x00)
									goto l0071257C;
								Eq_3 ecx_501 = *((word32) ebp_321 + 4);
								<anonymous> * edx_502 = *((word32) ecx_501 + 24);
								esp_453->tFFFFFFFC = ebp_321;
								Eq_3 edx_514;
								edx_502();
								edxOut = edx_514;
								return 0x00;
							}
							Eq_3 eax_459 = esp_322[2];
							word32 edx_460 = g_dwA1F410;
							struct Eq_112068 * esp_461 = esp_322 - 4;
							esp_461->t0000 = eax_459;
							int32 eax_464 = eax_459 *s g_dwA1F414 + 0x03 + edx_460;
							esp_461->tFFFFFFFC.u0 = 0x00A1F400;
							esp_461->tFFFFFFF8 = eax_464 & ~0x03;
							word32 edx_1805;
							word32 ecx_1804;
							esp_461->tFFFFFFF8 = fn00723860(esp_461->tFFFFFFF8, out ecx_1804, out edx_1805);
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							Eq_3 stackArg4 = <invalid>;
							Eq_3 stackArg12 = <invalid>;
							word32 ecx_1808;
							Eq_3 eax_484 = fn006DDD50(stackArg4, eax_292 + 0x01, stackArg12, out ecx_1808, out edx_1001);
							esp_453 = (struct Eq_111911 *) ((const char *) &esp_461->t0004 + 4);
							if (eax_484 == 0x00)
								goto l007124AF;
							esp_461->t0004 = esp_461->dw0038 * 0x02;
							esp_461->t0000 = (word32) ebp_321 + 0x0C;
							esp_461->tFFFFFFFC = (word32) eax_484 + 0x0C;
							memcpy(esp_461->tFFFFFFFC, esp_461->t0000, esp_461->t0004);
							word32 v33_541 = (word32) *ebp_321 - 1;
							*ebp_321 = v33_541;
							esp_322 = (struct Eq_111911 *) ((const char *) &esp_461->t0004 + 4);
							if (v33_541 == 0x00)
							{
								Eq_3 edx_545 = *((word32) ebp_321 + 4);
								<anonymous> * eax_546 = *((word32) edx_545 + 24);
								esp_461->t0004 = ebp_321;
								word32 esp_549;
								eax_546();
								esp_322 = esp_549 + 0x04;
							}
							int32 eax_559 = esp_322[6];
							*((word32) eax_484 + (eax_559 * 0x02 + 0x0C)) = si_561;
							esp_322[2] = (struct Eq_111911) ((word32) esp_322[2].tFFFFFFFC + 5);
							ebx_107 = esp_322[7];
							esp_322[6] = (struct Eq_111911) (eax_559 + 0x01);
							ebp_321 = eax_484;
						}
l0071249B:
					} while (edi_1070 < esp_322->dw0014);
				}
			}
			if (ebp_321 != 0x00)
			{
				if (edi_1070 != edi_100)
				{
					if (dwLoc14_1168 < 0x00)
						*((word32) ebp_321 + 8) = -*((word32) ebp_321 + 8);
					byte al_622 = *edi_1070;
					if (al_622 == 0x4C || al_622 == 0x6C)
						edi_1070 = (word32) edi_1070 + 1;
					byte al_1069 = *edi_1070;
					while (al_1069 != 0x00)
					{
						if (isspace((word32) al_1069) == 0x00)
						{
							if (*edi_1070 != 0x00)
								goto l007124D8;
							break;
						}
						al_1069 = (byte) *((word32) edi_1070 + 1);
						edi_1070 = (word32) edi_1070 + 1;
					}
					if (dwArg08 != null)
						*dwArg08 = (union Eq_3 *) edi_1070;
					edxOut = edx_1001;
					return ebp_321;
				}
l007124D8:
				word32 v16_654 = (word32) *ebp_321 - 1;
				*ebp_321 = v16_654;
				struct Eq_111625 * esp_660 = fp - 44;
				if (v16_654 == 0x00)
				{
					Eq_3 edx_658 = *((word32) ebp_321 + 4);
					word32 esp_685;
					(*((word32) edx_658 + 24))();
					esp_660 = esp_685 + 0x04;
				}
				byte * esi_695 = esp_660->ptr0028;
				byte * eax_696 = esi_695;
				do
				{
					eax_696 = eax_1810 + 1;
					eax_1810 = eax_696;
				} while (*eax_1810 != 0x00);
				Eq_3 eax_709;
				if (eax_696 - (esi_695 + 1) < 200)
				{
					byte * eax_711 = esi_695;
					do
					{
						eax_711 = eax_1811 + 1;
						eax_1811 = eax_711;
					} while (*eax_1811 != 0x00);
					eax_709 = eax_711 - (esi_695 + 1);
				}
				else
					eax_709.u0 = 200;
				struct Eq_111719 * esp_729 = esp_660 - 4;
				esp_729->t0000 = eax_709;
				esp_729->ptrFFFFFFFC = esi_695;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_3 stackArg4 = <invalid>;
				word32 ecx_1799;
				Eq_3 eax_755 = fn006EC9B0(stackArg4, dwArg04, out ecx_1799, out edx_1001);
				if (eax_755 != 0x00)
				{
					esp_729->t0000 = eax_755;
					word32 edi_1800;
					Eq_3 eax_977 = fn006DDDB0(eax_755, edx_1001, ebx_107, eax_755, edi_1070, es, ds, esp_729->t0000, out edx_1001, out edi_1800);
					word32 v18_989 = (word32) *eax_755 - 1;
					*eax_755 = v18_989;
					ptr32 esp_1004 = (const char *) &esp_729->t0004 + 4;
					if (v18_989 == 0x00)
					{
						Eq_3 ecx_994 = *((word32) eax_755 + 4);
						<anonymous> * edx_995 = *((word32) ecx_994 + 24);
						esp_729->t0004 = eax_755;
						word32 esp_998;
						edx_995();
						esp_1004 = esp_998 + 0x04;
					}
					if (eax_977 != 0x00)
					{
						Eq_3 ecx_1011 = g_tA17E2C;
						struct Eq_111782 * esp_1014 = esp_1004 - 4;
						esp_1014->t0000 = (word32) eax_977 + 20;
						esp_1014->tFFFFFFFC = ebx_107;
						esp_1014->dwFFFFFFF8 = 9275572;
						esp_1014->tFFFFFFF4 = ecx_1011;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_3 stackArg4 = <invalid>;
						word32 ecx_1802;
						fn006E15D0(stackArg4, dwArg04, out ecx_1802, out edx_1001);
						word32 v19_1040 = (word32) *eax_977 - 1;
						*eax_977 = v19_1040;
						if (v19_1040 == 0x00)
						{
							Eq_3 edx_1044 = *((word32) eax_977 + 4);
							<anonymous> * eax_1045 = *((word32) edx_1044 + 24);
							esp_1014->t0000 = eax_977;
							eax_1045();
						}
					}
				}
			}
			goto l0071257C;
		}
		dwLoc14_1168 = ~0x00;
	}
	edi_100 = (word32) edi_100 + 1;
	dwArg04 = edi_100;
	goto l00712174;
}

// 00715640: void fn00715640(Stack Eq_3 dwArg04)
// Called from:
//      fn00715A70
void fn00715640(Eq_3 dwArg04)
{
	struct Eq_112221 * esp_103 = fp - 8;
	if (g_tA74AF0 != 0x00 && *((word32) dwArg04 + 8) != 0x00)
	{
		struct Eq_112240 * esp_18;
		word32 eax_19;
		word32 ecx_20;
		word32 edx_21;
		_iob_func();
		esp_18->tFFFFFFFC = eax_19 + 0x40;
		fprintf(esp_18->tFFFFFFFC, esp_18->t0000, 0x00);
		esp_103 = (struct Eq_112221 *) ((const char *) &esp_18->t0000 + 4);
	}
	Eq_3 eax_32 = *((word32) dwArg04 + 8);
	if (eax_32 != 0x00)
	{
		((word32) dwArg04 + 8)->u0 = 0x00;
		word32 v10_37 = (word32) *eax_32 - 1;
		*eax_32 = v10_37;
		if (v10_37 == 0x00)
		{
			Eq_3 ecx_41 = *((word32) eax_32 + 4);
			<anonymous> * edx_42 = *((word32) ecx_41 + 24);
			esp_103->tFFFFFFFC = eax_32;
			word32 esp_47;
			word32 edx_50;
			edx_42();
			esp_103 = esp_47 + 0x04;
		}
	}
	Eq_3 eax_57 = *((word32) dwArg04 + 64);
	if (eax_57 != 0x00)
	{
		((word32) dwArg04 + 64)->u0 = 0x00;
		word32 v13_62 = (word32) *eax_57 - 1;
		*eax_57 = v13_62;
		if (v13_62 == 0x00)
		{
			Eq_3 ecx_66 = *((word32) eax_57 + 4);
			<anonymous> * edx_67 = *((word32) ecx_66 + 24);
			esp_103->tFFFFFFFC = eax_57;
			word32 esp_72;
			word32 edx_75;
			edx_67();
			esp_103 = esp_72 + 0x04;
		}
	}
	Eq_3 eax_82 = *((word32) dwArg04 + 76);
	if (eax_82 != 0x00)
	{
		((word32) dwArg04 + 76)->u0 = 0x00;
		word32 v14_87 = (word32) *eax_82 - 1;
		*eax_82 = v14_87;
		if (v14_87 == 0x00)
		{
			Eq_3 ecx_91 = *((word32) eax_82 + 4);
			<anonymous> * edx_92 = *((word32) ecx_91 + 24);
			esp_103->tFFFFFFFC = eax_82;
			word32 esp_97;
			word32 edx_100;
			edx_92();
			esp_103 = esp_97 + 0x04;
		}
	}
	Eq_3 eax_107 = *((word32) dwArg04 + 40);
	if (eax_107 != 0x00)
	{
		((word32) dwArg04 + 40)->u0 = 0x00;
		word32 v15_112 = (word32) *eax_107 - 1;
		*eax_107 = v15_112;
		if (v15_112 == 0x00)
		{
			Eq_3 ecx_116 = *((word32) eax_107 + 4);
			<anonymous> * edx_117 = *((word32) ecx_116 + 24);
			esp_103->tFFFFFFFC = eax_107;
			word32 esp_122;
			word32 edx_125;
			edx_117();
			esp_103 = esp_122 + 0x04;
		}
	}
	Eq_3 eax_132 = *((word32) dwArg04 + 44);
	if (eax_132 != 0x00)
	{
		((word32) dwArg04 + 44)->u0 = 0x00;
		word32 v16_137 = (word32) *eax_132 - 1;
		*eax_132 = v16_137;
		if (v16_137 == 0x00)
		{
			Eq_3 ecx_141 = *((word32) eax_132 + 4);
			<anonymous> * edx_142 = *((word32) ecx_141 + 24);
			esp_103->tFFFFFFFC = eax_132;
			word32 esp_147;
			word32 edx_150;
			edx_142();
			esp_103 = esp_147 + 0x04;
		}
	}
	Eq_3 eax_157 = *((word32) dwArg04 + 48);
	if (eax_157 != 0x00)
	{
		((word32) dwArg04 + 48)->u0 = 0x00;
		word32 v17_162 = (word32) *eax_157 - 1;
		*eax_157 = v17_162;
		if (v17_162 == 0x00)
		{
			Eq_3 ecx_166 = *((word32) eax_157 + 4);
			<anonymous> * edx_167 = *((word32) ecx_166 + 24);
			esp_103->tFFFFFFFC = eax_157;
			word32 esp_172;
			word32 edx_175;
			edx_167();
			esp_103 = esp_172 + 0x04;
		}
	}
	Eq_3 eax_182 = *((word32) dwArg04 + 52);
	if (eax_182 != 0x00)
	{
		((word32) dwArg04 + 52)->u0 = 0x00;
		word32 v18_187 = (word32) *eax_182 - 1;
		*eax_182 = v18_187;
		if (v18_187 == 0x00)
		{
			Eq_3 ecx_191 = *((word32) eax_182 + 4);
			<anonymous> * edx_192 = *((word32) ecx_191 + 24);
			esp_103->tFFFFFFFC = eax_182;
			word32 esp_197;
			word32 edx_200;
			edx_192();
			esp_103 = esp_197 + 0x04;
		}
	}
	Eq_3 eax_207 = *((word32) dwArg04 + 56);
	if (eax_207 != 0x00)
	{
		((word32) dwArg04 + 56)->u0 = 0x00;
		word32 v19_212 = (word32) *eax_207 - 1;
		*eax_207 = v19_212;
		if (v19_212 == 0x00)
		{
			Eq_3 ecx_216 = *((word32) eax_207 + 4);
			<anonymous> * edx_217 = *((word32) ecx_216 + 24);
			esp_103->tFFFFFFFC = eax_207;
			word32 esp_222;
			word32 edx_225;
			edx_217();
			esp_103 = esp_222 + 0x04;
		}
	}
	Eq_3 eax_232 = *((word32) dwArg04 + 60);
	if (eax_232 != 0x00)
	{
		((word32) dwArg04 + 60)->u0 = 0x00;
		word32 v20_237 = (word32) *eax_232 - 1;
		*eax_232 = v20_237;
		if (v20_237 == 0x00)
		{
			Eq_3 ecx_241 = *((word32) eax_232 + 4);
			<anonymous> * edx_242 = *((word32) ecx_241 + 24);
			esp_103->tFFFFFFFC = eax_232;
			word32 esp_247;
			word32 edx_250;
			edx_242();
			esp_103 = esp_247 + 0x04;
		}
	}
	Eq_3 eax_257 = *((word32) dwArg04 + 32);
	*((word32) dwArg04 + 24) = null;
	((word32) dwArg04 + 28)->u0 = 0x00;
	if (eax_257 != 0x00)
	{
		((word32) dwArg04 + 32)->u0 = 0x00;
		word32 v21_264 = (word32) *eax_257 - 1;
		*eax_257 = v21_264;
		if (v21_264 == 0x00)
		{
			Eq_3 ecx_268 = *((word32) eax_257 + 4);
			<anonymous> * edx_269 = *((word32) ecx_268 + 24);
			esp_103->tFFFFFFFC = eax_257;
			word32 edx_277;
			edx_269();
		}
	}
	struct Eq_112594 * eax_284 = *((word32) dwArg04 + 36);
	if (eax_284 == null)
		return;
	*((word32) dwArg04 + 36) = null;
	word32 v22_289 = eax_284->dw0000 + ~0x00;
	eax_284->dw0000 = v22_289;
	if (v22_289 != 0x00)
		return;
	struct Eq_112642 * ecx_300 = eax_284->ptr0004;
	word32 edx_311;
	ecx_300->ptr0018();
}

// 007157B0: void fn007157B0(Register Eq_3 edi)
// Called from:
//      fn00715B80
void fn007157B0(Eq_3 edi)
{
	if (edi == 0x00)
		fn006E86F0(0x008D8A4C);
	Eq_3 esi_23 = *((word32) edi + 4);
	if (esi_23 == 0x00)
		fn006E86F0(0x008D8A28);
	word32 ecx_113;
	fn0074F540(g_tA6D66C, 0x01, out ecx_113);
	Eq_3 esi_51 = (word32) esi_23 + 4;
	while (true)
	{
		if (*esi_51 == 0x00)
			fn006E86F0(0x008D8A00);
		Eq_3 eax_70 = *esi_51;
		if (eax_70 == edi)
			break;
		esi_51 = eax_70;
	}
	Eq_3 edx_75 = g_tA6D66C;
	*esi_51 = *edi;
	fn0074F570(edx_75);
	free(edi);
}

// 007158B0: Register Eq_3 fn007158B0(Stack Eq_3 dwArg04, Register out Eq_3 ecxOut)
// Called from:
//      fn006E8910
//      fn00706BE0
//      fn00706C20
//      fn00708DC0
Eq_3 fn007158B0(Eq_3 dwArg04, union Eq_3 & ecxOut)
{
	Eq_3 eax_6 = g_tA6D67C;
	g_tA6D67C = dwArg04;
	ecxOut = dwArg04;
	return eax_6;
}

// 007159F0: void fn007159F0()
// Called from:
//      fn006E8910
void fn007159F0()
{
	fn0074F5E0(g_tA6D674);
	g_tA6D674.u0 = 0x00;
	g_dwA6D670 = 0x00;
}

// 00715A70: void fn00715A70(Stack Eq_3 dwArg04)
// Called from:
//      fn006E8910
void fn00715A70(Eq_3 dwArg04)
{
	word32 ecx_347;
	fn0074F540(g_tA6D66C, 0x01, out ecx_347);
	Eq_3 edi_26 = *((word32) dwArg04 + 4);
	while (edi_26 != 0x00)
	{
		fn00715640(edi_26);
		edi_26 = *edi_26;
	}
	fn0074F570(g_tA6D66C);
	struct Eq_58241 * eax_59 = *((word32) dwArg04 + 24);
	struct Eq_112740 * esp_108 = fp - 0x0C;
	if (eax_59 != null)
	{
		*((word32) dwArg04 + 24) = null;
		word32 v12_65 = eax_59->t0000 + ~0x00;
		eax_59->t0000 = (<anonymous>) v12_65;
		if (v12_65 == 0x00)
		{
			struct Eq_112775 * edx_69 = eax_59->ptr0004;
			word32 esp_76;
			edx_69->ptr0018();
			esp_108 = esp_76 + 0x04;
		}
	}
	Eq_3 eax_86 = *((word32) dwArg04 + 28);
	if (eax_86 != 0x00)
	{
		((word32) dwArg04 + 28)->u0 = 0x00;
		word32 v14_91 = (word32) *eax_86 - 1;
		*eax_86 = v14_91;
		if (v14_91 == 0x00)
		{
			Eq_3 ecx_95 = *((word32) eax_86 + 4);
			<anonymous> * edx_96 = *((word32) ecx_95 + 24);
			esp_108->tFFFFFFFC = eax_86;
			word32 esp_102;
			word32 edx_105;
			edx_96();
			esp_108 = esp_102 + 0x04;
		}
	}
	Eq_3 eax_112 = *((word32) dwArg04 + 32);
	if (eax_112 != 0x00)
	{
		((word32) dwArg04 + 32)->u0 = 0x00;
		word32 v15_117 = (word32) *eax_112 - 1;
		*eax_112 = v15_117;
		if (v15_117 == 0x00)
		{
			Eq_3 ecx_121 = *((word32) eax_112 + 4);
			<anonymous> * edx_122 = *((word32) ecx_121 + 24);
			esp_108->tFFFFFFFC = eax_112;
			word32 esp_128;
			word32 edx_131;
			edx_122();
			esp_108 = esp_128 + 0x04;
		}
	}
	Eq_3 eax_138 = *((word32) dwArg04 + 8);
	if (eax_138 != 0x00)
	{
		((word32) dwArg04 + 8)->u0 = 0x00;
		word32 v16_143 = (word32) *eax_138 - 1;
		*eax_138 = v16_143;
		if (v16_143 == 0x00)
		{
			Eq_3 ecx_147 = *((word32) eax_138 + 4);
			<anonymous> * edx_148 = *((word32) ecx_147 + 24);
			esp_108->tFFFFFFFC = eax_138;
			word32 esp_154;
			word32 edx_157;
			edx_148();
			esp_108 = esp_154 + 0x04;
		}
	}
	Eq_3 eax_164 = *((word32) dwArg04 + 20);
	if (eax_164 != 0x00)
	{
		((word32) dwArg04 + 20)->u0 = 0x00;
		word32 v17_169 = (word32) *eax_164 - 1;
		*eax_164 = v17_169;
		if (v17_169 == 0x00)
		{
			Eq_3 ecx_173 = *((word32) eax_164 + 4);
			<anonymous> * edx_174 = *((word32) ecx_173 + 24);
			esp_108->tFFFFFFFC = eax_164;
			word32 esp_180;
			word32 edx_183;
			edx_174();
			esp_108 = esp_180 + 0x04;
		}
	}
	Eq_3 eax_190 = *((word32) dwArg04 + 0x0C);
	if (eax_190 != 0x00)
	{
		((word32) dwArg04 + 0x0C)->u0 = 0x00;
		word32 v18_195 = (word32) *eax_190 - 1;
		*eax_190 = v18_195;
		if (v18_195 == 0x00)
		{
			Eq_3 ecx_199 = *((word32) eax_190 + 4);
			<anonymous> * edx_200 = *((word32) ecx_199 + 24);
			esp_108->tFFFFFFFC = eax_190;
			word32 edx_209;
			edx_200();
		}
	}
	Eq_3 eax_216 = *((word32) dwArg04 + 16);
	if (eax_216 == 0x00)
		return;
	((word32) dwArg04 + 16)->u0 = 0x00;
	word32 v19_221 = (word32) *eax_216 - 1;
	*eax_216 = v19_221;
	if (v19_221 != 0x00)
		return;
	Eq_3 ecx_234 = *((word32) eax_216 + 4);
	word32 edx_247;
	(*((word32) ecx_234 + 24))();
}

// 00715B80: void fn00715B80(Register Eq_3 esi)
// Called from:
//      fn00715BD0
void fn00715B80(Eq_3 esi)
{
	Eq_3 edi_12 = *((word32) esi + 4);
	while (edi_12 != 0x00)
	{
		if (edi_12 == g_tA6D67C)
			fn006E86F0(0x008D8A70);
		fn007157B0(edi_12);
		Eq_3 eax_35 = g_tA6D674;
		if (eax_35 != 0x00 && fn0074F7F0(eax_35) == edi_12)
			fn0074F810(g_tA6D674);
		edi_12 = *((word32) esi + 4);
	}
}

// 00715BD0: void fn00715BD0(Stack Eq_3 dwArg04)
// Called from:
//      fn006E8910
void fn00715BD0(Eq_3 dwArg04)
{
	fn00715B80(dwArg04);
	word32 ecx_110;
	fn0074F540(g_tA6D66C, 0x01, out ecx_110);
	Eq_3 edi_31 = 10933880;
	while (true)
	{
		if (*edi_31 == 0x00)
			fn006E86F0(0x008D8BC4);
		Eq_3 eax_48 = *edi_31;
		if (eax_48 == dwArg04)
			break;
		edi_31 = eax_48;
	}
	if (*((word32) dwArg04 + 4) != 0x00)
		fn006E86F0(0x008D8B94);
	Eq_3 edx_66 = g_tA6D66C;
	*edi_31 = *dwArg04;
	fn0074F570(edx_66);
	free(dwArg04);
}

// 00715DD0: Register Eq_3 fn00715DD0(Register out Eq_3 ecxOut, Register out ptr32 edxOut)
// Called from:
//      fn006E1780
//      fn006E7CE0
//      fn006E8060
//      fn006E8730
//      fn006E8D90
//      fn006F7890
//      fn00707640
//      fn00708DC0
//      fn0072F830
//      fn0072FBB0
//      fn00753A60
Eq_3 fn00715DD0(union Eq_3 & ecxOut, ptr32 & edxOut)
{
	Eq_3 ecx_6 = *((word32) g_tA6D67C + 4);
	Eq_3 eax_7 = *((word32) ecx_6 + 0x0C);
	if (eax_7 != 0x00)
	{
		Eq_3 ecx_18;
		ptr32 edx_19;
		word32 esi_47;
		word32 edi_48;
		Eq_3 eax_17 = fn006FD8B0(eax_7, dwArg04, out ecx_18, out edx_19, out esi_47, out edi_48);
		ecxOut = ecx_18;
		edxOut = edx_19;
		return eax_17;
	}
	else
	{
		ecxOut = ecx_6;
		edxOut = edx;
		return eax_7;
	}
}

// 00715DF0: Register Eq_3 fn00715DF0(Register out Eq_3 ecxOut)
// Called from:
//      fn00753A60
Eq_3 fn00715DF0(union Eq_3 & ecxOut)
{
	Eq_3 eax_52;
	Eq_3 ecx_21 = *((word32) g_tA6D67C + 4);
	Eq_3 eax_7 = *((word32) ecx_21 + 0x0C);
	if (eax_7 != 0x00)
	{
		word32 edi_113;
		word32 esi_112;
		word32 edx_111;
		Eq_3 eax_20 = fn006FD8B0(eax_7, dwArg04, out ecx_21, out edx_111, out esi_112, out edi_113);
		if (eax_20 == 0x00)
			goto l00715E3D;
		Eq_3 eax_30 = *((word32) eax_20 + 4);
		if (eax_30 == 0x00A26EF0)
		{
l00715E30:
			word32 edx_114;
			eax_52 = fn0072FC60(eax_20, out ecx_21, out edx_114);
			if (eax_52 != 0x00)
			{
l00715E41:
				ecxOut = ecx_21;
				return eax_52;
			}
			goto l00715E3D;
		}
		word32 edx_115;
		if (fn006D5670(eax_30, 0x00A26EF0, out ecx_21, out edx_115) != 0x00)
			goto l00715E30;
	}
l00715E3D:
	eax_52 = dwArg08;
	goto l00715E41;
}

// 00715E50: Register word32 fn00715E50(Stack Eq_3 dwArg08, Register out ptr32 ediOut)
// Called from:
//      fn006E8730
//      fn006E8D90
//      fn00706E30
//      fn00706F10
word32 fn00715E50(Eq_3 dwArg08, ptr32 & ediOut)
{
	Eq_3 esi_13 = *((word32) *((word32) g_tA6D67C + 4) + 0x0C);
	if (dwArg08 != 0x00)
	{
		word32 ecx_109;
		word32 edx_110;
		word32 esi_111;
		fn006FD8F0(esi_13, dwArg04, dwArg08, out ecx_109, out edx_110, out esi_111);
		return;
	}
	else
	{
		word32 ecx_112;
		word32 edx_113;
		word32 esi_114;
		word32 edi_115;
		if (fn006FD8B0(esi_13, dwArg04, out ecx_112, out edx_113, out esi_114, out edi_115) == 0x00)
			return;
		fn006FD950(esi_13, dwArg04);
		return;
	}
}

// 00716A00: Register Eq_3 fn00716A00(Register word32 edx, Register Eq_3 ebx, Register Eq_3 ebp, Register Eq_3 esi, Register Eq_3 edi, Register (ptr16 Eq_7) es, Register (ptr16 Eq_8) ds, Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Register out Eq_3 edxOut)
// Called from:
//      fn00716B20
Eq_3 fn00716A00(word32 edx, Eq_3 ebx, Eq_3 ebp, Eq_3 esi, Eq_3 edi, struct Eq_7 * es, struct Eq_8 * ds, Eq_3 dwArg04, Eq_3 dwArg08, union Eq_3 & edxOut)
{
	ui32 eax_7 = g_tA14188 ^ fp - 1020;
	word32 edx_40 = fn006E1130(fp - 1016, fp - 1020, fp - 1012);
	Eq_3 ecx_46 = *((word32) g_tA6D67C + 4);
	Eq_3 eax_47 = *((word32) ecx_46 + 0x0C);
	if (eax_47 != 0x00)
	{
		word32 edi_359;
		word32 esi_358;
		Eq_3 eax_57 = fn006FD8B0(eax_47, ecx, out ecx_46, out edx_40, out esi_358, out edi_359);
		if (eax_57 != 0x00 && fn0072FC60(eax_57, out ecx_46, out edx_40) != dwArg04)
		{
			Eq_113236 eax_110 = fn00724FB0(fp - 0x03F0, 1001, edx, dwArg08);
			word32 esi_361;
			word32 edi_362;
			word32 edx_360;
			if (fn00731D30(fp - 0x03F0, dwArg04, out edx_360, out esi_361, out edi_362) != 0x00)
			{
				word32 edx_364;
				word32 ecx_363;
				fn006E1160(out ecx_363, out edx_364);
				fputs(fp - 0x03F0, dwArg04);
			}
			if (eax_110 < 0x00 || eax_110 >= 1001)
			{
				word32 edx_365;
				word32 edi_367;
				word32 esi_366;
				if (fn00731D30(9277224, dwArg04, out edx_365, out esi_366, out edi_367) != 0x00)
				{
					word32 ecx_369;
					word32 edx_370;
					fn006E1160(out ecx_369, out edx_370);
					fputs(9277224, dwArg04);
				}
			}
l00716AE8:
			Eq_3 edx_211;
			Eq_3 ecx_260;
			word32 ecx_368;
			fn00694B8E(fn006E0E00(dwLoc03F4, out ecx_368, out edx_211), eax_7 ^ fp - 1020, edx_211, ebx, ebp, esi, edi, es, ds, ebx, out ecx_260);
			edxOut = edx_211;
			return ecx_260;
		}
	}
	MSVCR80.dll!vfprintf();
	goto l00716AE8;
}

// 00716B20: Register word32 fn00716B20(Register out (ptr32 charconst ) edxOut)
// Called from:
//      fn006E1970
//      fn006E19F0
//      fn006E8730
//      fn006E8D90
//      fn006F5DD0
//      fn006F6630
//      fn006F6730
//      fn006F6810
//      fn006F68F0
//      fn006F6D50
//      fn006F7810
//      fn006F7890
//      fn006F8050
//      fn006F8960
//      fn006FE400
//      fn007173A0
//      fn007406A0
//      fn0074F9E0
//      fn00753C30
//      fn007544A0
//      fn007544F0
word32 fn00716B20(const char & edxOut)
{
	struct Eq_113311 * esp_7;
	word32 eax_8;
	_iob_func();
	word32 edx_13 = esp_7->dw0008;
	esp_7->dwFFFFFFFC = eax_8 + 0x40;
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_3 stackArg4 = <invalid>;
	Eq_3 stackArg8 = <invalid>;
	const char * edx_21;
	word32 ecx_22 = fn00716A00(edx_13, ebx, ebp, esi, edi, es, ds, stackArg4, stackArg8, out edx_21);
	edxOut = edx_21;
	return ecx_22;
}

// 00717180: Register Eq_3 fn00717180(Stack Eq_3 dwArg04, Register out ptr32 edxOut)
// Called from:
//      fn006F63A0
Eq_3 fn00717180(Eq_3 dwArg04, ptr32 & edxOut)
{
	ptr32 edx_12;
	word32 ecx_237;
	Eq_3 eax_10 = fn006FEF30(&g_tA215C0, out ecx_237, out edx_12);
	if (eax_10 == 0x00)
	{
		edxOut = edx_12;
		return eax_10;
	}
	word32 ecx_238;
	word32 edx_239;
	Eq_3 eax_27 = fn006ECAC0(dwArg04, out ecx_238, out edx_239);
	word32 ecx_240;
	ptr32 edx_100;
	Eq_3 eax_36 = fn006FDCC0(out ecx_240, out edx_100);
	*((word32) eax_10 + 8) = eax_36;
	struct Eq_113366 * esp_103 = fp - 0x08;
	if (eax_36 != 0x00)
	{
		if (eax_27 == 0x00)
		{
l00717217:
			Eq_3 v14_107 = (word32) *eax_10 - 1;
			*eax_10 = v14_107;
			if (v14_107 == 0x00)
			{
				Eq_3 eax_111 = *((word32) eax_10 + 4);
				<anonymous> * ecx_112 = *((word32) eax_111 + 24);
				esp_103->tFFFFFFFC = eax_10;
				ecx_112();
			}
			edxOut = edx_100;
			return 0x00;
		}
		word32 ecx_241;
		word32 esi_242;
		if (fn006FD8F0(eax_36, 0x008CA818, eax_27, out ecx_241, out edx_100, out esi_242) == 0x00)
		{
			word32 esi_244;
			word32 ecx_243;
			if (fn006FD8F0(*((word32) eax_10 + 8), 9243992, 0x00A163B8, out ecx_243, out edx_100, out esi_244) == 0x00)
			{
				Eq_3 v11_135 = (word32) *eax_27 - 1;
				*eax_27 = v11_135;
				if (v11_135 == 0x00)
				{
					Eq_3 edx_139 = *((word32) eax_27 + 4);
					(*((word32) edx_139 + 24))();
				}
				ptr32 edx_157;
				fn006FEE30(eax_10, out edx_157);
				edxOut = edx_157;
				return eax_10;
			}
		}
	}
	esp_103 = fp - 0x08;
	if (eax_27 != 0x00)
	{
		Eq_3 v13_86 = (word32) *eax_27 - 1;
		*eax_27 = v13_86;
		if (v13_86 == 0x00)
		{
			Eq_3 ecx_90 = *((word32) eax_27 + 4);
			word32 esp_97;
			(*((word32) ecx_90 + 24))();
			esp_103 = esp_97 + 0x04;
		}
	}
	goto l00717217;
}

// 00717230: Register Eq_3 fn00717230(Stack Eq_3 dwArg04, Register out Eq_3 ecxOut, Register out ptr32 edxOut)
// Called from:
//      fn006E1970
//      fn006E19F0
//      fn006E9FA0
//      fn006F5DD0
//      fn006F62D0
//      fn006F6490
//      fn006F6D50
//      fn006F7100
//      fn006F7810
//      fn006F8960
//      fn0073AFB0
Eq_3 fn00717230(Eq_3 dwArg04, union Eq_3 & ecxOut, ptr32 & edxOut)
{
	Eq_3 eax_8 = *((word32) dwArg04 + 4);
	if (eax_8 == 10622400 || fn006D5670(eax_8, 10622400, out ecx, out edx) != 0x00)
	{
		Eq_3 eax_28 = *((word32) dwArg04 + 8);
		if (eax_28 == 0x00)
		{
			eax_28 = fn006FDCC0(out ecx, out edx);
			*((word32) dwArg04 + 8) = eax_28;
		}
		ecxOut = ecx;
		edxOut = edx;
		return eax_28;
	}
	else
	{
		ptr32 edx_53;
		ecxOut = fn006E1DC0(out edx_53);
		edxOut = edx_53;
		return 0x00;
	}
}

// 00717280: void fn00717280(Stack Eq_3 dwArg04)
// Called from:
//      fn006E9FA0
void fn00717280(Eq_3 dwArg04)
{
	Eq_3 eax_8 = *((word32) dwArg04 + 4);
	if (eax_8 != 10622400)
	{
		word32 edx_160;
		word32 ecx_159;
		if (fn006D5670(eax_8, 10622400, out ecx_159, out edx_160) == 0x00)
		{
			word32 edx_161;
			fn006E11D0(out edx_161);
			return;
		}
	}
	Eq_3 eax_28 = *((word32) dwArg04 + 8);
	if (eax_28 != 0x00)
	{
		word32 ecx_164;
		word32 edx_165;
		word32 esi_166;
		word32 edi_167;
		Eq_3 eax_39 = fn006FD8B0(eax_28, 0x008CA818, out ecx_164, out edx_165, out esi_166, out edi_167);
		if (eax_39 != 0x00)
		{
			Eq_3 eax_49 = *((word32) eax_39 + 4);
			if (eax_49 == 0x00A1B450)
			{
l007172E1:
				word32 ecx_168;
				word32 edx_169;
				word32 esi_170;
				fn006ECC50(eax_39, out ecx_168, out edx_169, out esi_170);
				return;
			}
			word32 ecx_171;
			word32 edx_172;
			if (fn006D5670(eax_49, 0x00A1B450, out ecx_171, out edx_172) != 0x00)
				goto l007172E1;
		}
	}
	word32 ecx_162;
	word32 edx_163;
	fn006E0F80(g_tA18720, dwArg04, out ecx_162, out edx_163);
}

// 007173A0: Register word32 fn007173A0(Stack Eq_3 dwArg04)
// Called from:
//      fn006F5DD0
word32 fn007173A0(Eq_3 dwArg04)
{
	Eq_3 ebp_10 = *((word32) dwArg04 + 8);
	if (ebp_10 != 0x00)
	{
		Eq_3 ebx_114 = 0x00A1B450;
		word32 edx_482;
		if (fn006FC050(ebp_10, fp - 0x04, fp + 0x04, fp - 0x08, out edx_482) != 0x00)
		{
			do
			{
				if (dwLoc08 != 0x00A163B8)
				{
					if (*((word32) dwArg04 + 4) != ebx_114)
					{
						word32 ecx_488;
						word32 edx_489;
						if (fn006D5670(*((word32) dwArg04 + 4), ebx_114, out ecx_488, out edx_489) != 0x00)
							goto l00717408;
					}
					else
					{
l00717408:
						word32 edx_486;
						word32 esi_487;
						word32 ecx_485;
						Eq_3 eax_73 = fn006ECC50(dwArg04, out ecx_485, out edx_486, out esi_487);
						if (*eax_73 == 0x5F && *((word32) eax_73 + 1) != 0x5F)
						{
							if (g_tA74AF0 > 0x01)
							{
								word32 edx_492;
								fn00716B20(out edx_492);
							}
							word32 ecx_490;
							word32 edx_491;
							fn006FBD90(ebp_10, dwArg04, 0x00A163B8, out ecx_490, out edx_491, out ebx_114, out edi);
						}
					}
				}
				word32 edx_484;
			} while (fn006FC050(ebp_10, fp - 0x04, fp + 0x04, fp - 0x08, out edx_484) != 0x00);
		}
		word32 edx_483;
		if (fn006FC050(ebp_10, fp - 0x04, fp + 0x04, fp - 0x08, out edx_483) != 0x00)
		{
			do
			{
				if (dwLoc08 != 0x00A163B8)
				{
					if (*((word32) dwArg04 + 4) != ebx_114)
					{
						word32 edx_498;
						word32 ecx_497;
						if (fn006D5670(*((word32) dwArg04 + 4), ebx_114, out ecx_497, out edx_498) != 0x00)
							goto l007174B8;
						goto l00717502;
					}
l007174B8:
					word32 esi_496;
					word32 edx_495;
					word32 ecx_494;
					Eq_3 eax_213 = fn006ECC50(dwArg04, out ecx_494, out edx_495, out esi_496);
					if (*eax_213 == 0x5F)
					{
						union Eq_3 * edi_224 = &g_t8D41A4;
						Eq_3 esi_225 = eax_213;
						word32 ecx_226 = 0x0D;
						bool v17_337 = true;
						while (ecx_226 != 0x00)
						{
							v17_337 = *esi_503 == *edi_504;
							esi_225 = (word32) esi_503 + 1;
							edi_224 = (union Eq_3 *) ((const char *) edi_504 + 1);
							--ecx_226;
							esi_503 = esi_225;
							edi_504 = edi_224;
							if (*esi_503 == *edi_504)
								break;
						}
						if (!v17_337)
							goto l007174D8;
					}
					else
					{
l007174D8:
						if (g_tA74AF0 > 0x01)
						{
							word32 edx_502;
							fn00716B20(out edx_502);
						}
						word32 ecx_499;
						word32 edx_500;
						word32 edi_501;
						fn006FBD90(ebp_10, dwArg04, 0x00A163B8, out ecx_499, out edx_500, out ebx_114, out edi_501);
					}
				}
l00717502:
				word32 edx_493;
			} while (fn006FC050(ebp_10, fp - 0x04, fp + 0x04, fp - 0x08, out edx_493) != 0x00);
		}
	}
	return edi;
}

// 00717680: Register word32 fn00717680(Register Eq_3 ebx, Register Eq_3 esi, Register out Eq_113767 ecxOut, Register out ptr32 edxOut)
// Called from:
//      fn00717740
//      fn00717900
word32 fn00717680(Eq_3 ebx, Eq_3 esi, union Eq_113767 & ecxOut, ptr32 & edxOut)
{
	Eq_3 eax_6 = *((word32) esi + 8);
	if (eax_6 == ebx)
	{
l007176E9:
		struct Eq_113774 * eax_77 = *((word32) esi + 20);
		if (eax_77 != null)
		{
			eax_77->dw0000 += ~0x00;
			struct Eq_113774 * eax_83 = *((word32) esi + 20);
			if (eax_83->dw0000 == 0x00)
			{
				struct Eq_113857 * edx_86 = eax_83->ptr0004;
				edx_86->ptr0018();
			}
			*((word32) esi + 20) = null;
		}
		*((word32) esi + 16) = ~0x00;
		ecxOut = ecx;
		edxOut = edx;
		return 0x00;
	}
	if (esi != g_tA6DBB4)
	{
		if (eax_6 != 0x01)
		{
l007176B1:
			Eq_3 edi_50 = *((word32) esi + 0x0C);
			Eq_3 eax_52 = (word32) ebx + ((word32) ebx + 2);
			if (eax_52 == 0x00)
				eax_52.u0 = 0x01;
			Eq_3 eax_65 = realloc(edi_50, eax_52);
			*((word32) esi + 0x0C) = eax_65;
			if (eax_65 == 0x00)
			{
				*((word32) esi + 0x0C) = edi_50;
				Eq_113767 ecx_118;
				ptr32 edx_119;
				fn006E1210(out ecx_118, out edx_119);
				ecxOut = ecx_118;
				edxOut = edx_119;
				return ~0x00;
			}
			*((word32) eax_65 + ebx * 0x02) = 0x00;
			*((word32) esi + 8) = ebx;
			goto l007176E9;
		}
		Eq_3 ax_19 = **((word32) esi + 0x0C);
		if (ax_19 >= 0x0100)
			goto l007176B1;
		ecx = (word32) ax_19;
		if (*((const char *) g_aA6D7B0 + ecx * 0x04) != esi)
			goto l007176B1;
	}
	Eq_113767 ecx_38;
	ptr32 edx_39;
	fn006E0F80(g_tA18720, 0x008D9258, out ecx_38, out edx_39);
	ecxOut = ecx_38;
	edxOut = edx_39;
	return ~0x00;
}

// 00717740: Register Eq_3 fn00717740(Register Eq_3 eax, Register out ptr32 ecxOut, Register out Eq_3 edxOut)
// Called from:
//      fn00717900
//      fn00717A20
//      fn00718610
//      fn00718F10
//      fn00719870
//      fn00719DD0
//      fn0071A5A0
//      fn0071A870
//      fn00721290
Eq_3 fn00717740(Eq_3 eax, ptr32 & ecxOut, union Eq_3 & edxOut)
{
	if (eax == 0x00)
	{
		Eq_3 eax_12 = g_tA6DBB4;
		if (eax_12 != 0x00)
		{
			*eax_12 = (word32) *eax_12 + 1;
			ecxOut = ecx;
			edxOut = edx;
			return eax_12;
		}
	}
	Eq_3 edx_127;
	Eq_3 esi_21 = g_tA6DBB0;
	if (esi_21 != 0x00)
	{
		Eq_3 eax_56 = *esi_21;
		--g_dwA6D7AC;
		g_tA6DBB0 = eax_56;
		if (*((word32) esi_21 + 0x0C) != 0x00)
		{
			if (*((word32) esi_21 + 8) < eax)
			{
				word32 edx_229;
				if (fn00717680(eax, esi_21, out ecx, out edx_229) < 0x00)
				{
					free(*((word32) esi_21 + 0x0C));
					ptr32 ecx_150;
					Eq_3 edx_152;
					fn007239C0(esi_21, out ecx_150, out edx_152);
					ecxOut = ecx_150;
					edxOut = edx_152;
					return 0x00;
				}
			}
		}
		else
		{
			Eq_3 eax_62 = (word32) eax + ((word32) eax + 2);
			if (eax_62 == 0x00)
				eax_62.u0 = 0x01;
			*((word32) esi_21 + 0x0C) = malloc(eax_62);
		}
		((word32) esi_21 + 4)->u0 = 0x00A23B20;
		esi_21->u0 = 0x01;
	}
	else
	{
		Eq_3 eax_31 = fn006DDD80(&g_tA23B20, out ecx, out edx_127);
		esi_21 = eax_31;
		if (eax_31 == 0x00)
			goto l00717808;
		Eq_3 eax_42 = (word32) eax + ((word32) eax + 2);
		if (eax_42 == 0x00)
			eax_42.u0 = 0x01;
		*((word32) eax_31 + 0x0C) = malloc(eax_42);
	}
	Eq_3 eax_92 = *((word32) esi_21 + 0x0C);
	if (eax_92 != 0x00)
	{
		eax_92->u0 = 0x00;
		Eq_3 edx_97 = *((word32) esi_21 + 0x0C);
		*((word32) edx_97 + eax * 0x02) = 0x00;
		*((word32) esi_21 + 8) = eax;
		*((word32) esi_21 + 16) = ~0x00;
		*((word32) esi_21 + 20) = null;
		ecxOut = ecx;
		edxOut = edx_97;
		return esi_21;
	}
	word32 ecx_230;
	word32 edx_231;
	fn006E1210(out ecx_230, out edx_231);
	fn007239C0(esi_21, out ecx, out edx_127);
l00717808:
	ecxOut = ecx;
	edxOut = edx_127;
	return 0x00;
}

// 00717900: Register int32 fn00717900(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Register out Eq_3 ecxOut, Register out Eq_3 edxOut)
// Called from:
//      fn00717CB0
//      fn00718610
//      fn00718F10
//      fn00719870
//      fn0071A5A0
//      fn0071A870
int32 fn00717900(Eq_3 dwArg04, Eq_3 dwArg08, union Eq_3 & ecxOut, union Eq_3 & edxOut)
{
	if (dwArg04 == 0x00)
	{
		Eq_3 edx_227;
		ecxOut = fn006E1DC0(out edx_227);
		edxOut = edx_227;
		return ~0x00;
	}
	Eq_3 esi_17 = *dwArg04;
	if (esi_17 != 0x00)
	{
		Eq_3 eax_21 = *((word32) esi_17 + 4);
		if (eax_21 == 0x00A23B20)
		{
l0071794D:
			if (*esi_17 == 0x01)
			{
				Eq_3 ebx_125 = dwArg08;
				if (dwArg08 >= 0x00)
				{
					Eq_3 eax_76 = *((word32) esi_17 + 8);
					if (eax_76 == dwArg08 || esi_17 != g_tA6DBB4 && eax_76 != 0x01)
					{
						Eq_3 edx_90;
						Eq_3 ecx_91;
						int32 eax_89 = fn00717680(dwArg08, esi_17, out ecx_91, out edx_90);
						ecxOut = ecx_91;
						edxOut = edx_90;
						return eax_89;
					}
					else
					{
						Eq_3 edx_114;
						Eq_3 ecx_115;
						Eq_3 eax_113 = fn00717740(dwArg08, out ecx_115, out edx_114);
						if (eax_113 != 0x00)
						{
							Eq_3 eax_122 = *((word32) esi_17 + 8);
							if (dwArg08 >= eax_122)
								ebx_125 = eax_122;
							Eq_3 ecx_132 = ebx_125 * 0x02;
							Eq_3 eax_128 = *((word32) eax_113 + 0x0C);
							Eq_3 edx_130 = *((word32) esi_17 + 0x0C);
							word24 ecx_24_8_274 = SLICE(ecx_132, word24, 8);
							if (ecx_132 >= 0x10)
								memcpy(eax_128, edx_130, ecx_132);
							else if (ecx_132 > 0x00)
							{
								edx_130 -= eax_128;
								Eq_3 esi_141 = ecx_132;
								do
								{
									byte cl_147 = Mem146[edx_130 + eax_128:byte];
									*eax_128 = cl_147;
									eax_128 = (word32) eax_128 + 1;
									--esi_141;
									ecx_132 = SEQ(ecx_24_8_274, cl_147);
								} while (esi_141 != 0x00);
							}
							Eq_3 eax_167 = *dwArg04;
							*eax_167 = (word32) *eax_167 - 1;
							Eq_3 eax_170 = *dwArg04;
							if (*eax_170 == 0x00)
							{
								Eq_3 edx_173 = *((word32) eax_170 + 4);
								(*((word32) edx_173 + 24))();
							}
							*dwArg04 = eax_113;
							ecxOut = ecx_132;
							edxOut = edx_130;
							return 0x00;
						}
						else
						{
							ecxOut = ecx_115;
							edxOut = edx_114;
							return ~0x00;
						}
					}
				}
			}
			goto l007179FA;
		}
		word32 edx_346;
		word32 ecx_345;
		if (fn006D5670(eax_21, 0x00A23B20, out ecx_345, out edx_346) != 0x00)
			goto l0071794D;
	}
l007179FA:
	Eq_3 edx_62;
	ecxOut = fn006E1DC0(out edx_62);
	edxOut = edx_62;
	return ~0x00;
}

// 00717A20: Register Eq_3 fn00717A20(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Register out Eq_67994 edxOut)
// Called from:
//      fn006E9BD0
//      fn00720020
//      fn007203E0
//      fn00721290
Eq_3 fn00717A20(Eq_3 dwArg04, Eq_3 dwArg08, union Eq_67994 & edxOut)
{
	if (dwArg04 != 0x00)
	{
		if (dwArg08 == 0x00)
		{
			Eq_3 eax_58 = g_tA6DBB4;
			if (eax_58 != 0x00)
			{
				*eax_58 = (word32) *eax_58 + 1;
				edxOut = edx;
				return eax_58;
			}
		}
		else if (dwArg08 == 0x01)
		{
			Eq_3 ax_21 = *dwArg04;
			if (ax_21 < 0x0100)
			{
				Eq_3 eax_25 = *((const char *) g_aA6D7B0 + (word32) ax_21 * 0x04);
				if (eax_25 == 0x00)
				{
					Eq_67994 edx_32;
					word32 ecx_228;
					eax_25 = fn00717740(dwArg08, out ecx_228, out edx_32);
					word16 edx_16_16_175 = SLICE(edx_32, word16, 16);
					if (eax_25 == 0x00)
					{
						edxOut = edx_32;
						return eax_25;
					}
					Eq_3 dx_40 = *dwArg04;
					**((word32) eax_25 + 0x0C) = dx_40;
					*((const char *) g_aA6D7B0 + (word32) (*dwArg04) * 0x04) = (struct Eq_118654 **) eax_25;
					edx = SEQ(edx_16_16_175, dx_40);
				}
				*eax_25 = (word32) *eax_25 + 1;
				edxOut = edx;
				return eax_25;
			}
		}
	}
	word32 ecx_227;
	Eq_67994 edx_170;
	Eq_3 eax_72 = fn00717740(dwArg08, out ecx_227, out edx_170);
	if (eax_72 != 0x00)
	{
		if (dwArg04 != 0x00)
		{
			Eq_3 eax_101 = *((word32) eax_72 + 0x0C);
			edx_170 = dwArg08 * 0x02;
			word24 edx_24_8_172 = SLICE(dwArg08 * 0x02, word24, 8);
			if (dwArg08 * 0x02 >= 0x10)
			{
				memcpy(eax_101, dwArg04, dwArg08 * 0x02);
				edxOut = dwArg08 * 0x02;
				return eax_72;
			}
			if (dwArg08 * 0x02 > 0x00)
			{
				int32 ecx_93 = dwArg04 - eax_101;
				ui32 esi_102 = dwArg08 * 0x02;
				do
				{
					Eq_114280 dl_99 = *((word32) eax_101 + ecx_93);
					*eax_101 = dl_99;
					eax_101 = (word32) eax_101 + 1;
					--esi_102;
					edx_170 = SEQ(edx_24_8_172, dl_99);
				} while (esi_102 != 0x00);
			}
		}
		edxOut = edx_170;
		return eax_72;
	}
	else
	{
		edxOut = edx_170;
		return eax_72;
	}
}

// 00717C60: void fn00717C60()
// Called from:
//      fn006E5C60
void fn00717C60()
{
}

// 00717CB0: Register (ptr32 (ptr32 Eq_59662)) fn00717CB0(Register (ptr32 (ptr32 Eq_59662)) eax, Register Eq_3 ecx, Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Stack Eq_3 dwArg0C, Stack Eq_3 dwArg10, Stack Eq_3 dwArg14, Stack Eq_3 dwArg18, Stack Eq_3 dwArg1C, Stack Eq_3 dwArg20, Stack Eq_3 dwArg24, Stack Eq_3 dwArg28, Register out Eq_114305 ecxOut, Register out Eq_3 edxOut)
// Called from:
//      fn00718610
//      fn00718F10
//      fn00719870
//      fn0071A5A0
struct Eq_59662 ** fn00717CB0(struct Eq_59662 ** eax, Eq_3 ecx, Eq_3 dwArg04, Eq_3 dwArg08, Eq_3 dwArg0C, Eq_3 dwArg10, Eq_3 dwArg14, Eq_3 dwArg18, Eq_3 dwArg1C, Eq_3 dwArg20, Eq_3 dwArg24, Eq_3 dwArg28, union Eq_114305 & ecxOut, union Eq_3 & edxOut)
{
	Eq_3 edx_125;
	Eq_114305 ecx_124;
	int32 ebp_26 = *((word32) *dwArg20 + 8);
	if (*dwArg04 == 0x00)
	{
		Eq_3 eax_33 = fn0074EFB0(edx, out ecx_124, out edx_125);
		*dwArg04 = eax_33;
		if (eax_33 == 0x00)
			goto l00717EE8;
	}
	struct Eq_59662 * eax_45 = *eax;
	if (eax_45 == null)
	{
		struct Eq_59662 * eax_123 = fn006E3E50(out ecx_124, out edx_125);
		*eax = (struct Eq_59662 **) eax_123;
		if (eax_123 == null)
			goto l00717EE8;
	}
	else if (fn006E3770(eax_45, ~0x00, out ecx_124, out edx_125) != 0x00 || (fn006E38B0(*eax, ~0x00, out ecx_124, out edx_125) != 0x00 || fn006E3900(*eax, ~0x00, out ecx_124, out edx_125) != 0x00))
		goto l00717EE8;
	Eq_3 eax_150 = fn00703AF0(*dwArg04, out ecx_124, out edx_125);
	if (eax_150 == 0x00)
	{
l00717EE8:
		ecxOut = ecx_124;
		edxOut = edx_125;
		return (struct Eq_59662 **) ~0x00;
	}
	Eq_3 eax_200;
	Eq_3 eax_161 = *((word32) eax_150 + 4);
	if (eax_161 != 0x00A16588)
	{
		word32 ecx_678;
		word32 edx_679;
		if (fn006D5670(eax_161, 0x00A16588, out ecx_678, out edx_679) == 0x00)
		{
			eax_200 = fn006E15D0(g_tA16B7C, ~0x00, out ecx_124, out edx_125);
			goto l00717ED7;
		}
	}
	eax_200 = fn006E7CB0(out ecx_124, out edx_125);
	if (eax_200 == 0x00)
		goto l00717ED7;
	Eq_3 ecx_209 = dwLoc10;
	if (dwLoc10 < 0x00)
	{
		ecx_209 = dwLoc10 + ecx;
		dwLoc10 = ecx_209;
		if (ecx_209 < 0x00)
		{
l00717EC3:
			eax_200 = fn006E15D0(g_tA17CA4, ~0x00, out ecx_124, out edx_125);
			goto l00717ED7;
		}
	}
	if (ecx_209 <= ecx)
	{
		Eq_3 edi_254 = *(union Eq_3 *) 0x08;
		Eq_3 edx_253 = *(union Eq_3 *) 0x0C;
		int32 eax_259 = (word32) ecx + ((word32) edi_254 + (*dwArg24 - ecx_209));
		if (eax_259 > ebp_26)
		{
			eax_200 = fn00717900(dwArg20, ~0x00, out ecx_124, out edx_125);
			if (eax_200 < 0x00)
				goto l00717ED7;
			*dwArg28 = (word32) *((word32) *dwArg20 + 0x0C) + *dwArg24 * 0x02;
			ecx_209 = dwLoc10;
		}
		*dwArg18 = ecx_209;
		ecx_124 = ecx_209 + dwArg10;
		*dwArg1C = ecx_124;
		edx_125 = edx_253;
		word24 edx_24_8_457 = SLICE(edx_253, word24, 8);
		Eq_3 eax_314 = *dwArg28;
		if (edi_254 * 0x02 >= 0x10)
			memcpy(eax_314, edx_253, edi_254 * 0x02);
		else if (edi_254 * 0x02 > 0x00)
		{
			Eq_114305 ecx_322 = edx_253 - eax_314;
			ui32 ebp_324 = edi_254 * 0x02;
			ecx_124 = ecx_322;
			do
			{
				byte dl_329 = Mem328[ecx_322 + eax_314:byte];
				*eax_314 = dl_329;
				eax_314 = (word32) eax_314 + 1;
				--ebp_324;
				edx_125 = SEQ(edx_24_8_457, dl_329);
			} while (ebp_324 != 0x00);
		}
		*dwArg28 = (word32) *dwArg28 + edi_254 * 0x02;
		Mem358[dwArg24 + 0x00:word32] = Mem351[dwArg24 + 0x00:word32] + edi_254;
		eax_200 = dwArg24;
l00717ED7:
		word32 v16_380 = (word32) *eax_150 - 1;
		*eax_150 = v16_380;
		if (v16_380 == 0x00)
		{
			Eq_3 ecx_384 = *((word32) eax_150 + 4);
			<anonymous> * edx_385 = *((word32) ecx_384 + 24);
			edx_385();
		}
		goto l00717EE8;
	}
	goto l00717EC3;
}

// 00718610: Register Eq_3 fn00718610(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Stack (ptr32 ptr32) dwArg10, Register out ptr32 edxOut)
// Called from:
//      fn0071FC80
//      fn0071FEB0
Eq_3 fn00718610(Eq_3 dwArg04, Eq_3 dwArg08, ptr32 * dwArg10, ptr32 & edxOut)
{
	word32 ecx_782;
	ptr32 edx_278;
	Eq_3 eax_27 = fn00717740(dwArg08, out ecx_782, out edx_278);
	Eq_3 esi_14 = dwArg04;
	word24 ecx_24_8_524 = SLICE(eax_27, word24, 8);
	if (eax_27 != 0x00)
	{
		if (dwArg08 == 0x00)
		{
			if (dwArg10 != null)
				*dwArg10 = 0x00;
			edxOut = edx_278;
			return eax_27;
		}
		Eq_3 edi_120 = *((word32) eax_27 + 0x0C);
		word32 edx_42 = dwArg04 + dwArg08;
		Eq_3 dwLoc14_613 = edi_120;
		if (dwArg04 < edx_42)
		{
			do
			{
				byte cl_49 = *esi_14;
				struct Eq_114593 * eax_50 = (word32) cl_49;
				word24 edx_24_8_104 = SLICE(edx_42, word24, 8);
				word16 ax_288 = (word16) eax_50;
				ui32 ecx_93 = SEQ(ecx_24_8_524, cl_49);
				if (eax_50 < (struct Eq_114593 *) 0x80)
				{
					*edi_120 = ax_288;
					edi_120 = (word32) edi_120 + 2;
					esi_14 = (word32) esi_14 + 1;
					dwLoc14_613 = edi_120;
				}
				else
				{
					Eq_114603 eax_53 = (int32) eax_50->bA21708;
					word24 eax_24_8_99 = SLICE(eax_53, word24, 8);
					word32 ebx_54 = eax_53 + esi_14;
					if (ebx_54 > edx_42)
					{
						if (dwArg10 != null)
							goto l007188E3;
					}
					else if (eax_53 <= 0x04)
					{
						word16 ecx_16_16_527;
						word16 cx_175;
						switch (eax_53)
						{
						case 0x00:
							break;
						case 0x01:
							break;
						case 0x02:
							byte al_160 = *((word32) esi_14 + 1);
							ui32 eax_167 = SEQ(eax_24_8_99, al_160);
							if ((al_160 & 0xC0) == 0x80)
							{
								uint32 ecx_169 = ((ecx_93 & 0x1F) << 0x06) + (eax_167 & 0x3F);
								cx_175 = (word16) ecx_169;
								ecx_16_16_527 = SLICE(ecx_169, word16, 16);
								if (ecx_169 >= 0x80)
									goto l0071881F;
							}
							break;
						case 0x03:
							byte dl_126 = *((word32) esi_14 + 1);
							ui32 edx_146 = SEQ(edx_24_8_104, dl_126);
							if ((dl_126 & 0xC0) == 0x80)
							{
								byte al_131 = *((word32) esi_14 + 2);
								ui32 eax_150 = SEQ(eax_24_8_99, al_131);
								if ((al_131 & 0xC0) != 0x80)
									goto l00718793;
								uint32 ecx_152 = (((ecx_93 & 0x0F) << 0x06) + (edx_146 & 0x3F) << 0x06) + (eax_150 & 0x3F);
								cx_175 = (word16) ecx_152;
								ecx_16_16_527 = SLICE(ecx_152, word16, 16);
								if (ecx_152 >= 0x0800)
									goto l0071881F;
							}
							else
							{
l00718793:
							}
							break;
						case 0x04:
							byte al_68 = *((word32) esi_14 + 1);
							if ((al_68 & 0xC0) == 0x80)
							{
								byte al_73 = *((word32) esi_14 + 2);
								ui32 eax_100 = SEQ(eax_24_8_99, al_73);
								if ((al_73 & 0xC0) != 0x80)
									goto l00718846;
								byte dl_78 = *((word32) esi_14 + 3);
								ui32 edx_105 = SEQ(edx_24_8_104, dl_78);
								if ((dl_78 & 0xC0) != 0x80)
									goto l00718846;
								uint32 ecx_107 = ((((ecx_93 & 0x07) << 0x06) + ((word32) al_68 & 0x3F) << 0x06) + (eax_100 & 0x3F) << 0x06) + (edx_105 & 0x3F);
								if (ecx_107 <= 1114111)
								{
									*edi_120 = (word16) ((ecx_107 + 0xFFFF0000 >> 0x0A) - 0x2800);
									ui32 ecx_122 = ecx_107 + 0xFFFF0000 & 0x03FF;
									edi_120 = (word32) edi_120 + 2;
									cx_175 = (word16) (ecx_122 - 0x2400);
									ecx_16_16_527 = SLICE(ecx_122 - 0x2400, word16, 16);
l0071881F:
									*edi_120 = cx_175;
									edi_120 = (word32) edi_120 + 2;
									esi_14 = ebx_54;
									dwLoc14_613 = edi_120;
									ecx_24_8_524 = SEQ(ecx_16_16_527, SLICE(cx_175, byte, 8));
									goto l007188C2;
								}
							}
							else
							{
l00718846:
							}
							break;
						}
					}
					ecx_24_8_524 = SLICE(ecx_277, word24, 8);
					word32 ecx_277;
					if (fn00717CB0(fp - 0x0C, dwArg08, fp - 0x10, dwArg04, dwArg08, dwArg04, fp - 0x1C, fp - 0x20, fp + 0x04, fp - 0x18, fp - 0x08, fp - 0x14, out ecx_277, out edx_278) != 0x00)
						goto l00718944;
					esi_14 = dwArg04;
					edi_120 = dwLoc14_613;
				}
l007188C2:
			} while (esi_14 < edx_42);
		}
		if (dwArg10 != null)
		{
l007188E3:
			*dwArg10 = esi_14 - dwArg04;
		}
		struct Eq_114621 * esp_352 = fp - 0x34;
		word32 ecx_783;
		if (fn00717900(fp - 0x18, dwArg04, out ecx_783, out edx_278) >= 0x00)
		{
			if (false)
			{
				<anonymous> ** v17_449 = (const char *) null - 1;
				null = (<anonymous> ***) v17_449;
				if (v17_449 == null)
				{
					struct Eq_1218 * eax_453 = *(struct Eq_1218 **) 0x04;
					word32 esp_457;
					eax_453->ptr0018();
					esp_352 = esp_457 + 0x04;
				}
			}
			struct Eq_114642 * eax_467 = esp_352->ptr0028;
			if (eax_467 != null)
			{
				word32 v19_471 = eax_467->dw0000 + ~0x00;
				eax_467->dw0000 = v19_471;
				if (v19_471 == 0x00)
				{
					struct Eq_114736 * edx_475 = eax_467->ptr0004;
					esp_352->ptrFFFFFFFC = eax_467;
					edx_475->ptr0018();
				}
			}
			edxOut = edx_278;
			return eax_27;
		}
l00718944:
		struct Eq_114638 * esp_367 = fp - 0x34;
		if (false)
		{
			<anonymous> ** v24_361 = (const char *) null - 1;
			null = (<anonymous> ***) v24_361;
			if (v24_361 == null)
			{
				struct Eq_1218 * eax_365 = *(struct Eq_1218 **) 0x04;
				word32 esp_374;
				eax_365->ptr0018();
				esp_367 = esp_374 + 0x04;
			}
		}
		struct Eq_114854 * eax_384 = esp_367->ptr0028;
		if (eax_384 != null)
		{
			word32 v25_388 = eax_384->dw0000 + ~0x00;
			eax_384->dw0000 = v25_388;
			if (v25_388 == 0x00)
			{
				struct Eq_114904 * edx_392 = eax_384->ptr0004;
				esp_367->ptrFFFFFFFC = eax_384;
				word32 esp_401;
				edx_392->ptr0018();
				esp_367 = esp_401 + 0x04;
			}
		}
		struct Eq_114854 * eax_411 = esp_367->ptr001C;
		word32 v26_412 = eax_411->dw0000 + ~0x00;
		eax_411->dw0000 = v26_412;
		if (v26_412 == 0x00)
		{
			struct Eq_114904 * ecx_416 = eax_411->ptr0004;
			<anonymous> * edx_417 = ecx_416->ptr0018;
			esp_367->ptrFFFFFFFC = eax_411;
			edx_417();
		}
	}
	edxOut = edx_278;
	return 0x00;
}

// 007189B0: Register word32 fn007189B0(Register Eq_3 ebx, Register Eq_3 ebp, Register Eq_3 esi, Register Eq_3 edi, Register (ptr16 Eq_7) es, Register (ptr16 Eq_8) ds, Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Register out ptr32 ecxOut, Register out Eq_3 edxOut)
// Called from:
//      fn00718B50
word32 fn007189B0(Eq_3 ebx, Eq_3 ebp, Eq_3 esi, Eq_3 edi, struct Eq_7 * es, struct Eq_8 * ds, Eq_3 dwArg04, Eq_3 dwArg08, ptr32 & ecxOut, union Eq_3 & edxOut)
{
	Eq_3 dwLoc04B8_355;
	byte * ecx_148;
	Eq_3 eax_210;
	ui32 eax_7 = g_tA14188 ^ fp - 0x04B8;
	if (dwArg08 <= 300)
	{
		eax_210.u0 = 0x00;
		dwLoc04B8_355.u0 = 0x00;
		ecx_148 = fp - 0x04B4;
	}
	else
	{
		int64 edx_eax_17 = (int64) (dwArg08 * 0x04);
		if ((word32) edx_eax_17 + (SLICE(edx_eax_17, word32, 32) & 0x03) >> 0x02 != dwArg08)
		{
			Eq_3 edx_69;
			ptr32 ecx_79;
			word32 ecx_465;
			word32 eax_78 = fn00694B8E(fn006E1210(out ecx_465, out edx_69), eax_7 ^ fp - 0x04B8, edx_69, ebx, ebp, esi, edi, es, ds, ebx, out ecx_79);
			ecxOut = ecx_79;
			edxOut = edx_69;
			return eax_78;
		}
		Eq_3 edx_32;
		word32 ecx_464;
		eax_210 = fn006EC9B0(0x00, dwArg08 * 0x04, out ecx_464, out edx_32);
		dwLoc04B8_355 = eax_210;
		if (eax_210 == 0x00)
		{
			ptr32 ecx_57;
			word32 eax_56 = fn00694B8E(eax_210, eax_7 ^ fp - 0x04B8, edx_32, ebx, ebp, esi, edi, es, ds, ebx, out ecx_57);
			ecxOut = ecx_57;
			edxOut = edx_32;
			return eax_56;
		}
		ecx_148 = (byte *) ((word64) eax_210.u0 + 20);
	}
	Eq_3 edi_109 = 0x00;
	if (dwArg08 > 0x00)
	{
		do
		{
			uint32 eax_111 = (word32) *((word32) dwArg04 + edi_109 * 0x02);
			byte al_180 = (byte) eax_111;
			edi_109 = (word32) edi_109 + 1;
			if (eax_111 >= 0x80)
			{
				byte dl_168;
				if (eax_111 < 0x0800)
				{
					dl_168 = (byte) (eax_111 >> 0x06) | 0xC0;
					goto l00718ADD;
				}
				byte dl_133;
				if (eax_111 < 0x00010000)
				{
					if (eax_111 <= ~0xDBFE && edi_109 != dwArg08)
					{
						up32 esi_125 = (word32) *((word32) dwArg04 + edi_109 * 0x02);
						if (esi_125 > ~0xDFFE)
							goto l00718B0F;
						eax_111 = (eax_111 + ~0xD7FF << 0x0A | esi_125 + ~0xDBFF) + 0x00010000;
						edi_109 = (word32) edi_109 + 1;
						goto l00718AB5;
					}
l00718B0F:
					dl_133 = (byte) (eax_111 >> 0x0C) | 0xE0;
				}
				else
				{
l00718AB5:
					*ecx_148 = (byte) (eax_111 >> 0x12) | 0xF0;
					++ecx_148;
					dl_133 = (byte) (eax_111 >> 0x0C) & 0x3F | 0x80;
				}
				*ecx_148 = dl_133;
				al_180 = (byte) eax_111;
				++ecx_148;
				dl_168 = (byte) (eax_111 >> 0x06) & 0x3F | 0x80;
l00718ADD:
				*ecx_148 = dl_168;
				++ecx_148;
				al_180 = al_180 & 0x3F | 0x80;
			}
			*ecx_148 = al_180;
			++ecx_148;
		} while (edi_109 < dwArg08);
		eax_210 = dwLoc04B8_355;
	}
	Eq_3 edx_296;
	Eq_3 eax_299;
	if (eax_210 == 0x00)
	{
		word32 ecx_467;
		eax_299 = fn006EC9B0(fp - 0x04B4, ecx_148 - (fp - 0x04B4), out ecx_467, out edx_296);
	}
	else
	{
		word32 ecx_466;
		fn006EC4F0(fp - 0x04B8, ecx_148 - eax_210 - 0x14, out ecx_466, out edx_296);
		eax_299 = dwLoc04B8_355;
	}
	ptr32 ecx_335;
	word32 eax_334 = fn00694B8E(eax_299, eax_7 ^ fp - 0x04B8, edx_296, ebx, ebp, esi, edi, es, ds, ebx, out ecx_335);
	ecxOut = ecx_335;
	edxOut = edx_296;
	return eax_334;
}

// 00718B50: Register word32 fn00718B50(Stack Eq_3 dwArg04, Register out ptr32 ecxOut, Register out ptr32 edxOut)
// Called from:
//      fn0070BCC0
//      fn0071FB20
//      fn00735890
//      fn007533F0
//      fn007537A0
//      fn007537F0
word32 fn00718B50(Eq_3 dwArg04, ptr32 & ecxOut, ptr32 & edxOut)
{
	Eq_3 eax_8 = *((word32) dwArg04 + 4);
	if (eax_8 != 0x00A23B20)
	{
		word32 ecx_96;
		word32 edx_97;
		if (fn006D5670(eax_8, 0x00A23B20, out ecx_96, out edx_97) == 0x00)
		{
			ptr32 edx_52;
			ecxOut = fn006E11D0(out edx_52);
			edxOut = edx_52;
			return 0x00;
		}
	}
	ptr32 ecx_40;
	ptr32 edx_42;
	word32 eax_39 = fn007189B0(ebx, ebp, dwArg04, edi, es, ds, *((word32) dwArg04 + 0x0C), *((word32) dwArg04 + 8), out ecx_40, out edx_42);
	ecxOut = ecx_40;
	edxOut = edx_42;
	return eax_39;
}

// 00718F10: Register Eq_3 fn00718F10(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Register out ptr32 edxOut)
// Called from:
//      fn0073D2A0
Eq_3 fn00718F10(Eq_3 dwArg04, Eq_3 dwArg08, ptr32 & edxOut)
{
	Eq_3 esi_14 = dwArg04;
	struct Eq_115175 * ebp_19 = null;
	struct Eq_115177 * ebx_20 = null;
	word32 ecx_1220;
	ptr32 edx_1027;
	Eq_3 eax_1012 = fn00717740(dwArg08, out ecx_1220, out edx_1027);
	struct Eq_115186 * esp_122 = fp - 0x40;
	if (eax_1012 != 0x00)
	{
		if (dwArg08 == 0x00)
		{
l0071944F:
			edxOut = edx_1027;
			return eax_1012;
		}
		Eq_3 edi_41 = *((word32) eax_1012 + 0x0C);
		if (dwArg04 <u dwArg04 + dwArg08)
		{
			esp_122 = fp - 0x40;
			do
			{
				byte al_51 = *esi_14;
				if (al_51 != 0x5C)
				{
					*edi_41 = (word16) al_51;
					edi_41 = (word32) edi_41 + 2;
					esi_14 = (word32) esi_14 + 1;
					goto l007193EB;
				}
				esp_122[0x0E] = (struct Eq_115186) (esi_14 - esp_122[0x0C]);
				struct Eq_115239 * esi_58 = (word32) esi_14 + 1;
				byte al_60 = esi_58->b0000;
				esp_122[0x0011] = (struct Eq_115186) &esi_58->t0001;
				esi_14 = &esi_58->t0001;
				if (&esi_58->t0001 > esp_122[0x0D])
					al_60 = 0x00;
				ptr32 esp_190;
				word16 cx_609;
				up32 eax_69 = (word32) al_60;
				if (eax_69 <= 0x78)
				{
					uint32 eax_141;
					int32 eax_126;
					Eq_115329 ecx_100;
					switch (eax_69)
					{
					case 0x0A:
						goto l007193EF;
					case 11:
					case 0x0C:
					case 0x0D:
					case 0x0E:
					case 0x0F:
					case 0x10:
					case 0x11:
					case 0x12:
					case 0x13:
					case 0x14:
					case 0x15:
					case 22:
					case 0x17:
					case 0x18:
					case 0x19:
					case 0x1A:
					case 0x1B:
					case 0x1C:
					case 0x1D:
					case 0x1E:
					case 0x1F:
					case 0x20:
					case 33:
					case 0x23:
					case 0x24:
					case 0x25:
					case 0x26:
					case 0x28:
					case 0x29:
					case 0x2A:
					case 0x2B:
					case 44:
					case 0x2D:
					case 0x2E:
					case 0x2F:
					case 0x38:
					case 0x39:
					case 0x3A:
					case 0x3B:
					case 0x3C:
					case 0x3D:
					case 0x3E:
					case 0x3F:
					case 0x40:
					case 0x41:
					case 66:
					case 0x43:
					case 0x44:
					case 0x45:
					case 0x46:
					case 0x47:
					case 0x48:
					case 0x49:
					case 0x4A:
					case 0x4B:
					case 0x4C:
					case 77:
					case 0x4F:
					case 0x50:
					case 0x51:
					case 0x52:
					case 0x53:
					case 0x54:
					case 0x56:
					case 0x57:
					case 88:
					case 0x59:
					case 0x5A:
					case 0x5B:
					case 0x5D:
					case 0x5E:
					case 0x5F:
					case 0x60:
					case 99:
					case 100:
					case 101:
					case 0x67:
					case 0x68:
					case 0x69:
					case 0x6A:
					case 0x6B:
					case 0x6C:
					case 0x6D:
					case 111:
					case 0x70:
					case 113:
					case 115:
					case 0x77:
						goto l00719387;
					case 0x22:
						*edi_41 = 0x22;
						break;
					case 0x27:
						*edi_41 = 0x27;
						break;
					case 0x30:
					case 0x31:
					case 0x32:
					case 0x33:
					case 0x34:
					case 0x35:
					case 0x36:
					case 55:
						ui32 eax_559 = (word32) ((int16) esi_58->b0000 - 0x30);
						word16 ax_593 = (word16) eax_559;
						ptr32 edx_561 = esp_122[0x0D];
						if (&esi_58->t0001 < edx_561)
						{
							Eq_115835 cl_564 = esi_58->t0001;
							if (cl_564 >= 0x30 && cl_564 <= 55)
							{
								ui32 eax_578 = (word32) ((word16) (eax_559 * 0x08) + (int16) cl_564 - 0x30);
								esi_14 = &esi_58->b0002;
								ax_593 = (word16) eax_578;
								if (&esi_58->b0002 < edx_561)
								{
									ci8 cl_580 = esi_58->b0002;
									if (cl_580 >= 0x30 && cl_580 <= 55)
									{
										ax_593 = (word16) (eax_578 * 0x08) + (int16) cl_580 - 0x30;
										esi_14 = &esi_58->b0002 + 1;
									}
								}
							}
						}
						*edi_41 = ax_593;
						break;
					case 0x4E:
						Eq_3 eax_192 = g_tA6DBBC;
						esp_122[11] = (struct Eq_115186) 9278748;
						if (eax_192 != 0x00)
						{
l00719278:
							if (esi_58->t0001 == 0x7B)
							{
								Eq_3 edx_390 = esp_122[0x0D];
								while (esi_14 < edx_390)
								{
									esi_14 = (word32) esi_14 + 1;
									if (*esi_14 == 0x7D)
										break;
								}
								esp_122[0x0011] = (struct Eq_115186) esi_14;
								if (esi_14 > &esi_58->b0002 && (esi_14 < edx_390 && *esi_14 == 0x7D))
								{
									<anonymous> * eax_416 = *((word32) eax_192 + 8);
									struct Eq_116088 * esp_418 = esp_122 - 4;
									esp_418->ptr0000 = (ui32 *) (esp_122 + 6);
									esi_14 = (word32) esi_14 + 1;
									int32 edx_422 = esi_14 - &esi_58->b0002;
									esp_418->dwFFFFFFFC = edx_422 - 0x01;
									esp_418->ptrFFFFFFF8 = &esi_58->b0002;
									esp_418->dwFFFFFFF4 = 0x00;
									esp_418->dw0030 = 9278688;
									esp_418->t0048 = esi_14;
									word32 esp_445;
									word32 eax_446;
									eax_416();
									esp_122 = esp_445 + 0x10;
									if (eax_446 != 0x00)
										goto l007192E0;
								}
							}
							eax_126 = (int32) esp_122[0x0C];
							int32 edi_460 = edi_41 - *((word32) (esp_122)[5].dwFFFFFFFC + 16);
							esp_122[7] = (struct Eq_115186) (esi_14 - eax_126);
							esp_122[8] = (struct Eq_115186) (edi_460 >> 0x01);
l007191C9:
							struct Eq_116127 * esp_469 = esp_122 - 4;
							esp_469->ptr0000 = (word32 *) (esp_122 + 4);
							esp_469->ptrFFFFFFFC = (const char *) &esp_469->ptr0000 + 36;
							esp_469->ptrFFFFFFF8 = (const char *) &esp_469->ptr0000 + 24;
							esp_469->ptrFFFFFFF4 = &esp_469->dw0030 + 6;
							esp_469->ptrFFFFFFF0 = (const char *) &esp_469->ptr0000 + 32;
							word32 edx_483 = esp_469->dw0030;
							esp_469->ptrFFFFFFEC = &esp_469->dw0030 + 3;
							esp_469->dwFFFFFFE8 = eax_126;
							esp_469->dwFFFFFFE4 = edx_483;
							esp_190 = esp_469 - 28;
							goto l0071910F;
						}
						else
						{
							struct Eq_115838 * esp_197 = esp_122 - 4;
							esp_197->t0000.u0 = 0x008D9510;
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							Eq_3 stackArg4 = <invalid>;
							Eq_3 eax_206 = fn006F92B0(stackArg4);
							esp_122 = (struct Eq_115186 *) ((const char *) &esp_197->t0000 + 4);
							if (eax_206 != 0x00)
							{
								esp_197->t0000.u0 = 0x008D9500;
								esp_197->tFFFFFFFC = eax_206;
								// Failed to bind call argument.
								// Please report this issue at https://github.com/uxmal/reko
								Eq_3 stackArg4 = <invalid>;
								word32 edx_1237;
								word32 edi_1238;
								Eq_3 eax_221 = fn006DF760(stackArg4, dwArg04, out edx_1237, out edi_1238);
								word32 v24_227 = (word32) *eax_206 - 1;
								*eax_206 = v24_227;
								esp_122 = (struct Eq_115186 *) ((const char *) &esp_197->t0000 + 4);
								if (v24_227 == 0x00)
								{
									Eq_3 ecx_232 = *((word32) eax_206 + 4);
									<anonymous> * edx_233 = *((word32) ecx_232 + 24);
									esp_197->t0000 = eax_206;
									word32 esp_236;
									edx_233();
									esp_122 = esp_236 + 0x04;
								}
								if (eax_221 == 0x00)
									goto l00719457;
								union Eq_3 * esp_249 = esp_122 - 4;
								*esp_249 = (union Eq_3 *) eax_221;
								// Failed to bind call argument.
								// Please report this issue at https://github.com/uxmal/reko
								Eq_3 stackArg4 = <invalid>;
								word32 edx_1240;
								eax_192 = fn0072E9C0(stackArg4, out edx_1240);
								word32 v25_262 = (word32) *eax_221 - 1;
								*eax_221 = v25_262;
								g_tA6DBBC = eax_192;
								esp_122 = (struct Eq_115186 *) ((const char *) esp_249 + 4);
								if (v25_262 == 0x00)
								{
									Eq_3 eax_267 = *((word32) eax_221 + 4);
									<anonymous> * ecx_268 = *((word32) eax_267 + 24);
									*esp_249 = (union Eq_3 *) eax_221;
									word32 esp_271;
									ecx_268();
									eax_192 = g_tA6DBBC;
									esp_122 = esp_271 + 0x04;
								}
								if (eax_192 != 0x00)
									goto l00719278;
							}
l00719457:
							word32 edx_287 = g_dwA17FB0;
							struct Eq_115856 * esp_290 = esp_122 - 4;
							esp_290->ptr0000 = &g_t8D9474;
							esp_290->dwFFFFFFFC = edx_287;
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							Eq_3 stackArg4 = <invalid>;
							word32 ecx_1235;
							fn006E0F80(stackArg4, dwArg04, out ecx_1235, out edx_1027);
							struct Eq_115859 * eax_310 = esp_290->ptr0018;
							struct Eq_115876 * esp_311 = (const char *) &esp_290->ptr0000 + 4;
							if (eax_310 != null)
							{
								word32 v26_315 = eax_310->dw0000 + ~0x00;
								eax_310->dw0000 = v26_315;
								if (v26_315 == 0x00)
								{
									struct Eq_116026 * ecx_319 = eax_310->ptr0004;
									<anonymous> * edx_320 = ecx_319->ptr0018;
									esp_290->ptr0000 = eax_310;
									word32 esp_323;
									edx_320();
									esp_311 = esp_323 + 0x04;
								}
							}
							struct Eq_116009 * eax_333 = esp_311->ptr0024;
							if (eax_333 != null)
							{
								word32 v27_337 = eax_333->dw0000 + ~0x00;
								eax_333->dw0000 = v27_337;
								if (v27_337 == 0x00)
								{
									struct Eq_116189 * ecx_341 = eax_333->ptr0004;
									<anonymous> * edx_342 = ecx_341->ptr0018;
									esp_311->ptrFFFFFFFC = eax_333;
									word32 esp_350;
									edx_342();
									esp_311 = esp_350 + 0x04;
								}
							}
							struct Eq_116009 * eax_360 = esp_311->ptr0028;
							if (eax_360 != null)
							{
								word32 v28_364 = eax_360->dw0000 + ~0x00;
								eax_360->dw0000 = v28_364;
								if (v28_364 == 0x00)
								{
									struct Eq_116189 * ecx_368 = eax_360->ptr0004;
									<anonymous> * edx_369 = ecx_368->ptr0018;
									esp_311->ptrFFFFFFFC = eax_360;
									edx_369();
								}
							}
							goto l007194B6;
						}
					case 0x55:
						esp_122[11] = (struct Eq_115186) 9278832;
						ecx_100.u0 = 0x08;
						goto l007190BD;
					case 0x5C:
						*edi_41 = 0x5C;
						break;
					case 0x61:
						*edi_41 = 0x07;
						break;
					case 0x62:
						*edi_41 = 0x08;
						break;
					case 0x66:
						*edi_41 = 0x0C;
						break;
					case 110:
						*edi_41 = 0x0A;
						break;
					case 114:
						*edi_41 = 0x0D;
						break;
					case 116:
						*edi_41 = 0x09;
						break;
					case 117:
						esp_122[11] = (struct Eq_115186) 0x008D958C;
						ecx_100.u0 = 0x04;
						goto l007190BD;
					case 118:
						*edi_41 = 11;
						break;
					case 0x78:
						esp_122[11] = (struct Eq_115186) 9278884;
						ecx_100.u0 = 0x02;
l007190BD:
						struct Eq_115552 * ebp_94 = esp_122[5];
						esp_122[6] = (struct Eq_115186) 0x00;
						int32 ebx_99 = edi_41 - ebp_94->t000C;
						esp_122[0x0F] = (struct Eq_115186) ecx_100;
						esp_122[8] = (struct Eq_115186) (ebx_99 >> 0x01);
						eax_141 = 0x00;
						if (ecx_100 + (esi_58 + 0x01) >u Mem103[esp_122 + 0x34:word32])
						{
							word32 ecx_167 = esp_122[18];
							struct Eq_115600 * esp_169 = esp_122 - 4;
							esp_169->ptr0000 = (word32 *) (esp_122 + 4);
							esp_169->ptrFFFFFFFC = &esp_169->dw0020 + 1;
							esp_169->ptrFFFFFFF8 = (const char *) &esp_169->ptr0000 + 24;
							esp_169->ptrFFFFFFF4 = &esp_169->dw0034 + 5;
							esp_169->ptrFFFFFFF0 = &esp_169->dw0020;
							esp_169->ptrFFFFFFEC = &esp_169->dw0034 + 2;
							esp_169->dwFFFFFFE8 = esp_169->dw0034;
							esp_169->dw0020 = ecx_167;
							esp_169->dwFFFFFFE4 = 9278796;
							esp_190 = esp_169 - 28;
							goto l0071910F;
						}
						int32 ebp_109 = 0x00;
						if (ecx_100 > 0x00)
						{
							do
							{
								cu8 bl_115 = *((const char *) &esi_58->t0001 + ebp_109);
								Eq_3 eax_116 = (word32) bl_115;
								struct Eq_115661 * esp_118 = esp_122 - 4;
								esp_118->t0000 = eax_116;
								esp_118->t0020 = eax_116;
								esp_122 = (struct Eq_115186 *) ((const char *) &esp_118->t0000 + 4);
								if (isxdigit(esp_118->t0000) == 0x00)
								{
									eax_126 = esp_118->dw0034;
									esp_118->t0020 = &esi_58->b0002 + (ebp_109 - eax_126);
									goto l007191C9;
								}
								uint32 eax_131 = esp_118->dw001C;
								if (bl_115 <= 0x39)
									eax_141 = (word32) esp_118->t0020 + ((eax_131 << 0x04) - 0x30);
								else if (bl_115 <= 0x66)
									eax_141 = (word32) esp_118->t0020 + ((eax_131 << 0x04) - 0x57);
								else
									eax_141 = (word32) esp_118->t0020 + ((eax_131 << 0x04) - 55);
								esp_118->dw001C = eax_141;
								++ebp_109;
							} while (ebp_109 < esp_118->dw0040);
						}
						esi_14 = (const char *) &esi_58->t0001 + ebp_109;
						esp_122[0x0011] = (struct Eq_115186) esi_14;
						if (eax_141 == ~0x00)
						{
							if (fn006E0FC0() != 0x00)
								goto l007193EF;
l007192E0:
							eax_141 = (uint32) esp_122[6];
						}
						word16 ax_553 = (word16) eax_141;
						if (eax_141 > 0xFFFF)
						{
							if (eax_141 > 1114111)
							{
								int32 edi_510 = edi_41 - *((word32) (esp_122)[5].dwFFFFFFFC + 16);
								ui32 eax_511 = esp_122[0x0C];
								struct Eq_115756 * esp_513 = esp_122 - 4;
								esp_513->ptr0000 = (word32 *) (esp_122 + 4);
								esp_513->ptrFFFFFFFC = &esp_513->dw0024;
								esp_513->ptrFFFFFFF8 = (const char *) &esp_513->ptr0000 + 24;
								esp_513->ptrFFFFFFF4 = &esp_513->dw0024 + 9;
								esp_513->ptrFFFFFFF0 = &esp_513->ptr0020;
								esp_513->ptrFFFFFFEC = &esp_513->dw0024 + 6;
								esp_513->dwFFFFFFE8 = eax_511;
								esp_513->ptr0020 = esi_14 - eax_511;
								esp_513->dw0024 = edi_510 >> 0x01;
								esp_513->dwFFFFFFE4 = 0x008D94C4;
								esp_190 = esp_513 - 28;
								goto l0071910F;
							}
							else
							{
								uint32 eax_543 = eax_141 - 0x00010000;
								esp_122[6] = (struct Eq_115186) eax_543;
								*edi_41 = (word16) ((eax_543 >> 0x0A) - 0x2800);
								cx_609 = (word16) ((esp_122[6] & 0x03FF) - 0x2400);
								goto l007193E2;
							}
						}
						*edi_41 = ax_553;
						break;
					}
					goto l007193E8;
				}
l00719387:
				if (&esi_58->t0001 > esp_122[0x0D])
				{
					Eq_115452 edi_620 = edi_41 - *((word32) (esp_122)[5].dwFFFFFFFC + 16);
					ui32 eax_621 = esp_122[0x0C];
					struct Eq_115464 * esp_623 = esp_122 - 4;
					esp_623->ptr0000 = (word32 *) (esp_122 + 4);
					esp_623->ptrFFFFFFFC = &esp_623->dw0024;
					esp_623->ptrFFFFFFF8 = (const char *) &esp_623->ptr0000 + 24;
					esp_623->ptrFFFFFFF4 = &esp_623->ptr0048;
					esp_623->ptrFFFFFFF0 = &esp_623->ptr0020;
					esp_623->ptrFFFFFFEC = &esp_623->dw0024 + 6;
					esp_623->ptr0048 = esi_58;
					esp_623->dwFFFFFFE8 = eax_621;
					esp_623->ptr0020 = esi_58 - eax_621;
					esp_623->dw0024 = edi_620 >> 0x01;
					esp_623->dwFFFFFFE4 = 0x008D94B0;
					esp_190 = esp_623 - 28;
l0071910F:
					struct Eq_115518 * esp_654 = esp_190 - 4;
					esp_654->dw0000 = 9278780;
					esp_654->ptrFFFFFFFC = esp_190 + 0x44;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_3 stackArg4 = <invalid>;
					Eq_3 stackArg16 = <invalid>;
					Eq_3 stackArg20 = <invalid>;
					Eq_3 stackArg24 = <invalid>;
					Eq_3 stackArg28 = <invalid>;
					Eq_3 stackArg32 = <invalid>;
					Eq_3 stackArg36 = <invalid>;
					Eq_3 stackArg40 = <invalid>;
					esp_122 = (struct Eq_115186 *) (&esp_654->dw0000 + 9);
					word32 ecx_1232;
					if (fn00717CB0(&esp_654->ptr004C, ecx, stackArg4, dwArg04, dwArg08, stackArg16, stackArg20, stackArg24, stackArg28, stackArg32, stackArg36, stackArg40, out ecx_1232, out edx_1027) != 0x00)
					{
						ebp_19 = esp_654->ptr0048;
						ebx_20 = esp_654->ptr004C;
						goto l007194C8;
					}
					esi_14 = esp_654->t0068;
					edi_41 = esp_654->t0034;
				}
				else
				{
					*edi_41 = 0x5C;
					cx_609 = (word16) esi_58->b0000;
l007193E2:
					edi_41 = (word32) edi_41 + 2;
					*edi_41 = cx_609;
l007193E8:
					edi_41 = (word32) edi_41 + 2;
l007193EB:
					esp_122[4] = (struct Eq_115186) edi_41;
				}
l007193EF:
			} while (esi_14 < esp_122[0x0D]);
			ebp_19 = (struct Eq_115175 *) esp_122[9];
			ebx_20 = (struct Eq_115177 *) esp_122[0x0A];
		}
		struct Eq_115201 * esp_737 = esp_122 - 4;
		esp_737->ptr0000 = edi_41 - *((word32) (esp_122)[5].dwFFFFFFFC + 16) >> 0x01;
		esp_737->ptrFFFFFFFC = (struct Eq_115217 **) (esp_122 + 5);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_3 stackArg4 = <invalid>;
		esp_122 = (struct Eq_115186 *) ((const char *) &esp_737->ptr0000 + 4);
		word32 ecx_1222;
		if (fn00717900(stackArg4, dwArg04, out ecx_1222, out edx_1027) >= 0x00)
		{
			if (ebp_19 != null)
			{
				word32 v18_866 = ebp_19->dw0000 + ~0x00;
				ebp_19->dw0000 = v18_866;
				if (v18_866 == 0x00)
				{
					struct Eq_115308 * edx_870 = ebp_19->ptr0004;
					<anonymous> * eax_871 = edx_870->ptr0018;
					esp_737->ptr0000 = ebp_19;
					word32 esp_874;
					eax_871();
					esp_122 = esp_874 + 0x04;
				}
			}
			if (ebx_20 != null)
			{
				word32 v19_887 = ebx_20->dw0000 + ~0x00;
				ebx_20->dw0000 = v19_887;
				if (v19_887 == 0x00)
				{
					struct Eq_115430 * ecx_891 = ebx_20->ptr0004;
					<anonymous> * edx_892 = ecx_891->ptr0018;
					esp_122->dwFFFFFFFC = ebx_20;
					word32 esp_900;
					edx_892();
					esp_122 = esp_900 + 0x04;
				}
			}
			eax_1012 = esp_122[5];
			goto l0071944F;
		}
l007194C8:
		struct Eq_115287 * eax_763 = esp_122[5];
		if (eax_763 != null)
		{
			word32 v29_767 = eax_763->dw0000 + ~0x00;
			eax_763->dw0000 = v29_767;
			if (v29_767 == 0x00)
			{
				struct Eq_116238 * edx_771 = eax_763->ptr0004;
				esp_122->dwFFFFFFFC = eax_763;
				word32 esp_780;
				edx_771->ptr0018();
				esp_122 = esp_780 + 0x04;
			}
		}
		if (ebp_19 != null)
		{
			word32 v30_793 = ebp_19->dw0000 + ~0x00;
			ebp_19->dw0000 = v30_793;
			if (v30_793 == 0x00)
			{
				struct Eq_115308 * ecx_797 = ebp_19->ptr0004;
				<anonymous> * edx_798 = ecx_797->ptr0018;
				esp_122->dwFFFFFFFC = ebp_19;
				word32 esp_806;
				edx_798();
				esp_122 = esp_806 + 0x04;
			}
		}
		if (ebx_20 != null)
		{
			word32 v31_819 = ebx_20->dw0000 + ~0x00;
			ebx_20->dw0000 = v31_819;
			if (v31_819 == 0x00)
			{
				struct Eq_115430 * eax_837 = ebx_20->ptr0004;
				<anonymous> * ecx_838 = eax_837->ptr0018;
				esp_122->dwFFFFFFFC = ebx_20;
				ptr32 edx_848;
				ecx_838();
				edxOut = edx_848;
				return 0x00;
			}
		}
	}
l007194B6:
	edxOut = edx_1027;
	return 0x00;
}

// 00719870: Register Eq_3 fn00719870(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Register out Eq_3 edxOut)
// Called from:
//      fn0073D2A0
Eq_3 fn00719870(Eq_3 dwArg04, Eq_3 dwArg08, union Eq_3 & edxOut)
{
	word32 edx_769;
	word32 ecx_768;
	Eq_3 eax_27 = fn00717740(dwArg08, out ecx_768, out edx_769);
	Eq_3 esi_104 = dwArg04;
	Eq_3 edx_176 = eax_27;
	if (eax_27 != 0x00)
	{
		if (dwArg08 == 0x00)
		{
l00719A8D:
			edxOut = edx_176;
			return eax_27;
		}
		Eq_3 ebp_185 = *((word32) eax_27 + 0x0C);
		word32 ecx_39 = dwArg04 + dwArg08;
		if (dwArg04 < ecx_39)
		{
			ecx_186 = ecx_39;
			do
			{
				Eq_3 ecx_186;
				byte al_46 = *esi_104;
				if (al_46 != 0x5C)
				{
					*ebp_185 = (word16) al_46;
					ebp_185 = (word32) ebp_185 + 2;
					esi_104 = (word32) esi_104 + 1;
				}
				else
				{
					if (esi_104 < ecx_186)
					{
						while (*esi_104 == 0x5C)
						{
							*ebp_185 = 0x5C;
							esi_104 = (word32) esi_104 + 1;
							ebp_185 = (word32) ebp_185 + 2;
							if (esi_104 >= ecx_186)
								break;
						}
					}
					if (((byte) (esi_104 - esi_104) & 0x01) != 0x00)
					{
						if (esi_104 >= ecx_186)
							break;
						byte al_82 = *esi_104;
						if (al_82 == 117 || al_82 == 0x55)
						{
							Eq_3 ebp_90 = ebp_185 - 0x02;
							esi_104 = (word32) esi_104 + 1;
							uint32 edi_110 = 0x00;
							word16 di_268 = 0x00;
							int32 ebx_113 = (uint32) (int8) (al_82 != 117) * 0x04 + 0x04;
							word32 dwLoc14_592 = 0x01;
							if (ebx_113 > 0x00)
							{
								do
								{
									cu8 bl_123 = *esi_104;
									if (isxdigit((word32) bl_123) == 0x00)
									{
										word32 ecx_771;
										if (fn00717CB0(fp - 0x20, dwArg08, fp - 0x24, dwArg04, dwArg08, dwArg04, fp - 0x08, fp - 0x0C, fp + 0x04, fp - 44, fp - 0x10, fp - 0x28, out ecx_771, out edx_176) != 0x00)
											goto l00719AFA;
										esi_104 = dwArg04;
										ebp_185 = ebp_90;
										ecx_186 = ecx_39;
										goto l00719A30;
									}
									ui32 edi_189 = edi_110 << 0x04;
									if (bl_123 <= 0x39)
										edi_110 = (word32) dwArg04 + (edi_189 - 0x30);
									else if (bl_123 <= 0x66)
										edi_110 = (word32) dwArg04 + (edi_189 - 0x57);
									else
										edi_110 = (word32) dwArg04 + (edi_189 - 55);
									di_268 = (word16) edi_110;
									esi_104 = (word32) esi_104 + 1;
									dwLoc14_592 = dwLoc14_773 + 0x01;
									dwLoc14_773 = dwLoc14_592;
								} while (dwLoc14_773 + 0x00 < ebx_113);
								if (edi_110 > 0x00010000)
								{
									word32 ecx_772;
									if (fn00717CB0(fp - 0x20, dwArg08, fp - 0x24, dwArg04, dwArg08, dwArg04, fp - 0x08, fp - 0x0C, fp + 0x04, fp - 44, fp - 0x10, fp - 0x28, out ecx_772, out edx_176) != 0x00)
									{
l00719AFA:
										goto l00719AFE;
									}
									esi_104 = dwArg04;
								}
								ecx_186 = ecx_39;
							}
							*ebp_90 = di_268;
							ebp_185 = (word32) ebp_90 + 2;
						}
					}
				}
l00719A30:
			} while (esi_104 < ecx_186);
		}
		struct Eq_116327 * esp_336 = fp - 0x3C;
		word32 ecx_770;
		if (fn00717900(fp - 44, dwArg04, out ecx_770, out edx_176) >= 0x00)
		{
			if (false)
			{
				<anonymous> ** v20_440 = (const char *) null - 1;
				null = (<anonymous> ***) v20_440;
				if (v20_440 == null)
				{
					struct Eq_1218 * ecx_444 = *(struct Eq_1218 **) 0x04;
					word32 esp_448;
					ecx_444->ptr0018();
					esp_336 = esp_448 + 0x04;
				}
			}
			struct Eq_116469 * eax_458 = esp_336->ptr001C;
			if (eax_458 != null)
			{
				word32 v21_462 = eax_458->dw0000 + ~0x00;
				eax_458->dw0000 = v21_462;
				if (v21_462 == 0x00)
				{
					struct Eq_116532 * ecx_466 = eax_458->ptr0004;
					<anonymous> * edx_467 = ecx_466->ptr0018;
					esp_336->ptrFFFFFFFC = eax_458;
					word32 esp_475;
					edx_467();
					esp_336 = esp_475 + 0x04;
				}
			}
			eax_27 = esp_336->t0010;
			goto l00719A8D;
		}
l00719AFE:
		struct Eq_116464 * esp_340 = fp - 0x3C;
		if (eax_27 != 0x00)
		{
			word32 v22_346 = (word32) *eax_27 - 1;
			*eax_27 = v22_346;
			if (v22_346 == 0x00)
			{
				Eq_3 ecx_350 = *((word32) eax_27 + 4);
				word32 esp_363;
				(*((word32) ecx_350 + 24))();
				esp_340 = esp_363 + 0x04;
			}
		}
		if (false)
		{
			<anonymous> ** v24_376 = (const char *) null - 1;
			null = (<anonymous> ***) v24_376;
			if (v24_376 == null)
			{
				struct Eq_1218 * eax_380 = *(struct Eq_1218 **) 0x04;
				<anonymous> * ecx_381 = eax_380->ptr0018;
				esp_340->ptrFFFFFFFC = null;
				word32 esp_389;
				ecx_381();
				esp_340 = esp_389 + 0x04;
			}
		}
		struct Eq_116574 * eax_399 = esp_340->ptr001C;
		if (eax_399 != null)
		{
			word32 v25_403 = eax_399->dw0000 + ~0x00;
			eax_399->dw0000 = v25_403;
			if (v25_403 == 0x00)
			{
				struct Eq_116614 * edx_407 = eax_399->ptr0004;
				esp_340->ptrFFFFFFFC = eax_399;
				edx_407->ptr0018();
			}
		}
	}
	edxOut = edx_176;
	return 0x00;
}

// 00719DD0: Register Eq_3 fn00719DD0(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Register out Eq_3 edxOut)
// Called from:
//      fn0071FEB0
Eq_3 fn00719DD0(Eq_3 dwArg04, Eq_3 dwArg08, union Eq_3 & edxOut)
{
	Eq_3 edx_127;
	Eq_3 esi_32 = dwArg08;
	if (dwArg08 == 0x01)
	{
		word32 edi_49 = (word32) (word16) *dwArg04;
		cup16 di_50 = (word16) edi_49;
		word16 wArg08_172 = (word16) edi_49;
		if (di_50 < 0x0100)
		{
			ui32 esi_71 = (word32) di_50;
			Eq_3 eax_72 = *((const char *) g_aA6D7B0 + esi_71 * 0x04);
			if (eax_72 != 0x00)
			{
l00719E1A:
				*eax_72 = (word32) *eax_72 + 1;
				edxOut = edx;
				return eax_72;
			}
			word32 ecx_183;
			eax_72 = fn00717740(0x01, out ecx_183, out edx_127);
			if (eax_72 != 0x00)
			{
				edx = *((word32) eax_72 + 0x0C);
				edx->u2 = di_50;
				*((const char *) g_aA6D7B0 + esi_71 * 0x04) = (struct Eq_118654 **) eax_72;
				goto l00719E1A;
			}
		}
		else
		{
			word32 ecx_182;
			Eq_3 eax_56 = fn00717740(0x01, out ecx_182, out edx_127);
			word16 edx_16_16_131 = SLICE(edx_127, word16, 16);
			if (eax_56 != 0x00)
			{
				**((word32) eax_56 + 0x0C) = wArg08_172;
				edxOut = SEQ(edx_16_16_131, wArg08_172);
				return eax_56;
			}
		}
	}
	else
	{
		word32 ecx_181;
		Eq_3 eax_15 = fn00717740(dwArg08, out ecx_181, out edx_127);
		if (eax_15 != 0x00)
		{
			if (dwArg08 != 0x00)
			{
				Eq_3 ecx_26 = *((word32) eax_15 + 0x0C);
				if (dwArg08 > 0x00)
				{
					edx_127 = dwArg04;
					do
					{
						*ecx_26 = (word16) *edx_127;
						--esi_32;
						ecx_26 = (word32) ecx_26 + 2;
						edx_127 = (word32) edx_127 + 1;
					} while (esi_32 > 0x00);
				}
			}
			edxOut = edx_127;
			return eax_15;
		}
	}
	edxOut = edx_127;
	return 0x00;
}

// 00719E80: Register Eq_3 fn00719E80(Register (ptr32 (ptr32 Eq_59662)) esi, Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Stack Eq_3 dwArg0C, Register out Eq_116735 edxOut)
// Called from:
//      fn00719F20
//      fn0071A060
Eq_3 fn00719E80(struct Eq_59662 ** esi, Eq_3 dwArg04, Eq_3 dwArg08, Eq_3 dwArg0C, union Eq_116735 & edxOut)
{
	struct Eq_59662 * eax_6 = *esi;
	if (eax_6 != null)
	{
		Eq_3 ecx_129;
		Eq_116735 edx_132;
		if (fn006E3770(eax_6, ecx, out ecx_129, out edx_132) != 0x00 || (fn006E38B0(*esi, edi, out ecx_129, out edx_132) != 0x00 || fn006E3900(*esi, ebx, out ecx_129, out edx_132) != 0x00))
		{
			struct Eq_59662 * eax_59 = *esi;
			eax_59->dw0000 += ~0x00;
			struct Eq_59662 * eax_62 = *esi;
			if (eax_62->dw0000 == 0x00)
			{
				struct Eq_116805 * edx_65 = eax_62->ptr0004;
				edx_65->ptr0018();
			}
			*esi = (struct Eq_59662 **) null;
		}
		edxOut = edx_132;
		return ecx_129;
	}
	else
	{
		Eq_116735 edx_101;
		Eq_3 ecx_102;
		*esi = (struct Eq_59662 **) fn006E3D10(out ecx_102, out edx_101);
		edxOut = edx_101;
		return ecx_102;
	}
}

// 00719F20: Register Eq_3 fn00719F20(Register (ptr32 (ptr32 Eq_59662)) ecx, Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Stack Eq_3 dwArg0C, Stack Eq_3 dwArg10, Stack Eq_3 dwArg14, Stack Eq_3 dwArg18, Stack Eq_3 dwArg1C, Register out Eq_3 ecxOut, Register out Eq_3 edxOut)
// Called from:
//      fn0071A060
Eq_3 fn00719F20(struct Eq_59662 ** ecx, Eq_3 dwArg04, Eq_3 dwArg08, Eq_3 dwArg0C, Eq_3 dwArg10, Eq_3 dwArg14, Eq_3 dwArg18, Eq_3 dwArg1C, union Eq_3 & ecxOut, union Eq_3 & edxOut)
{
	if (*dwArg04 == 0x00)
	{
		Eq_3 ecx_19;
		Eq_3 edx_21;
		Eq_3 eax_20 = fn0074EFB0(eax, out ecx_19, out edx_21);
		*dwArg04 = eax_20;
		if (eax_20 == 0x00)
		{
			ecxOut = ecx_19;
			edxOut = edx_21;
			return eax_20;
		}
	}
	Eq_3 edx_117;
	Eq_3 ecx_115 = fn00719E80(ecx, dwArg08, dwArg04, dwArg10, out edx_117);
	if (*ecx == null)
	{
l0071A056:
		ecxOut = ecx_115;
		edxOut = edx_117;
		return 0x00;
	}
	Eq_3 eax_69 = fn00703AF0(*dwArg04, out ecx_115, out edx_117);
	if (eax_69 == 0x00)
		goto l0071A056;
	Eq_3 eax_160;
	Eq_3 eax_78 = *((word32) eax_69 + 4);
	if (eax_78 != 0x00A16588)
	{
		word32 edx_418;
		word32 ecx_417;
		if (fn006D5670(eax_78, 0x00A16588, out ecx_417, out edx_418) == 0x00)
		{
			eax_160 = fn006E15D0(g_tA16B7C, dwArg04, out ecx_115, out edx_117);
			goto l0071A045;
		}
	}
	if (fn006E7CB0(out ecx_115, out edx_117) == 0x00)
	{
		word32 v14_194 = (word32) *eax_69 - 1;
		*eax_69 = v14_194;
		if (v14_194 == 0x00)
		{
			Eq_3 edx_198 = *((word32) eax_69 + 4);
			<anonymous> * eax_199 = *((word32) edx_198 + 24);
			Eq_3 ecx_203;
			Eq_3 edx_205;
			eax_199();
			ecxOut = ecx_203;
			edxOut = edx_205;
			return 0x00;
		}
		goto l0071A056;
	}
	Eq_3 eax_124 = *dwArg1C;
	if (eax_124 < 0x00)
	{
		word32 eax_129 = eax_124 + dwArg10;
		*dwArg1C = eax_129;
		ecx_115 = dwArg10;
		if (eax_129 < 0x00)
		{
l0071A02F:
			eax_160 = fn006E15D0(g_tA17CA4, dwArg04, out ecx_115, out edx_117);
l0071A045:
			word32 v13_236 = (word32) *eax_69 - 1;
			*eax_69 = v13_236;
			if (v13_236 == 0x00)
			{
				Eq_3 ecx_240 = *((word32) eax_69 + 4);
				(*((word32) ecx_240 + 24))();
			}
			goto l0071A056;
		}
	}
	Eq_3 edx_135 = dwArg10;
	if (*dwArg1C <= dwArg10)
	{
		*dwArg04 = (word32) *dwArg04 + 1;
		word32 v18_169 = (word32) *eax_69 - 1;
		*eax_69 = v18_169;
		if (v18_169 == 0x00)
		{
			Eq_3 eax_173 = *((word32) eax_69 + 4);
			<anonymous> * ecx_174 = *((word32) eax_173 + 24);
			ecx_174();
		}
		ecxOut = ecx_115;
		edxOut = edx_135;
		return dwArg04;
	}
	goto l0071A02F;
}

// 0071A060: Register Eq_3 fn0071A060(Register Eq_3 eax, Stack Eq_3 dwArg04, Stack Eq_3 dwArg0C, Register out Eq_3 ecxOut, Register out (ptr32 word16) edxOut)
// Called from:
//      fn0071A550
//      fn0071A7D0
Eq_3 fn0071A060(Eq_3 eax, Eq_3 dwArg04, Eq_3 dwArg0C, union Eq_3 & ecxOut, word16 & edxOut)
{
	Eq_3 ebx_18 = eax;
	Eq_3 ebp_19 = (word32) eax + dwArg04 * 0x02;
	word32 ecx_1245;
	word16 * edx_1016;
	Eq_3 eax_1000 = fn006EC9B0(0x00, dwArg04, out ecx_1245, out edx_1016);
	struct Eq_117001 * edi_30 = null;
	Eq_3 ecx_1004 = eax_1000;
	struct Eq_117004 * esp_361 = fp - 0x44;
	if (eax_1000 == 0x00)
	{
l0071A4BF:
		ecxOut = ecx_1004;
		edxOut = edx_1016;
		return 0x00;
	}
	else
	{
		if (dwArg04 != 0x00)
		{
			word32 eax_62 = (word32) eax_1000 + 20;
			if (eax < ebp_19)
			{
				esp_361 = fp - 0x44;
				do
				{
					word32 eax_69 = (word32) *ebx_18;
					byte al_768 = (byte) eax_69;
					word16 * ecx_71 = esp_361[20];
					edx_1016 = (word32) (word16) eax_69;
					if (edx_1016 < ecx_71)
					{
						byte * ecx_767 = esp_361[4];
						*ecx_767 = al_768;
						esp_361[4] = (struct Eq_117004) (ecx_767 + 1);
						ebx_18 = (word32) ebx_18 + 2;
						goto l0071A3B1;
					}
					int32 eax_77 = ebx_18 - esp_361[9];
					esp_361[7] = (struct Eq_117004) ebx_18;
					esp_361[0x0F] = (struct Eq_117004) (eax_77 >> 0x01);
					Eq_3 eax_81 = esp_361[11];
					Eq_3 ebp_217 = ebx_18;
					if (ebx_18 < eax_81)
					{
						do
						{
							edx_1016 = (word32) *ebp_217;
							if (edx_1016 < ecx_71)
								break;
							ebp_217 = (word32) ebp_217 + 2;
						} while (ebp_217 < eax_81);
					}
					ui32 eax_124 = esp_361[8];
					if (eax_124 == ~0x00)
					{
						byte * eax_102 = esp_361[19];
						if (eax_102 != null)
						{
							byte * edi_106 = &g_b8D1DC8;
							byte * esi_107 = eax_102;
							word32 ecx_108 = 0x07;
							edx_1016 = null;
							bool v29_893 = true;
							while (ecx_108 != 0x00)
							{
								v29_893 = *esi_1260 == *edi_1261;
								esi_107 = esi_1260 + 1;
								edi_106 = edi_1261 + 1;
								--ecx_108;
								esi_1260 = esi_107;
								edi_1261 = edi_106;
								if (*esi_1260 == *edi_1261)
									break;
							}
							if (v29_893)
								goto l0071A1AF;
							byte * edi_125 = &g_b8D46D8;
							byte * esi_128 = eax_102;
							word32 ecx_129 = 0x08;
							edx_1016 = null;
							bool v33_897 = false;
							while (ecx_129 != 0x00)
							{
								v33_897 = *esi_1262 != *edi_1263;
								esi_128 = esi_1262 + 1;
								edi_125 = edi_1263 + 1;
								--ecx_129;
								esi_1262 = esi_128;
								edi_1263 = edi_125;
								if (*esi_1262 == *edi_1263)
									break;
							}
							if (!v33_897)
								eax_124 = 0x02;
							else
							{
								byte * edi_145 = &g_b8B056C;
								byte * esi_148 = eax_102;
								word32 ecx_149 = 0x07;
								edx_1016 = null;
								bool v37_901 = false;
								while (ecx_149 != 0x00)
								{
									v37_901 = *esi_1264 != *edi_1265;
									esi_148 = esi_1264 + 1;
									edi_145 = edi_1265 + 1;
									--ecx_149;
									esi_1264 = esi_148;
									edi_1265 = edi_145;
									if (*esi_1264 == *edi_1265)
										break;
								}
								if (!v37_901)
									eax_124 = 0x03;
								else
								{
									byte * esi_167 = eax_102;
									bool v41_905 = false;
									byte * edi_171 = &g_b8D9620;
									word32 ecx_172 = 0x12;
									while (ecx_172 != 0x00)
									{
										v41_905 = *esi_1266 != *edi_1267;
										esi_167 = esi_1266 + 1;
										edi_171 = edi_1267 + 1;
										--ecx_172;
										esi_1266 = esi_167;
										edi_1267 = edi_171;
										if (*esi_1266 == *edi_1267)
											break;
									}
									eax_124 = (uint32) (int8) v41_905 - 0x01 & 0x04;
								}
							}
						}
						else
						{
l0071A1AF:
							eax_124 = 0x01;
						}
						esp_361[8] = (struct Eq_117004) eax_124;
					}
					struct Eq_117004 * esp_293;
					struct Eq_117102 * esi_399;
					up32 eax_209 = eax_124 + ~0x00;
					if (eax_209 <= 0x03)
					{
						switch (eax_209)
						{
						case 0x00:
							word32 eax_630 = esp_361[9];
							struct Eq_117403 * esp_632 = esp_361 - 4;
							esp_632->ptr0000 = (struct Eq_117102 *) esp_361[18];
							esp_632->dwFFFFFFFC = eax_630;
							esp_632->dwFFFFFFF8 = esp_632->dw0034;
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							Eq_3 stackArg4 = <invalid>;
							Eq_3 stackArg12 = <invalid>;
							ecx_1004 = fn00719E80(&esp_632->ptr001C, stackArg4, dwArg04, stackArg12, out edx_1016);
							esi_399 = esp_632->ptr001C;
							esp_293 = (struct Eq_117004 *) ((const char *) &esp_632->ptr0000 + 4);
							if (esi_399 != null)
							{
								esp_632->ptr0000 = esi_399;
								// Failed to bind call argument.
								// Please report this issue at https://github.com/uxmal/reko
								Eq_3 stackArg4 = <invalid>;
								ecx_1004 = fn0074E280(stackArg4, out edx_1016);
								esp_293 = (struct Eq_117004 *) ((const char *) &esp_632->ptr0000 + 4);
							}
							goto l0071A471;
						case 0x01:
							if (ebx_18 < ebp_217)
							{
								Eq_3 edi_611 = esp_361[4];
								uint32 esi_615 = ebp_217 - ebx_18 - 0x01 >> 0x01;
								struct Eq_117499 * esp_617 = esp_361 - 4;
								esp_617->t0000 = esi_615 + 0x01;
								esp_617->dwFFFFFFFC = 0x3F;
								esp_617->tFFFFFFF8 = edi_611;
								memset(esp_617->tFFFFFFF8, esp_617->dwFFFFFFFC, esp_617->t0000);
								esp_617->dw0014 = (word32) edi_611 + (esi_615 + 0x01);
							}
							break;
						case 0x02:
							break;
						case 0x03:
							word32 edi_477 = esp_361[4] - esp_361[5];
							word32 ecx_478 = 0x00;
							for (; ebx_18 < ebp_217; ebx_18 += 0x02)
							{
								cup16 ax_499 = *ebx_18;
								if (ax_499 < 0x0A)
									ecx_478 += 0x04;
								else if (ax_499 < 100)
									ecx_478 += 0x05;
								else if (ax_499 < 1000)
									ecx_478 += 0x06;
								else if (ax_499 < 10000)
									ecx_478 += 0x07;
								else
									ecx_478 += 0x08;
							}
							int32 eax_531 = esp_361[0x0A];
							int32 esi_541 = (esp_361[11] - ebp_217 >> 0x01) + ecx_478 + (edi_477 - 0x14);
							if (esi_541 > eax_531)
							{
								if (esi_541 < eax_531 * 0x02)
									esi_541 = eax_531 * 0x02;
								struct Eq_117580 * esp_550 = esp_361 - 4;
								esp_550->dw0000 = esi_541;
								esp_550->ptrFFFFFFFC = (word32 *) (esp_361 + 5);
								// Failed to bind call argument.
								// Please report this issue at https://github.com/uxmal/reko
								Eq_3 stackArg4 = <invalid>;
								esp_293 = (struct Eq_117004 *) (&esp_550->dw0000 + 1);
								if (fn006EC4F0(stackArg4, dwArg04, out ecx_1004, out edx_1016) != 0x00)
									goto l0071A46D;
								edx_1016 = esp_550->ptr0018;
								esp_550->dw0014 = edx_1016 + edi_477;
								esp_550->dw002C = esi_541;
							}
							Eq_3 esi_583 = esp_361[7];
							if (esi_583 < ebp_217)
							{
								Eq_3 edi_588 = esp_361[4];
								do
								{
									struct Eq_117618 * esp_593 = esp_361 - 4;
									esp_593->dw0000 = (word32) *esi_583;
									esp_593->tFFFFFFFC.u0 = 0x008A8448;
									esp_593->tFFFFFFF8 = edi_588;
									esi_583 = (word32) esi_583 + 2;
									esp_361 = (struct Eq_117004 *) (&esp_593->dw0000 + 1);
									edi_588 = (word32) edi_588 + sprintf(esp_593->tFFFFFFF8, esp_593->tFFFFFFFC, esp_593->dw0000);
								} while (esi_583 < ebp_217);
								esp_593->t0014 = edi_588;
								ebx_18 = ebp_217;
								goto l0071A3B1;
							}
							break;
						}
						ebx_18 = ebp_217;
						goto l0071A3B1;
					}
					word16 * eax_214 = esp_361[9];
					struct Eq_117336 * esp_231 = esp_361 - 4;
					esp_231->ptr0000 = (struct Eq_117340 *) (esp_361 + 16);
					word32 edx_233 = esp_231->dw0040;
					esp_231->ptrFFFFFFFC = ebp_217 - eax_214 >> 0x01;
					word32 ecx_238 = esp_231->dw004C;
					esp_231->dwFFFFFFF8 = edx_233;
					word32 edx_241 = esp_231->dw0034;
					esp_231->dwFFFFFFF4 = ecx_238;
					esp_231->ptrFFFFFFF0 = eax_214;
					esp_231->dwFFFFFFEC = edx_241;
					esp_231->ptrFFFFFFE8 = &esp_231->dw0034 + 2;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_3 stackArg4 = <invalid>;
					Eq_3 stackArg12 = <invalid>;
					Eq_3 stackArg20 = <invalid>;
					Eq_3 stackArg24 = <invalid>;
					Eq_3 stackArg28 = <invalid>;
					struct Eq_117340 * eax_288 = fn00719F20(&esp_231->dw0018 + 1, stackArg4, dwArg04, stackArg12, dwArg0C, stackArg20, stackArg24, stackArg28, out ecx_1004, out edx_1016);
					esp_231->ptr0020 = eax_288;
					esp_293 = (struct Eq_117004 *) ((const char *) &esp_231->ptr0000 + 4);
					if (eax_288 == null)
					{
l0071A46D:
						esi_399 = (struct Eq_117102 *) esp_293[6];
l0071A471:
						struct Eq_117102 * eax_671 = esp_293[5];
						if (eax_671 != null)
						{
							eax_671->dw0000 += ~0x00;
							struct Eq_117102 * eax_677 = esp_293[5];
							if (eax_677->dw0000 == 0x00)
							{
								struct Eq_117318 * ecx_680 = eax_677->ptr0004;
								<anonymous> * edx_681 = ecx_680->ptr0018;
								esp_293->dwFFFFFFFC = eax_677;
								word32 esp_693;
								edx_681();
								esp_293 = esp_693 + 0x04;
							}
						}
						struct Eq_117102 * eax_703 = esp_293[0x0E];
						if (eax_703 != null)
						{
							word32 v21_707 = eax_703->dw0000 + ~0x00;
							eax_703->dw0000 = v21_707;
							if (v21_707 == 0x00)
							{
								struct Eq_117318 * ecx_711 = eax_703->ptr0004;
								<anonymous> * edx_712 = ecx_711->ptr0018;
								esp_293->dwFFFFFFFC = eax_703;
								word32 esp_720;
								edx_712();
								esp_293 = esp_720 + 0x04;
							}
						}
						if (esi_399 != null)
						{
							word32 v22_733 = esi_399->dw0000 + ~0x00;
							esi_399->dw0000 = v22_733;
							if (v22_733 == 0x00)
							{
								struct Eq_117318 * eax_737 = esi_399->ptr0004;
								<anonymous> * ecx_738 = eax_737->ptr0018;
								esp_293->dwFFFFFFFC = esi_399;
								ecx_738();
							}
						}
						goto l0071A4BF;
					}
					byte * ecx_298 = esp_231->ptr0014;
					int32 ebx_304 = eax_288->dw0008;
					word32 edi_302 = ecx_298 - esp_231->dw0018;
					struct Eq_117340 * eax_305 = esp_231->ptr002C;
					struct Eq_117340 * esi_309 = (esp_231->dw0030 - ebp_217 >> 0x01) + ebx_304 + (edi_302 - 0x14);
					if (esi_309 > eax_305)
					{
						if (esi_309 < eax_305 * 0x02)
							esi_309 = eax_305 * 0x02;
						esp_231->ptr0000 = esi_309;
						esp_231->ptrFFFFFFFC = &esp_231->dw0018;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_3 stackArg4 = <invalid>;
						esp_293 = (struct Eq_117004 *) ((const char *) &esp_231->ptr0000 + 4);
						if (fn006EC4F0(stackArg4, dwArg04, out ecx_1004, out edx_1016) == 0x00)
						{
							ecx_298 = edi_302 + esp_231->dw0018;
							esp_231->ptr0014 = ecx_298;
							esp_231->ptr002C = esi_309;
							goto l0071A35B;
						}
						struct Eq_117340 * eax_337 = esp_231->ptr0020;
						word32 v24_338 = eax_337->dw0000 + ~0x00;
						eax_337->dw0000 = v24_338;
						if (v24_338 == 0x00)
						{
							struct Eq_117903 * ecx_342 = eax_337->ptr0004;
							<anonymous> * edx_343 = ecx_342->ptr0018;
							esp_231->ptr0000 = eax_337;
							word32 esp_346;
							edx_343();
							esp_293 = esp_346 + 0x04;
						}
						goto l0071A46D;
					}
l0071A35B:
					edx_1016 = (word16 *) *((word32) esp_361[7].dwFFFFFFFC + 16);
					if (ebx_304 > 0x00)
					{
						int32 esi_365 = esp_361[20];
						int32 ebx_366 = ebx_304;
						do
						{
							word32 eax_369 = (word32) *edx_1016;
							byte al_438 = (byte) eax_369;
							--ebx_366;
							if ((word32) (word16) eax_369 >= esi_365)
							{
								word32 edx_379 = esp_361[9];
								struct Eq_117834 * esp_382 = esp_361 - 4;
								esp_382->ptr0000 = (struct Eq_117102 *) esp_361[18];
								word32 eax_384 = esp_382->dw0034;
								esp_382->dwFFFFFFFC = edx_379;
								esp_382->dwFFFFFFF8 = eax_384;
								// Failed to bind call argument.
								// Please report this issue at https://github.com/uxmal/reko
								// Failed to bind call argument.
								// Please report this issue at https://github.com/uxmal/reko
								Eq_3 stackArg4 = <invalid>;
								Eq_3 stackArg12 = <invalid>;
								ecx_1004 = fn00719E80(&esp_382->ptr001C, stackArg4, dwArg04, stackArg12, out edx_1016);
								esi_399 = esp_382->ptr001C;
								if (esi_399 != null)
								{
									esp_382->ptr0000 = esi_399;
									// Failed to bind call argument.
									// Please report this issue at https://github.com/uxmal/reko
									Eq_3 stackArg4 = <invalid>;
									ecx_1004 = fn0074E280(stackArg4, out edx_1016);
								}
								struct Eq_117917 * eax_416 = esp_361[7];
								word32 v25_417 = eax_416->dw0000 + ~0x00;
								eax_416->dw0000 = v25_417;
								esp_293 = esp_361;
								if (v25_417 == 0x00)
								{
									struct Eq_117939 * ecx_421 = eax_416->ptr0004;
									<anonymous> * edx_422 = ecx_421->ptr0018;
									esp_361->dwFFFFFFFC = eax_416;
									word32 esp_430;
									edx_422();
									esp_293 = esp_430 + 0x04;
								}
								goto l0071A471;
							}
							*ecx_298 = al_438;
							++ecx_298;
							esp_361[4] = (struct Eq_117004) ecx_298;
							++edx_1016;
						} while (ebx_366 > 0x00);
					}
					struct Eq_117801 * eax_451 = esp_361[7];
					ebx_18 = (word32) esp_361[9].dwFFFFFFFC + (esp_361[16] * 0x02 + 4);
					word32 v23_452 = eax_451->dw0000 + ~0x00;
					eax_451->dw0000 = v23_452;
					if (v23_452 == 0x00)
					{
						struct Eq_117889 * edx_456 = eax_451->ptr0004;
						esp_361->dwFFFFFFFC = eax_451;
						<anonymous> * eax_459 = edx_456->ptr0018;
						word32 esp_468;
						eax_459();
						esp_361 = esp_468 + 0x04;
					}
l0071A3B1:
				} while (ebx_18 < esp_361[11]);
				edi_30 = (struct Eq_117001 *) esp_361[0x0E];
				eax_62 = (word32) esp_361[4];
				ecx_1004 = esp_361[5];
			}
			int32 eax_786 = eax_62 - ecx_1004;
			if (eax_786 - 0x14 < esp_361[0x0A])
			{
				struct Eq_117194 * esp_792 = esp_361 - 4;
				esp_792->dw0000 = eax_786 - 0x14;
				esp_792->ptrFFFFFFFC = &esp_792->dw0000 + 6;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_3 stackArg4 = <invalid>;
				fn006EC4F0(stackArg4, dwArg04, out ecx_1004, out edx_1016);
			}
			struct Eq_117004 * esp_829 = esp_361;
			if (edi_30 != null)
			{
				word32 v17_823 = edi_30->dw0000 + ~0x00;
				edi_30->dw0000 = v17_823;
				if (v17_823 == 0x00)
				{
					struct Eq_117228 * eax_827 = edi_30->ptr0004;
					<anonymous> * ecx_828 = eax_827->ptr0018;
					esp_361->dwFFFFFFFC = edi_30;
					word32 esp_836;
					ecx_828();
					esp_829 = esp_836 + 0x04;
				}
			}
			struct Eq_117102 * eax_846 = esp_829[6];
			if (eax_846 != null)
			{
				word32 v18_850 = eax_846->dw0000 + ~0x00;
				eax_846->dw0000 = v18_850;
				if (v18_850 == 0x00)
				{
					struct Eq_117318 * edx_854 = eax_846->ptr0004;
					esp_829->dwFFFFFFFC = eax_846;
					<anonymous> * eax_857 = edx_854->ptr0018;
					word32 esp_863;
					eax_857();
					esp_829 = esp_863 + 0x04;
				}
			}
			eax_1000 = esp_829[5];
		}
		ecxOut = ecx_1004;
		edxOut = edx_1016;
		return eax_1000;
	}
}

// 0071A550: Register word32 fn0071A550(Stack Eq_3 dwArg04, Register out ptr32 ecxOut, Register out ptr32 edxOut)
// Called from:
//      fn0071FB20
word32 fn0071A550(Eq_3 dwArg04, ptr32 & ecxOut, ptr32 & edxOut)
{
	Eq_3 eax_8 = *((word32) dwArg04 + 4);
	if (eax_8 != 0x00A23B20)
	{
		word32 ecx_91;
		word32 edx_92;
		if (fn006D5670(eax_8, 0x00A23B20, out ecx_91, out edx_92) == 0x00)
		{
			ptr32 edx_52;
			ecxOut = fn006E11D0(out edx_52);
			edxOut = edx_52;
			return 0x00;
		}
	}
	ptr32 ecx_40;
	ptr32 edx_42;
	word32 eax_39 = fn0071A060(*((word32) dwArg04 + 0x0C), *((word32) dwArg04 + 8), 0x0100, out ecx_40, out edx_42);
	ecxOut = ecx_40;
	edxOut = edx_42;
	return eax_39;
}

// 0071A5A0: Register Eq_3 fn0071A5A0(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Register out Eq_3 edxOut)
// Called from:
//      fn0071FEB0
Eq_3 fn0071A5A0(Eq_3 dwArg04, Eq_3 dwArg08, union Eq_3 & edxOut)
{
	Eq_3 esi_114 = dwArg04;
	if (dwArg08 == 0x01)
	{
		cu8 al_25 = *dwArg04;
		if (al_25 < 0x80)
		{
			word32 edi_317 = (word32) (word16) al_25;
			cup16 di_318 = (word16) edi_317;
			word16 wArg04_553 = (word16) edi_317;
			if (di_318 < 0x0100)
			{
				ui32 esi_344 = (word32) di_318;
				Eq_3 eax_345 = *((const char *) g_aA6D7B0 + esi_344 * 0x04);
				if (eax_345 != 0x00)
				{
l0071A602:
					*eax_345 = (word32) *eax_345 + 1;
					edxOut = edx;
					return eax_345;
				}
				word32 ecx_584;
				eax_345 = fn00717740(dwArg08, out ecx_584, out edx);
				if (eax_345 != 0x00)
				{
					(*((word32) eax_345 + 0x0C))->u2 = di_318;
					*((const char *) g_aA6D7B0 + esi_344 * 0x04) = (struct Eq_118654 **) eax_345;
					goto l0071A602;
				}
			}
			else
			{
				word32 ecx_583;
				Eq_3 eax_324 = fn00717740(0x01, out ecx_583, out edx);
				word16 edx_16_16_443 = SLICE(edx, word16, 16);
				if (eax_324 != 0x00)
				{
					**((word32) eax_324 + 0x0C) = wArg04_553;
					edxOut = SEQ(edx_16_16_443, wArg04_553);
					return eax_324;
				}
			}
l0071A75C:
			edxOut = edx;
			return 0x00;
		}
	}
	word32 ecx_582;
	Eq_3 eax_220 = fn00717740(dwArg08, out ecx_582, out edx);
	Eq_3 ebp_115 = eax_220;
	if (eax_220 == 0x00)
		goto l0071A75C;
	if (dwArg08 != 0x00)
	{
		Eq_3 eax_116 = *((word32) eax_220 + 0x0C);
		edx = dwArg04 + dwArg08;
		Eq_3 dwLoc1C_481 = eax_116;
		if (dwArg04 < edx)
		{
			do
			{
				cu8 cl_57 = *esi_114;
				if (cl_57 < 0x80)
				{
					*eax_116 = (word16) cl_57;
					eax_116 = (word32) eax_116 + 2;
					esi_114 = (word32) esi_114 + 1;
					dwLoc1C_481 = eax_116;
				}
				else
				{
					word32 ecx_585;
					if (fn00717CB0(fp - 0x14, dwArg08, fp - 0x18, dwArg04, dwArg08, dwArg04, fp - 0x08, fp - 0x0C, fp + 0x04, fp + 0x08, fp - 0x10, fp - 0x1C, out ecx_585, out edx) != 0x00)
						goto l0071A711;
					esi_114 = dwArg04;
					ebp_115 = dwArg08;
					eax_116 = dwLoc1C_481;
				}
			} while (esi_114 < edx);
		}
		if (eax_116 - *((word32) ebp_115 + 0x0C) >> 0x01 < *((word32) ebp_115 + 8))
		{
			word32 ecx_586;
			if (fn00717900(fp + 0x08, dwArg04, out ecx_586, out edx) < 0x00)
			{
l0071A711:
				struct Eq_118148 * esp_235 = fp - 44;
				if (dwArg08 != 0x00)
				{
					word32 v21_241 = (word32) *dwArg08 - 1;
					*dwArg08 = v21_241;
					if (v21_241 == 0x00)
					{
						Eq_3 ecx_245 = *((word32) dwArg08 + 4);
						word32 esp_254;
						(*((word32) ecx_245 + 24))();
						esp_235 = esp_254 + 0x04;
					}
				}
				struct Eq_118153 * eax_264 = esp_235->ptr0014;
				if (eax_264 != null)
				{
					word32 v22_268 = eax_264->dw0000 + ~0x00;
					eax_264->dw0000 = v22_268;
					if (v22_268 == 0x00)
					{
						struct Eq_118197 * ecx_272 = eax_264->ptr0004;
						<anonymous> * edx_273 = ecx_272->ptr0018;
						esp_235->ptrFFFFFFFC = eax_264;
						word32 esp_281;
						edx_273();
						esp_235 = esp_281 + 0x04;
					}
				}
				struct Eq_118153 * eax_291 = esp_235->ptr0018;
				if (eax_291 != null)
				{
					word32 v24_295 = eax_291->dw0000 + ~0x00;
					eax_291->dw0000 = v24_295;
					if (v24_295 == 0x00)
					{
						struct Eq_118197 * ecx_299 = eax_291->ptr0004;
						<anonymous> * edx_300 = ecx_299->ptr0018;
						esp_235->ptrFFFFFFFC = eax_291;
						edx_300();
					}
				}
				goto l0071A75C;
			}
			ebp_115 = dwArg08;
		}
		struct Eq_118135 * esp_165 = fp - 44;
		if (false)
		{
			<anonymous> ** v23_171 = (const char *) null - 1;
			null = (<anonymous> ***) v23_171;
			if (v23_171 == null)
			{
				struct Eq_1218 * ecx_175 = *(struct Eq_1218 **) 0x04;
				word32 esp_184;
				ecx_175->ptr0018();
				esp_165 = esp_184 + 0x04;
			}
		}
		struct Eq_118211 * eax_194 = esp_165->ptr0018;
		if (eax_194 != null)
		{
			word32 v25_198 = eax_194->dw0000 + ~0x00;
			eax_194->dw0000 = v25_198;
			if (v25_198 == 0x00)
			{
				struct Eq_118268 * ecx_202 = eax_194->ptr0004;
				<anonymous> * edx_203 = ecx_202->ptr0018;
				esp_165->ptrFFFFFFFC = eax_194;
				edx_203();
			}
		}
		eax_220 = ebp_115;
	}
	edxOut = edx;
	return eax_220;
}

// 0071A7D0: Register word32 fn0071A7D0(Stack Eq_3 dwArg04, Register out ptr32 ecxOut, Register out ptr32 edxOut)
// Called from:
//      fn0071FB20
word32 fn0071A7D0(Eq_3 dwArg04, ptr32 & ecxOut, ptr32 & edxOut)
{
	Eq_3 eax_8 = *((word32) dwArg04 + 4);
	if (eax_8 != 0x00A23B20)
	{
		word32 ecx_91;
		word32 edx_92;
		if (fn006D5670(eax_8, 0x00A23B20, out ecx_91, out edx_92) == 0x00)
		{
			ptr32 edx_52;
			ecxOut = fn006E11D0(out edx_52);
			edxOut = edx_52;
			return 0x00;
		}
	}
	ptr32 ecx_40;
	ptr32 edx_42;
	word32 eax_39 = fn0071A060(*((word32) dwArg04 + 0x0C), *((word32) dwArg04 + 8), 0x80, out ecx_40, out edx_42);
	ecxOut = ecx_40;
	edxOut = edx_42;
	return eax_39;
}

// 0071A820: Register int32 fn0071A820(Register int32 eax, Register Eq_3 ecx)
// Called from:
//      fn0071A870
int32 fn0071A820(int32 eax, Eq_3 ecx)
{
	Eq_3 esi_18 = (word32) ecx + eax;
	if (IsDBCSLeadByte(*((word32) ecx + eax)) != 0x00)
	{
		Eq_3 eax_30 = CharPrevA(ecx, esi_18);
		if (eax_30 == esi_18 || (IsDBCSLeadByte(*eax_30) == 0x00 || esi_18 - eax_30 == (CHAR *) 0x02))
			return 0x01;
	}
	return 0x00;
}

// 0071A870: Register Eq_3 fn0071A870(Register Eq_3 eax, Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Stack word32 dwArg0C, Register out Eq_3 ecxOut, Register out Eq_3 edxOut)
// Called from:
//      fn0071A9A0
Eq_3 fn0071A870(Eq_3 eax, Eq_3 dwArg04, Eq_3 dwArg08, word32 dwArg0C, union Eq_3 & ecxOut, union Eq_3 & edxOut)
{
	Eq_3 ebx_117 = 0x00;
	Eq_3 esi_15 = 0x00;
	Eq_3 edi_21 = eax;
	if (dwArg0C == 0x00 && (eax >= 0x01 && fn0071A820(eax - 0x01, dwArg08) != 0x00))
		edi_21 = eax - 0x01;
	Eq_3 edx_110;
	Eq_3 ecx_113;
	if (edi_21 > 0x00)
	{
		Eq_3 eax_57 = MultiByteToWideChar(0x00, 0x00, dwArg08, edi_21, null, 0x00);
		esi_15 = eax_57;
		if (eax_57 == 0x00)
			goto l0071A8BF;
	}
	Eq_3 eax_66 = *dwArg04;
	if (eax_66 == 0x00)
	{
		Eq_3 eax_96 = fn00717740(esi_15, out ecx_113, out edx_110);
		*dwArg04 = eax_96;
		if (eax_96 == 0x00)
		{
			ecxOut = ecx_113;
			edxOut = edx_110;
			return ~0x00;
		}
	}
	else
	{
		ebx_117 = *((word32) eax_66 + 8);
		if (fn00717900(dwArg04, esi_15 + ebx_117, out ecx_113, out edx_110) < 0x00)
		{
l0071A8CB:
			ecxOut = ecx_113;
			edxOut = edx_110;
			return ~0x00;
		}
	}
	if (edi_21 > 0x00)
	{
		edx_110 = *dwArg04;
		ecx_113 = dwArg08;
		if (MultiByteToWideChar(0x00, 0x00, dwArg08, edi_21, (word32) *((word32) edx_110 + 0x0C) + ebx_117 * 0x02, esi_15) == 0x00)
		{
l0071A8BF:
			ecx_113 = fn006E1520(0x00, dwArg04, out edx_110);
			goto l0071A8CB;
		}
	}
	ecxOut = ecx_113;
	edxOut = edx_110;
	return edi_21;
}

// 0071A9A0: Register word32 fn0071A9A0(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Register out ptr32 edxOut)
// Called from:
//      fn0071FEB0
word32 fn0071A9A0(Eq_3 dwArg04, Eq_3 dwArg08, ptr32 & edxOut)
{
	word32 ecx_18;
	ptr32 edx_20;
	if (fn0071A870(dwArg08, fp - 0x04, dwArg04, 0x01, out ecx_18, out edx_20) < 0x00)
	{
		if (false)
		{
			<anonymous> ** v10_31 = (const char *) null - 1;
			null = (<anonymous> ***) v10_31;
			if (v10_31 == null)
			{
				struct Eq_1218 * edx_35 = *(struct Eq_1218 **) 0x04;
				edx_35->ptr0018();
			}
		}
	}
	edxOut = edx_20;
	return 0x00;
}

// 0071A9F0: Register word32 fn0071A9F0(Register Eq_3 edi, Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Register out Eq_3 ecxOut, Register out Eq_3 edxOut)
// Called from:
//      fn0071AAE0
word32 fn0071A9F0(Eq_3 edi, Eq_3 dwArg04, Eq_3 dwArg08, union Eq_3 & ecxOut, union Eq_3 & edxOut)
{
	Eq_3 edx_157;
	Eq_3 ecx_158;
	Eq_3 esi_14 = 0x00;
	Eq_3 ebx_106 = 0x00;
	if (edi > 0x00)
	{
		Eq_3 eax_36 = WideCharToMultiByte(0x00, 0x00, dwArg08, edi, 0x00, 0x00, 0x00, null);
		esi_14 = eax_36;
		if (eax_36 == 0x00)
			goto l0071AA17;
	}
	Eq_3 eax_44 = *dwArg04;
	if (eax_44 == 0x00)
	{
		Eq_3 eax_82 = fn006EC9B0(eax_44, esi_14, out ecx_158, out edx_157);
		*dwArg04 = eax_82;
		if (eax_82 == 0x00)
		{
			ecxOut = ecx_158;
			edxOut = edx_157;
			return ~0x00;
		}
	}
	else
	{
		ebx_106 = fn006ECC00(eax_44);
		if (fn006EC4F0(dwArg04, dwArg04, out ecx_158, out edx_157) < 0x00)
		{
l0071AA23:
			ecxOut = ecx_158;
			edxOut = edx_157;
			return ~0x00;
		}
	}
	if (edi > 0x00)
	{
		edx_157 = *dwArg04;
		if (WideCharToMultiByte(0x00, 0x00, dwArg08, edi, (word32) ebx_106 + ((word32) edx_157 + 20), esi_14, 0x00, null) == 0x00)
		{
l0071AA17:
			ecx_158 = fn006E1520(0x00, dwArg04, out edx_157);
			goto l0071AA23;
		}
	}
	ecxOut = ecx_158;
	edxOut = edx_157;
	return 0x00;
}

// 0071AAE0: Register Eq_3 fn0071AAE0(Stack Eq_3 dwArg04, Register out ptr32 ecxOut, Register out ptr32 edxOut)
// Called from:
//      fn0071FB20
Eq_3 fn0071AAE0(Eq_3 dwArg04, ptr32 & ecxOut, ptr32 & edxOut)
{
	Eq_3 eax_8 = *((word32) dwArg04 + 4);
	if (eax_8 != 0x00A23B20)
	{
		word32 ecx_146;
		word32 edx_147;
		if (fn006D5670(eax_8, 0x00A23B20, out ecx_146, out edx_147) == 0x00)
		{
			ptr32 edx_86;
			ecxOut = fn006E11D0(out edx_86);
			edxOut = edx_86;
			return <invalid>;
		}
	}
	ptr32 ecx_107;
	ptr32 edx_113;
	if (fn0071A9F0(*((word32) dwArg04 + 8), fp + 0x04, *((word32) dwArg04 + 0x0C), out ecx_107, out edx_113) < 0x00)
	{
		if (false)
		{
			null = (<anonymous> ***) ((const char *) null - 1);
			if (null == null)
			{
				struct Eq_1218 * ecx_62 = *(struct Eq_1218 **) 0x04;
				ecx_62->ptr0018();
			}
		}
	}
	ecxOut = ecx_107;
	edxOut = edx_113;
	return <invalid>;
}

// 0071F9C0: void fn0071F9C0(Register Eq_3 ebp)
// Called from:
//      fn006E8910
void fn0071F9C0(Eq_3 ebp)
{
	Eq_3 eax_5 = g_tA6DBB4;
	struct Eq_118617 * esp_14 = fp - 0x0C;
	if (eax_5 != 0x00)
	{
		Eq_3 v11_18 = (word32) *eax_5 - 1;
		*eax_5 = v11_18;
		if (v11_18 == 0x00)
		{
			Eq_3 ecx_22 = *((word32) eax_5 + 4);
			word32 esp_26;
			word32 edx_29;
			(*((word32) ecx_22 + 24))();
			esp_14 = esp_26 + 0x04;
		}
	}
	g_tA6DBB4.u0 = 0x00;
	struct Eq_118654 ** esi_36 = g_aA6D7B0;
	do
	{
		struct Eq_118654 * eax_40 = *esi_36;
		if (eax_40 != null)
		{
			eax_40->dw0000 += ~0x00;
			struct Eq_118654 * eax_46 = *esi_36;
			if (eax_46->dw0000 == 0x00)
			{
				struct Eq_118676 * ecx_49 = eax_46->ptr0004;
				<anonymous> * edx_50 = ecx_49->ptr0018;
				esp_14->ptrFFFFFFFC = eax_46;
				word32 esp_56;
				word32 edx_59;
				edx_50();
				esp_14 = esp_56 + 0x04;
			}
			*esi_36 = (struct Eq_118654 **) null;
		}
		esi_36 = (struct Eq_118654 **) ((const char *) esi_36 + 4);
	} while (esi_36 < &g_tA6DBB0);
	Eq_3 edi_72 = g_tA6DBB0;
	if (edi_72 != 0x00)
	{
		struct Eq_118707 * esp_78 = esp_14 - 4;
		esp_78->t0000 = ebp;
		struct Eq_118707 * esp_140 = esp_78;
		do
		{
			Eq_3 eax_90 = *((word32) edi_72 + 0x0C);
			edi_72 = *edi_72;
			if (eax_90 != 0x00)
			{
				union Eq_3 * esp_96 = esp_140 - 4;
				*esp_96 = (union Eq_3 *) eax_90;
				free(*esp_96);
			}
			struct Eq_118707 * esp_113 = esp_140;
			if (*((word32) edi_72 + 20) != null)
			{
				struct Eq_118717 * eax_105 = *((word32) edi_72 + 20);
				eax_105->dw0000 += ~0x00;
				struct Eq_118717 * eax_108 = *((word32) edi_72 + 20);
				if (eax_108->dw0000 == 0x00)
				{
					struct Eq_118772 * ecx_111 = eax_108->ptr0004;
					<anonymous> * edx_112 = ecx_111->ptr0018;
					esp_140->dwFFFFFFFC = eax_108;
					word32 esp_121;
					word32 edx_124;
					edx_112();
					esp_113 = esp_121 + 0x04;
				}
			}
			union Eq_3 * esp_130 = esp_113 - 4;
			*esp_130 = (union Eq_3 *) edi_72;
			word32 ecx_225;
			word32 edx_226;
			fn007239C0(*esp_130, out ecx_225, out edx_226);
			esp_140 = (struct Eq_118707 *) ((const char *) esp_130 + 4);
		} while (edi_72 != 0x00);
	}
	g_dwA6D7AC = 0x00;
	g_tA6DBB0.u0 = 0x00;
}

// 0071FB20: Register Eq_3 fn0071FB20(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Stack Eq_3 dwArg0C, Register out ptr32 ecxOut, Register out ptr32 edxOut)
// Called from:
//      fn006DDEB0
//      fn006DDF70
//      fn006DE430
//      fn006E5C60
//      fn006F2090
//      fn0071FC50
//      fn00720020
//      fn00731B10
//      fn0073D240
//      fn0073D450
//      fn00753A60
//      fn00754FD0
Eq_3 fn0071FB20(Eq_3 dwArg04, Eq_3 dwArg08, Eq_3 dwArg0C, ptr32 & ecxOut, ptr32 & edxOut)
{
	Eq_3 eax_8 = *((word32) dwArg04 + 4);
	if (eax_8 != 0x00A23B20)
	{
		word32 edx_570;
		word32 ecx_569;
		if (fn006D5670(eax_8, 0x00A23B20, out ecx_569, out edx_570) == 0x00)
		{
			ptr32 edx_361;
			ecxOut = fn006E11D0(out edx_361);
			edxOut = edx_361;
			return 0x00;
		}
	}
	Eq_3 eax_37 = dwArg08;
	if (dwArg08 == 0x00)
		eax_37.u0 = 10934088;
	if (dwArg0C == 0x00)
	{
		union Eq_3 * edi_48 = &g_t8D9880;
		Eq_3 esi_50 = eax_37;
		word32 ecx_51 = 0x06;
		bool v18_379 = false;
		while (ecx_51 != 0x00)
		{
			v18_379 = *esi_571 != *edi_572;
			esi_50 = (word32) esi_571 + 1;
			edi_48 = (union Eq_3 *) ((const char *) edi_572 + 1);
			--ecx_51;
			esi_571 = esi_50;
			edi_572 = edi_48;
			if (*esi_571 == *edi_572)
				break;
		}
		if (!v18_379)
		{
			ptr32 edx_345;
			ptr32 ecx_346;
			Eq_3 eax_344 = fn00718B50(dwArg04, out ecx_346, out edx_345);
			ecxOut = ecx_346;
			edxOut = edx_345;
			return eax_344;
		}
		union Eq_3 * edi_67 = &g_t8D9674;
		Eq_3 esi_70 = eax_37;
		word32 ecx_71 = 0x08;
		bool v22_383 = false;
		while (ecx_71 != 0x00)
		{
			v22_383 = *esi_573 != *edi_574;
			esi_70 = (word32) esi_573 + 1;
			edi_67 = (union Eq_3 *) ((const char *) edi_574 + 1);
			--ecx_71;
			esi_573 = esi_70;
			edi_574 = edi_67;
			if (*esi_573 == *edi_574)
				break;
		}
		if (!v22_383)
		{
			ptr32 edx_323;
			ptr32 ecx_324;
			Eq_3 eax_322 = fn0071A550(dwArg04, out ecx_324, out edx_323);
			ecxOut = ecx_324;
			edxOut = edx_323;
			return eax_322;
		}
		union Eq_3 * edi_101 = &g_t8D9878;
		Eq_3 esi_100 = eax_37;
		word32 ecx_102 = 0x05;
		bool v26_387 = false;
		while (ecx_102 != 0x00)
		{
			v26_387 = *esi_575 != *edi_576;
			esi_100 = (word32) esi_575 + 1;
			edi_101 = (union Eq_3 *) ((const char *) edi_576 + 1);
			--ecx_102;
			esi_575 = esi_100;
			edi_576 = edi_101;
			if (*esi_575 == *edi_576)
				break;
		}
		if (!v26_387)
		{
			ptr32 edx_301;
			ptr32 ecx_302;
			Eq_3 eax_300 = fn0071AAE0(dwArg04, out ecx_302, out edx_301);
			ecxOut = ecx_302;
			edxOut = edx_301;
			return eax_300;
		}
		union Eq_3 * edi_107 = &g_t8D9650;
		Eq_3 esi_110 = eax_37;
		word32 ecx_111 = 0x06;
		bool v30_391 = false;
		while (ecx_111 != 0x00)
		{
			v30_391 = *esi_577 != *edi_578;
			esi_110 = (word32) esi_577 + 1;
			edi_107 = (union Eq_3 *) ((const char *) edi_578 + 1);
			--ecx_111;
			esi_577 = esi_110;
			edi_578 = edi_107;
			if (*esi_577 == *edi_578)
				break;
		}
		if (!v30_391)
		{
			ptr32 edx_279;
			ptr32 ecx_280;
			Eq_3 eax_278 = fn0071A7D0(dwArg04, out ecx_280, out edx_279);
			ecxOut = ecx_280;
			edxOut = edx_279;
			return eax_278;
		}
	}
	ptr32 edx_191;
	ptr32 ecx_192;
	Eq_3 eax_190 = fn0074ED80(eax_37, out ecx_192, out edx_191);
	if (eax_190 != 0x00)
	{
		Eq_3 eax_200 = *((word32) eax_190 + 4);
		if (eax_200 == 0x00A1B450 || fn006D5670(eax_200, 0x00A1B450, out ecx_192, out edx_191) != 0x00)
		{
			ecxOut = ecx_192;
			edxOut = edx_191;
			return eax_190;
		}
		fn006E15D0(g_tA16B7C, dwArg04, out ecx_192, out edx_191);
		Eq_3 v14_246 = (word32) *eax_190 - 1;
		*eax_190 = v14_246;
		if (v14_246 == 0x00)
		{
			Eq_3 eax_250 = *((word32) eax_190 + 4);
			(*((word32) eax_250 + 24))();
		}
	}
	ecxOut = ecx_192;
	edxOut = edx_191;
	return 0x00;
}

// 0071FC50: Register Eq_3 fn0071FC50(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Register out Eq_540 ecxOut, Register out Eq_540 edxOut)
// Called from:
//      fn006DE330
//      fn006E5C60
//      fn006EA420
Eq_3 fn0071FC50(Eq_3 dwArg04, Eq_3 dwArg08, union Eq_540 & ecxOut, union Eq_540 & edxOut)
{
	Eq_3 eax_23 = *((word32) dwArg04 + 20);
	if (eax_23 == 0x00)
	{
		word32 ecx_75;
		word32 edx_76;
		eax_23 = fn0071FB20(dwArg04, eax_23, dwArg08, out ecx_75, out edx_76);
		if (eax_23 != 0x00 && dwArg08 == 0x00)
			*((word32) dwArg04 + 20) = eax_23;
	}
	ecxOut.u0 = <invalid>;
	edxOut.u0 = <invalid>;
	return eax_23;
}

// 0071FC80: Register (ptr32 Eq_119048) fn0071FC80(Register out (ptr32 (arr Eq_3)) edxOut)
// Called from:
//      fn006F2090
//      fn007367D0
//      fn0073D240
//      fn0073D450
//      fn00754FD0
struct Eq_119048 * fn0071FC80(Eq_3 (& edxOut)
{
	Eq_3 (* edx_19)[];
	struct Eq_119048 * eax_17 = fn00718610(dwArg04, dwArg08, null, out edx_19);
	edxOut = edx_19;
	return eax_17;
}

<anonymous> g_t71FE40 = <code>; // 0071FE40
// 0071FEB0: Register (ptr32 Eq_119048) fn0071FEB0(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Stack Eq_3 dwArg0C, Stack word32 dwArg10, Register out ptr32 edxOut)
// Called from:
//      fn00720070
//      fn007537A0
//      fn007537F0
//      fn00753A60
struct Eq_119048 * fn0071FEB0(Eq_3 dwArg04, Eq_3 dwArg08, Eq_3 dwArg0C, word32 dwArg10, ptr32 & edxOut)
{
	Eq_3 ebx_17 = dwArg0C;
	if (dwArg0C == 0x00)
		ebx_17.u0 = 10934088;
	byte * edi_18 = &g_t8D9880;
	Eq_3 esi_20 = ebx_17;
	word32 ecx_21 = 0x06;
	bool v19_376 = false;
	while (ecx_21 != 0x00)
	{
		v19_376 = *esi_579 != *edi_580;
		esi_20 = (word32) esi_579 + 1;
		edi_18 = edi_580 + 1;
		--ecx_21;
		esi_579 = esi_20;
		edi_580 = edi_18;
		if (*esi_579 == *edi_580)
			break;
	}
	if (!v19_376)
	{
		ptr32 edx_364;
		struct Eq_119048 * eax_363 = fn00718610(dwArg04, dwArg08, null, out edx_364);
		edxOut = edx_364;
		return eax_363;
	}
	byte * edi_37 = &g_t8D9674;
	Eq_3 esi_40 = ebx_17;
	word32 ecx_41 = 0x08;
	bool v23_380 = false;
	while (ecx_41 != 0x00)
	{
		v23_380 = *esi_581 != *edi_582;
		esi_40 = (word32) esi_581 + 1;
		edi_37 = edi_582 + 1;
		--ecx_41;
		esi_581 = esi_40;
		edi_582 = edi_37;
		if (*esi_581 == *edi_582)
			break;
	}
	if (!v23_380)
	{
		ptr32 edx_334;
		struct Eq_119048 * eax_333 = fn00719DD0(dwArg04, dwArg08, out edx_334);
		edxOut = edx_334;
		return eax_333;
	}
	byte * edi_57 = &g_t8D9878;
	Eq_3 esi_60 = ebx_17;
	word32 ecx_61 = 0x05;
	bool v27_384 = false;
	while (ecx_61 != 0x00)
	{
		v27_384 = *esi_583 != *edi_584;
		esi_60 = (word32) esi_583 + 1;
		edi_57 = edi_584 + 1;
		--ecx_61;
		esi_583 = esi_60;
		edi_584 = edi_57;
		if (*esi_583 == *edi_584)
			break;
	}
	if (!v27_384)
	{
		ptr32 edx_308;
		struct Eq_119048 * eax_307 = fn0071A9A0(dwArg04, dwArg08, out edx_308);
		edxOut = edx_308;
		return eax_307;
	}
	byte * edi_77 = &g_t8D9650;
	Eq_3 esi_80 = ebx_17;
	word32 ecx_81 = 0x06;
	bool v31_388 = false;
	while (ecx_81 != 0x00)
	{
		v31_388 = *esi_585 != *edi_586;
		esi_80 = (word32) esi_585 + 1;
		edi_77 = edi_586 + 1;
		--ecx_81;
		esi_585 = esi_80;
		edi_586 = edi_77;
		if (*esi_585 == *edi_586)
			break;
	}
	if (!v31_388)
	{
		ptr32 edx_282;
		struct Eq_119048 * eax_281 = fn0071A5A0(dwArg04, dwArg08, out edx_282);
		edxOut = edx_282;
		return eax_281;
	}
	ptr32 edx_129;
	struct Eq_119211 * eax_128 = fn007514B0(dwArg04, dwArg08, out edx_129);
	if (eax_128 == null)
	{
l0071FFFB:
		edxOut = edx_129;
		return null;
	}
	struct Eq_119048 * eax_146 = fn0074EE90(dwArg04, out edx_129);
	struct Eq_119235 * esp_151 = fp - 0x0C;
	if (eax_146 == null)
	{
l0071FFEA:
		word32 v14_239 = eax_128->dw0000 + ~0x00;
		eax_128->dw0000 = v14_239;
		if (v14_239 == 0x00)
		{
			struct Eq_119307 * edx_243 = eax_128->ptr0004;
			<anonymous> * eax_244 = edx_243->ptr0018;
			esp_151->ptrFFFFFFFC = eax_128;
			eax_244();
		}
		goto l0071FFFB;
	}
	else
	{
		Eq_3 eax_155 = eax_146->t0004;
		if (eax_155 != 0x00A23B20)
		{
			word32 ecx_577;
			if (fn006D5670(eax_155, 0x00A23B20, out ecx_577, out edx_129) == 0x00)
			{
				word32 ecx_578;
				fn006E15D0(g_tA16B7C, dwArg04, out ecx_578, out edx_129);
				word32 v13_221 = eax_146->dw0000 + ~0x00;
				eax_146->dw0000 = v13_221;
				esp_151 = fp - 0x0C;
				if (v13_221 == 0x00)
				{
					Eq_3 eax_225 = eax_146->t0004;
					word32 esp_229;
					(*((word32) eax_225 + 24))();
					esp_151 = esp_229 + 0x04;
				}
				goto l0071FFEA;
			}
		}
		word32 v15_175 = eax_128->dw0000 + ~0x00;
		eax_128->dw0000 = v15_175;
		if (v15_175 == 0x00)
		{
			struct Eq_119307 * ecx_179 = eax_128->ptr0004;
			ecx_179->ptr0018();
		}
		edxOut = edx_129;
		return eax_146;
	}
}

// 00720020: Register Eq_3 fn00720020(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Stack Eq_3 dwArg0C, Stack Eq_3 dwArg10, Register out ptr32 edxOut)
// Called from:
//      fn006F7890
Eq_3 fn00720020(Eq_3 dwArg04, Eq_3 dwArg08, Eq_3 dwArg0C, Eq_3 dwArg10, ptr32 & edxOut)
{
	ptr32 edx_17;
	Eq_3 eax_15 = fn00717A20(dwArg04, dwArg08, out edx_17);
	if (eax_15 != 0x00)
	{
		word32 ecx_117;
		ptr32 edx_39;
		Eq_3 eax_37 = fn0071FB20(eax_15, dwArg04, dwArg08, out ecx_117, out edx_39);
		Eq_3 v12_43 = (word32) *eax_15 - 1;
		*eax_15 = v12_43;
		if (v12_43 == 0x00)
		{
			Eq_3 ecx_48 = *((word32) eax_15 + 4);
			(*((word32) ecx_48 + 24))();
		}
		edxOut = edx_39;
		return eax_37;
	}
	else
	{
		edxOut = edx_17;
		return eax_15;
	}
}

// 00720070: Register Eq_3 fn00720070(Stack Eq_3 dwArg04, Register out ptr32 edxOut)
// Called from:
//      fn007203E0
//      fn00721290
Eq_3 fn00720070(Eq_3 dwArg04, ptr32 & edxOut)
{
	Eq_3 dwLoc04_199 = 0x00;
	if (dwArg04 == 0x00)
	{
		ptr32 edx_185;
		fn006E1DC0(out edx_185);
		edxOut = edx_185;
		return 0x00;
	}
	ptr32 edx_139;
	Eq_3 eax_15 = *((word32) dwArg04 + 4);
	if (eax_15 != 0x00A23B20)
	{
		word32 ecx_281;
		ptr32 edx_221;
		if (fn006D5670(eax_15, 0x00A23B20, out ecx_281, out edx_221) == 0x00)
		{
			Eq_3 esi_71;
			Eq_3 eax_50 = *((word32) dwArg04 + 4);
			if (eax_50 != 0x00A1B450)
			{
				word32 ecx_282;
				if (fn006D5670(eax_50, 0x00A1B450, out ecx_282, out edx_221) == 0x00)
				{
					if (fn00701880(dwArg04, fp - 0x04, fp + 0x04, out edx_221) != 0x00)
					{
						word32 ecx_283;
						if (fn006E1110(out ecx_283, out edx_139) != 0x00)
						{
							ptr32 edx_167;
							word32 ecx_284;
							fn006E15D0(g_tA16B7C, dwArg04, out ecx_284, out edx_167);
							edxOut = edx_167;
							return 0x00;
						}
l00720175:
						edxOut = edx_139;
						return 0x00;
					}
					esi_71 = dwArg04;
l00720137:
					if (esi_71 != 0x00)
					{
						ptr32 edx_116;
						Eq_3 eax_115 = fn0071FEB0(dwLoc04_199, dwArg04, dwArg08, dwArg0C, out edx_116);
						edxOut = edx_116;
						return eax_115;
					}
					else
					{
						Eq_3 eax_125 = g_tA6DBB4;
						*eax_125 = (word32) *eax_125 + 1;
						edxOut = edx_221;
						return eax_125;
					}
				}
			}
			esi_71 = *((word32) dwArg04 + 8);
			dwLoc04_199 = (word32) dwArg04 + 20;
			dwArg04 = esi_71;
			goto l00720137;
		}
	}
	word32 ecx_280;
	fn006E0F80(g_tA16B7C, 0x008D98C0, out ecx_280, out edx_139);
	goto l00720175;
}

// 007203E0: Register Eq_3 fn007203E0(Stack Eq_3 dwArg04, Register out ptr32 edxOut)
// Called from:
//      fn006E5C60
//      fn00721290
Eq_3 fn007203E0(Eq_3 dwArg04, ptr32 & edxOut)
{
	Eq_3 eax_8 = *((word32) dwArg04 + 4);
	if (eax_8 != 0x00A23B20)
	{
		word32 ecx_102;
		word32 edx_103;
		if (fn006D5670(eax_8, 0x00A23B20, out ecx_102, out edx_103) != 0x00)
		{
			ptr32 edx_36;
			Eq_3 eax_33 = fn00717A20(*((word32) dwArg04 + 0x0C), *((word32) dwArg04 + 8), out edx_36);
			edxOut = edx_36;
			return eax_33;
		}
		else
		{
			ptr32 edx_52;
			Eq_3 eax_49 = fn00720070(dwArg04, out edx_52);
			edxOut = edx_52;
			return eax_49;
		}
	}
	else
	{
		*dwArg04 = (word32) *dwArg04 + 1;
		edxOut = edx;
		return dwArg04;
	}
}

