// sho_text_0033.c
// Generated by decompiling sho.exe
// using Reko decompiler version 0.10.0.0.

#include "sho.h"

// 00731A20: Register Eq_3 fn00731A20(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Register out Eq_540 ebxOut, Register out ptr32 esiOut, Register out Eq_540 ediOut)
// Called from:
//      fn00707640
//      fn00708DC0
Eq_3 fn00731A20(Eq_3 dwArg04, Eq_3 dwArg08, union Eq_540 & ebxOut, ptr32 & esiOut, union Eq_540 & ediOut)
{
	Eq_3 ebx_106 = 0x00;
	if (dwArg04 == 0x00)
	{
l00731AC1:
		ebxOut.u0 = <invalid>;
		esiOut = esi;
		ediOut.u0 = <invalid>;
		return ebx_106;
	}
	Eq_3 eax_15 = *((word32) dwArg04 + 4);
	if (eax_15 != 0x00A26EF0)
	{
		word32 edx_323;
		word32 ecx_322;
		if (fn006D5670(eax_15, 0x00A26EF0, out ecx_322, out edx_323) == 0x00)
		{
			word32 edx_324;
			word32 edi_325;
			Eq_3 eax_51 = fn006DF760(dwArg04, 9226872, out edx_324, out edi_325);
			struct Eq_140132 * esp_103 = fp - 0x0C;
			if (eax_51 == 0x00)
			{
				word32 edx_327;
				word32 ecx_326;
				fn006E1160(out ecx_326, out edx_327);
				goto l00731AA8;
			}
			Eq_3 eax_61 = *((word32) eax_51 + 4);
			if (eax_61 != 10610664)
			{
				word32 ecx_340;
				word32 edx_341;
				if (fn006D5670(eax_61, 10610664, out ecx_340, out edx_341) == 0x00)
				{
l00731A97:
					word32 v12_97 = (word32) *eax_51 - 1;
					*eax_51 = v12_97;
					esp_103 = fp - 0x0C;
					if (v12_97 == 0x00)
					{
						Eq_3 eax_101 = *((word32) eax_51 + 4);
						word32 esp_109;
						word32 edx_111;
						word32 ecx_112;
						(*((word32) eax_101 + 24))();
						esp_103 = esp_109 + 0x04;
					}
l00731AA8:
					struct Eq_140150 * esp_127 = esp_103 - 4;
					esp_127->t0000 = esp_103->t0014;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_3 stackArg4 = <invalid>;
					word32 ecx_329;
					word32 edx_330;
					Eq_3 eax_134 = fn007050A0(stackArg4, out ecx_329, out edx_330);
					if (eax_134 == 0x00)
					{
						word32 ecx_334;
						word32 edx_335;
						fn006E1160(out ecx_334, out edx_335);
					}
					else
					{
						esp_127->t0000 = eax_134;
						esp_127->dwFFFFFFFC = 9226872;
						esp_127->tFFFFFFF8 = dwArg04;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_3 stackArg4 = <invalid>;
						word32 ecx_332;
						word32 edx_333;
						if (fn006DF800(stackArg4, dwArg04, dwArg08, out ecx_332, out edx_333) != 0x00)
						{
							word32 ecx_342;
							word32 edx_343;
							fn006E1160(out ecx_342, out edx_343);
						}
						word32 v14_169 = (word32) *eax_134 - 1;
						*eax_134 = v14_169;
						if (v14_169 == 0x00)
						{
							struct Eq_140258 * eax_173 = *((word32) eax_134 + 4);
							<anonymous> * ecx_174 = eax_173->ptr0018;
							esp_127->t0000 = eax_134;
							word32 edx_183;
							word32 ecx_184;
							ecx_174();
							ebxOut.u0 = <invalid>;
							esiOut = esi;
							ediOut.u0 = <invalid>;
							return ebx_106;
						}
					}
					esi = esp_103->ptr0000;
					goto l00731AC1;
				}
			}
			word32 ecx_336;
			word32 edx_337;
			word32 esi_338;
			word32 edi_339;
			ebx_106 = fn007051A0(dwArg04, eax_51, out ecx_336, out edx_337, out esi_338, out edi_339);
			goto l00731A97;
		}
	}
	Eq_3 eax_35 = *((word32) dwArg04 + 24);
	*((word32) dwArg04 + 24) = dwArg08;
	ebxOut.u0 = <invalid>;
	esiOut = esi;
	ediOut.u0 = <invalid>;
	return eax_35;
}

// 00731B10: Register word32 fn00731B10(Register Eq_3 edi, Register (ptr16 Eq_7) es, Register (ptr16 Eq_8) ds, Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Stack Eq_3 dwArg0C, Register out Eq_3 edxOut, Register out Eq_540 ebxOut, Register out Eq_540 esiOut)
// Called from:
//      fn006E1780
//      fn006E8060
//      fn00708DC0
//      fn00731D30
word32 fn00731B10(Eq_3 edi, struct Eq_7 * es, struct Eq_8 * ds, Eq_3 dwArg04, Eq_3 dwArg08, Eq_3 dwArg0C, union Eq_3 & edxOut, union Eq_540 & ebxOut, union Eq_540 & esiOut)
{
	byte bArg0C_865 = (byte) dwArg0C;
	if (dwArg08 == 0x00)
	{
		Eq_3 edx_586;
		word32 ecx_929;
		fn006E0F80(g_tA16B7C, 9286196, out ecx_929, out edx_586);
		edxOut = edx_586;
		ebxOut.u0 = <invalid>;
		esiOut.u0 = <invalid>;
		return ~0x00;
	}
	Eq_3 edx_125;
	Eq_3 eax_11 = *((word32) dwArg08 + 4);
	if (eax_11 != 0x00A26EF0)
	{
		word32 ecx_930;
		word32 edx_931;
		if (fn006D5670(eax_11, 0x00A26EF0, out ecx_930, out edx_931) == 0x00)
		{
			word32 edi_932;
			Eq_3 eax_218 = fn006DF760(dwArg08, 9225520, out edx_125, out edi_932);
			if (eax_218 == 0x00)
				goto l00731CFC;
			struct Eq_140319 * esp_286;
			Eq_3 edi_251;
			ptr32 esp_250;
			Eq_3 eax_240;
			if ((bArg0C_865 & 0x01) == 0x00)
			{
				word32 edi_933;
				eax_240 = fn006DDDB0(eax_218, edx_125, eax_218, dwArg08, edi, es, ds, dwArg04, out edx_125, out edi_933);
				esp_250 = fp - 0x10;
				goto l00731BAE;
			}
			else
			{
				edi_251 = dwArg04;
				Eq_3 eax_252 = *((word32) dwArg04 + 4);
				if (eax_252 != 0x00A23B20)
				{
					word32 ecx_934;
					if (fn006D5670(eax_252, 0x00A23B20, out ecx_934, out edx_125) == 0x00)
					{
						word32 edi_935;
						eax_240 = fn006DDF70(dwArg04, out edx_125, out edi_935);
						esp_250 = fp - 0x14;
l00731BAE:
						edi_251 = eax_240;
						esp_286 = esp_250 + 0x04;
l00731BB3:
						if (edi_251 == 0x00)
						{
							word32 v12_536 = (word32) *eax_218 - 1;
							*eax_218 = v12_536;
							if (v12_536 == 0x00)
							{
								struct Eq_140423 * edx_557 = *((word32) eax_218 + 4);
								<anonymous> * eax_558 = edx_557->ptr0018;
								esp_286->tFFFFFFFC = eax_218;
								Eq_3 edx_563;
								eax_558();
								edxOut = edx_563;
								ebxOut.u0 = <invalid>;
								esiOut.u0 = <invalid>;
								return ~0x00;
							}
							goto l00731C03;
						}
						struct Eq_140387 * esp_294 = esp_286 - 4;
						esp_294->t0000 = edi_251;
						esp_294->tFFFFFFFC.u0 = 0x01;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_3 stackArg4 = <invalid>;
						word32 ecx_939;
						word32 esi_940;
						Eq_3 eax_329 = fn006DFF80(stackArg4, out ecx_939, out edx_125, out esi_940);
						struct Eq_140406 * esp_335 = (const char *) &esp_294->t0000 + 4;
						if (eax_329 == 0x00)
						{
							word32 v16_489 = (word32) *edi_251 - 1;
							*edi_251 = v16_489;
							if (v16_489 == 0x00)
							{
								struct Eq_140561 * ecx_493 = *((word32) edi_251 + 4);
								<anonymous> * edx_494 = ecx_493->ptr0018;
								esp_294->t0000 = edi_251;
								word32 esp_497;
								edx_494();
								esp_335 = esp_497 + 0x04;
							}
							word32 v18_507 = (word32) *eax_218 - 1;
							*eax_218 = v18_507;
							if (v18_507 == 0x00)
							{
								struct Eq_140423 * eax_511 = *((word32) eax_218 + 4);
								<anonymous> * ecx_512 = eax_511->ptr0018;
								esp_335->tFFFFFFFC = eax_218;
								ecx_512();
							}
l00731C03:
							edxOut = edx_125;
							ebxOut.u0 = <invalid>;
							esiOut.u0 = <invalid>;
							return ~0x00;
						}
						esp_294->t0000.u0 = 0x00;
						esp_294->tFFFFFFFC = eax_329;
						esp_294->tFFFFFFF8 = eax_218;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_3 stackArg4 = <invalid>;
						word32 ecx_946;
						word32 esi_947;
						word32 edi_948;
						Eq_3 eax_346 = fn00707680(stackArg4, dwArg04, dwArg08, out ecx_946, out edx_125, out esi_947, out edi_948);
						word32 v19_352 = (word32) *eax_329 - 1;
						*eax_329 = v19_352;
						struct Eq_140534 * esp_351 = (const char *) &esp_294->t0000 + 4;
						if (v19_352 == 0x00)
						{
							struct Eq_140604 * edx_357 = *((word32) eax_329 + 4);
							<anonymous> * eax_358 = edx_357->ptr0018;
							esp_294->t0000 = eax_329;
							word32 esp_361;
							eax_358();
							esp_351 = esp_361 + 0x04;
						}
						word32 v21_371 = (word32) *edi_251 - 1;
						*edi_251 = v21_371;
						if (v21_371 == 0x00)
						{
							struct Eq_140561 * ecx_375 = *((word32) edi_251 + 4);
							<anonymous> * edx_376 = ecx_375->ptr0018;
							esp_351->tFFFFFFFC = edi_251;
							word32 esp_390;
							edx_376();
							esp_351 = esp_390 + 0x04;
						}
						word32 v23_400 = (word32) *eax_218 - 1;
						*eax_218 = v23_400;
						if (v23_400 == 0x00)
						{
							struct Eq_140423 * eax_404 = *((word32) eax_218 + 4);
							<anonymous> * ecx_405 = eax_404->ptr0018;
							esp_351->tFFFFFFFC = eax_218;
							word32 esp_419;
							ecx_405();
							esp_351 = esp_419 + 0x04;
						}
						if (eax_346 != 0x00)
						{
							word32 v24_450 = (word32) *eax_346 - 1;
							*eax_346 = v24_450;
							if (v24_450 == 0x00)
							{
								struct Eq_140673 * edx_454 = *((word32) eax_346 + 4);
								<anonymous> * eax_455 = edx_454->ptr0018;
								esp_351->tFFFFFFFC = eax_346;
								eax_455();
							}
							edxOut = edx_125;
							ebxOut.u0 = <invalid>;
							esiOut.u0 = <invalid>;
							return 0x00;
						}
l00731CFC:
						edxOut = edx_125;
						ebxOut.u0 = <invalid>;
						esiOut.u0 = <invalid>;
						return ~0x00;
					}
				}
				*dwArg04 = (word32) *dwArg04 + 1;
				esp_286 = fp - 0x10;
				goto l00731BB3;
			}
		}
	}
	Eq_3 ebp_59;
	Eq_3 eax_40 = *((word32) dwArg08 + 4);
	if (eax_40 != 0x00A26EF0)
	{
		word32 edx_937;
		word32 ecx_936;
		if (fn006D5670(eax_40, 0x00A26EF0, out ecx_936, out edx_937) == 0x00)
		{
			ebp_59.u0 = 0x00;
l00731C90:
			word32 edi_70 = *((word32) dwArg08 + 60);
			if (ebp_59 == 0x00)
			{
				Eq_3 edx_197;
				word32 ecx_941;
				fn006E0F80(g_tA17E2C, 0x008DB028, out ecx_941, out edx_197);
				edxOut = edx_197;
				ebxOut.u0 = <invalid>;
				esiOut.u0 = <invalid>;
				return ~0x00;
			}
			Eq_3 esi_129 = dwArg04;
			if (((byte) dwArg0C & 0x01) != 0x00)
			{
				Eq_3 eax_80 = *((word32) dwArg04 + 4);
				if (eax_80 == 0x00A23B20)
				{
l00731CDC:
					if (edi_70 != 0x00A163B8)
					{
						word32 ecx_944;
						Eq_3 eax_124 = fn0071FB20(dwArg04, edi_70 + 0x14, 0x008D1DC8, out ecx_944, out edx_125);
						esi_129 = eax_124;
						if (eax_124 == 0x00)
							goto l00731CFC;
l00731D07:
						Eq_3 edx_153;
						word32 eax_152 = fn006DEFC0(out edx_153);
						Eq_57788 v17_158 = (word32) *esi_129 - 1;
						*esi_129 = v17_158;
						if (v17_158 == 0x00)
						{
							Eq_3 edx_163 = *((word32) esi_129 + 4);
							(*((word32) edx_163 + 24))();
						}
						edxOut = edx_153;
						ebxOut.u0 = <invalid>;
						esiOut.u0 = <invalid>;
						return eax_152;
					}
					goto l00731D04;
				}
				word32 ecx_942;
				word32 edx_943;
				if (fn006D5670(eax_80, 0x00A23B20, out ecx_942, out edx_943) != 0x00)
					goto l00731CDC;
			}
l00731D04:
			*dwArg04 = (word32) *dwArg04 + 1;
			goto l00731D07;
		}
	}
	ebp_59 = *((word32) dwArg08 + 8);
	goto l00731C90;
}

// 00731D30: Register Eq_3 fn00731D30(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Register out Eq_3 edxOut, Register out Eq_540 esiOut, Register out Eq_540 ediOut)
// Called from:
//      fn006E1780
//      fn006E7F60
//      fn006E8060
//      fn00707640
//      fn00708DC0
//      fn00716A00
//      fn0072F830
//      fn0072FBB0
Eq_3 fn00731D30(Eq_3 dwArg04, Eq_3 dwArg08, union Eq_3 & edxOut, union Eq_540 & esiOut, union Eq_540 & ediOut)
{
	if (dwArg08 == 0x00)
	{
		if (fn006E0FC0() == 0x00)
		{
			word32 ecx_274;
			fn006E0F80(g_tA18720, 9286224, out ecx_274, out edx);
		}
		goto l00731D55;
	}
	Eq_3 eax_11 = *((word32) dwArg08 + 4);
	if (eax_11 != 0x00A26EF0)
	{
		word32 ecx_275;
		if (fn006D5670(eax_11, 0x00A26EF0, out ecx_275, out edx) == 0x00)
		{
			if (fn006E0FC0() == 0x00)
			{
				Eq_3 edx_105;
				word32 ecx_276;
				Eq_3 eax_103 = fn006ECAC0(dwArg04, out ecx_276, out edx_105);
				if (eax_103 != 0x00)
				{
					word32 ebx_279;
					word32 esi_280;
					Eq_3 edx_122;
					Eq_3 eax_120 = fn00731B10(dwArg08, es, ds, eax_103, dwArg04, dwArg08, out edx_122, out ebx_279, out esi_280);
					word32 v11_126 = (word32) *eax_103 - 1;
					*eax_103 = v11_126;
					if (v11_126 == 0x00)
					{
						struct Eq_140785 * edx_131 = *((word32) eax_103 + 4);
						word32 ecx_137;
						edx_131->ptr0018();
					}
					edxOut = edx_122;
					esiOut.u0 = <invalid>;
					ediOut.u0 = <invalid>;
					return eax_120;
				}
				else
				{
					edxOut = edx_105;
					esiOut.u0 = <invalid>;
					ediOut.u0 = <invalid>;
					return ~0x00;
				}
			}
l00731D55:
			edxOut = edx;
			esiOut.u0 = <invalid>;
			ediOut.u0 = <invalid>;
			return ~0x00;
		}
	}
	Eq_3 eax_31 = *((word32) dwArg08 + 4);
	if (eax_31 != 0x00A26EF0)
	{
		word32 ecx_281;
		word32 edx_282;
		if (fn006D5670(eax_31, 0x00A26EF0, out ecx_281, out edx_282) == 0x00)
		{
l00731DE0:
			Eq_3 edx_83;
			word32 ecx_283;
			fn006E0F80(g_tA17E2C, 0x008DB028, out ecx_283, out edx_83);
			edxOut = edx_83;
			esiOut.u0 = <invalid>;
			ediOut.u0 = <invalid>;
			return ~0x00;
		}
	}
	Eq_3 edi_52 = *((word32) dwArg08 + 8);
	if (edi_52 != 0x00)
	{
		fputs(dwArg04, edi_52);
		edxOut = dwArg04;
		esiOut.u0 = <invalid>;
		ediOut.u0 = <invalid>;
		return 0x00;
	}
	goto l00731DE0;
}

// 00731F90: Register Eq_3 fn00731F90(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Stack Eq_3 dwArg0C, Stack (ptr32 Eq_58738) dwArg10, Register out Eq_3 edxOut)
// Called from:
//      fn006E1AB0
//      fn0072F830
//      fn00753600
Eq_3 fn00731F90(Eq_3 dwArg04, Eq_3 dwArg08, Eq_3 dwArg0C, struct Eq_58738 * dwArg10, union Eq_3 & edxOut)
{
	ui32 edi_113 = 0x00;
	word32 esi_117 = 0x00;
	if (dwArg10 != null)
	{
		Eq_3 eax_21 = dwArg10->t0004;
		if (eax_21 != 0x00A26EF0)
		{
			Eq_3 edx_30;
			word32 ecx_431;
			if (fn006D5670(eax_21, 0x00A26EF0, out ecx_431, out edx_30) == 0x00)
			{
				*_errno() = 0x06;
				edxOut = edx_30;
				return 0x00;
			}
		}
		if (dwArg10->dw0030 == 0x00)
		{
			Eq_3 eax_276 = fgets(dwArg04, dwArg08, dwArg0C);
			edxOut = dwArg08;
			return eax_276;
		}
		edi_113 = dwArg10->dw0034;
		esi_117 = dwArg10->dw0038;
	}
	struct Eq_58738 * ecx_137 = dwArg10;
	struct Eq_140801 * esp_105 = fp - 20;
	if (dwArg08 > 0x01)
	{
		do
		{
			esp_105->tFFFFFFFC = dwArg0C;
			union Eq_3 * esp_76;
			word32 ecx_77;
			uip32 eax_101;
			MSVCR80.dll!getc();
			esp_105 = (struct Eq_140801 *) ((const char *) esp_76 + 4);
			if (eax_101 == ~0x00)
				goto l00732088;
			if (esi_117 != 0x00)
			{
				esi_117 = 0x00;
				if (eax_101 == 0x0A)
				{
					*esp_76 = (union Eq_3 *) dwArg0C;
					word32 esp_99;
					MSVCR80.dll!getc();
					edi_113 |= 0x04;
					esp_105 = esp_99 + 0x04;
					if (eax_101 == ~0x00)
						goto l0073208F;
				}
				else
					edi_113 |= 0x01;
			}
			if (eax_101 == 0x0D)
			{
				esi_117 = 0x01;
				eax_101 = 0x0A;
			}
			else if (eax_101 == 0x0A)
				edi_113 |= 0x02;
			byte * ecx_123 = esp_105->ptr0010;
			*ecx_123 = (byte) eax_101;
			esp_105->ptr0010 = ecx_123 + 1;
			if (eax_101 == 0x0A)
				break;
			int32 ecx_136 = esp_105->dw001C;
			esp_105->dw001C = ecx_136 - 0x01;
			ecx_137 = ecx_136 - 0x01;
		} while (ecx_136 > 0x01);
		if (eax_101 == ~0x00)
		{
l00732088:
			if (esi_117 != 0x00)
				edi_113 |= 0x01;
		}
l0073208F:
		ecx_137 = esp_105->ptr0024;
	}
	*dwArg04 = 0x00;
	Eq_3 edx_170 = dwArg04;
	if (ecx_137 == null)
	{
		if (esi_117 != 0x00)
		{
			struct Eq_140886 * esp_204;
			word32 ecx_205;
			word32 eax_206;
			MSVCR80.dll!getc();
			if (eax_206 != 0x0A)
			{
				esp_204->t0000 = dwArg0C;
				esp_204->dwFFFFFFFC = eax_206;
				MSVCR80.dll!ungetc();
			}
		}
		edxOut = edx_170;
		return dwArg04;
	}
	else
	{
		ecx_137->dw0034 = edi_113;
		ecx_137->dw0038 = esi_117;
		edxOut = dwArg04;
		return dwArg04;
	}
}

// 007331D0: Register Eq_3 fn007331D0(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Stack Eq_3 dwArg0C, Stack Eq_3 dwArg10, Register out Eq_3 edxOut)
// Called from:
//      fn006E9BD0
//      fn007367D0
//      fn0073D140
Eq_3 fn007331D0(Eq_3 dwArg04, Eq_3 dwArg08, Eq_3 dwArg0C, Eq_3 dwArg10, union Eq_3 & edxOut)
{
	word32 ecx_56;
	word32 edx_57;
	Eq_3 eax_6 = fn00723860(0x18, out ecx_56, out edx_57);
	if (eax_6 != 0x00)
	{
		*((word32) eax_6 + 8) = dwArg04;
		*((word32) eax_6 + 0x0C) = dwArg08;
		*((word32) eax_6 + 16) = dwArg0C;
		*((word32) eax_6 + 4) = 0x00A27190;
		*eax_6 = 0x01;
		*((word32) eax_6 + 20) = dwArg10;
		edxOut = dwArg10;
		return eax_6;
	}
	else
	{
		Eq_3 edx_30;
		word32 ecx_58;
		Eq_3 eax_28 = fn006E1210(out ecx_58, out edx_30);
		edxOut = edx_30;
		return eax_28;
	}
}

// 00733250: Register word32 fn00733250(Stack Eq_3 dwArg04, FpuStack out Eq_3 rLoc1Out)
// Called from:
//      fn00735890
word32 fn00733250(Eq_3 dwArg04, union Eq_3 & rLoc1Out)
{
	Eq_3 eax_8 = *((word32) dwArg04 + 4);
	if (eax_8 != 0x00A27190)
	{
		word32 edx_85;
		if (fn006D5670(eax_8, 0x00A27190, out ecx, out edx_85) == 0x00)
		{
			real64 rLoc1_86;
			word32 ecx_39 = fn006FF3E0(dwArg04, out rLoc1_86);
			rLoc1Out = rLoc1;
			return ecx_39;
		}
	}
	rLoc1Out = *((word32) dwArg04 + 8);
	return ecx;
}

// 00733290: Register word32 fn00733290(Stack Eq_3 dwArg04, FpuStack out Eq_3 rLoc1Out)
// Called from:
//      fn00735890
word32 fn00733290(Eq_3 dwArg04, union Eq_3 & rLoc1Out)
{
	Eq_3 eax_8 = *((word32) dwArg04 + 4);
	if (eax_8 != 0x00A27190)
	{
		word32 edx_70;
		if (fn006D5670(eax_8, 0x00A27190, out ecx, out edx_70) == 0x00)
		{
			rLoc1Out.u1 = 0.0;
			return ecx;
		}
	}
	rLoc1Out = *((word32) dwArg04 + 16);
	return ecx;
}

// 007332C0: Register word32 fn007332C0(Stack (ptr32 Eq_60699) dwArg04, Stack Eq_3 dwArg08)
// Called from:
//      fn006E5C60
word32 fn007332C0(struct Eq_60699 * dwArg04, Eq_3 dwArg08)
{
	Eq_3 eax_8 = *((word32) dwArg08 + 4);
	if (eax_8 != 0x00A27190)
	{
		word32 ecx_102;
		word32 edx_103;
		if (fn006D5670(eax_8, 0x00A27190, out ecx_102, out edx_103) == 0x00)
		{
			Eq_3 rRet0;
			fn006FF3E0(dwArg08, out rRet0);
			dwArg04->t0000 = rRet0;
			dwArg04->t0008.u1 = 0.0;
			return;
		}
	}
	Eq_3 edx_31 = *((word32) dwArg08 + 0x0C);
	dwArg04->t0000 = *((word32) dwArg08 + 8);
	Eq_3 ecx_33 = *((word32) dwArg08 + 16);
	dwArg04->t0004 = edx_31;
	Eq_3 edx_35 = *((word32) dwArg08 + 20);
	dwArg04->t0008 = ecx_33;
	dwArg04->t000C = edx_35;
	return;
}

// 00734B00: Register (ptr32 byte) fn00734B00(Register (ptr32 byte) eax)
// Called from:
//      fn00734BB0
byte * fn00734B00(byte * eax)
{
	byte * edx_24 = g_ptrA27250;
	byte cl_22 = *edx_24;
	byte * esi_16 = eax;
	byte * eax_17 = (byte *) 0x01;
	if (g_aA6DCE0[(word32) cl_22] == 0x00 && cl_22 != 0x00)
	{
		do
		{
			g_aA6DCE0[(word32) cl_22] = 0x01;
			++edx_24;
			cl_22 = *edx_24;
		} while (cl_22 != 0x00);
	}
	byte cl_36 = *eax;
	if (cl_36 == 0x00)
		return eax_17;
	do
	{
		++esi_16;
		if (g_aA6DCE0[(word32) cl_36] == 0x00)
		{
			eax_17 = null;
			return eax_17;
		}
		cl_36 = *esi_16;
	} while (cl_36 != 0x00);
	return (byte *) 0x01;
}

// 00734B60: void fn00734B60(Register Eq_3 eax)
// Called from:
//      fn00734BB0
void fn00734B60(Eq_3 eax)
{
	Eq_3 esi_8 = *((word32) eax + 8);
	int32 esi_42 = esi_8 - 0x01;
	if (esi_8 >= 0x01)
	{
		Eq_3 edi_16 = (word32) eax + 0x0C + (esi_8 - 0x01) * 0x04;
		do
		{
			struct Eq_141159 * eax_19 = *edi_16;
			if (eax_19 == null || eax_19->dw0004 != 0x00A1B450)
				fn006E86F0(0x008DB820);
			word32 edx_90;
			fn006EC890(edi_16, out edx_90);
			--esi_42;
			edi_16 -= 0x04;
		} while (esi_42 >= 0x00);
	}
}

// 00734BB0: Register (ptr32 Eq_138891) fn00734BB0(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Stack Eq_3 dwArg0C, Stack Eq_3 dwArg10, Stack Eq_3 dwArg14, Stack Eq_3 dwArg18, Stack Eq_3 dwArg1C, Stack Eq_3 dwArg20, Stack Eq_3 dwArg24, Stack Eq_3 dwArg28, Stack Eq_3 dwArg2C, Stack Eq_3 dwArg30, Stack Eq_3 dwArg34, Stack Eq_3 dwArg38, Register out Eq_3 edxOut)
// Called from:
//      fn00728BE0
//      fn007367D0
struct Eq_138891 * fn00734BB0(Eq_3 dwArg04, Eq_3 dwArg08, Eq_3 dwArg0C, Eq_3 dwArg10, Eq_3 dwArg14, Eq_3 dwArg18, Eq_3 dwArg1C, Eq_3 dwArg20, Eq_3 dwArg24, Eq_3 dwArg28, Eq_3 dwArg2C, Eq_3 dwArg30, Eq_3 dwArg34, Eq_3 dwArg38, union Eq_3 & edxOut)
{
	Eq_3 edx_279;
	struct Eq_138891 * eax_283;
	if (dwArg04 >= 0x00 && (dwArg08 >= 0x00 && (dwArg14 != 0x00 && dwArg18 != 0x00)))
	{
		Eq_3 eax_28 = *((word32) dwArg18 + 4);
		if (eax_28 != 0x00A16588)
		{
			word32 ecx_841;
			word32 edx_842;
			if (fn006D5670(eax_28, 0x00A16588, out ecx_841, out edx_842) == 0x00)
				goto l00734E7E;
		}
		if (dwArg1C == 0x00)
			goto l00734E7E;
		Eq_3 eax_52 = *((word32) dwArg1C + 4);
		if (eax_52 != 0x00A16588)
		{
			word32 edx_844;
			word32 ecx_843;
			if (fn006D5670(eax_52, 0x00A16588, out ecx_843, out edx_844) == 0x00)
				goto l00734E7E;
		}
		if (dwArg20 == 0x00)
			goto l00734E7E;
		Eq_3 eax_76 = *((word32) dwArg20 + 4);
		if (eax_76 != 0x00A16588)
		{
			word32 ecx_845;
			word32 edx_846;
			if (fn006D5670(eax_76, 0x00A16588, out ecx_845, out edx_846) == 0x00)
				goto l00734E7E;
		}
		if (dwArg24 == 0x00)
			goto l00734E7E;
		Eq_3 eax_100 = *((word32) dwArg24 + 4);
		if (eax_100 != 0x00A16588)
		{
			word32 ecx_847;
			word32 edx_848;
			if (fn006D5670(eax_100, 0x00A16588, out ecx_847, out edx_848) == 0x00)
				goto l00734E7E;
		}
		if (dwArg28 == 0x00)
			goto l00734E7E;
		Eq_3 eax_124 = *((word32) dwArg28 + 4);
		if (eax_124 != 0x00A16588)
		{
			word32 ecx_849;
			word32 edx_850;
			if (fn006D5670(eax_124, 0x00A16588, out ecx_849, out edx_850) == 0x00)
				goto l00734E7E;
		}
		if (dwArg30 == 0x00)
			goto l00734E7E;
		Eq_3 eax_148 = *((word32) dwArg30 + 4);
		if (eax_148 != 0x00A1B450)
		{
			word32 edx_852;
			word32 ecx_851;
			if (fn006D5670(eax_148, 0x00A1B450, out ecx_851, out edx_852) == 0x00)
				goto l00734E7E;
		}
		if (dwArg2C == 0x00)
			goto l00734E7E;
		Eq_3 eax_172 = *((word32) dwArg2C + 4);
		if (eax_172 != 0x00A1B450)
		{
			word32 edx_854;
			word32 ecx_853;
			if (fn006D5670(eax_172, 0x00A1B450, out ecx_853, out edx_854) == 0x00)
				goto l00734E7E;
		}
		if (dwArg38 == 0x00)
			goto l00734E7E;
		Eq_3 eax_196 = *((word32) dwArg38 + 4);
		if (eax_196 == 0x00A1B450)
		{
l00734D38:
			if (fn00701950(dwArg14) != 0x00)
			{
				fn00734B60(dwArg1C);
				fn00734B60(dwArg20);
				fn00734B60(dwArg24);
				fn00734B60(dwArg28);
				word32 edx_858;
				word32 ecx_857;
				Eq_3 eax_317 = fn006DFE20(dwArg18, out ecx_857, out edx_858);
				int32 esi_324 = eax_317 - 0x01;
				if (eax_317 >= 0x01)
				{
					Eq_3 dwLoc08_725 = (word32) dwArg18 + 0x0C + (eax_317 - 0x01) * 0x04;
					do
					{
						Eq_3 eax_340 = fn006DFE60(dwArg18, dwArg04);
						Eq_3 ecx_345 = *((word32) eax_340 + 4);
						if (ecx_345 != 0x00A1B450)
						{
							word32 edx_862;
							word32 ecx_861;
							if (fn006D5670(ecx_345, 0x00A1B450, out ecx_861, out edx_862) != 0x00)
								goto l00734DB4;
						}
						else
						{
l00734DB4:
							if (fn00734B00((word32) eax_340 + 20) != 0x00)
							{
								word32 edx_863;
								fn006EC890(dwLoc08_725, out edx_863);
							}
						}
						dwLoc08_725 -= 0x04;
						--esi_324;
					} while (esi_324 >= 0x00);
				}
				word32 edx_860;
				word32 ecx_859;
				eax_283 = fn006DDD30(fn00723860(g_tA27468, out ecx_859, out edx_860), dwArg04, out edx_279);
				if (eax_283 != null)
				{
					eax_283->t0008 = dwArg04;
					eax_283->t0010 = dwArg0C;
					eax_283->t000C = dwArg08;
					eax_283->t0014 = dwArg10;
					*dwArg14 = (word32) *dwArg14 + 1;
					eax_283->t0018 = dwArg14;
					*dwArg18 = (word32) *dwArg18 + 1;
					eax_283->t001C = dwArg18;
					*dwArg1C = (word32) *dwArg1C + 1;
					eax_283->t0020 = dwArg1C;
					*dwArg20 = (word32) *dwArg20 + 1;
					eax_283->t0024 = dwArg20;
					*dwArg24 = (word32) *dwArg24 + 1;
					eax_283->t0028 = dwArg24;
					*dwArg28 = (word32) *dwArg28 + 1;
					eax_283->t002C = dwArg28;
					*dwArg2C = (word32) *dwArg2C + 1;
					eax_283->t0030 = dwArg2C;
					*dwArg30 = (word32) *dwArg30 + 1;
					eax_283->t0034 = dwArg30;
					eax_283->t0038 = dwArg34;
					*dwArg38 = (word32) *dwArg38 + 1;
					eax_283->t003C = dwArg38;
					eax_283->dw0040 = 0x00;
					edxOut = dwArg10;
					return eax_283;
				}
l00734E8F:
				edxOut = edx_279;
				return eax_283;
			}
			goto l00734E7E;
		}
		word32 edx_856;
		word32 ecx_855;
		if (fn006D5670(eax_196, 0x00A1B450, out ecx_855, out edx_856) != 0x00)
			goto l00734D38;
	}
l00734E7E:
	fn006E1DC0(out edx_279);
	eax_283 = null;
	goto l00734E8F;
}

<anonymous> g_t735170 = <code>; // 00735170
// 00735550: Register Eq_3 fn00735550(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08)
// Called from:
//      fn00708DC0
//      fn0072F770
Eq_3 fn00735550(Eq_3 dwArg04, Eq_3 dwArg08)
{
	int64 edx_eax_21 = (int64) fn006ECC00(*((word32) dwArg04 + 60));
	word32 ecx_122;
	word32 edx_123;
	word32 esi_124;
	Eq_3 ecx_40 = fn006ECC50(*((word32) dwArg04 + 60), out ecx_122, out edx_123, out esi_124);
	Eq_3 edx_37 = 0x00;
	int32 esi_38;
	Eq_3 eax_41 = *((word32) dwArg04 + 56);
	for (esi_38 = ((word32) edx_eax_21 - SLICE(edx_eax_21, word32, 32) >> 0x01) - 0x01; esi_38 >= 0x00; --esi_38)
	{
		edx_37 = (word32) edx_37 + (word32) (*ecx_40);
		byte * ecx_52 = (word32) ecx_40 + 1;
		if (edx_37 > dwArg08)
			break;
		eax_41 = (word32) eax_41 + (word32) (*ecx_52);
		ecx_40 = ecx_52 + 1;
	}
	return eax_41;
}

// 007355A0: Register word32 fn007355A0(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Stack (ptr32 Eq_94576) dwArg0C)
// Called from:
//      fn00707430
word32 fn007355A0(Eq_3 dwArg04, Eq_3 dwArg08, struct Eq_94576 * dwArg0C)
{
	Eq_3 eax_18 = *((word32) dwArg04 + 60);
	int64 edx_eax_22 = (int64) *((word32) eax_18 + 8);
	dwArg0C->t0000.u0 = 0x00;
	int32 eax_25 = (word32) edx_eax_22 - SLICE(edx_eax_22, word32, 32);
	byte * ecx_103 = (word32) eax_18 + 20;
	int32 edx_28 = eax_25 >> 0x01;
	Eq_3 esi_100 = 0x00;
	if (eax_25 >> 0x01 > 0x00)
	{
		do
		{
			Eq_3 edi_37 = (word32) esi_100 + (word32) (*ecx_103);
			if (edi_37 > dwArg08)
				break;
			byte * ecx_41 = ecx_103 + 1;
			esi_100 = edi_37;
			if (*ecx_41 != 0x00)
				dwArg0C->t0000 = edi_37;
			--edx_28;
			ecx_103 = ecx_41 + 1;
		} while (edx_28 > 0x00);
	}
	if (edx_28 <= 0x00)
	{
		dwArg0C->t0004.u0 = 0x7FFFFFFF;
		return;
	}
	else
	{
		int32 edx_107;
		for (edx_107 = edx_28 - 0x01; edx_107 >= 0x00; --edx_107)
		{
			byte * ecx_99 = ecx_103 + 1;
			esi_100 = (word32) esi_100 + (word32) (*ecx_103);
			ecx_103 = ecx_99 + 1;
			if (*ecx_99 != 0x00)
				break;
		}
		dwArg0C->t0004 = esi_100;
		return;
	}
}

// 00735640: Register Eq_3 fn00735640(Register Eq_3 esi, Stack Eq_125083 bArg04, Register out Eq_3 ecxOut, Register out Eq_540 edxOut)
// Called from:
//      fn007356A0
//      fn00735710
//      fn00735790
//      fn00735890
Eq_3 fn00735640(Eq_3 esi, Eq_125083 bArg04, union Eq_3 & ecxOut, union Eq_540 & edxOut)
{
	Eq_3 eax_47 = *((word32) esi + 0x0C);
	if (eax_47 != 0x00)
	{
		Eq_3 eax_23 = fn006ECC00(eax_47);
		Eq_3 ecx_37;
		word32 edx_120;
		if (fn006EC4F0((word32) esi + 0x0C, (word32) eax_23 + 0x0400, out ecx_37, out edx_120) != 0x00)
		{
			((word32) esi + 20)->u0 = 0x00;
			((word32) esi + 16)->u0 = 0x00;
			ecxOut = ecx_37;
			edxOut.u0 = <invalid>;
			return 0x00;
		}
		Eq_3 eax_44 = *((word32) esi + 0x0C);
		ecx = (word32) eax_23 + ((word32) eax_44 + 20);
		*((word32) esi + 16) = ecx;
		eax_47 = (word32) eax_44 + 20 + ((word32) eax_23 + 0x0400);
		*((word32) esi + 20) = eax_47;
		*ecx = bArg04;
		*((word32) esi + 16) = (word32) *((word32) esi + 16) + 1;
	}
	ecxOut = ecx;
	edxOut.u0 = <invalid>;
	return eax_47;
}

// 007356A0: Register Eq_3 fn007356A0(Register Eq_3 eax, Register Eq_3 ecx, Register Eq_141735 edx, Register out Eq_540 edxOut)
// Called from:
//      fn00735890
Eq_3 fn007356A0(Eq_3 eax, Eq_3 ecx, Eq_141735 edx, union Eq_540 & edxOut)
{
	Eq_3 eax_12 = *eax;
	ptr32 esp_15 = fp - 0x0C;
	Eq_141735 edi_21 = edx;
	if (eax_12 == 0x00)
	{
		int32 ebx_23 = ecx - 0x01;
		if (ecx >= 0x01)
		{
			do
			{
				word24 ecx_24_8_105 = SLICE(ecx, word24, 8);
				Eq_3 eax_28 = *eax;
				if (eax_28 != 0x00)
				{
					struct Eq_141776 * esp_56 = esp_15 - 4;
					esp_56->t0000 = eax_28;
					int32 eax_58 = (int32) *edi_21;
					esp_56->dwFFFFFFFC = eax_58;
					word32 esp_62;
					MSVCR80.dll!putc();
					esp_15 = esp_62 + 0x08;
				}
				else
				{
					eax_12 = *((word32) eax + 16);
					if (eax_12 != *((word32) eax + 20))
					{
						byte cl_51 = *edi_21;
						*eax_12 = cl_51;
						*((word32) eax + 16) = (word32) *((word32) eax + 16) + 1;
						ecx = SEQ(ecx_24_8_105, cl_51);
					}
					else
					{
						int32 * esp_38 = esp_15 - 4;
						*esp_38 = (int32) *edi_21;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_125083 stackArg4 = <invalid>;
						eax_12 = fn00735640(eax, stackArg4, out ecx, out edx);
						esp_15 = esp_38 + 1;
					}
				}
				edi_21 = (word32) edi_21 + 1;
				--ebx_23;
			} while (ebx_23 >= 0x00);
		}
		edxOut.u0 = <invalid>;
		return eax_12;
	}
	else
	{
		Eq_3 eax_94 = fwrite(edx, 0x01, ecx, eax_12);
		edxOut.u0 = <invalid>;
		return eax_94;
	}
}

// 00735710: Register Eq_3 fn00735710(Register Eq_3 eax, Register int32 ecx, Register out ptr32 edxOut)
// Called from:
//      fn00735890
Eq_3 fn00735710(Eq_3 eax, int32 ecx, ptr32 & edxOut)
{
	int32 ecx_31;
	word32 eax_12 = *eax;
	byte bl_25 = (byte) ecx;
	if (eax_12 != 0x00)
	{
		int32 eax_43 = (int32) bl_25;
		MSVCR80.dll!putc();
	}
	else
	{
		Eq_3 eax_22 = *((word32) eax + 16);
		if (eax_22 != *((word32) eax + 20))
		{
			*eax_22 = bl_25;
			*((word32) eax + 16) = (word32) *((word32) eax + 16) + 1;
			ecx_31 = ecx;
		}
		else
			fn00735640(eax, (int32) bl_25, out ecx_31, out edx);
	}
	word32 eax_56 = *eax;
	byte bl_65 = (byte) (ecx >> 0x08);
	if (eax_56 == 0x00)
	{
		Eq_3 eax_62 = *((word32) eax + 16);
		if (eax_62 == *((word32) eax + 20))
		{
			ptr32 edx_76;
			word32 ecx_162;
			Eq_3 eax_74 = fn00735640(eax, (int32) bl_65, out ecx_162, out edx_76);
			edxOut = edx_76;
			return eax_74;
		}
		else
		{
			*eax_62 = bl_65;
			*((word32) eax + 16) = (word32) *((word32) eax + 16) + 1;
			edxOut = edx;
			return eax_62;
		}
	}
	else
	{
		int32 edx_97 = (int32) bl_65;
		Eq_3 eax_103;
		ptr32 edx_105;
		MSVCR80.dll!putc();
		edxOut = edx_105;
		return eax_103;
	}
}

// 00735790: Register Eq_3 fn00735790(Register Eq_3 eax, Register Eq_3 ecx, Register out ptr32 edxOut)
// Called from:
//      fn00735890
//      fn00736560
Eq_3 fn00735790(Eq_3 eax, Eq_3 ecx, ptr32 & edxOut)
{
	Eq_3 ecx_35;
	word32 eax_15 = *eax;
	struct Eq_141926 * esp_110 = fp - 16;
	byte bl_29 = (byte) ecx;
	if (eax_15 != 0x00)
	{
		int32 eax_47 = (int32) bl_29;
		word32 esp_50;
		MSVCR80.dll!putc();
		esp_110 = esp_50 + 0x08;
	}
	else
	{
		Eq_3 eax_26 = *((word32) eax + 16);
		if (eax_26 != *((word32) eax + 20))
		{
			*eax_26 = bl_29;
			*((word32) eax + 16) = (word32) *((word32) eax + 16) + 1;
			ecx_35 = ecx;
		}
		else
		{
			fn00735640(eax, (int32) bl_29, out ecx_35, out edx);
			esp_110 = fp - 0x10;
		}
	}
	word32 eax_60 = *eax;
	if (eax_60 != 0x00)
	{
		struct Eq_141982 * esp_96 = esp_110 - 4;
		esp_96->dw0000 = eax_60;
		int32 eax_101 = (int32) (byte) (ecx >> 0x08);
		esp_96->dwFFFFFFFC = eax_101;
		word32 esp_104;
		MSVCR80.dll!putc();
		esp_110 = esp_104 + 0x08;
	}
	else
	{
		Eq_3 eax_64 = *((word32) eax + 16);
		if (eax_64 != *((word32) eax + 20))
		{
			*eax_64 = (byte) (ecx >> 0x08);
			*((word32) eax + 16) = (word32) *((word32) eax + 16) + 1;
		}
		else
		{
			int32 * esp_74 = esp_110 - 4;
			*esp_74 = (int32) (byte) (ecx >> 0x08);
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_125083 stackArg4 = <invalid>;
			word32 ecx_301;
			fn00735640(eax, stackArg4, out ecx_301, out edx);
			esp_110 = (struct Eq_141926 *) (esp_74 + 1);
		}
	}
	word32 eax_114 = *eax;
	if (eax_114 != 0x00)
	{
		struct Eq_142014 * esp_154 = esp_110 - 4;
		esp_154->dw0000 = eax_114;
		int32 edx_153 = (int32) (byte) (ecx >> 0x10);
		esp_154->dwFFFFFFFC = edx_153;
		MSVCR80.dll!putc();
	}
	else
	{
		Eq_3 eax_118 = *((word32) eax + 16);
		if (eax_118 != *((word32) eax + 20))
		{
			*eax_118 = (byte) (ecx >> 0x10);
			*((word32) eax + 16) = (word32) *((word32) eax + 16) + 1;
		}
		else
		{
			esp_110->dwFFFFFFFC = (int32) (byte) (ecx >> 0x10);
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_125083 stackArg4 = <invalid>;
			word32 ecx_303;
			fn00735640(eax, stackArg4, out ecx_303, out edx);
		}
	}
	word32 eax_168 = *eax;
	byte bl_177 = (byte) (ecx >> 0x18);
	if (eax_168 == 0x00)
	{
		Eq_3 eax_174 = *((word32) eax + 16);
		if (eax_174 == *((word32) eax + 20))
		{
			ptr32 edx_189;
			word32 ecx_304;
			Eq_3 eax_187 = fn00735640(eax, (int32) bl_177, out ecx_304, out edx_189);
			edxOut = edx_189;
			return eax_187;
		}
		else
		{
			*eax_174 = bl_177;
			*((word32) eax + 16) = (word32) *((word32) eax + 16) + 1;
			edxOut = edx;
			return eax_174;
		}
	}
	else
	{
		int32 ecx_214 = (int32) bl_177;
		Eq_3 eax_220;
		ptr32 edx_222;
		MSVCR80.dll!putc();
		edxOut = edx_222;
		return eax_220;
	}
}

// 00735890: Register word32 fn00735890(Register Eq_3 edx, Register Eq_3 ebx, Register Eq_3 ebp, Register Eq_3 esi, Register Eq_3 edi, Register (ptr16 Eq_7) es, Register (ptr16 Eq_8) ds, Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Register out Eq_3 edxOut)
// Called from:
//      fn00735890
//      fn00736590
word32 fn00735890(Eq_3 edx, Eq_3 ebx, Eq_3 ebp, Eq_3 esi, Eq_3 edi, struct Eq_7 * es, struct Eq_8 * ds, Eq_3 dwArg04, Eq_3 dwArg08, union Eq_3 & edxOut)
{
	ui32 eax_7 = g_tA14188 ^ fp - 0x0114;
	*((word32) dwArg08 + 8) = (word32) *((word32) dwArg08 + 8) + 1;
	word32 ebp_1118 = 0x01;
	Eq_3 eax_1017 = *((word32) dwArg08 + 8);
	if (eax_1017 > 2000)
	{
		((word32) dwArg08 + 4)->u0 = 0x02;
		goto l0073653D;
	}
	if (dwArg04 == 0x00)
	{
		word32 eax_2688 = *dwArg08;
		if (eax_2688 != 0x00)
			MSVCR80.dll!putc();
		else
		{
			eax_1017 = *((word32) dwArg08 + 16);
			if (eax_1017 != *((word32) dwArg08 + 20))
			{
				*eax_1017 = 0x30;
				*((word32) dwArg08 + 16) = (word32) *((word32) dwArg08 + 16) + 1;
			}
			else
			{
				word32 ecx_3577;
				eax_1017 = fn00735640(dwArg08, 0x30, out ecx_3577, out edx);
			}
		}
		goto l0073653D;
	}
	if (dwArg04 == 0x00A163B8)
	{
		word32 eax_2655 = *dwArg08;
		if (eax_2655 != 0x00)
			MSVCR80.dll!putc();
		else
		{
			eax_1017 = *((word32) dwArg08 + 16);
			if (eax_1017 != *((word32) dwArg08 + 20))
			{
				*eax_1017 = 0x4E;
				*((word32) dwArg08 + 16) = (word32) *((word32) dwArg08 + 16) + 1;
			}
			else
			{
				word32 ecx_3578;
				eax_1017 = fn00735640(dwArg08, 0x4E, out ecx_3578, out edx);
			}
		}
		goto l0073653D;
	}
	if (dwArg04 == g_tA16D00)
	{
		word32 eax_2622 = *dwArg08;
		if (eax_2622 != 0x00)
			MSVCR80.dll!putc();
		else
		{
			eax_1017 = *((word32) dwArg08 + 16);
			if (eax_1017 != *((word32) dwArg08 + 20))
			{
				*eax_1017 = 0x53;
				*((word32) dwArg08 + 16) = (word32) *((word32) dwArg08 + 16) + 1;
			}
			else
			{
				word32 ecx_3579;
				eax_1017 = fn00735640(dwArg08, 0x53, out ecx_3579, out edx);
			}
		}
		goto l0073653D;
	}
	if (dwArg04 == 10640184)
	{
		word32 eax_2589 = *dwArg08;
		if (eax_2589 != 0x00)
			MSVCR80.dll!putc();
		else
		{
			eax_1017 = *((word32) dwArg08 + 16);
			if (eax_1017 != *((word32) dwArg08 + 20))
			{
				*eax_1017 = 0x2E;
				*((word32) dwArg08 + 16) = (word32) *((word32) dwArg08 + 16) + 1;
			}
			else
			{
				word32 ecx_3580;
				eax_1017 = fn00735640(dwArg08, 0x2E, out ecx_3580, out edx);
			}
		}
		goto l0073653D;
	}
	if (dwArg04 == 0x00A191D8)
	{
		word32 eax_2556 = *dwArg08;
		if (eax_2556 != 0x00)
			MSVCR80.dll!putc();
		else
		{
			eax_1017 = *((word32) dwArg08 + 16);
			if (eax_1017 != *((word32) dwArg08 + 20))
			{
				*eax_1017 = 0x46;
				*((word32) dwArg08 + 16) = (word32) *((word32) dwArg08 + 16) + 1;
			}
			else
			{
				word32 ecx_3581;
				eax_1017 = fn00735640(dwArg08, 0x46, out ecx_3581, out edx);
			}
		}
		goto l0073653D;
	}
	if (dwArg04 == 0x00A191E4)
	{
		word32 eax_2523 = *dwArg08;
		if (eax_2523 != 0x00)
			MSVCR80.dll!putc();
		else
		{
			eax_1017 = *((word32) dwArg08 + 16);
			if (eax_1017 != *((word32) dwArg08 + 20))
			{
				*eax_1017 = 0x54;
				*((word32) dwArg08 + 16) = (word32) *((word32) dwArg08 + 16) + 1;
			}
			else
			{
				word32 ecx_3582;
				eax_1017 = fn00735640(dwArg08, 0x54, out ecx_3582, out edx);
			}
		}
		goto l0073653D;
	}
	Eq_3 edi_1270;
	Eq_3 eax_42 = *((word32) dwArg04 + 4);
	if (eax_42 != 10610664)
	{
		word32 edx_3584;
		word32 ecx_3583;
		if (fn006D5670(eax_42, 10610664, out ecx_3583, out edx_3584) == 0x00)
		{
			Eq_3 eax_93 = *((word32) dwArg04 + 4);
			if (eax_93 != 0x00A1F400)
			{
				word32 ecx_3585;
				word32 edx_3586;
				if (fn006D5670(eax_93, 0x00A1F400, out ecx_3585, out edx_3586) == 0x00)
				{
					struct Eq_142431 * esp_411;
					Eq_3 ebx_328;
					struct Eq_142433 * esp_251;
					Eq_3 eax_197 = *((word32) dwArg04 + 4);
					if (eax_197 != 10609848)
					{
						word32 ecx_3587;
						word32 edx_3588;
						if (fn006D5670(eax_197, 10609848, out ecx_3587, out edx_3588) == 0x00)
						{
							Eq_3 eax_447 = *((word32) dwArg04 + 4);
							if (eax_447 != 0x00A27190)
							{
								word32 ecx_3589;
								if (fn006D5670(eax_447, 0x00A27190, out ecx_3589, out edx) == 0x00)
								{
									Eq_3 eax_984 = *((word32) dwArg04 + 4);
									if (eax_984 != 0x00A1B450)
									{
										word32 ecx_3590;
										if (fn006D5670(eax_984, 0x00A1B450, out ecx_3590, out edx) == 0x00)
										{
											Eq_3 eax_1343 = *((word32) dwArg04 + 4);
											if (eax_1343 != 0x00A23B20)
											{
												word32 edx_3593;
												word32 ecx_3592;
												if (fn006D5670(eax_1343, 0x00A23B20, out ecx_3592, out edx_3593) == 0x00)
												{
													Eq_3 eax_1467 = *((word32) dwArg04 + 4);
													if (eax_1467 != 0x00A16588)
													{
														word32 edx_3595;
														word32 ecx_3594;
														if (fn006D5670(eax_1467, 0x00A16588, out ecx_3594, out edx_3595) == 0x00)
														{
															Eq_3 eax_1595 = *((word32) dwArg04 + 4);
															if (eax_1595 != 0x00A1BAF0)
															{
																word32 edx_3597;
																word32 ecx_3596;
																if (fn006D5670(eax_1595, 0x00A1BAF0, out ecx_3596, out edx_3597) == 0x00)
																{
																	Eq_3 eax_1712 = *((word32) dwArg04 + 4);
																	if (eax_1712 != 0x00A1D1B8)
																	{
																		word32 ecx_3598;
																		word32 edx_3599;
																		if (fn006D5670(eax_1712, 0x00A1D1B8, out ecx_3598, out edx_3599) == 0x00)
																		{
																			Eq_3 eax_1893 = *((word32) dwArg04 + 4);
																			if (eax_1893 != 10663056 && eax_1893 != 10663672)
																			{
																				word32 edx_3601;
																				word32 ecx_3600;
																				if (fn006D5670(eax_1893, 10663056, out ecx_3600, out edx_3601) == 0x00)
																				{
																					struct Eq_142617 * esp_1925 = fp - 292;
																					word32 ecx_3602;
																					if (fn006D5670(*((word32) dwArg04 + 4), 10663672, out ecx_3602, out edx) == 0x00)
																					{
																						if (*((word32) dwArg04 + 4) == 10646616)
																						{
																							word32 eax_2334 = *dwArg08;
																							if (eax_2334 != 0x00)
																							{
																								word32 esp_2359;
																								word32 edx_2362;
																								MSVCR80.dll!putc();
																								esp_1925 = esp_2359 + 0x08;
																							}
																							else
																							{
																								Eq_3 eax_2338 = *((word32) dwArg08 + 16);
																								if (eax_2338 != *((word32) dwArg08 + 20))
																								{
																									*eax_2338 = 99;
																									*((word32) dwArg08 + 16) = (word32) *((word32) dwArg08 + 16) + 1;
																								}
																								else
																								{
																									word32 edx_3626;
																									word32 ecx_3625;
																									fn00735640(dwArg08, 99, out ecx_3625, out edx_3626);
																									esp_1925 = fp - 292;
																								}
																							}
																							word32 edx_3603;
																							fn00735790(dwArg08, *((word32) dwArg04 + 8), out edx_3603);
																							word32 edx_3604;
																							fn00735790(dwArg08, *((word32) dwArg04 + 0x0C), out edx_3604);
																							word32 edx_3605;
																							fn00735790(dwArg08, *((word32) dwArg04 + 16), out edx_3605);
																							word32 edx_3606;
																							fn00735790(dwArg08, *((word32) dwArg04 + 20), out edx_3606);
																							Eq_3 ecx_2412 = *((word32) dwArg04 + 24);
																							esp_1925->tFFFFFFFC = dwArg08;
																							esp_1925->tFFFFFFF8 = ecx_2412;
																							// Failed to bind call argument.
																							// Please report this issue at https://github.com/uxmal/reko
																							Eq_3 stackArg4 = <invalid>;
																							word32 edx_3608;
																							fn00735890(edx, ebx, 0x01, dwArg08, dwArg04, es, ds, stackArg4, dwArg04, out edx_3608);
																							struct Eq_142714 * esp_2417 = esp_1925 - 8;
																							Eq_3 edx_2423 = *((word32) dwArg04 + 28);
																							esp_2417->tFFFFFFFC = dwArg08;
																							esp_2417->tFFFFFFF8 = edx_2423;
																							// Failed to bind call argument.
																							// Please report this issue at https://github.com/uxmal/reko
																							Eq_3 stackArg4 = <invalid>;
																							word32 edx_3610;
																							fn00735890(edx_2423, ebx, 0x01, dwArg08, dwArg04, es, ds, stackArg4, dwArg04, out edx_3610);
																							word32 eax_2434 = *((word32) dwArg04 + 32);
																							esp_2417->tFFFFFFF4 = dwArg08;
																							esp_2417->dwFFFFFFF0 = eax_2434;
																							// Failed to bind call argument.
																							// Please report this issue at https://github.com/uxmal/reko
																							Eq_3 stackArg4 = <invalid>;
																							word32 edx_3612;
																							fn00735890(edx, ebx, 0x01, dwArg08, dwArg04, es, ds, stackArg4, dwArg04, out edx_3612);
																							word32 ecx_2445 = *((word32) dwArg04 + 36);
																							esp_2417->tFFFFFFEC = dwArg08;
																							esp_2417->dwFFFFFFE8 = ecx_2445;
																							// Failed to bind call argument.
																							// Please report this issue at https://github.com/uxmal/reko
																							Eq_3 stackArg4 = <invalid>;
																							word32 edx_3614;
																							fn00735890(edx, ebx, 0x01, dwArg08, dwArg04, es, ds, stackArg4, dwArg04, out edx_3614);
																							Eq_3 edx_2456 = *((word32) dwArg04 + 40);
																							esp_2417->tFFFFFFE4 = dwArg08;
																							esp_2417->tFFFFFFE0 = edx_2456;
																							// Failed to bind call argument.
																							// Please report this issue at https://github.com/uxmal/reko
																							Eq_3 stackArg4 = <invalid>;
																							word32 edx_3616;
																							fn00735890(edx_2456, ebx, 0x01, dwArg08, dwArg04, es, ds, stackArg4, dwArg04, out edx_3616);
																							word32 eax_2467 = *((word32) dwArg04 + 44);
																							esp_2417->tFFFFFFDC = dwArg08;
																							esp_2417->dwFFFFFFD8 = eax_2467;
																							// Failed to bind call argument.
																							// Please report this issue at https://github.com/uxmal/reko
																							Eq_3 stackArg4 = <invalid>;
																							word32 edx_3618;
																							fn00735890(edx, ebx, 0x01, dwArg08, dwArg04, es, ds, stackArg4, dwArg04, out edx_3618);
																							word32 ecx_2478 = *((word32) dwArg04 + 48);
																							esp_2417->tFFFFFFD4 = dwArg08;
																							esp_2417->dwFFFFFFD0 = ecx_2478;
																							// Failed to bind call argument.
																							// Please report this issue at https://github.com/uxmal/reko
																							Eq_3 stackArg4 = <invalid>;
																							word32 edx_3620;
																							fn00735890(edx, ebx, 0x01, dwArg08, dwArg04, es, ds, stackArg4, dwArg04, out edx_3620);
																							Eq_3 edx_2489 = *((word32) dwArg04 + 52);
																							esp_2417->tFFFFFFCC = dwArg08;
																							esp_2417->tFFFFFFC8 = edx_2489;
																							// Failed to bind call argument.
																							// Please report this issue at https://github.com/uxmal/reko
																							Eq_3 stackArg4 = <invalid>;
																							word32 edx_3622;
																							fn00735890(edx_2489, ebx, 0x01, dwArg08, dwArg04, es, ds, stackArg4, dwArg04, out edx_3622);
																							word32 edx_3623;
																							fn00735790(dwArg08, *((word32) dwArg04 + 56), out edx_3623);
																							word32 eax_2510 = *((word32) dwArg04 + 60);
																							esp_2417->t0004 = dwArg08;
																							esp_2417->dw0000 = eax_2510;
																							// Failed to bind call argument.
																							// Please report this issue at https://github.com/uxmal/reko
																							Eq_3 stackArg4 = <invalid>;
																							eax_1017 = fn00735890(edx, ebx, 0x01, dwArg08, dwArg04, es, ds, stackArg4, dwArg04, out edx);
																							goto l0073653D;
																						}
																						word32 eax_2204 = fn00701950(dwArg04);
																						ptr32 esp_2210 = fp - 292;
																						word32 eax_2213 = *dwArg08;
																						if (eax_2204 != 0x00)
																						{
																							<anonymous> ** ebx_2252 = *((word32) *((word32) dwArg04 + 4) + 80);
																							if (eax_2213 != 0x00)
																							{
																								word32 esp_2275;
																								word32 edx_2278;
																								MSVCR80.dll!putc();
																								esp_2210 = esp_2275 + 0x08;
																							}
																							else
																							{
																								Eq_3 eax_2254 = *((word32) dwArg08 + 16);
																								if (eax_2254 != *((word32) dwArg08 + 20))
																								{
																									*eax_2254 = 115;
																									*((word32) dwArg08 + 16) = (word32) *((word32) dwArg08 + 16) + 1;
																								}
																								else
																								{
																									word32 edx_3629;
																									word32 ecx_3628;
																									fn00735640(dwArg08, 115, out ecx_3628, out edx_3629);
																									esp_2210 = fp - 292;
																								}
																							}
																							<anonymous> * eax_2285 = *ebx_2252;
																							ptr32 edx_2287 = esp_2210 + 0x18;
																							struct Eq_142904 * esp_2288 = esp_2210 - 4;
																							esp_2288->ptr0000 = edx_2287;
																							esp_2288->dwFFFFFFFC = 0x00;
																							esp_2288->tFFFFFFF8 = dwArg04;
																							struct Eq_142917 * esp_2304;
																							eax_2285();
																							if (eax_1017 <= 0x7FFFFFFF)
																							{
																								word32 edx_3627;
																								fn00735790(dwArg08, eax_1017, out edx_3627);
																								eax_1017 = fn007356A0(dwArg08, eax_1017, esp_2304->t0024, out edx);
																								goto l0073653D;
																							}
																						}
																						else
																						{
																							if (eax_2213 != 0x00)
																							{
																								MSVCR80.dll!putc();
																								((word32) dwArg08 + 4)->u0 = 0x01;
																								goto l0073653D;
																							}
																							eax_1017 = *((word32) dwArg08 + 16);
																							if (eax_1017 != *((word32) dwArg08 + 20))
																							{
																								*eax_1017 = 0x3F;
																								*((word32) dwArg08 + 16) = (word32) *((word32) dwArg08 + 16) + 1;
																								((word32) dwArg08 + 4)->u0 = 0x01;
																								goto l0073653D;
																							}
																							word32 ecx_3642;
																							eax_1017 = fn00735640(dwArg08, 0x3F, out ecx_3642, out edx);
																						}
																						goto l00735D61;
																					}
																				}
																			}
																			ptr32 esp_1946;
																			Eq_3 eax_1931 = *((word32) dwArg04 + 4);
																			if (eax_1931 != 10663056)
																			{
																				esp_1946 = fp - 292;
																				word32 ecx_3630;
																				word32 edx_3631;
																				if (fn006D5670(eax_1931, 10663056, out ecx_3630, out edx_3631) == 0x00)
																				{
																					word32 eax_1998 = *dwArg08;
																					if (eax_1998 != 0x00)
																					{
																						word32 esp_2035;
																						word32 edx_2038;
																						MSVCR80.dll!putc();
																						esp_1946 = esp_2035 + 0x08;
																						goto l00735DDB;
																					}
																					Eq_3 eax_2002 = *((word32) dwArg08 + 16);
																					if (eax_2002 != *((word32) dwArg08 + 20))
																					{
																						*eax_2002 = 0x3E;
																						*((word32) dwArg08 + 16) = (word32) *((word32) dwArg08 + 16) + 1;
																						goto l00735DDB;
																					}
																					goto l00735DD3;
																				}
																			}
																			esp_1946 = fp - 292;
																			word32 eax_1953 = *dwArg08;
																			if (eax_1953 != 0x00)
																			{
																				word32 esp_1990;
																				word32 edx_1993;
																				MSVCR80.dll!putc();
																				esp_1946 = esp_1990 + 0x08;
																				goto l00735DDB;
																			}
																			Eq_3 eax_1957 = *((word32) dwArg08 + 16);
																			if (eax_1957 != *((word32) dwArg08 + 20))
																			{
																				*eax_1957 = 0x3C;
																				*((word32) dwArg08 + 16) = (word32) *((word32) dwArg08 + 16) + 1;
l00735DDB:
																				union Eq_3 * esp_2044 = esp_1946 - 4;
																				*esp_2044 = (union Eq_3 *) dwArg04;
																				// Failed to bind call argument.
																				// Please report this issue at https://github.com/uxmal/reko
																				Eq_3 stackArg4 = <invalid>;
																				eax_1017 = fn00704080(stackArg4, out edx);
																				if (eax_1017 == ~0x00)
																					goto l00735D61;
																				word32 edx_3634;
																				fn00735790(dwArg08, ecx, out edx_3634);
																				*esp_2044 = (union Eq_3 *) dwArg04;
																				// Failed to bind call argument.
																				// Please report this issue at https://github.com/uxmal/reko
																				Eq_3 stackArg4 = <invalid>;
																				word32 ecx_3636;
																				eax_1017 = fn00704B00(stackArg4, out ecx_3636, out edx);
																				if (eax_1017 == 0x00)
																				{
l00735D61:
																					((word32) dwArg08 + 4)->u0 = 0x01;
																					goto l0073653D;
																				}
																				*esp_2044 = (union Eq_3 *) eax_1017;
																				// Failed to bind call argument.
																				// Please report this issue at https://github.com/uxmal/reko
																				Eq_3 stackArg4 = <invalid>;
																				word32 ecx_3638;
																				Eq_3 eax_2090 = fn00704040(stackArg4, out ecx_3638, out edx);
																				Eq_3 edi_2095 = eax_2090;
																				struct Eq_143047 * esp_2096 = (const char *) esp_2044 + 4;
																				if (eax_2090 != 0x00)
																				{
																					do
																					{
																						struct Eq_143063 * esp_2101 = esp_2096 - 4;
																						esp_2101->t0000 = dwArg08;
																						esp_2101->tFFFFFFFC = edi_2095;
																						// Failed to bind call argument.
																						// Please report this issue at https://github.com/uxmal/reko
																						Eq_3 stackArg4 = <invalid>;
																						Eq_3 edx_2119;
																						fn00735890(edx_2119, eax_1017, 0x01, dwArg08, edi_2095, es, ds, stackArg4, dwArg04, out edx_2119);
																						word32 v24_2123 = (word32) *edi_2095 - 1;
																						*edi_2095 = v24_2123;
																						ptr32 esp_2122 = (const char *) &esp_2101->t0000 + 4;
																						if (v24_2123 == 0x00)
																						{
																							Eq_3 ecx_2127 = *((word32) edi_2095 + 4);
																							Eq_3 edx_2128 = *((word32) ecx_2127 + 24);
																							esp_2101->t0000 = edi_2095;
																							word32 esp_2131;
																							word32 edx_2134;
																							edx_2128();
																							esp_2122 = esp_2131 + 0x04;
																						}
																						union Eq_3 * esp_2140 = esp_2122 - 4;
																						*esp_2140 = (union Eq_3 *) eax_1017;
																						// Failed to bind call argument.
																						// Please report this issue at https://github.com/uxmal/reko
																						Eq_3 stackArg4 = <invalid>;
																						word32 ecx_3641;
																						Eq_3 eax_2154 = fn00704040(stackArg4, out ecx_3641, out edx);
																						edi_2095 = eax_2154;
																						esp_2096 = (struct Eq_143047 *) ((const char *) esp_2140 + 4);
																					} while (eax_2154 != 0x00);
																				}
																				Eq_142199 v27_2166 = (word32) *eax_1017 - 1;
																				*eax_1017 = v27_2166;
																				if (v27_2166 == 0x00)
																				{
																					Eq_3 eax_2170 = *((word32) eax_1017 + 4);
																					Eq_3 ecx_2171 = *((word32) eax_2170 + 24);
																					esp_2096->dwFFFFFFFC = (word32) eax_1017;
																					ecx_2171();
																				}
																				eax_1017 = fn006E0FC0();
																				if (eax_1017 != 0x00)
																					((word32) dwArg08 + 4)->u0 = 0x01;
l0073653D:
																				*((word32) dwArg08 + 8) = (word32) *((word32) dwArg08 + 8) - 1;
																				goto l00736541;
																			}
l00735DD3:
																			// Failed to bind call argument.
																			// Please report this issue at https://github.com/uxmal/reko
																			Eq_125083 stackArg4 = <invalid>;
																			word32 ecx_3644;
																			word32 edx_3645;
																			fn00735640(dwArg08, stackArg4, out ecx_3644, out edx_3645);
																			esp_1946 = fp - 292;
																			goto l00735DDB;
																		}
																	}
																	struct Eq_142575 * esp_1739 = fp - 292;
																	word32 eax_1732 = *dwArg08;
																	if (eax_1732 != 0x00)
																	{
																		word32 esp_1768;
																		word32 edx_1771;
																		MSVCR80.dll!putc();
																		esp_1739 = esp_1768 + 0x08;
																	}
																	else
																	{
																		Eq_3 eax_1736 = *((word32) dwArg08 + 16);
																		if (eax_1736 != *((word32) dwArg08 + 20))
																		{
																			*eax_1736 = 0x7B;
																			*((word32) dwArg08 + 16) = (word32) *((word32) dwArg08 + 16) + 1;
																		}
																		else
																		{
																			word32 ecx_3652;
																			word32 edx_3653;
																			fn00735640(dwArg08, 0x7B, out ecx_3652, out edx_3653);
																			esp_1739 = fp - 292;
																		}
																	}
																	struct Eq_143226 * esp_1778 = esp_1739 - 4;
																	esp_1778->ptr0000 = (struct Eq_73053 **) ((const char *) &esp_1739->t0010 + 4);
																	esp_1778->ptrFFFFFFFC = (union Eq_3 *) ((const char *) &esp_1778->ptr0000 + 20);
																	esp_1778->ptrFFFFFFF8 = (union Eq_3 *) &esp_1778->dw001C;
																	esp_1778->tFFFFFFF4 = dwArg04;
																	esp_1778->dw001C = 0x00;
																	word32 edx_3646;
																	if (fn006FC050(esp_1778->tFFFFFFF4, esp_1778->ptrFFFFFFF8, esp_1778->ptrFFFFFFFC, esp_1778->ptr0000, out edx_3646) != 0x00)
																	{
																		do
																		{
																			Eq_3 edx_1805 = esp_1739->t0010;
																			struct Eq_143313 * esp_1806 = esp_1739 - 4;
																			esp_1806->t0000 = dwArg08;
																			esp_1806->tFFFFFFFC = edx_1805;
																			// Failed to bind call argument.
																			// Please report this issue at https://github.com/uxmal/reko
																			Eq_3 stackArg4 = <invalid>;
																			word32 edx_3649;
																			fn00735890(edx_1805, ebx, 0x01, dwArg08, dwArg04, es, ds, stackArg4, dwArg04, out edx_3649);
																			word32 eax_1827 = esp_1806->dw0018;
																			esp_1806->tFFFFFFF8 = dwArg08;
																			esp_1806->dwFFFFFFF4 = eax_1827;
																			// Failed to bind call argument.
																			// Please report this issue at https://github.com/uxmal/reko
																			Eq_3 stackArg4 = <invalid>;
																			word32 edx_3651;
																			fn00735890(edx_1851, ebx, 0x01, dwArg08, dwArg04, es, ds, stackArg4, dwArg04, out edx_3651);
																			esp_1806->ptrFFFFFFF0 = &esp_1806->dw0018;
																			esp_1806->ptrFFFFFFEC = (union Eq_3 *) ((const char *) &esp_1806->t0000 + 20);
																			esp_1806->ptrFFFFFFE8 = (union Eq_3 *) (&esp_1806->dw0018 + 1);
																			esp_1806->tFFFFFFE4 = dwArg04;
																			Eq_3 edx_1851;
																		} while (fn006FC050(esp_1806->tFFFFFFE4, esp_1806->ptrFFFFFFE8, esp_1806->ptrFFFFFFEC, esp_1806->ptrFFFFFFF0, out edx_1851) != 0x00);
																	}
																	struct Eq_143294 * esp_1861 = esp_1739 - 4;
																	esp_1861->t0000 = dwArg08;
																	esp_1861->dwFFFFFFFC = 0x00;
																	// Failed to bind call argument.
																	// Please report this issue at https://github.com/uxmal/reko
																	Eq_3 stackArg4 = <invalid>;
																	eax_1017 = fn00735890(edx, ebx, 0x01, dwArg08, dwArg04, es, ds, stackArg4, dwArg04, out edx);
																	goto l0073653D;
																}
															}
															ptr32 esp_1622 = fp - 292;
															word32 eax_1615 = *dwArg08;
															if (eax_1615 != 0x00)
															{
																word32 esp_1651;
																word32 edx_1654;
																MSVCR80.dll!putc();
																esp_1622 = esp_1651 + 0x08;
															}
															else
															{
																Eq_3 eax_1619 = *((word32) dwArg08 + 16);
																if (eax_1619 != *((word32) dwArg08 + 20))
																{
																	*eax_1619 = 0x5B;
																	*((word32) dwArg08 + 16) = (word32) *((word32) dwArg08 + 16) + 1;
																}
																else
																{
																	word32 ecx_3655;
																	word32 edx_3656;
																	fn00735640(dwArg08, 0x5B, out ecx_3655, out edx_3656);
																	esp_1622 = fp - 292;
																}
															}
															Eq_3 ebp_1661 = *((word32) dwArg04 + 8);
															eax_1017 = fn00735790(dwArg08, ebp_1661, out edx);
															Eq_3 ebx_1680 = 0x00;
															if (ebp_1661 > 0x00)
															{
																do
																{
																	Eq_3 edx_1687 = *((word32) *((word32) dwArg04 + 0x0C) + ebx_1680 * 0x04);
																	struct Eq_143408 * esp_1689 = esp_1622 - 4;
																	esp_1689->t0000 = dwArg08;
																	esp_1689->tFFFFFFFC = edx_1687;
																	// Failed to bind call argument.
																	// Please report this issue at https://github.com/uxmal/reko
																	Eq_3 stackArg4 = <invalid>;
																	eax_1017 = fn00735890(edx_1687, ebx_1680, ebp_1661, dwArg08, dwArg04, es, ds, stackArg4, dwArg04, out edx);
																	ebx_1680 = (word32) ebx_1680 + 1;
																} while (ebx_1680 < ebp_1661);
															}
															goto l0073653D;
														}
													}
													struct Eq_142527 * esp_1494 = fp - 292;
													word32 eax_1487 = *dwArg08;
													if (eax_1487 != 0x00)
													{
														word32 esp_1523;
														word32 edx_1526;
														MSVCR80.dll!putc();
														esp_1494 = esp_1523 + 0x08;
													}
													else
													{
														Eq_3 eax_1491 = *((word32) dwArg08 + 16);
														if (eax_1491 != *((word32) dwArg08 + 20))
														{
															*eax_1491 = 0x28;
															*((word32) dwArg08 + 16) = (word32) *((word32) dwArg08 + 16) + 1;
														}
														else
														{
															word32 ecx_3660;
															word32 edx_3661;
															fn00735640(dwArg08, 0x28, out ecx_3660, out edx_3661);
															esp_1494 = fp - 292;
														}
													}
													esp_1494->tFFFFFFFC = dwArg04;
													// Failed to bind call argument.
													// Please report this issue at https://github.com/uxmal/reko
													Eq_3 stackArg4 = <invalid>;
													word32 ecx_3658;
													word32 edx_3659;
													Eq_3 eax_1546 = fn006DFE20(stackArg4, out ecx_3658, out edx_3659);
													Eq_3 ebx_1551 = eax_1546;
													eax_1017 = fn00735790(dwArg08, eax_1546, out edx);
													if (eax_1546 > 0x00)
													{
														Eq_3 edi_1564 = (word32) dwArg04 + 0x0C;
														do
														{
															word32 eax_1568 = *edi_1564;
															struct Eq_143527 * esp_1570 = esp_1494 - 4;
															esp_1570->t0000 = dwArg08;
															esp_1570->dwFFFFFFFC = eax_1568;
															// Failed to bind call argument.
															// Please report this issue at https://github.com/uxmal/reko
															Eq_3 stackArg4 = <invalid>;
															eax_1017 = fn00735890(edx, ebx_1551, 0x01, dwArg08, edi_1564, es, ds, stackArg4, dwArg04, out edx);
															edi_1564 = (word32) edi_1564 + 4;
															--ebx_1551;
														} while (ebx_1551 != 0x00);
													}
													goto l0073653D;
												}
											}
											word32 ecx_3591;
											eax_1017 = fn00718B50(dwArg04, out ecx_3591, out edx);
											struct Eq_142507 * esp_1382 = fp - 292;
											if (eax_1017 != 0x00)
											{
												if (*dwArg08 != 0x00)
												{
													word32 esp_1411;
													MSVCR80.dll!putc();
													esp_1382 = esp_1411 + 0x08;
												}
												else
												{
													eax_1017 = *((word32) dwArg08 + 16);
													if (eax_1017 != *((word32) dwArg08 + 20))
													{
														*eax_1017 = 117;
														*((word32) dwArg08 + 16) = (word32) *((word32) dwArg08 + 16) + 1;
													}
													else
													{
														word32 ecx_3664;
														eax_1017 = fn00735640(dwArg08, 117, out ecx_3664, out edx);
														esp_1382 = fp - 292;
													}
												}
												Eq_3 ebx_1421 = *((word32) eax_1017 + 8);
												if (ebx_1421 <= 0x7FFFFFFF)
												{
													word32 edx_3663;
													fn00735790(dwArg08, ebx_1421, out edx_3663);
													eax_1017 = fn007356A0(dwArg08, ebx_1421, (word32) eax_1017 + 20, out edx);
													Eq_142199 v33_1451 = (word32) *eax_1017 - 1;
													*eax_1017 = v33_1451;
													if (v33_1451 == 0x00)
													{
														Eq_3 ecx_1455 = *((word32) eax_1017 + 4);
														Eq_3 edx_1456 = *((word32) ecx_1455 + 24);
														esp_1382->tFFFFFFFC = eax_1017;
														edx_1456();
													}
													goto l0073653D;
												}
											}
											goto l00735D61;
										}
									}
									Eq_3 eax_1004 = *((word32) dwArg08 + 24);
									if (eax_1004 == 0x00 || *((word32) dwArg04 + 16) == 0x00)
									{
										word32 eax_1013 = *dwArg08;
										if (eax_1013 != 0x00)
										{
											MSVCR80.dll!putc();
											goto l00736162;
										}
										eax_1017 = *((word32) dwArg08 + 16);
										if (eax_1017 != *((word32) dwArg08 + 20))
										{
											*eax_1017 = 115;
											*((word32) dwArg08 + 16) = (word32) *((word32) dwArg08 + 16) + 1;
											goto l00736162;
										}
										word32 ecx_3694;
										eax_1017 = fn00735640(dwArg08, 115, out ecx_3694, out edx);
l00736162:
										Eq_3 ebx_1222 = *((word32) dwArg04 + 8);
										if (ebx_1222 <= 0x7FFFFFFF)
										{
											word32 edx_3687;
											fn00735790(dwArg08, ebx_1222, out edx_3687);
											eax_1017 = fn007356A0(dwArg08, ebx_1222, (word32) dwArg04 + 20, out edx);
											goto l0073653D;
										}
										goto l00735D61;
									}
									word32 ecx_3665;
									word32 edx_3666;
									Eq_3 eax_1070 = fn006FBCC0(eax_1004, dwArg04, out ecx_3665, out edx_3666);
									if (eax_1070 != 0x00)
									{
										word32 edx_3669;
										word32 ecx_3668;
										word32 edi_3671;
										word32 esi_3670;
										edi_1270 = fn007051A0(dwArg04, eax_1070, out ecx_3668, out edx_3669, out esi_3670, out edi_3671);
										if (*dwArg08 != 0x00)
										{
											word32 edx_1318;
											MSVCR80.dll!putc();
											goto l00736534;
										}
										Eq_3 eax_1276 = *((word32) dwArg08 + 16);
										if (eax_1276 != *((word32) dwArg08 + 20))
										{
											*eax_1276 = 0x52;
											*((word32) dwArg08 + 16) = (word32) *((word32) dwArg08 + 16) + 1;
											goto l00736534;
										}
l0073652C:
										// Failed to bind call argument.
										// Please report this issue at https://github.com/uxmal/reko
										Eq_125083 stackArg4 = <invalid>;
										word32 ecx_3681;
										word32 edx_3682;
										fn00735640(dwArg08, stackArg4, out ecx_3681, out edx_3682);
										goto l00736534;
									}
									word32 ecx_3667;
									Eq_3 eax_1091 = fn00705120(fn006FCF20(*((word32) dwArg08 + 24)), out ecx_3667, out edx);
									eax_1017 = eax_1091;
									if (eax_1091 != 0x00)
									{
										word32 ecx_3676;
										word32 ebx_3677;
										word32 edi_3678;
										eax_1017 = fn006FBD90(*((word32) dwArg08 + 24), dwArg04, dwArg08, out ecx_3676, out edx, out ebx_3677, out edi_3678);
										if (eax_1017 >= 0x00)
										{
l007360D2:
											struct Eq_143760 * esp_1134 = fp - 292;
											if (eax_1091 != 0x00)
											{
												word32 v37_1128 = (word32) *eax_1091 - 1;
												*eax_1091 = v37_1128;
												if (v37_1128 == 0x00)
												{
													Eq_3 edx_1132 = *((word32) eax_1091 + 4);
													word32 esp_1157;
													(*((word32) edx_1132 + 24))();
													esp_1134 = esp_1157 + 0x04;
												}
											}
											if (ebp_1118 == 0x00)
											{
												((word32) dwArg08 + 4)->u0 = 0x01;
												goto l0073653D;
											}
											word32 eax_1171 = *dwArg08;
											if (eax_1171 != 0x00)
											{
												struct Eq_143859 * esp_1205 = esp_1134 - 4;
												esp_1205->dw0000 = eax_1171;
												esp_1205->dwFFFFFFFC = 116;
												MSVCR80.dll!putc();
												goto l00736162;
											}
											eax_1017 = *((word32) dwArg08 + 16);
											if (eax_1017 != *((word32) dwArg08 + 20))
											{
												*eax_1017 = 116;
												*((word32) dwArg08 + 16) = (word32) *((word32) dwArg08 + 16) + 1;
												goto l00736162;
											}
											esp_1134->dwFFFFFFFC = 116;
											// Failed to bind call argument.
											// Please report this issue at https://github.com/uxmal/reko
											Eq_125083 stackArg4 = <invalid>;
											word32 ecx_3691;
											eax_1017 = fn00735640(dwArg08, stackArg4, out ecx_3691, out edx);
											goto l0073615F;
										}
									}
									ebp_1118 = 0x00;
									goto l007360D2;
								}
							}
							ptr32 esp_478 = fp - 292;
							if (*((word32) dwArg08 + 28) > 0x01)
							{
								Eq_3 rRet0;
								fn00733250(dwArg04, out rRet0);
								// Failed to bind call argument.
								// Please report this issue at https://github.com/uxmal/reko
								Eq_3 stackArg16 = <invalid>;
								eax_1017 = fn007012A0(rRet0, dwArg08, stackArg16, out edx);
								struct Eq_142431 * esp_871 = fp - 292;
								if (eax_1017 < 0x00)
									goto l0073620E;
								if (*dwArg08 != 0x00)
								{
									word32 esp_900;
									word32 edx_903;
									MSVCR80.dll!putc();
									esp_871 = esp_900 + 0x08;
								}
								else
								{
									Eq_3 eax_879 = *((word32) dwArg08 + 16);
									if (eax_879 != *((word32) dwArg08 + 20))
									{
										*eax_879 = 121;
										*((word32) dwArg08 + 16) = (word32) *((word32) dwArg08 + 16) + 1;
									}
									else
									{
										word32 ecx_3683;
										word32 edx_3684;
										fn00735640(dwArg08, 121, out ecx_3683, out edx_3684);
										esp_871 = fp - 292;
									}
								}
								word32 edx_3673;
								fn007356A0(dwArg08, 0x08, &esp_871->dwFFFFFFFC + 7, out edx_3673);
								esp_871->dwFFFFFFFC = 0x01;
								esp_871->ptrFFFFFFF8 = &esp_871->dwFFFFFFFC + 7;
								esp_871->tFFFFFFF4 = dwArg04;
								Eq_143723 rRet0_943;
								esp_871->tFFFFFFF0 = fn00733290(esp_871->tFFFFFFF4, out rRet0_943);
								esp_871->tFFFFFFF0 = rRet0_943;
								// Failed to bind call argument.
								// Please report this issue at https://github.com/uxmal/reko
								// Failed to bind call argument.
								// Please report this issue at https://github.com/uxmal/reko
								Eq_3 stackArg4 = <invalid>;
								Eq_3 stackArg16 = <invalid>;
								eax_1017 = fn007012A0(stackArg4, dwArg08, stackArg16, out edx);
								esp_411 = esp_871;
								if (eax_1017 < 0x00)
								{
l0073620E:
									((word32) dwArg08 + 4)->u0 = 0x01;
									goto l00736541;
								}
								goto l007363F9;
							}
							word32 eax_470 = *dwArg08;
							if (eax_470 != 0x00)
							{
								word32 esp_506;
								word32 edx_509;
								MSVCR80.dll!putc();
								esp_478 = esp_506 + 0x08;
							}
							else
							{
								Eq_3 eax_475 = *((word32) dwArg08 + 16);
								if (eax_475 != *((word32) dwArg08 + 20))
								{
									*eax_475 = 0x78;
									*((word32) dwArg08 + 16) = (word32) *((word32) dwArg08 + 16) + 1;
								}
								else
								{
									word32 ecx_3688;
									word32 edx_3689;
									fn00735640(dwArg08, 0x78, out ecx_3688, out edx_3689);
									esp_478 = fp - 292;
								}
							}
							struct Eq_143891 * esp_515 = esp_478 - 4;
							esp_515->t0000 = dwArg04;
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							Eq_3 stackArg4 = <invalid>;
							Eq_3 rRet0;
							esp_515->tFFFFFFFC = fn00733250(stackArg4, out rRet0);
							esp_515->tFFFFFFFC = rRet0;
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							Eq_3 stackArg4 = <invalid>;
							eax_1017 = fn006FF060(stackArg4, out edx);
							if (eax_1017 == 0x00)
							{
l0073625F:
								((word32) dwArg08 + 4)->u0 = 0x01;
l00736541:
								word32 ecx_3679;
								word32 eax_2841 = fn00694B8E(eax_1017, eax_7 ^ fp - 0x0114, edx, ebx, ebp, esi, edi, es, ds, ebx, out ecx_3679);
								edxOut = edx;
								return eax_2841;
							}
							esp_515->t0000 = eax_1017;
							esp_515->tFFFFFFFC = (const char *) &esp_515->t0000 + 36;
							<anonymous> * ebp_557 = fn006FF5D0(eax_1017, dwArg08, dwArg04, es, ds, esp_515->tFFFFFFFC, esp_515->t0000);
							Eq_142199 v40_567 = (word32) *eax_1017 - 1;
							*eax_1017 = v40_567;
							struct Eq_143971 * esp_566 = (const char *) &esp_515->t0000 + 4;
							if (v40_567 == 0x00)
							{
								Eq_3 ecx_571 = *((word32) eax_1017 + 4);
								Eq_3 edx_572 = *((word32) ecx_571 + 24);
								esp_515->t0000 = eax_1017;
								word32 esp_575;
								word32 edx_578;
								edx_572();
								esp_566 = esp_575 + 0x04;
							}
							byte * eax_584 = (const char *) &esp_566->tFFFFFFFC + 36;
							eax_586 = eax_584;
							do
							{
								byte * eax_586;
								eax_586 = eax_3709 + 1;
								eax_3709 = eax_586;
							} while (*eax_3709 != 0x00);
							Eq_3 eax_594 = eax_586 - (eax_584 + 1);
							byte bl_634 = (byte) eax_594;
							word32 eax_598 = *dwArg08;
							if (eax_598 != 0x00)
							{
								struct Eq_144058 * esp_639 = esp_566 - 4;
								esp_639->dw0000 = eax_598;
								esp_639->tFFFFFFFC = eax_594;
								ebp_557();
							}
							else
							{
								Eq_3 eax_602 = *((word32) dwArg08 + 16);
								if (eax_602 != *((word32) dwArg08 + 20))
								{
									*eax_602 = bl_634;
									*((word32) dwArg08 + 16) = (word32) *((word32) dwArg08 + 16) + 1;
								}
								else
								{
									esp_566->tFFFFFFFC = eax_594;
									// Failed to bind call argument.
									// Please report this issue at https://github.com/uxmal/reko
									Eq_125083 stackArg4 = <invalid>;
									word32 edx_3697;
									word32 ecx_3696;
									fn00735640(dwArg08, stackArg4, out ecx_3696, out edx_3697);
								}
							}
							word32 edx_3692;
							fn007356A0(dwArg08, eax_594, (const char *) &esp_566->tFFFFFFFC + 36, out edx_3692);
							esp_566->tFFFFFFFC = dwArg04;
							Eq_143723 rRet0_685;
							esp_566->tFFFFFFF8 = fn00733290(esp_566->tFFFFFFFC, out rRet0_685);
							esp_566->tFFFFFFF8 = rRet0_685;
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							Eq_3 stackArg4 = <invalid>;
							eax_1017 = fn006FF060(stackArg4, out edx);
							struct Eq_144093 * esp_692 = esp_566 - 8;
							if (eax_1017 == 0x00)
								goto l0073625F;
							esp_692->t0004 = eax_1017;
							esp_692->t0000 = (const char *) &esp_692->t0004 + 36;
							<anonymous> * ebp_709 = fn006FF5D0(eax_594, dwArg08, eax_1017, es, ds, esp_692->t0000, esp_692->t0004);
							Eq_142199 v44_719 = (word32) *eax_1017 - 1;
							*eax_1017 = v44_719;
							esp_251 = (struct Eq_142433 *) ((const char *) &esp_692->t0004 + 4);
							if (v44_719 == 0x00)
							{
								Eq_3 ecx_723 = *((word32) eax_1017 + 4);
								Eq_3 edx_724 = *((word32) ecx_723 + 24);
								esp_692->t0004 = eax_1017;
								word32 esp_727;
								word32 edx_730;
								edx_724();
								esp_251 = esp_727 + 0x04;
							}
							byte * eax_736 = &esp_251->dw0000 + 8;
							eax_738 = eax_736;
							do
							{
								byte * eax_738;
								eax_738 = eax_3710 + 1;
								eax_3710 = eax_738;
							} while (*eax_3710 != 0x00);
							Eq_3 eax_746 = eax_738 - (eax_736 + 1);
							ebx_328 = eax_746;
							byte bl_807 = (byte) eax_746;
							word32 eax_750 = *dwArg08;
							if (eax_750 != 0x00)
							{
								struct Eq_144214 * esp_821 = esp_251 - 4;
								esp_821->dw0000 = eax_750;
								esp_821->tFFFFFFFC = eax_746;
								ebp_709();
								eax_1017 = fn007356A0(dwArg08, eax_746, &esp_821->dw0000 + 9, out edx);
								goto l0073653D;
							}
							Eq_3 eax_754 = *((word32) dwArg08 + 16);
							if (eax_754 != *((word32) dwArg08 + 20))
							{
								*eax_754 = bl_807;
								*((word32) dwArg08 + 16) = (word32) *((word32) dwArg08 + 16) + 1;
								eax_1017 = fn007356A0(dwArg08, eax_746, &esp_251->dw0000 + 8, out edx);
								goto l0073653D;
							}
l00736361:
							union Eq_3 * esp_759 = esp_251 - 4;
							*esp_759 = (union Eq_3 *) ebx_328;
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							Eq_125083 stackArg4 = <invalid>;
							word32 edx_3700;
							word32 ecx_3699;
							fn00735640(dwArg08, stackArg4, out ecx_3699, out edx_3700);
							eax_1017 = fn007356A0(dwArg08, ebx_328, (const char *) esp_759 + 36, out edx);
							goto l0073653D;
						}
					}
					if (*((word32) dwArg08 + 28) > 0x01)
					{
						Eq_3 rRet0;
						fn006FF3E0(dwArg04, out rRet0);
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_3 stackArg16 = <invalid>;
						eax_1017 = fn007012A0(rRet0, dwArg08, stackArg16, out edx);
						if (eax_1017 < 0x00)
							goto l0073620E;
						if (*dwArg08 != 0x00)
						{
							word32 esp_430;
							MSVCR80.dll!putc();
							eax_1017 = fn007356A0(dwArg08, 0x08, esp_430 + 0x20, out edx);
							goto l0073653D;
						}
						Eq_3 eax_400 = *((word32) dwArg08 + 16);
						if (eax_400 != *((word32) dwArg08 + 20))
						{
							*eax_400 = 0x67;
							*((word32) dwArg08 + 16) = (word32) *((word32) dwArg08 + 16) + 1;
							eax_1017 = fn007356A0(dwArg08, 0x08, fp - 0x010C, out edx);
							goto l0073653D;
						}
						word32 ecx_3702;
						word32 edx_3703;
						fn00735640(dwArg08, 0x67, out ecx_3702, out edx_3703);
						esp_411 = fp - 292;
l007363F9:
						eax_1017 = fn007356A0(dwArg08, 0x08, &esp_411->dwFFFFFFFC + 7, out edx);
						goto l0073653D;
					}
					<anonymous> * ebp_241 = fn006FF5D0(ebx, dwArg08, dwArg04, es, ds, fp - 0x0104, dwArg04);
					byte * eax_250 = fp - 0x0104;
					esp_251 = fp - 292;
					do
					{
						eax_250 = eax_3708 + 1;
						eax_3708 = eax_250;
					} while (*eax_3708 != 0x00);
					Eq_3 eax_263 = eax_250 - (fp - (struct Eq_144402 *) 0x0103);
					byte bl_319 = (byte) eax_263;
					word32 eax_266 = *dwArg08;
					if (eax_266 != 0x00)
					{
						word32 esp_301;
						word32 edx_304;
						MSVCR80.dll!putc();
						esp_251 = esp_301 + 0x08;
					}
					else
					{
						Eq_3 eax_270 = *((word32) dwArg08 + 16);
						if (eax_270 != *((word32) dwArg08 + 20))
						{
							*eax_270 = 0x66;
							Mem295[dwArg08 + 0x10:word32] = Mem293[dwArg08 + 0x10:word32] + ebp_241;
						}
						else
						{
							word32 edx_3707;
							word32 ecx_3706;
							fn00735640(dwArg08, 0x66, out ecx_3706, out edx_3707);
							esp_251 = fp - (struct Eq_144451 *) 292;
						}
					}
					word32 eax_311 = *dwArg08;
					ebx_328 = eax_263;
					if (eax_311 != 0x00)
					{
						struct Eq_144472 * esp_346 = esp_251 - (struct Eq_144473 *) 4;
						esp_346->dw0000 = eax_311;
						esp_346->tFFFFFFFC = eax_263;
						word32 esp_350;
						MSVCR80.dll!putc();
						eax_1017 = fn007356A0(dwArg08, eax_263, esp_350 + 0x28, out edx);
						goto l0073653D;
					}
					Eq_3 eax_315 = *((word32) dwArg08 + 16);
					if (eax_315 != *((word32) dwArg08 + 20))
					{
						*eax_315 = bl_319;
						Mem323[dwArg08 + 0x10:word32] = Mem320[dwArg08 + 0x10:word32] + ebp_241;
						eax_1017 = fn007356A0(dwArg08, eax_263, esp_251 + 0x20, out edx);
						goto l0073653D;
					}
					goto l00736361;
				}
			}
			word32 eax_113 = *dwArg08;
			if (eax_113 != 0x00)
			{
				word32 edx_146;
				MSVCR80.dll!putc();
			}
			else
			{
				Eq_3 eax_117 = *((word32) dwArg08 + 16);
				if (eax_117 != *((word32) dwArg08 + 20))
				{
					*eax_117 = 0x6C;
					*((word32) dwArg08 + 16) = (word32) *((word32) dwArg08 + 16) + 1;
				}
				else
				{
					word32 ecx_3704;
					word32 edx_3705;
					fn00735640(dwArg08, 0x6C, out ecx_3704, out edx_3705);
				}
			}
			Eq_3 ebx_153 = *((word32) dwArg04 + 8);
			eax_1017 = fn00735790(dwArg08, ebx_153, out edx);
			bool v69_2856 = ebx_153 <= 0x00;
			if (ebx_153 < 0x00)
			{
				ebx_153 = -ebx_153;
				v69_2856 = ebx_153 <= 0x00;
			}
			if (!v69_2856)
			{
				union Eq_144376 * edi_174 = (word32) dwArg04 + 0x0C;
				do
				{
					eax_1017 = fn00735710(dwArg08, (word32) *edi_174, out edx);
					edi_174 = (union Eq_144376 *) ((const char *) edi_174 + 2);
					--ebx_153;
				} while (ebx_153 != 0x00);
			}
			goto l0073653D;
		}
	}
	word32 eax_62 = *dwArg08;
	edi_1270 = *((word32) dwArg04 + 8);
	if (eax_62 != 0x00)
	{
		word32 edx_88;
		MSVCR80.dll!putc();
	}
	else
	{
		Eq_3 eax_68 = *((word32) dwArg08 + 16);
		if (eax_68 == *((word32) dwArg08 + 20))
			goto l0073652C;
		*eax_68 = 0x69;
		*((word32) dwArg08 + 16) = (word32) *((word32) dwArg08 + 16) + 1;
	}
l00736534:
	eax_1017 = fn00735790(dwArg08, edi_1270, out edx);
	goto l0073653D;
}

// 00736560: void fn00736560()
// Called from:
//      fn006F6810
void fn00736560()
{
	word32 edx_39;
	fn00735790(fp - 0x20, dwArg04, out edx_39);
}

// 00736590: void fn00736590(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Stack Eq_3 dwArg0C)
// Called from:
//      fn006F6810
void fn00736590(Eq_3 dwArg04, Eq_3 dwArg08, Eq_3 dwArg0C)
{
	Eq_3 dwLoc08_74;
	if (dwArg0C > 0x00)
	{
		word32 edx_101;
		word32 ecx_100;
		dwLoc08_74 = fn006FDCC0(out ecx_100, out edx_101);
	}
	else
		dwLoc08_74.u0 = 0x00;
	word32 edx_107;
	fn00735890(dwArg04, ebx, ebp, dwArg0C, edi, es, ds, dwArg04, fp - 0x20, out edx_107);
	if (dwLoc08_74 != 0x00)
	{
		*dwLoc08_74.u0 = (word32) *dwLoc08_74.u0 - 1;
		if (*dwLoc08_74.u0 == 0x00)
		{
			struct Eq_144560 * ecx_53 = *((word64) dwLoc08_74.u0 + 4);
			ecx_53->ptr0018();
		}
	}
}

// 00736610: Register Eq_3 fn00736610(Register Eq_3 eax, Register Eq_3 edx, Register Eq_3 edi)
// Called from:
//      fn007367D0
Eq_3 fn00736610(Eq_3 eax, Eq_3 edx, Eq_3 edi)
{
	Eq_3 esi_19 = eax;
	Eq_3 eax_10 = *edi;
	if (eax_10 != 0x00)
		return fread(edx, 0x01, eax, eax_10);
	Eq_3 ecx_14 = *((word32) edi + 16);
	Eq_3 eax_16 = *((word32) edi + 20) - ecx_14;
	if (eax_16 < eax)
		esi_19 = eax_16;
	memcpy(edx, ecx_14, esi_19);
	Mem34[edi + 0x10:word32] = Mem30[edi + 0x10:word32] + esi_19;
	return esi_19;
}

// 00736650: Register ui32 fn00736650(Register Eq_3 esi, Register out Eq_144601 edxOut)
// Called from:
//      fn007367D0
ui32 fn00736650(Eq_3 esi, union Eq_144601 & edxOut)
{
	ui32 edi_20;
	word32 eax_6 = *esi;
	struct Eq_144607 * esp_13 = fp - 8;
	if (eax_6 != 0x00)
	{
		word32 esp_30;
		word32 eax_31;
		MSVCR80.dll!getc();
		esp_13 = esp_30 + 0x04;
		edi_20 = (word32) (word16) eax_31;
	}
	else
	{
		Eq_3 eax_17 = *((word32) esi + 16);
		if (eax_17 < *((word32) esi + 20))
		{
			edi_20 = (word32) (word16) *eax_17;
			*((word32) esi + 16) = (word32) eax_17 + 1;
		}
		else
			edi_20 = ~0x00;
	}
	byte al_71;
	word32 eax_42 = *esi;
	if (eax_42 != 0x00)
	{
		esp_13->dwFFFFFFFC = eax_42;
		word32 eax_63;
		MSVCR80.dll!getc();
		al_71 = (byte) eax_63;
	}
	else
	{
		Eq_3 ecx_46 = *((word32) esi + 16);
		if (ecx_46 < *((word32) esi + 20))
		{
			al_71 = (byte) *ecx_46;
			*((word32) esi + 16) = (word32) ecx_46 + 1;
		}
		else
			al_71 = ~0x00;
	}
	Eq_144601 edx_79 = SEQ(0x00, al_71, 0x00);
	edxOut = edx_79;
	ui32 edi_80 = edi_20 | edx_79;
	return (int32) (word16) -(edi_80 & ~0x7FFF) | (int32) ((word16) edi_80);
}

// 007366D0: Register Eq_3 fn007366D0(Register Eq_3 eax, Register Eq_3 ecx, Register out Eq_3 edxOut)
// Called from:
//      fn00736780
//      fn007367D0
//      fn00737370
Eq_3 fn007366D0(Eq_3 eax, Eq_3 ecx, union Eq_3 & edxOut)
{
	word32 esi_8 = *ecx;
	if (esi_8 == 0x00)
	{
		ui32 eax_20;
		Eq_3 edx_15 = *((word32) ecx + 16);
		Eq_3 edi_16 = *((word32) ecx + 20);
		if (edx_15 < edi_16)
		{
			eax_20 = (word32) *edx_15;
			*((word32) ecx + 16) = (word32) edx_15 + 1;
		}
		else
			eax_20 = ~0x00;
		ui32 edx_34;
		Eq_3 esi_29 = *((word32) ecx + 16);
		if (esi_29 < edi_16)
		{
			edx_34 = (word32) *esi_29;
			*((word32) ecx + 16) = (word32) esi_29 + 1;
		}
		else
			edx_34 = ~0x00;
		ui32 edx_52;
		Eq_3 esi_43 = *((word32) ecx + 16);
		ui32 eax_48 = eax_20 | edx_34 << 0x08;
		if (esi_43 < edi_16)
		{
			edx_52 = (word32) *esi_43;
			*((word32) ecx + 16) = (word32) esi_43 + 1;
		}
		else
			edx_52 = ~0x00;
		ui32 eax_62 = eax_48 | edx_52 << 0x10;
		Eq_3 edx_65 = *((word32) ecx + 16);
		if (edx_65 >= edi_16)
		{
			edxOut = edx_65;
			return eax_62 | 0xFF000000;
		}
		else
		{
			Eq_3 eax_87 = eax_62 | (word32) (*edx_65) << 0x18;
			*((word32) ecx + 16) = (word32) edx_65 + 1;
			edxOut = (word32) edx_65 + 1;
			return eax_87;
		}
	}
	else
	{
		struct Eq_144703 * esp_99;
		word32 ecx_100;
		ui32 eax_101;
		MSVCR80.dll!getc();
		esp_99->dwFFFFFFFC = esi_8;
		struct Eq_144711 * esp_108;
		word32 ecx_109;
		ui32 eax_110;
		MSVCR80.dll!getc();
		esp_108->dwFFFFFFFC = esi_8;
		struct Eq_144718 * esp_120;
		word32 ecx_121;
		ui32 eax_122;
		MSVCR80.dll!getc();
		esp_120->dwFFFFFFFC = esi_8;
		ui32 eax_134;
		Eq_3 edx_135;
		MSVCR80.dll!getc();
		edxOut = edx_135;
		return eax_101 | eax_110 << 0x08 | eax_122 << 0x10 | eax_134 << 0x18;
	}
}

// 00736780: Register word32 fn00736780(Register Eq_3 ebx, Register Eq_3 ebp, Register Eq_3 esi, Register Eq_3 edi, Register (ptr16 Eq_7) es, Register (ptr16 Eq_8) ds, Register out Eq_3 edxOut)
// Called from:
//      fn007367D0
word32 fn00736780(Eq_3 ebx, Eq_3 ebp, Eq_3 esi, Eq_3 edi, struct Eq_7 * es, struct Eq_8 * ds, union Eq_3 & edxOut)
{
	Eq_3 eax_7 = g_tA14188 ^ fp - 0x0C;
	word32 edx_90;
	word32 edx_91;
	fn007366D0(fn007366D0(eax_7, esi, out edx_90), esi, out edx_91);
	Eq_3 edx_45;
	word32 ecx_92;
	word32 ecx_93;
	word32 eax_62 = fn00694B8E(fn00710CB0(fp - 0x0C, 0x08, 0x01, 0x01, out ecx_92, out edx_45), eax_7 ^ fp - 0x0C, edx_45, ebx, ebp, esi, edi, es, ds, edi, out ecx_93);
	edxOut = edx_45;
	return eax_62;
}

// 007367D0: Register word32 fn007367D0(Register Eq_3 edx, Register Eq_3 ebx, Register Eq_3 ebp, Register Eq_3 esi, Register Eq_3 edi, Register (ptr16 Eq_7) es, Register (ptr16 Eq_8) ds, Stack Eq_3 dwArg04, Register out Eq_3 edxOut)
// Called from:
//      fn007367D0
//      fn007373A0
//      fn00737410
word32 fn007367D0(Eq_3 edx, Eq_3 ebx, Eq_3 ebp, Eq_3 esi, Eq_3 edi, struct Eq_7 * es, struct Eq_8 * ds, Eq_3 dwArg04, union Eq_3 & edxOut)
{
	ui32 eax_7 = g_tA14188 ^ fp - 332;
	struct Eq_144868 * esp_19 = fp - 0x015C;
	Eq_3 eax_23 = *dwArg04;
	if (eax_23 != 0x00)
	{
		struct Eq_144885 * esp_38;
		word32 eax_39;
		MSVCR80.dll!getc();
		esp_38->dw0018 = eax_39;
		esp_19 = (struct Eq_144868 *) ((const char *) esp_38 + 4);
	}
	else
	{
		Eq_3 eax_27 = *((word32) dwArg04 + 16);
		if (eax_27 < *((word32) dwArg04 + 20))
			*((word32) dwArg04 + 16) = (word32) eax_27 + 1;
	}
	Eq_3 eax_1385;
	*((word32) dwArg04 + 8) = (word32) *((word32) dwArg04 + 8) + 1;
	Eq_3 eax_52 = *((word32) dwArg04 + 8);
	if (eax_52 > 2000)
	{
		*((word32) dwArg04 + 8) = (word32) eax_52 - 1;
		Eq_3 edx_1856 = g_tA17E2C;
		struct Eq_144930 * esp_1857 = esp_19 - 4;
		esp_1857->dw0000 = 0x008DB9B8;
		esp_1857->tFFFFFFFC = edx_1856;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_3 stackArg4 = <invalid>;
		word32 ecx_2758;
		fn006E0F80(stackArg4, dwArg04, out ecx_2758, out edx);
		eax_1385.u0 = 0x00;
	}
	else
	{
		Eq_3 eax_1760;
		struct Eq_144915 * esp_1762;
		Eq_3 ebp_100 = esp_19[5];
		if (ebp_100 <= 0x7B)
		{
			struct Eq_144868 * esp_1705;
			Eq_3 eax_60 = (word32) *((word32) ebp_100 + 0x00737259);
			switch (eax_60)
			{
			case 0x00:
				goto l00736877;
			case 0x01:
			case 0x02:
			case 0x03:
			case 0x04:
			case 0x05:
			case 0x06:
			case 0x07:
			case 0x08:
			case 0x09:
			case 0x0A:
			case 11:
			case 0x0C:
			case 0x0D:
			case 0x0E:
			case 0x0F:
			case 0x10:
			case 0x11:
			case 0x12:
			case 0x13:
			case 0x14:
			case 0x15:
			case 22:
			case 0x17:
			case 0x18:
			case 0x19:
			case 0x1A:
			case 0x1B:
			case 0x1C:
			case 0x1D:
			case 0x1E:
			case 0x1F:
			case 0x20:
			case 33:
			case 0x22:
			case 0x23:
			case 0x24:
			case 0x25:
			case 0x26:
			case 0x27:
			case 0x28:
			case 0x2A:
			case 0x2B:
			case 44:
			case 0x2D:
			case 0x2E:
			case 0x30:
			case 0x32:
			case 0x33:
			case 0x34:
			case 0x35:
			case 0x36:
			case 55:
			case 0x38:
			case 0x39:
			case 0x3A:
			case 0x3B:
			case 0x3C:
			case 0x3E:
			case 0x40:
			case 0x41:
			case 66:
			case 0x43:
			case 0x44:
			case 0x45:
			case 0x46:
			case 0x48:
			case 0x49:
			case 0x4B:
			case 0x4C:
			case 77:
			case 0x4E:
			case 0x50:
			case 0x51:
			case 0x52:
			case 0x56:
			case 0x57:
			case 88:
			case 0x59:
			case 0x5A:
			case 0x5B:
			case 0x5D:
			case 0x5E:
			case 0x5F:
			case 0x60:
			case 0x61:
			case 0x62:
			case 99:
			case 101:
			case 0x66:
			case 0x69:
			case 0x6B:
			case 0x6C:
			case 110:
			case 111:
			case 0x70:
			case 113:
			case 114:
			case 115:
			case 0x77:
			case 0x78:
			case 0x7B:
				goto l007371C8;
			case 0x29:
				word32 edx_2760;
				Eq_3 eax_1628 = fn007366D0(eax_60, dwArg04, out edx_2760);
				if (eax_1628 > 0x7FFFFFFF)
					goto l007371C8;
				struct Eq_145136 * esp_1637 = esp_19 - 4;
				esp_1637->t0000 = eax_1628;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_3 stackArg4 = <invalid>;
				word32 ecx_2771;
				eax_1385 = fn006DFD20(stackArg4, out ecx_2771, out edx);
				esp_1637->t0014 = eax_1385;
				if (eax_1385 == 0x00)
					goto l007371DB;
				Eq_3 esi_1650 = 0x00;
				if (eax_1628 > 0x00)
				{
					Eq_3 ebx_1653 = 0x0C;
					do
					{
						struct Eq_145171 * esp_1655 = esp_19 - 4;
						esp_1655->t0000 = dwArg04;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_3 stackArg4 = <invalid>;
						Eq_3 eax_1664 = fn007367D0(edx, ebx_1653, eax_1628, esi_1650, dwArg04, es, ds, stackArg4, out edx);
						if (eax_1664 == 0x00)
							goto l00736DA9;
						edx = esp_1655->t0014;
						Mem1752[ebx_1653 + edx:word32] = eax_1664;
						esi_1650 = (word32) esi_1650 + 1;
						ebx_1653 = (word32) ebx_1653 + 4;
					} while (esi_1650 < eax_1628);
					eax_1385 = esp_1655->t0014;
				}
				break;
			case 0x2F:
				++g_dwA25B38;
				eax_1385.u0 = 10640184;
				break;
			case 0x31:
				goto l007371DB;
			case 0x3D:
			case 0x3F:
				word32 edx_2761;
				Eq_3 eax_1499 = fn007366D0(eax_60, dwArg04, out edx_2761);
				if (eax_1499 > 0x7FFFFFFF)
					goto l007371C8;
				struct Eq_146484 * esp_1509 = esp_19 - 4;
				esp_1509->t0000 = eax_1499;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_3 stackArg4 = <invalid>;
				word32 ecx_2837;
				Eq_3 eax_1516 = fn006DFD20(stackArg4, out ecx_2837, out edx);
				esp_1509->t0014 = eax_1516;
				if (eax_1516 == 0x00)
					goto l007371DB;
				Eq_3 esi_1526 = 0x00;
				if (eax_1499 > 0x00)
				{
					Eq_3 ebx_1529 = 0x0C;
					do
					{
						struct Eq_146515 * esp_1531 = esp_19 - 4;
						esp_1531->t0000 = dwArg04;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_3 stackArg4 = <invalid>;
						Eq_3 eax_1540 = fn007367D0(edx, ebx_1529, eax_1499, esi_1526, dwArg04, es, ds, stackArg4, out edx);
						if (eax_1540 == 0x00)
						{
							if (fn006E0FC0() != 0x00)
								goto l00736DC5;
							Eq_3 edx_1553 = g_tA16B7C;
							esp_1531->t0000.u0 = 9288040;
							esp_1531->tFFFFFFFC = edx_1553;
							goto l00736DBD;
						}
						Mem1559[ebx_1529 + Mem1533[esp_1531 + 0x14:word32]:word32] = eax_1540;
						esi_1526 = (word32) esi_1526 + 1;
						ebx_1529 = (word32) ebx_1529 + 4;
					} while (esi_1526 < eax_1499);
					eax_1516 = esp_1531->t0014;
				}
				if (eax_1516 == 0x00)
					goto l007371DB;
				Eq_3 eax_1582;
				struct Eq_146568 * esp_1572 = esp_19 - 4;
				esp_1572->t0000 = eax_1516;
				if (esp_19[5] == 0x3C)
					eax_1582 = fn0073A5D0(out edx);
				else
				{
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_3 stackArg4 = <invalid>;
					eax_1582 = fn0073A5E0(stackArg4, out edx);
				}
				Eq_3 eax_1597 = esp_1572->t0014;
				*eax_1597 = (word32) *eax_1597 - 1;
				Eq_3 eax_1600 = esp_1572->t0014;
				if (*eax_1600 == 0x00)
				{
					Eq_3 ecx_1604 = *((word32) eax_1600 + 4);
					Eq_3 edx_1605 = *((word32) ecx_1604 + 24);
					esp_1572->t0000 = eax_1600;
					edx_1605();
				}
				eax_1385 = eax_1582;
				break;
			case 0x47:
				++g_dwA191D8;
				eax_1385.u0 = 0x00A191D8;
				break;
			case 0x4A:
				eax_1385 = fn00736780(MSVCR80.dll!getc, ebp_100, dwArg04, dwArg04, es, ds, out edx);
				break;
			case 0x4F:
				++g_dwA163B8;
				eax_1385.u0 = 0x00A163B8;
				break;
			case 0x53:
				Eq_3 eax_1454 = fn007366D0(eax_60, dwArg04, out edx);
				if (eax_1454 < 0x00)
					goto l00736C8F;
				Eq_3 ecx_1463 = *((word32) dwArg04 + 24);
				if (eax_1454 >= *((word32) ecx_1463 + 8))
					goto l00736C8F;
				Eq_3 eax_1475 = *((word32) *((word32) ecx_1463 + 0x0C) + eax_1454 * 0x04);
				esp_19[4] = (struct Eq_144868) eax_1475;
				*eax_1475 = (word32) *eax_1475 + 1;
				eax_1385 = esp_19[4];
				break;
			case 0x54:
				Eq_3 eax_1448 = g_tA16D00;
				*eax_1448 = (word32) *eax_1448 + 1;
				eax_1385 = g_tA16D00;
				break;
			case 0x55:
				++g_dwA191E4;
				eax_1385.u0 = 0x00A191E4;
				break;
			case 0x5C:
				word32 edx_2762;
				Eq_3 eax_1392 = fn007366D0(eax_60, dwArg04, out edx_2762);
				if (eax_1392 > 0x7FFFFFFF)
					goto l007371C8;
				struct Eq_146110 * esp_1401 = esp_19 - 4;
				esp_1401->t0000 = eax_1392;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_3 stackArg4 = <invalid>;
				eax_1385 = fn006F2650(stackArg4, out edx);
				esp_1401->t0014 = eax_1385;
				if (eax_1385 == 0x00)
					goto l007371DB;
				Eq_3 esi_1414 = 0x00;
				if (eax_1392 > 0x00)
				{
					do
					{
						struct Eq_146129 * esp_1419 = esp_19 - 4;
						esp_1419->t0000 = dwArg04;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_3 stackArg4 = <invalid>;
						Eq_3 eax_1428 = fn007367D0(edx, eax_1392, ebp_100, esi_1414, dwArg04, es, ds, stackArg4, out edx);
						if (eax_1428 == 0x00)
						{
l00736DA9:
							if (fn006E0FC0() == 0x00)
							{
								Eq_3 eax_1678 = g_tA16B7C;
								struct Eq_145680 * esp_1680 = esp_19 - 4;
								esp_1680->dw0000 = 9288040;
								esp_1680->tFFFFFFFC = eax_1678;
l00736DBD:
								// Failed to bind call argument.
								// Please report this issue at https://github.com/uxmal/reko
								Eq_3 stackArg4 = <invalid>;
								word32 ecx_2841;
								fn006E0F80(stackArg4, dwArg04, out ecx_2841, out edx);
							}
l00736DC5:
							esp_1705 = esp_19;
							eax_1385 = esp_19[4];
							goto l00736DC9;
						}
						edx = *((word32) esp_1419->t0014 + 0x0C);
						*((word32) edx + esi_1414 * 0x04) = eax_1428;
						esi_1414 = (word32) esi_1414 + 1;
					} while (esi_1414 < eax_1392);
					eax_1385 = esp_1419->t0014;
				}
				break;
			case 100:
				Eq_3 eax_912 = fn007075D0();
				if (eax_912 != 0x00)
				{
					Eq_3 ecx_1386 = g_tA175E0;
					struct Eq_146100 * esp_1387 = esp_19 - 4;
					esp_1387->dw0000 = 9287980;
					esp_1387->tFFFFFFFC = ecx_1386;
					goto l007371D3;
				}
				esp_19[5] = (struct Eq_144868) 0x00;
				esp_19[0x0A] = (struct Eq_144868) 0x00;
				esp_19[9] = (struct Eq_144868) 0x00;
				esp_19[7] = (struct Eq_144868) 0x00;
				esp_19[8] = (struct Eq_144868) 0x00;
				esp_19[4] = (struct Eq_144868) 0x00;
				word32 edx_2805;
				Eq_3 eax_933 = fn007366D0(eax_912, dwArg04, out edx_2805);
				esp_19[18] = (struct Eq_144868) eax_933;
				word32 edx_2806;
				Eq_3 eax_941 = fn007366D0(eax_933, dwArg04, out edx_2806);
				esp_19[0x0C] = (struct Eq_144868) eax_941;
				word32 edx_2807;
				Eq_3 eax_949 = fn007366D0(eax_941, dwArg04, out edx_2807);
				esp_19[0x0011] = (struct Eq_144868) eax_949;
				word32 edx_2808;
				Eq_3 eax_957 = fn007366D0(eax_949, dwArg04, out edx_2808);
				struct Eq_146071 * esp_963 = esp_19 - 4;
				esp_963->t0000 = dwArg04;
				esp_963->t0044 = eax_957;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_3 stackArg4 = <invalid>;
				Eq_3 ebx_1011 = 0x00;
				Eq_3 ebp_1149 = 0x00;
				Eq_3 eax_967 = fn007367D0(edx, 0x00, 0x00, 0x01, dwArg04, es, ds, stackArg4, out edx);
				struct Eq_144868 * esp_1145 = (const char *) &esp_963->t0000 + 4;
				if (eax_967 != 0x00)
				{
					esp_963->t0000 = dwArg04;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_3 stackArg4 = <invalid>;
					Eq_3 eax_980 = fn007367D0(edx, 0x00, 0x00, eax_967, dwArg04, es, ds, stackArg4, out edx);
					esp_963->t001C = eax_980;
					if (eax_980 != 0x00)
					{
						esp_963->t0000 = dwArg04;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_3 stackArg4 = <invalid>;
						Eq_3 eax_993 = fn007367D0(edx, 0x00, 0x00, eax_967, dwArg04, es, ds, stackArg4, out edx);
						ebp_1149 = eax_993;
						if (eax_993 != 0x00)
						{
							esp_963->t0000 = dwArg04;
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							Eq_3 stackArg4 = <invalid>;
							Eq_3 eax_1006 = fn007367D0(edx, 0x00, eax_993, eax_967, dwArg04, es, ds, stackArg4, out edx);
							ebx_1011 = eax_1006;
							if (eax_1006 != 0x00)
							{
								esp_963->t0000 = dwArg04;
								// Failed to bind call argument.
								// Please report this issue at https://github.com/uxmal/reko
								Eq_3 stackArg4 = <invalid>;
								Eq_3 eax_1019 = fn007367D0(edx, eax_1006, eax_993, eax_967, dwArg04, es, ds, stackArg4, out edx);
								esp_963->t0018 = eax_1019;
								if (eax_1019 != 0x00)
								{
									esp_963->t0000 = dwArg04;
									// Failed to bind call argument.
									// Please report this issue at https://github.com/uxmal/reko
									Eq_3 stackArg4 = <invalid>;
									Eq_3 eax_1032 = fn007367D0(edx, eax_1006, eax_993, eax_967, dwArg04, es, ds, stackArg4, out edx);
									esp_963->t002C = eax_1032;
									if (eax_1032 != 0x00)
									{
										esp_963->t0000 = dwArg04;
										// Failed to bind call argument.
										// Please report this issue at https://github.com/uxmal/reko
										Eq_3 stackArg4 = <invalid>;
										Eq_3 eax_1045 = fn007367D0(edx, eax_1006, eax_993, eax_967, dwArg04, es, ds, stackArg4, out edx);
										esp_963->t0028 = eax_1045;
										if (eax_1045 != 0x00)
										{
											esp_963->t0000 = dwArg04;
											// Failed to bind call argument.
											// Please report this issue at https://github.com/uxmal/reko
											Eq_3 stackArg4 = <invalid>;
											Eq_3 eax_1058 = fn007367D0(edx, eax_1006, eax_993, eax_967, dwArg04, es, ds, stackArg4, out edx);
											esp_963->t0020 = eax_1058;
											if (eax_1058 != 0x00)
											{
												word32 edx_2821;
												Eq_3 eax_1069 = fn007366D0(eax_1058, dwArg04, out edx_2821);
												esp_963->t0000 = dwArg04;
												esp_963->t0030 = eax_1069;
												// Failed to bind call argument.
												// Please report this issue at https://github.com/uxmal/reko
												Eq_3 stackArg4 = <invalid>;
												Eq_3 eax_1079 = fn007367D0(edx, eax_1006, eax_993, eax_967, dwArg04, es, ds, stackArg4, out edx);
												esp_963->t0024 = eax_1079;
												if (eax_1079 != 0x00)
												{
													Eq_3 ecx_1089 = esp_963->t0020;
													Eq_3 eax_1091 = esp_963->t0030;
													esp_963->t0000 = eax_1079;
													Eq_3 edx_1094 = esp_963->t0028;
													esp_963->tFFFFFFFC = eax_1091;
													Eq_3 eax_1097 = esp_963->t002C;
													esp_963->tFFFFFFF8 = ecx_1089;
													Eq_3 ecx_1100 = esp_963->t0018;
													esp_963->tFFFFFFF4 = edx_1094;
													Eq_3 edx_1103 = esp_963->t001C;
													esp_963->tFFFFFFF0 = eax_1097;
													Eq_3 eax_1106 = esp_963->t0044;
													esp_963->tFFFFFFEC = ecx_1100;
													word32 ecx_1109 = esp_963->dw0048;
													esp_963->tFFFFFFE8 = eax_1006;
													esp_963->tFFFFFFE4 = eax_993;
													esp_963->tFFFFFFE0 = edx_1103;
													word32 edx_1116 = esp_963->dw0034;
													esp_963->tFFFFFFDC = eax_967;
													esp_963->tFFFFFFD8 = eax_1106;
													word32 eax_1121 = esp_963->dw004C;
													esp_963->dwFFFFFFD4 = ecx_1109;
													esp_963->dwFFFFFFD0 = edx_1116;
													esp_963->dwFFFFFFCC = eax_1121;
													// Failed to bind call argument.
													// Please report this issue at https://github.com/uxmal/reko
													// Failed to bind call argument.
													// Please report this issue at https://github.com/uxmal/reko
													// Failed to bind call argument.
													// Please report this issue at https://github.com/uxmal/reko
													// Failed to bind call argument.
													// Please report this issue at https://github.com/uxmal/reko
													// Failed to bind call argument.
													// Please report this issue at https://github.com/uxmal/reko
													// Failed to bind call argument.
													// Please report this issue at https://github.com/uxmal/reko
													// Failed to bind call argument.
													// Please report this issue at https://github.com/uxmal/reko
													// Failed to bind call argument.
													// Please report this issue at https://github.com/uxmal/reko
													// Failed to bind call argument.
													// Please report this issue at https://github.com/uxmal/reko
													// Failed to bind call argument.
													// Please report this issue at https://github.com/uxmal/reko
													// Failed to bind call argument.
													// Please report this issue at https://github.com/uxmal/reko
													// Failed to bind call argument.
													// Please report this issue at https://github.com/uxmal/reko
													// Failed to bind call argument.
													// Please report this issue at https://github.com/uxmal/reko
													Eq_3 stackArg4 = <invalid>;
													Eq_3 stackArg12 = <invalid>;
													Eq_3 stackArg16 = <invalid>;
													Eq_3 stackArg20 = <invalid>;
													Eq_3 stackArg24 = <invalid>;
													Eq_3 stackArg28 = <invalid>;
													Eq_3 stackArg32 = <invalid>;
													Eq_3 stackArg36 = <invalid>;
													Eq_3 stackArg40 = <invalid>;
													Eq_3 stackArg44 = <invalid>;
													Eq_3 stackArg48 = <invalid>;
													Eq_3 stackArg52 = <invalid>;
													Eq_3 stackArg56 = <invalid>;
													esp_963->dw0014 = fn00734BB0(stackArg4, dwArg04, stackArg12, stackArg16, stackArg20, stackArg24, stackArg28, stackArg32, stackArg36, stackArg40, stackArg44, stackArg48, stackArg52, stackArg56, out edx);
												}
											}
										}
									}
								}
							}
						}
					}
					word32 v41_1139 = (word32) *eax_967 - 1;
					*eax_967 = v41_1139;
					esp_1145 = esp_19;
					if (v41_1139 == 0x00)
					{
						Eq_3 ecx_1143 = *((word32) eax_967 + 4);
						Eq_3 edx_1144 = *((word32) ecx_1143 + 24);
						esp_19->dwFFFFFFFC = (word32) eax_967;
						word32 esp_1153;
						edx_1144();
						esp_1145 = esp_1153 + 0x04;
					}
					Eq_3 eax_1163 = esp_1145[6];
					if (eax_1163 != 0x00)
					{
						word32 v42_1167 = (word32) *eax_1163 - 1;
						*eax_1163 = v42_1167;
						if (v42_1167 == 0x00)
						{
							Eq_3 ecx_1171 = *((word32) eax_1163 + 4);
							Eq_3 edx_1172 = *((word32) ecx_1171 + 24);
							esp_1145->dwFFFFFFFC = (word32) eax_1163;
							word32 esp_1181;
							edx_1172();
							esp_1145 = esp_1181 + 0x04;
						}
					}
					if (ebp_1149 != 0x00)
					{
						word32 v44_1194 = (word32) *ebp_1149 - 1;
						*ebp_1149 = v44_1194;
						if (v44_1194 == 0x00)
						{
							Eq_3 eax_1198 = *((word32) ebp_1149 + 4);
							Eq_3 ecx_1199 = *((word32) eax_1198 + 24);
							esp_1145->dwFFFFFFFC = (word32) ebp_1149;
							word32 esp_1208;
							ecx_1199();
							esp_1145 = esp_1208 + 0x04;
						}
					}
					if (ebx_1011 != 0x00)
					{
						word32 v45_1221 = (word32) *ebx_1011 - 1;
						*ebx_1011 = v45_1221;
						if (v45_1221 == 0x00)
						{
							Eq_3 edx_1225 = *((word32) ebx_1011 + 4);
							Eq_3 eax_1226 = *((word32) edx_1225 + 24);
							esp_1145->dwFFFFFFFC = (word32) ebx_1011;
							word32 esp_1235;
							eax_1226();
							esp_1145 = esp_1235 + 0x04;
						}
					}
					Eq_3 eax_1245 = esp_1145[5];
					if (eax_1245 != 0x00)
					{
						word32 v46_1249 = (word32) *eax_1245 - 1;
						*eax_1245 = v46_1249;
						if (v46_1249 == 0x00)
						{
							Eq_3 ecx_1253 = *((word32) eax_1245 + 4);
							Eq_3 edx_1254 = *((word32) ecx_1253 + 24);
							esp_1145->dwFFFFFFFC = (word32) eax_1245;
							word32 esp_1263;
							edx_1254();
							esp_1145 = esp_1263 + 0x04;
						}
					}
					Eq_3 eax_1273 = esp_1145[0x0A];
					if (eax_1273 != 0x00)
					{
						word32 v47_1277 = (word32) *eax_1273 - 1;
						*eax_1273 = v47_1277;
						if (v47_1277 == 0x00)
						{
							Eq_3 ecx_1281 = *((word32) eax_1273 + 4);
							Eq_3 edx_1282 = *((word32) ecx_1281 + 24);
							esp_1145->dwFFFFFFFC = (word32) eax_1273;
							word32 esp_1291;
							edx_1282();
							esp_1145 = esp_1291 + 0x04;
						}
					}
					Eq_3 eax_1301 = esp_1145[9];
					if (eax_1301 != 0x00)
					{
						word32 v49_1305 = (word32) *eax_1301 - 1;
						*eax_1301 = v49_1305;
						if (v49_1305 == 0x00)
						{
							Eq_3 ecx_1309 = *((word32) eax_1301 + 4);
							Eq_3 edx_1310 = *((word32) ecx_1309 + 24);
							esp_1145->dwFFFFFFFC = (word32) eax_1301;
							word32 esp_1319;
							edx_1310();
							esp_1145 = esp_1319 + 0x04;
						}
					}
					Eq_3 eax_1329 = esp_1145[7];
					if (eax_1329 != 0x00)
					{
						word32 v50_1333 = (word32) *eax_1329 - 1;
						*eax_1329 = v50_1333;
						if (v50_1333 == 0x00)
						{
							Eq_3 ecx_1337 = *((word32) eax_1329 + 4);
							Eq_3 edx_1338 = *((word32) ecx_1337 + 24);
							esp_1145->dwFFFFFFFC = (word32) eax_1329;
							word32 esp_1347;
							edx_1338();
							esp_1145 = esp_1347 + 0x04;
						}
					}
					Eq_3 eax_1357 = esp_1145[8];
					if (eax_1357 != 0x00)
					{
						word32 v51_1361 = (word32) *eax_1357 - 1;
						*eax_1357 = v51_1361;
						if (v51_1361 == 0x00)
						{
							Eq_3 ecx_1365 = *((word32) eax_1357 + 4);
							Eq_3 edx_1366 = *((word32) ecx_1365 + 24);
							esp_1145->dwFFFFFFFC = (word32) eax_1357;
							word32 esp_1375;
							edx_1366();
							esp_1145 = esp_1375 + 0x04;
						}
					}
				}
				eax_1385 = esp_1145[4];
				break;
			case 0x67:
				Eq_3 esi_844;
				Eq_3 eax_837 = *dwArg04;
				if (eax_837 != 0x00)
				{
					esp_19->dwFFFFFFFC = (word32) eax_837;
					word32 esp_850;
					Eq_3 eax_851;
					word32 edx_853;
					MSVCR80.dll!getc();
					esp_19 = esp_850 + 0x04;
					esi_844 = eax_851;
				}
				else
				{
					Eq_3 eax_841 = *((word32) dwArg04 + 16);
					if (eax_841 >= *((word32) dwArg04 + 20))
						goto l00736A0B;
					esi_844 = (word32) *eax_841;
					*((word32) dwArg04 + 16) = (word32) eax_841 + 1;
				}
				if (esi_844 == ~0x00 || fn00736610(esi_844, esp_19 + 22, dwArg04) != esi_844)
					goto l00736A0B;
				struct Eq_145374 * esp_883 = esp_19 - 4;
				esp_883->t0000 = esp_19 + 22;
				Mem885[esp_883 + 0x5C + esi_844:byte] = 0x00;
				Eq_145387 rRet0_893;
				esp_883->tFFFFFFFC = fn0074F3B0(esp_883->t0000, out rRet0_893);
				esp_883->tFFFFFFFC = rRet0_893;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_3 stackArg4 = <invalid>;
				eax_1385 = fn006FF060(stackArg4, out edx);
				break;
			case 0x68:
				if (fn00736610(0x08, esp_19 + 18, dwArg04) != 0x08)
					goto l00736877;
				struct Eq_145836 * esp_781 = esp_19 - 4;
				esp_781->dw0000 = 0x01;
				Eq_145843 edx_780 = esp_19 + 18;
				esp_781->tFFFFFFFC = edx_780;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_3 stackArg4 = <invalid>;
				Eq_145843 rRet0;
				edx = fn00701650(SLICE(edx_780, word24, 8), MSVCR80.dll!getc, ebp_100, 0x01, dwArg04, es, ds, stackArg4, dwArg04, out rRet0);
				esp_781->t0034 = rRet0;
				Eq_145843 rLoc1_2431 = rRet0;
				if (!PARITY_EVEN(rRet0 - g_r8A86F8))
				{
					if (fn006E0FC0() != 0x00)
						goto l007371DB;
					rLoc1_2431 = esp_781->t0034;
				}
				esp_781->tFFFFFFFC = rLoc1_2431;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_3 stackArg4 = <invalid>;
				eax_1385 = fn006FF060(stackArg4, out edx);
				break;
			case 0x6A:
				word32 edx_2763;
				esp_19->dwFFFFFFFC = (word32) fn007366D0(eax_60, dwArg04, out edx_2763);
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_3 stackArg4 = <invalid>;
				word32 ecx_2765;
				eax_1385 = fn007050A0(stackArg4, out ecx_2765, out edx);
				break;
			case 0x6D:
				word32 edx_2766;
				Eq_3 eax_635 = fn007366D0(eax_60, dwArg04, out edx_2766);
				if (eax_635 > 0x80000001)
					goto l007369A5;
				Eq_3 ebp_654 = eax_635;
				if (eax_635 < 0x00)
					ebp_654 = -eax_635;
				struct Eq_145817 * esp_660 = esp_19 - 4;
				esp_660->t0000 = ebp_654;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_3 stackArg4 = <invalid>;
				eax_1385 = fn007105C0(stackArg4, out edx);
				esp_660->t0018 = eax_1385;
				ptr32 esp_674 = (const char *) &esp_660->t0000 + 4;
				if (eax_1385 == 0x00)
					goto l007371DB;
				*((word32) eax_1385 + 8) = eax_635;
				Eq_3 ebx_679 = 0x00;
				if (ebp_654 > 0x00)
				{
					esp_660->ptr001C = (word32) eax_1385 + 0x0C;
					do
					{
						int32 eax_688 = fn00736650(dwArg04, out edx);
						word16 ax_745 = (word16) eax_688;
						if (eax_688 < 0x00)
						{
							Eq_3 eax_700 = esp_660->t0018;
							word32 v36_701 = (word32) *eax_700 - 1;
							*eax_700 = v36_701;
							if (v36_701 == 0x00)
							{
								Eq_3 ecx_705 = *((word32) eax_700 + 4);
								Eq_3 edx_706 = *((word32) ecx_705 + 24);
								esp_660->t0000 = eax_700;
								word32 esp_713;
								word32 edx_716;
								edx_706();
								esp_674 = esp_713 + 0x04;
							}
							Eq_3 eax_722 = g_tA17E2C;
							struct Eq_145938 * esp_724 = esp_674 - 4;
							esp_724->dw0000 = 9288068;
							esp_724->tFFFFFFFC = eax_722;
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							Eq_3 stackArg4 = <invalid>;
							word32 ecx_2799;
							fn006E0F80(stackArg4, dwArg04, out ecx_2799, out edx);
							esp_724->t0018.u0 = 0x00;
							eax_1385 = esp_724->t0018;
							goto l007371DD;
						}
						word16 * ecx_744 = esp_660->ptr001C;
						*ecx_744 = ax_745;
						esp_660->ptr001C = ecx_744 + 1;
						ebx_679 = (word32) ebx_679 + 1;
					} while (ebx_679 < ebp_654);
					eax_1385 = esp_660->t0018;
				}
				break;
			case 116:
			case 117:
				word32 edx_2767;
				Eq_3 eax_540 = fn007366D0(eax_60, dwArg04, out edx_2767);
				if (eax_540 > 0x7FFFFFFF)
				{
l00736C8F:
					Eq_3 edx_1468 = g_tA17E2C;
					struct Eq_145724 * esp_1470 = esp_19 - 4;
					esp_1470->dw0000 = 9288068;
					esp_1470->tFFFFFFFC = edx_1468;
					goto l007371D3;
				}
				struct Eq_145734 * esp_550 = esp_19 - 4;
				esp_550->t0000 = eax_540;
				esp_550->tFFFFFFFC.u0 = 0x00;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_3 stackArg4 = <invalid>;
				word32 ecx_2794;
				Eq_3 eax_559 = fn006EC9B0(stackArg4, dwArg04, out ecx_2794, out edx);
				esp_550->t0014 = eax_559;
				ptr32 esp_564 = (const char *) &esp_550->t0000 + 4;
				if (eax_559 == 0x00)
					goto l007371DB;
				edx = (word32) eax_559 + 20;
				if (fn00736610(eax_540, (word32) eax_559 + 20, dwArg04) != eax_540)
				{
					Eq_3 eax_609 = esp_550->t0014;
					*eax_609 = (word32) *eax_609 - 1;
					Eq_3 eax_612 = esp_550->t0014;
					if (*eax_612 == 0x00)
					{
						Eq_3 edx_615 = *((word32) eax_612 + 4);
						esp_550->t0000 = eax_612;
						word32 esp_619;
						(*((word32) edx_615 + 24))();
						esp_564 = esp_619 + 0x04;
					}
					Eq_3 ecx_628 = g_tA1745C;
					struct Eq_145791 * esp_630 = esp_564 - 4;
					esp_630->dw0000 = 9288088;
					esp_630->tFFFFFFFC = ecx_628;
					goto l007371D3;
				}
				if (ebp_100 == 116)
				{
					esp_550->t0000 = &esp_550->t0014;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_3 stackArg4 = <invalid>;
					word32 edx_2801;
					fn006EC890(stackArg4, out edx_2801);
					Eq_3 ecx_591 = *((word32) dwArg04 + 24);
					esp_550->tFFFFFFFC = esp_550->t0014;
					esp_550->tFFFFFFF8 = ecx_591;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_3 stackArg4 = <invalid>;
					word32 ecx_2803;
					if (fn006F2A10(stackArg4, dwArg04, out ecx_2803, out edx) < 0x00)
						goto l007371DB;
				}
				eax_1385 = esp_19[4];
				break;
			case 118:
				word32 edx_2768;
				Eq_3 eax_460 = fn007366D0(eax_60, dwArg04, out edx_2768);
				if (eax_460 > 0x7FFFFFFF)
				{
l007369A5:
					Eq_3 ecx_646 = g_tA17E2C;
					struct Eq_145693 * esp_648 = esp_19 - 4;
					esp_648->dw0000 = 9288068;
					esp_648->tFFFFFFFC = ecx_646;
					goto l007371D3;
				}
				Eq_3 eax_472;
				eax_472 = eax_460;
				if (eax_460 == 0x00)
					eax_472.u0 = 0x01;
				struct Eq_145706 * esp_474 = esp_19 - 4;
				esp_474->t0000 = eax_472;
				Eq_3 eax_477 = malloc(esp_474->t0000);
				if (eax_477 == 0x00)
				{
					word32 ecx_2804;
					eax_1385 = fn006E1210(out ecx_2804, out edx);
				}
				else
				{
					if (fn00736610(eax_460, eax_477, dwArg04) != eax_460)
					{
						esp_474->t0000 = eax_477;
						free(esp_474->t0000);
						Eq_3 eax_518 = g_tA1745C;
						esp_474->tFFFFFFFC.u0 = 9288088;
						esp_474->tFFFFFFF8 = eax_518;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_3 stackArg4 = <invalid>;
						word32 ecx_2813;
						fn006E0F80(stackArg4, dwArg04, out ecx_2813, out edx);
						goto l007371DB;
					}
					esp_474->t0000.u0 = 0x00;
					esp_474->tFFFFFFFC = eax_460;
					esp_474->tFFFFFFF8 = eax_477;
					Eq_3 eax_505 = fn0071FC80(out edx);
					esp_474->tFFFFFFF4 = eax_477;
					esp_474->t0014 = eax_505;
					free(esp_474->tFFFFFFF4);
					eax_1385 = esp_474->t0014;
				}
				break;
			case 121:
				Eq_3 esi_327;
				Eq_3 eax_320 = *dwArg04;
				if (eax_320 != 0x00)
				{
					esp_19->dwFFFFFFFC = (word32) eax_320;
					word32 esp_333;
					Eq_3 eax_334;
					word32 edx_336;
					MSVCR80.dll!getc();
					esp_19 = esp_333 + 0x04;
					esi_327 = eax_334;
				}
				else
				{
					Eq_3 eax_324 = *((word32) dwArg04 + 16);
					if (eax_324 >= *((word32) dwArg04 + 20))
						goto l00736A0B;
					esi_327 = (word32) *eax_324;
					*((word32) dwArg04 + 16) = (word32) eax_324 + 1;
				}
				if (esi_327 == ~0x00 || fn00736610(esi_327, esp_19 + 22, dwArg04) != esi_327)
					goto l00736A0B;
				Eq_3 esi_382;
				struct Eq_145450 * esp_358 = esp_19 - 4;
				esp_358->t0000 = esp_19 + 22;
				Mem360[esp_358 + 0x5C + esi_327:byte] = 0x00;
				real64 rRet0_368;
				fn0074F3B0(esp_358->t0000, out rRet0_368);
				esp_358->r004C = rRet0_368;
				Eq_3 eax_374 = *dwArg04;
				ptr32 esp_375 = (const char *) &esp_358->t0000 + 4;
				if (eax_374 != 0x00)
				{
					esp_358->t0000 = eax_374;
					word32 esp_391;
					Eq_3 eax_392;
					word32 edx_394;
					MSVCR80.dll!getc();
					esp_375 = esp_391 + 0x04;
					esi_382 = eax_392;
					goto l00736AF5;
				}
				Eq_3 eax_379 = *((word32) dwArg04 + 16);
				if (eax_379 >= *((word32) dwArg04 + 20))
				{
l00736B33:
					Eq_3 edx_417 = g_tA1745C;
					struct Eq_145528 * esp_419 = esp_375 - 4;
					esp_419->dw0000 = 9288088;
					esp_419->tFFFFFFFC = edx_417;
					goto l007371D3;
				}
				esi_382 = (word32) *eax_379;
				*((word32) dwArg04 + 16) = (word32) eax_379 + 1;
l00736AF5:
				if (esi_382 == ~0x00 || fn00736610(esi_382, esp_375 + 88, dwArg04) != esi_382)
					goto l00736B33;
				struct Eq_145543 * esp_424 = esp_375 - 4;
				esp_424->t0000 = esp_375 + 88;
				Mem426[esp_424 + 0x5C + esi_382:byte] = 0x00;
				real64 rRet0_434;
				fn0074F3B0(esp_424->t0000, out rRet0_434);
				esp_424->rFFFFFFF4 = esp_424->r004C;
				esp_424->rFFFFFFFC = rRet0_434;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_3 stackArg4 = <invalid>;
				Eq_3 stackArg12 = <invalid>;
				Eq_3 stackArg16 = <invalid>;
				eax_1385 = fn007331D0(stackArg4, dwArg04, stackArg12, stackArg16, out edx);
				break;
			case 122:
				if (fn00736610(0x08, esp_19 + 18, dwArg04) != 0x08)
				{
l00736877:
					Eq_3 ecx_1769 = g_tA1745C;
					struct Eq_144972 * esp_1771 = esp_19 - 4;
					esp_1771->dw0000 = 9288088;
					esp_1771->tFFFFFFFC = ecx_1769;
					goto l007371D3;
				}
				struct Eq_145250 * esp_206 = esp_19 - 4;
				esp_206->dw0000 = 0x01;
				Eq_145257 edx_205 = esp_19 + 18;
				esp_206->tFFFFFFFC = edx_205;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_3 stackArg4 = <invalid>;
				real64 rRet0;
				edx = fn00701650(SLICE(edx_205, word24, 8), MSVCR80.dll!getc, ebp_100, 0x01, dwArg04, es, ds, stackArg4, dwArg04, out rRet0);
				esp_206->r0034 = rRet0;
				esp_19 = (struct Eq_144868 *) (&esp_206->dw0000 + 1);
				if (!PARITY_EVEN(rRet0 - g_r8A86F8) && fn006E0FC0() != 0x00)
					goto l007371DB;
				if (fn00736610(0x08, (const char *) &esp_206->t003C + 16, dwArg04) != 0x08)
				{
l00736A0B:
					eax_1760 = g_tA1745C;
					esp_1762 = esp_19 - 4;
					esp_1762->dw0000 = 9288088;
					goto l007371D2;
				}
				esp_206->dw0000 = 0x01;
				esp_206->tFFFFFFFC = (const char *) &esp_206->t003C + 16;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_3 stackArg4 = <invalid>;
				Eq_145257 rRet0;
				edx = fn00701650(SLICE(edx, word24, 8), MSVCR80.dll!getc, ebp_100, 0x01, dwArg04, es, ds, stackArg4, dwArg04, out rRet0);
				esp_206->t003C = rRet0;
				Eq_145257 rLoc1_2390 = rRet0;
				if (!PARITY_EVEN(rRet0 - g_r8A86F8))
				{
					if (fn006E0FC0() != 0x00)
						goto l007371DB;
					rLoc1_2390 = esp_206->t003C;
				}
				esp_206->rFFFFFFF4 = esp_206->r0034;
				esp_206->tFFFFFFFC = rLoc1_2390;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_3 stackArg4 = <invalid>;
				Eq_3 stackArg12 = <invalid>;
				Eq_3 stackArg16 = <invalid>;
				eax_1385 = fn007331D0(stackArg4, dwArg04, stackArg12, stackArg16, out edx);
				break;
			case 0x7C:
				word32 ecx_2769;
				Eq_3 eax_64 = fn006FDCC0(out ecx_2769, out edx);
				esp_19[4] = (struct Eq_144868) eax_64;
				if (eax_64 == 0x00)
					goto l007371DB;
				esp_19->dwFFFFFFFC = (word32) dwArg04;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_3 stackArg4 = <invalid>;
				Eq_3 eax_76 = fn007367D0(edx, MSVCR80.dll!getc, ebp_100, 0x01, dwArg04, es, ds, stackArg4, out edx);
				Eq_3 esi_183 = eax_76;
				esp_1705 = esp_19;
				if (eax_76 != 0x00)
				{
					do
					{
						struct Eq_145236 * esp_87 = esp_1705 - 4;
						esp_87->t0000 = dwArg04;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_3 stackArg4 = <invalid>;
						Eq_3 edx_97;
						Eq_3 eax_95 = fn007367D0(edx_97, MSVCR80.dll!getc, ebp_100, esi_183, dwArg04, es, ds, stackArg4, out edx_97);
						ebp_100 = eax_95;
						if (eax_95 != 0x00)
						{
							word32 ecx_105 = esp_87->dw0014;
							esp_87->t0000 = eax_95;
							esp_87->tFFFFFFFC = esi_183;
							esp_87->dwFFFFFFF8 = ecx_105;
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							Eq_3 stackArg4 = <invalid>;
							Eq_3 stackArg12 = <invalid>;
							word32 edi_2786;
							word32 ebx_2785;
							word32 edx_2784;
							word32 ecx_2783;
							fn006FBD90(stackArg4, dwArg04, stackArg12, out ecx_2783, out edx_2784, out ebx_2785, out edi_2786);
						}
						word32 v28_122 = (word32) *esi_183 - 1;
						*esi_183 = v28_122;
						struct Eq_144868 * esp_128 = esp_1705;
						if (v28_122 == 0x00)
						{
							Eq_3 edx_126 = *((word32) esi_183 + 4);
							Eq_3 eax_127 = *((word32) edx_126 + 24);
							esp_1705->dwFFFFFFFC = (word32) esi_183;
							word32 esp_135;
							eax_127();
							esp_128 = esp_135 + 0x04;
						}
						if (eax_95 != 0x00)
						{
							word32 v29_148 = (word32) *eax_95 - 1;
							*eax_95 = v29_148;
							if (v29_148 == 0x00)
							{
								Eq_3 ecx_152 = *((word32) eax_95 + 4);
								Eq_3 edx_153 = *((word32) ecx_152 + 24);
								esp_128->dwFFFFFFFC = (word32) eax_95;
								word32 esp_161;
								word32 edx_164;
								edx_153();
								esp_128 = esp_161 + 0x04;
							}
						}
						union Eq_3 * esp_170 = esp_128 - 4;
						*esp_170 = (union Eq_3 *) dwArg04;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_3 stackArg4 = <invalid>;
						Eq_3 eax_178 = fn007367D0(edx, MSVCR80.dll!getc, eax_95, esi_183, dwArg04, es, ds, stackArg4, out edx);
						esi_183 = eax_178;
						esp_1705 = (struct Eq_144868 *) ((const char *) esp_170 + 4);
					} while (eax_178 != 0x00);
				}
				Eq_3 eax_188 = fn006E0FC0();
				eax_1385 = esp_1705[4];
				if (eax_188 != 0x00)
				{
l00736DC9:
					*eax_1385 = (word32) *eax_1385 - 1;
					struct Eq_145645 * eax_1714 = esp_1705[4];
					if (eax_1714->dw0000 == 0x00)
					{
						struct Eq_145654 * ecx_1717 = eax_1714->ptr0004;
						<anonymous> * edx_1718 = ecx_1717->ptr0018;
						esp_1705->dwFFFFFFFC = eax_1714;
						edx_1718();
					}
					goto l007371DB;
				}
				break;
			}
		}
		else
		{
l007371C8:
			eax_1760 = g_tA17E2C;
			esp_1762 = esp_19 - 4;
			esp_1762->dw0000 = 9288068;
l007371D2:
			esp_1762->tFFFFFFFC = eax_1760;
l007371D3:
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg4 = <invalid>;
			word32 ecx_2791;
			fn006E0F80(stackArg4, dwArg04, out ecx_2791, out edx);
l007371DB:
			eax_1385.u0 = 0x00;
		}
l007371DD:
		*((word32) dwArg04 + 8) = (word32) *((word32) dwArg04 + 8) - 1;
	}
	word32 ecx_2759;
	word32 eax_2226 = fn00694B8E(eax_1385, eax_7 ^ fp - 332, edx, ebx, ebp, esi, edi, es, ds, ebx, out ecx_2759);
	edxOut = edx;
	return eax_2226;
}

// 00737370: Register Eq_3 fn00737370()
// Called from:
//      fn006F6630
//      fn006F6730
Eq_3 fn00737370()
{
	word32 edx_32;
	return fn007366D0(0x00, fp - 0x20, out edx_32);
}

// 007373A0: Register Eq_3 fn007373A0(Stack Eq_3 dwArg04, Register out ptr32 edxOut)
// Called from:
//      fn00737880
Eq_3 fn007373A0(Eq_3 dwArg04, ptr32 & edxOut)
{
	word32 edx_85;
	Eq_3 eax_15 = fn006F2650(0x00, out edx_85);
	ptr32 edx_30;
	Eq_3 eax_28 = fn007367D0(edx, ebx, ebp, esi, edi, es, ds, fp - 0x20, out edx_30);
	*eax_15 = (word32) *eax_15 - 1;
	if (*eax_15 == 0x00)
	{
		Eq_3 edx_41 = *((word32) eax_15 + 4);
		(*((word32) edx_41 + 24))();
	}
	edxOut = edx_30;
	return eax_28;
}

// 00737410: Register Eq_3 fn00737410(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Register out ptr32 edxOut)
// Called from:
//      fn006F6D50
//      fn00737880
Eq_3 fn00737410(Eq_3 dwArg04, Eq_3 dwArg08, ptr32 & edxOut)
{
	word32 edx_88;
	Eq_3 eax_19 = fn006F2650(0x00, out edx_88);
	ptr32 edx_32;
	Eq_3 eax_30 = fn007367D0(fp - 0x20, ebx, ebp, esi, edi, es, ds, fp - 0x20, out edx_32);
	*eax_19 = (word32) *eax_19 - 1;
	if (*eax_19 == 0x00)
	{
		Eq_3 ecx_43 = *((word32) eax_19 + 4);
		(*((word32) ecx_43 + 24))();
	}
	edxOut = edx_32;
	return eax_30;
}

// 00737880: Register word32 fn00737880(Register word32 ebx, Register Eq_3 ebp, Register word32 esi, Register word32 edi, Register (ptr16 Eq_7) es, Register (ptr16 Eq_8) ds, Register out Eq_3 edxOut)
// Called from:
//      fn006F66E0
word32 fn00737880(word32 ebx, Eq_3 ebp, word32 esi, word32 edi, struct Eq_7 * es, struct Eq_8 * ds, union Eq_3 & edxOut)
{
	fn006952A0(0x4034, dwLoc04);
	Eq_3 esp_7 = <invalid>;
	ui32 eax_14 = g_tA14188 ^ (word32) esp_7 + 4;
	*((word32) esp_7 + 0x00004034) = eax_14;
	*esp_7 = ebx;
	Eq_3 ebx_21 = *((word32) esp_7 + 16444);
	*((word32) esp_7 - 4) = esi;
	*((word32) esp_7 - 8) = edi;
	*((word32) esp_7 - 0x0C) = ebx_21;
	struct Eq_146974 * esp_30;
	word32 eax_31;
	fileno();
	esp_30->dwFFFFFFFC = &esp_30->dwFFFFFFFC + 5;
	esp_30->dwFFFFFFF8 = eax_31;
	struct Eq_146986 * esp_41;
	word32 eax_42;
	fstat64i32();
	if (eax_42 == 0x00)
	{
		Eq_3 edi_51 = esp_41->t002C;
		if (edi_51 > 0x00)
		{
			Eq_3 esi_114;
			if (edi_51 <= 0x4000)
			{
				esi_114 = (const char *) &esp_41->t002C + 28;
				goto l007378EA;
			}
			if (edi_51 <= 0x00040000)
			{
				esp_41->t0008 = edi_51;
				Eq_3 eax_60 = malloc(esp_41->t0008);
				esi_114 = eax_60;
				if (eax_60 != 0x00)
				{
l007378EA:
					esp_41->t0008 = ebx_21;
					esp_41->t0004 = edi_51;
					esp_41->t0000.u0 = 0x01;
					esp_41->tFFFFFFFC = esi_114;
					esp_41->tFFFFFFF8 = fread(esp_41->tFFFFFFFC, esp_41->t0000, esp_41->t0004, esp_41->t0008);
					esp_41->tFFFFFFF4 = esi_114;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_3 stackArg4 = <invalid>;
					Eq_3 stackArg8 = <invalid>;
					word32 edx_243;
					Eq_3 eax_141 = fn00737410(stackArg4, stackArg8, out edx_243);
					if (esi_114 != fp - 0x4004)
						free(esi_114);
					word32 ecx_244;
					word32 eax_177 = fn00694B8E(eax_141, dwLoc04 ^ fp - 0x4034, fp - 0x4004, dwLoc4038, ebp, dwLoc403C, dwLoc4040, es, ds, dwLoc4038, out ecx_244);
					edxOut = fp - 0x4004;
					return eax_177;
				}
			}
		}
	}
	esp_41->t0008 = ebx_21;
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_3 stackArg4 = <invalid>;
	Eq_3 edx_76;
	word32 ecx_240;
	word32 eax_104 = fn00694B8E(fn007373A0(stackArg4, out edx_76), dwLoc04 ^ fp - 0x4034, edx_76, dwLoc4038, ebp, dwLoc403C, dwLoc4040, es, ds, dwLoc4038, out ecx_240);
	edxOut = edx_76;
	return eax_104;
}

// 00737950: void fn00737950(Stack Eq_3 dwArg04)
// Called from:
//      fn006E8910
void fn00737950(Eq_3 dwArg04)
{
	int32 ebp_10 = *dwArg04;
	Eq_3 ecx_6 = *((word32) dwArg04 + 4);
	((word32) dwArg04 + 20)->u0 = 0x00;
	int32 ebp_11 = ebp_10 - 0x01;
	if (ebp_10 >= 0x01)
	{
		struct Eq_147109 * ebx_24 = (word32) ecx_6 + 0x0C;
		do
		{
			word32 eax_28 = ebx_24->dw0004;
			int32 edi_29 = 0x00;
			if (ebx_24->dw0000 > 0x00)
			{
				struct Eq_147118 * esi_32 = eax_28 + 0x10;
				do
				{
					Eq_3 eax_37 = esi_32->dw0000;
					if (eax_37 != 0x00)
					{
						word32 ecx_140;
						word32 edx_141;
						fn007239C0(eax_37, out ecx_140, out edx_141);
					}
					esi_32->dw0000 = 0x00;
					++edi_29;
					++esi_32;
				} while (edi_29 < ebx_24->dw0000);
			}
			++ebx_24;
			--ebp_11;
		} while (ebp_11 >= 0x00);
	}
}

// 007379B0: void fn007379B0(Stack (ptr32 Eq_147156) dwArg04, Stack (ptr32 Eq_147157) dwArg08)
// Called from:
//      fn00737BE0
void fn007379B0(struct Eq_147156 * dwArg04, struct Eq_147157 * dwArg08)
{
	Eq_147158 esi_18 = dwArg04->t0008;
	dwArg08->dw0014 = 0x00;
	Eq_147158 dwLoc0C_366 = esi_18;
	word32 ecx_504;
	word32 edx_505;
	Eq_3 eax_24 = fn00723860(esi_18 * 0x04, out ecx_504, out edx_505);
	if (eax_24 != 0x00)
	{
		if (esi_18 > 0x00)
		{
			Eq_147158 ecx_324;
			Eq_3 edi_321 = eax_24;
			for (ecx_324 = esi_18; ecx_324 != 0x00; --ecx_324)
			{
				*edi_321 = ~0x00;
				edi_321 = (word32) edi_321 + 4;
			}
		}
		int32 eax_52 = dwArg08->dw0000;
		struct Eq_147211 * ebx_55 = dwArg08->ptr0004;
		int32 dwLoc08_370 = eax_52 - 0x01;
		if (eax_52 >= 0x01)
		{
			struct Eq_147211 * ebx_164 = ebx_55;
			do
			{
				Eq_147158 eax_64 = (int32) ebx_164->w0000;
				struct Eq_147235 * esi_68 = dwArg04->ptr000C[eax_64];
				ci16 cx_70 = ebx_164->w0002;
				if (cx_70 >= 0x80)
					printf(9288488);
				else if (esi_68 >= (struct Eq_147235 *) 0x0100)
				{
					Eq_3 eax_92 = fn00752E10(dwArg04, esi_68);
					if (esi_68 >= (struct Eq_147235 *) 0x0180)
						printf(0x008DBB04);
					else
					{
						Eq_147158 esi_101 = 0x00;
						if (dwArg04->t0008 > 0x00)
						{
							do
							{
								if ((CONVERT(Mem111[(esi_101 >>u 0x03) + Mem111[eax_92 + 0x14:word32]:byte], byte, int32) & 0x01 << SLICE(esi_101 & 0x07, byte, 0)) != 0x00)
								{
									if (*((word32) eax_24 + esi_101 * 0x04) != ~0x00)
										printf(9288436);
									*((word32) eax_24 + esi_101 * 0x04) = esi_68 - 0x0100 << 0x08 | (int32) ebx_164->w0002 | 0x80;
								}
								esi_101 = (word32) esi_101 + 1;
							} while (esi_101 < dwArg04->t0008);
						}
					}
				}
				else if (eax_64 == 0x00)
					dwArg08->dw0014 = 0x01;
				else if (eax_64 >= 0x00 && eax_64 < esi_18)
					*((word32) eax_24 + eax_64 * 0x04) = (int32) cx_70;
				int32 v17_167 = dwLoc08_370 - 0x01;
				++ebx_164;
				dwLoc08_370 = v17_167;
			} while (v17_167 >= 0x00);
		}
		Eq_147158 esi_172 = esi_18;
		if (esi_18 > 0x00)
		{
			word32 * eax_182 = eax_24 - 0x04 + esi_18 * 0x04;
			while (*eax_182 == ~0x00)
			{
				--esi_172;
				eax_182 -= 0x04;
				if (esi_172 <= 0x00)
					break;
			}
			dwLoc0C_366 = esi_172;
		}
		Eq_147158 esi_202 = 0x00;
		if (dwLoc0C_366 <= 0x00)
		{
l00737BCA:
			word32 edx_507;
			word32 ecx_506;
			fn007239C0(eax_24, out ecx_506, out edx_507);
		}
		else
		{
			do
			{
				if (*((word32) eax_24 + esi_202 * 0x04) != ~0x00)
				{
					if (esi_202 >= dwLoc0C_366)
						goto l00737BCA;
					word32 ecx_510;
					word32 edx_511;
					Eq_3 eax_221 = fn00723860((dwLoc0C_366 - esi_202) * 0x04, out ecx_510, out edx_511);
					dwArg08->t0010 = eax_221;
					if (eax_221 != 0x00)
					{
						dwArg08->t0008 = esi_202;
						dwArg08->t000C = dwLoc0C_366;
						ptr32 eax_236 = 0x00;
						do
						{
							*((word32) dwArg08->t0010 + eax_236) = *((word32) eax_24 + esi_202 * 0x04);
							esi_202 = (word32) esi_202 + 1;
							eax_236 += 0x04;
						} while (esi_202 < dwLoc0C_366);
						goto l00737BCA;
					}
					else
					{
						struct Eq_147408 * esp_282;
						word32 eax_283;
						_iob_func();
						esp_282->tFFFFFFFC = eax_283 + 0x40;
						fprintf(esp_282->tFFFFFFFC, esp_282->t0000, 0x00);
						esp_282->t0000.u0 = 0x01;
						exit(esp_282->t0000);
					}
				}
				esi_202 = (word32) esi_202.u0 + 1;
			} while (esi_202 < dwLoc0C_366);
			word32 ecx_508;
			word32 edx_509;
			fn007239C0(eax_24, out ecx_508, out edx_509);
		}
	}
	else
	{
		struct Eq_147180 * esp_327;
		word32 eax_328;
		_iob_func();
		esp_327->tFFFFFFFC = eax_328 + 0x40;
		fprintf(esp_327->tFFFFFFFC, esp_327->t0000, 0x00);
		esp_327->t0000.u0 = 0x01;
		exit(esp_327->t0000);
	}
}

// 00737BE0: Register word32 fn00737BE0(Stack (ptr32 Eq_147156) dwArg04)
// Called from:
//      fn007551F0
word32 fn00737BE0(struct Eq_147156 * dwArg04)
{
	int32 eax_11 = dwArg04->dw0000;
	word32 ebx_12 = dwArg04->dw0004;
	word32 ecx_13 = 0x01;
	int32 dwArg04_84 = eax_11 - 0x01;
	if (eax_11 >= 0x01)
	{
		struct Eq_147467 * ebx_21 = ebx_12 + 0x0C;
		do
		{
			struct Eq_147157 * edi_29 = ebx_21->dw0004;
			int32 esi_30 = 0x00;
			if (ebx_21->dw0000 > 0x00)
			{
				do
				{
					fn007379B0(dwArg04, edi_29);
					++esi_30;
					edi_29 = &edi_29->dw0014 + 1;
				} while (esi_30 < ebx_21->dw0000);
				ecx_13 = 0x01;
			}
			int32 v14_63 = dwArg04_84 - ecx_13;
			++ebx_21;
			dwArg04_84 = v14_63;
		} while (v14_63 >= 0x00);
	}
	dwArg04->dw0014 = ecx_13;
	return ecx_13;
}

// 00737EB0: Register word32 fn00737EB0(Register Eq_3 ebx, Register Eq_3 esi, Register Eq_3 edi, Register out Eq_3 ecxOut)
// Called from:
//      fn007380A0
//      fn00738130
//      fn00738600
word32 fn00737EB0(Eq_3 ebx, Eq_3 esi, Eq_3 edi, union Eq_3 & ecxOut)
{
	struct Eq_147504 * eax_16;
	Eq_3 ecx_18;
	(*((word32) esi + 24))();
	if (eax_16 != null)
	{
		Eq_3 edx_25 = eax_16->t0004;
		if (edx_25 != 0x00)
		{
			Eq_3 ecx_29 = g_tA6DF20;
			if (edx_25 == ecx_29)
			{
				eax_16->t0004 = edi;
				eax_16->t0000 = ebx;
				*((word32) esi + 0x0C) = (word32) *((word32) esi + 0x0C) + 1;
				word32 v16_52 = (word32) *ecx_29 - 1;
				*ecx_29 = v16_52;
				if (v16_52 == 0x00)
				{
					Eq_3 edx_59 = *((word32) ecx_29 + 4);
					Eq_3 ecx_66;
					(*((word32) edx_59 + 24))();
					ecxOut = ecx_66;
					return 0x00;
				}
			}
			else
			{
				word32 v17_32 = (word32) *edi - 1;
				*edi = v17_32;
				if (v17_32 == 0x00)
				{
					Eq_3 ecx_36 = *((word32) edi + 4);
					(*((word32) ecx_36 + 24))();
				}
			}
			ecxOut = ecx_29;
			return 0x00;
		}
		else
		{
			*((word32) esi + 8) = (word32) *((word32) esi + 8) + 1;
			eax_16->t0004 = edi;
			eax_16->t0000 = ebx;
			*((word32) esi + 0x0C) = (word32) *((word32) esi + 0x0C) + 1;
			ecxOut.u0 = 0x01;
			return 0x00;
		}
	}
	else
	{
		ecxOut = ecx_18;
		return ~0x00;
	}
}

// 00737F20: Register (ptr32 Eq_147599) fn00737F20(Register Eq_3 esi, Stack Eq_3 dwArg04, Stack uint32 dwArg08)
// Called from:
//      fn00737F70
struct Eq_147599 * fn00737F20(Eq_3 esi, Eq_3 dwArg04, uint32 dwArg08)
{
	Eq_3 edi_16 = *((word32) esi + 16);
	Eq_3 ebx_8 = *((word32) esi + 20);
	ui32 eax_18 = edi_16 & dwArg08;
	struct Eq_147599 * ecx_20 = (word32) ebx_8 + eax_18 * 0x08;
	uint32 edx_21 = dwArg08;
	if (*((word32) ebx_8 + (eax_18 * 0x08 + 4)) != 0x00)
	{
		do
		{
			eax_18 = eax_18 + 0x01 + (edx_21 + eax_18 * 0x04);
			ecx_20 = (word32) ebx_8 + (eax_18 & edi_16) * 0x08;
			edx_21 >>= 0x05;
		} while (ecx_20->t0004 != 0x00);
	}
	*((word32) esi + 8) = (word32) *((word32) esi + 8) + 1;
	ecx_20->dw0000 = dwArg08;
	ecx_20->t0004 = dwArg04;
	*((word32) esi + 0x0C) = (word32) *((word32) esi + 0x0C) + 1;
	return ecx_20;
}

// 00737F70: Register int32 fn00737F70(Register int32 eax, Stack Eq_3 dwArg04, Register out Eq_3 ecxOut)
// Called from:
//      fn007380A0
//      fn00738130
//      fn00738600
//      fn007389B0
int32 fn00737F70(int32 eax, Eq_3 dwArg04, union Eq_3 & ecxOut)
{
	int32 ebx_16 = 0x08;
	if (eax >= 0x08)
	{
		do
		{
			if (ebx_16 <= 0x00)
				goto l00737F90;
			ebx_16 *= 0x02;
		} while (ebx_16 <= eax);
		if (ebx_16 <= 0x00)
		{
l00737F90:
			Eq_3 ecx_224;
			word32 edx_336;
			fn006E1210(out ecx_224, out edx_336);
			ecxOut = ecx_224;
			return ~0x00;
		}
	}
	Eq_3 esi_101 = *((word32) dwArg04 + 20);
	Eq_3 eax_113 = (word32) dwArg04 + 28;
	Eq_3 ecx_104 = (uint32) (int8) (esi_101 != (word32) dwArg04 + 28);
	if (ebx_16 == 0x08)
	{
		if ((word32) dwArg04 + 28 == esi_101)
		{
			if (*((word32) dwArg04 + 8) == *((word32) dwArg04 + 0x0C))
				goto l00738092;
			word32 ecx_214;
			word32 * edi_210 = fp - 0x40;
			for (ecx_214 = 0x10; ecx_214 != 0x00; --ecx_214)
			{
				*edi_210 = (word32) *esi_101;
				esi_101 = (word32) esi_101 + 4;
				++edi_210;
			}
			esi_101 = fp - 0x40;
		}
	}
	else
	{
		Eq_3 eax_52 = ebx_16 * 0x08;
		if (eax_52 == 0x00)
			eax_52.u0 = 0x01;
		eax_113 = malloc(eax_52);
		if (eax_113 == 0x00)
		{
			Eq_3 ecx_75;
			word32 edx_337;
			fn006E1210(out ecx_75, out edx_337);
			ecxOut = ecx_75;
			return ~0x00;
		}
	}
	*((word32) dwArg04 + 20) = eax_113;
	*((word32) dwArg04 + 16) = ebx_16 - 0x01;
	ecx_104 = ebx_16 * 0x08;
	memset(eax_113, 0x00, ecx_104);
	Eq_3 ebx_121 = *((word32) dwArg04 + 8);
	((word32) dwArg04 + 0x0C)->u0 = 0x00;
	((word32) dwArg04 + 8)->u0 = 0x00;
	struct Eq_147731 * esp_122 = fp - 88;
	if (ebx_121 > 0x00)
	{
		struct Eq_147771 * edi_128 = (word32) esi_101 + 4;
		esp_122 = fp - 88;
		do
		{
			Eq_3 eax_132 = edi_128->dw0000;
			if (eax_132 != 0x00)
			{
				--ebx_121;
				if (eax_132 == g_tA6DF20)
				{
					*eax_132 = (word32) *eax_132 - 1;
					struct Eq_147819 * eax_160 = edi_128->dw0000;
					if (eax_160->dw0000 == 0x00)
					{
						struct Eq_147828 * edx_163 = eax_160->ptr0004;
						esp_122->dwFFFFFFFC = eax_160;
						<anonymous> * eax_166 = edx_163->ptr0018;
						word32 esp_169;
						eax_166();
						esp_122 = esp_169 + 0x04;
					}
				}
				else
				{
					struct Eq_147785 * esp_142 = esp_122 - 4;
					esp_142->dw0000 = edi_128->dwFFFFFFFC;
					esp_142->tFFFFFFFC = eax_132;
					ecx_104 = fn00737F20(dwArg04, esp_142->tFFFFFFFC, esp_142->dw0000);
					esi_101 = esp_142->t0014;
					esp_122 = (struct Eq_147731 *) (&esp_142->dw0000 + 1);
				}
			}
			++edi_128;
		} while (ebx_121 > 0x00);
	}
	if (esp_122[5] != 0x00)
	{
		union Eq_3 * esp_188 = esp_122 - 4;
		*esp_188 = (union Eq_3 *) esi_101;
		free(*esp_188);
	}
l00738092:
	ecxOut = ecx_104;
	return 0x00;
}

// 007380A0: Register Eq_3 fn007380A0(Register Eq_3 eax, Stack (ptr32 Eq_147871) dwArg04, Register out Eq_3 ecxOut)
// Called from:
//      fn007389B0
Eq_3 fn007380A0(Eq_3 eax, struct Eq_147871 * dwArg04, union Eq_3 & ecxOut)
{
	Eq_3 eax_18 = dwArg04->t0004;
	Eq_3 eax_16 = *((word32) eax + 0x0C);
	*eax_18 = (word32) *eax_18 + 1;
	Eq_3 ecx_141;
	if (fn00737EB0(dwArg04->t0000, eax, dwArg04->t0004, out ecx_141) != ~0x00)
	{
		Eq_3 eax_36 = *((word32) eax + 0x0C);
		if (eax_36 > eax_16)
		{
			Eq_3 ecx_41 = *((word32) eax + 8);
			Eq_3 ecx_39 = *((word32) eax + 16);
			ecx_141 = ecx_41 * 0x03;
			if (ecx_41 * 0x03 >= (word32) ecx_39 + ((word32) ecx_39 + 2))
			{
				if (eax_36 <= 50000)
					eax_36 *= 0x02;
				Eq_3 ecx_75;
				Eq_3 eax_74 = fn00737F70(eax_36 * 0x02, eax, out ecx_75);
				ecxOut = ecx_75;
				return eax_74;
			}
		}
		ecxOut = ecx_141;
		return 0x00;
	}
	else
	{
		Eq_3 eax_89 = dwArg04->t0004;
		*eax_89 = (word32) *eax_89 - 1;
		Eq_3 ecx_102 = dwArg04->t0004;
		if (*ecx_102 == 0x00)
		{
			Eq_3 edx_96 = *((word32) ecx_102 + 4);
			Eq_3 eax_97 = *((word32) edx_96 + 24);
			eax_97();
		}
		ecxOut = ecx_102;
		return ~0x00;
	}
}

// 00738130: Register Eq_3 fn00738130(Register Eq_3 eax, Register Eq_3 ecx, Register out Eq_147967 ecxOut)
// Called from:
//      fn007389B0
Eq_3 fn00738130(Eq_3 eax, Eq_3 ecx, union Eq_147967 & ecxOut)
{
	Eq_3 eax_16;
	if (*((word32) eax + 4) == 0x00A1B450)
	{
		eax_16 = *((word32) eax + 0x0C);
		if (eax_16 != ~0x00)
		{
l0073815A:
			Eq_3 ebp_48 = *((word32) ecx + 0x0C);
			*eax = (word32) *eax + 1;
			Eq_147967 ecx_129;
			word32 eax_55 = fn00737EB0(eax_16, ecx, eax, out ecx_129);
			if (eax_55 != ~0x00)
			{
				Eq_3 eax_64 = *((word32) ecx + 0x0C);
				if (eax_64 > ebp_48)
				{
					Eq_3 ecx_68 = *((word32) ecx + 8);
					Eq_3 edx_67 = *((word32) ecx + 16);
					ecx_129 = ecx_68 * 0x03;
					if (ecx_68 * 0x03 >= (word32) edx_67 + ((word32) edx_67 + 2))
					{
						if (eax_64 <= 50000)
							eax_64 *= 0x02;
						Eq_147967 ecx_105;
						Eq_3 eax_104 = fn00737F70(eax_64 * 0x02, ecx, out ecx_105);
						ecxOut = ecx_105;
						return eax_104;
					}
				}
				ecxOut = ecx_129;
				return 0x00;
			}
			else
			{
				word32 v14_119 = (word32) *eax + eax_55;
				*eax = v14_119;
				if (v14_119 == 0x00)
				{
					Eq_3 eax_123 = *((word32) eax + 4);
					Eq_3 ecx_124 = *((word32) eax_123 + 24);
					ecx_124();
				}
				ecxOut = ecx_129;
				return ~0x00;
			}
		}
	}
	Eq_147967 ecx_29;
	word32 edx_217;
	eax_16 = fn006DE2E0(eax, out ecx_29, out edx_217);
	if (eax_16 == ~0x00)
	{
		ecxOut = ecx_29;
		return eax_16;
	}
	goto l0073815A;
}

<anonymous> g_t738370 = <code>; // 00738370
// 00738600: Register Eq_3 fn00738600(Register Eq_3 eax, Stack Eq_3 dwArg04, Register out Eq_3 ecxOut)
// Called from:
//      fn007389B0
Eq_3 fn00738600(Eq_3 eax, Eq_3 dwArg04, union Eq_3 & ecxOut)
{
	Eq_3 edi_13 = dwArg04;
	if (dwArg04 != eax)
	{
		Eq_3 ecx_18 = *((word32) dwArg04 + 0x0C);
		if (ecx_18 != 0x00)
		{
			Eq_3 edx_34 = *((word32) eax + 16);
			if ((Mem12[eax + 0x08:word32] + ecx_18) * 0x03 >= (edx_34 + 0x02) + edx_34)
			{
				word32 ecx_250;
				if (fn00737F70((Mem12[eax + 0x0C:word32] + ecx_18) * 0x02, eax, out ecx_250) != 0x00)
				{
					ecxOut = ecx;
					return ~0x00;
				}
			}
			Eq_3 ecx_134 = 0x00;
			Eq_3 dwLoc04_224 = 0x00;
			if (*((word32) dwArg04 + 16) >= 0x00)
			{
				do
				{
					struct Eq_148107 * ebp_75 = (word32) *((word32) edi_13 + 20) + ecx_134 * 0x08;
					Eq_3 eax_76 = ebp_75->t0004;
					if (eax_76 != 0x00 && eax_76 != g_tA6DF20)
					{
						*eax_76 = (word32) *eax_76 + 1;
						word32 ecx_251;
						if (fn00737EB0(ebp_75->t0000, eax, ebp_75->t0004, out ecx_251) == ~0x00)
						{
							Eq_3 eax_97 = ebp_75->t0004;
							*eax_97 = (word32) *eax_97 - 1;
							Eq_3 ecx_100 = ebp_75->t0004;
							if (*ecx_100 == 0x00)
							{
								Eq_3 edx_104 = *((word32) ecx_100 + 4);
								Eq_3 eax_105 = *((word32) edx_104 + 24);
								eax_105();
							}
							ecxOut = dwLoc04_224;
							return ~0x00;
						}
						ecx_134 = dwLoc04_224;
						edi_13 = dwArg04;
					}
					ecx_134 = (word32) ecx_134 + 1;
					dwLoc04_224 = ecx_134;
				} while (ecx_134 <= *((word32) edi_13 + 16));
			}
			ecxOut = dwLoc04_224;
			return 0x00;
		}
	}
	ecxOut = ecx;
	return 0x00;
}

// 007389B0: Register Eq_3 fn007389B0(Register Eq_3 eax, Register Eq_3 edi, Register out Eq_3 ecxOut)
// Called from:
//      fn00738BB0
Eq_3 fn007389B0(Eq_3 eax, Eq_3 edi, union Eq_3 & ecxOut)
{
	Eq_3 eax_10 = *((word32) eax + 4);
	if (eax_10 != 10663056 && eax_10 != 10663672)
	{
		word32 edx_441;
		word32 ecx_440;
		if (fn006D5670(eax_10, 10663056, out ecx_440, out edx_441) == 0x00)
		{
			word32 ecx_442;
			word32 edx_443;
			if (fn006D5670(*((word32) eax + 4), 10663672, out ecx_442, out edx_443) == 0x00)
			{
				Eq_3 ecx_101;
				if (*((word32) eax + 4) == 0x00A1D1B8)
				{
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_3 stackArg4 = <invalid>;
					Eq_3 eax_217 = fn006FCF20(stackArg4);
					ecx_101 = eax_217;
					if (eax_217 != ~0x00)
					{
						Eq_3 eax_229 = *((word32) edi + 16);
						if ((Mem215[edi + 0x08:word32] + eax_217) * 0x03 < (eax_229 + 0x02) + eax_229 || fn00737F70((Mem215[edi + 0x0C:word32] + eax_217) * 0x02, edi, out ecx_101) == 0x00)
						{
							Eq_3 ecx_266;
							while (fn006FC0E0(eax, fp - 0x10, fp - 0x18, fp - 0x0C, fp - 0x14, out ecx_266) != 0x00)
							{
								if (fn007380A0(edi, fp - 0x08, out ecx_101) == ~0x00)
									goto l00738B68;
							}
							ecxOut = ecx_266;
							return 0x00;
						}
					}
				}
				else
				{
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_3 stackArg4 = <invalid>;
					word32 edx_445;
					Eq_3 eax_70 = fn00704B00(stackArg4, out ecx_101, out edx_445);
					if (eax_70 != 0x00)
					{
						word32 edx_447;
						Eq_3 ecx_174;
						Eq_3 eax_173 = fn00704040(eax_70, out ecx_174, out edx_447);
						struct Eq_148309 * esp_178 = fp - 0x1C;
						while (eax_173 != 0x00)
						{
							struct Eq_148309 * esp_122 = esp_178;
							if (fn00738130(eax_173, edi, out ecx_101) == ~0x00)
							{
								word32 v15_108 = (word32) *eax_70 - 1;
								*eax_70 = v15_108;
								if (v15_108 == 0x00)
								{
									Eq_3 eax_112 = *((word32) eax_70 + 4);
									Eq_3 ecx_113 = *((word32) eax_112 + 24);
									esp_178->dwFFFFFFFC = (word32) eax_70;
									word32 esp_116;
									ecx_113();
									esp_122 = esp_116 + 0x04;
								}
								word32 * eax_126 = esp_122[1];
								*eax_126 += ~0x00;
								struct Eq_148427 * eax_129 = esp_122[1];
								if (eax_129->dw0000 == 0x00)
								{
									struct Eq_148450 * edx_132 = eax_129->ptr0004;
									esp_122->dwFFFFFFFC = eax_129;
									<anonymous> * eax_135 = edx_132->ptr0018;
									eax_135();
								}
								goto l00738B68;
							}
							word32 * eax_147 = esp_178[1];
							*eax_147 += ~0x00;
							struct Eq_148355 * eax_150 = esp_178[1];
							if (eax_150->dw0000 == 0x00)
							{
								struct Eq_148383 * ecx_153 = eax_150->ptr0004;
								<anonymous> * edx_154 = ecx_153->ptr0018;
								esp_178->dwFFFFFFFC = eax_150;
								word32 esp_157;
								edx_154();
								esp_122 = esp_157 + 0x04;
							}
							struct Eq_148364 * esp_166 = esp_122 - 4;
							esp_166->t0000 = eax_70;
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							Eq_3 stackArg4 = <invalid>;
							word32 edx_449;
							eax_173 = fn00704040(stackArg4, out ecx_174, out edx_449);
							esp_166->t0008 = eax_173;
							esp_178 = (struct Eq_148309 *) ((const char *) &esp_166->t0000 + 4);
						}
						word32 v14_185 = (word32) *eax_70 - 1;
						*eax_70 = v14_185;
						if (v14_185 == 0x00)
						{
							Eq_3 ecx_189 = *((word32) eax_70 + 4);
							Eq_3 edx_190 = *((word32) ecx_189 + 24);
							esp_178->dwFFFFFFFC = (word32) eax_70;
							edx_190();
						}
						Eq_3 eax_208 = 0x00 - (fn006E0FC0() == 0x00);
						ecxOut = ecx_174;
						return eax_208;
					}
				}
l00738B68:
				ecxOut = ecx_101;
				return ~0x00;
			}
		}
	}
	Eq_3 ecx_56;
	Eq_3 eax_55 = fn00738600(edi, eax, out ecx_56);
	ecxOut = ecx_56;
	return eax_55;
}

// 00738BB0: Register Eq_3 fn00738BB0(Register Eq_3 eax, Stack Eq_3 dwArg04, Register out ptr32 ecxOut)
// Called from:
//      fn00738CB0
//      fn0073A5D0
Eq_3 fn00738BB0(Eq_3 eax, Eq_3 dwArg04, ptr32 & ecxOut)
{
	if (g_tA6DF20 == 0x00)
	{
		ptr32 ecx_21;
		word32 edx_241;
		Eq_3 eax_19 = fn006ECAC0(9266284, out ecx_21, out edx_241);
		g_tA6DF20 = eax_19;
		if (eax_19 == 0x00)
		{
			ecxOut = ecx_21;
			return eax_19;
		}
	}
	struct Eq_148468 * esp_104;
	Eq_3 edi_110;
	ptr32 ecx_122;
	ui32 eax_30 = g_dwA6DF24;
	if (eax_30 != 0x00 && (eax == 10663056 || eax == 10663672))
	{
		edi_110 = *((const char *) g_aA6DDDC + eax_30 * 0x04);
		*((word32) edi_110 + 4) = eax;
		g_dwA6DF24 = eax_30 - 0x01;
		*edi_110 = 0x01;
		memset((word32) edi_110 + 28, 0x00, 0x40);
		((word32) edi_110 + 8)->u0 = 0x00;
		((word32) edi_110 + 0x0C)->u0 = 0x00;
		*((word32) edi_110 + 20) = (word32) edi_110 + 28;
		((word32) edi_110 + 16)->u0 = 0x07;
		*((word32) edi_110 + 92) = ~0x00;
		word32 edx_242;
		ecx_122 = fn006FEE30(edi_110, out edx_242);
		esp_104 = fp - 0x0C;
	}
	else
	{
		<anonymous> * eax_46 = *((word32) eax + 0x0098);
		word32 esp_57;
		Eq_3 eax_58;
		eax_46();
		edi_110 = eax_58;
		esp_104 = esp_57 + 0x08;
		if (eax_58 == 0x00)
			goto l00738C99;
		*((word32) eax_58 + 20) = (word32) eax_58 + 28;
		((word32) eax_58 + 16)->u0 = 0x07;
		*((word32) eax_58 + 92) = ~0x00;
		ecx_122 = (word32) eax_58 + 28;
	}
	((word32) edi_110 + 24)->u0 = 0x00737DA0;
	*((word32) edi_110 + 96) = 0x00;
	if (dwArg04 != 0x00)
	{
		word32 eax_120 = fn007389B0(dwArg04, edi_110, out ecx_122);
		if (eax_120 == ~0x00)
		{
			word32 v11_137 = (word32) *edi_110 + eax_120;
			*edi_110 = v11_137;
			if (v11_137 == 0x00)
			{
				Eq_3 edx_141 = *((word32) edi_110 + 4);
				Eq_3 eax_142 = *((word32) edx_141 + 24);
				esp_104->tFFFFFFFC = edi_110;
				eax_142();
			}
l00738C99:
			ecxOut = ecx_122;
			return 0x00;
		}
	}
	ecxOut = ecx_122;
	return edi_110;
}

// 00738CB0: Register Eq_3 fn00738CB0(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Stack Eq_3 dwArg0C)
// Called from:
//      fn0073A5E0
Eq_3 fn00738CB0(Eq_3 dwArg04, Eq_3 dwArg08, Eq_3 dwArg0C)
{
	if (dwArg04 == 10663672 && fn006E5C00(dwArg0C) == 0x00)
		return 0x00;
	struct Eq_148609 * esp_100 = fp - 0x08;
	if (fn006E5AD0(dwArg08, dwArg04, 0x00, dwArg0C) == 0x00)
		return 0x00;
	if (dwArg04 == 10663672)
	{
		Eq_3 eax_109;
		if (false)
		{
			if (*(struct Eq_1218 **) 0x04 == &g_tA2B6F8)
			{
				null = (<anonymous> ***) ((const char *) null + 1);
				return 0x00;
			}
			word32 ecx_68;
			eax_109 = fn00738BB0(dwArg04, 0x00, out ecx_68);
			esp_100 = fp - 0x08;
			if (eax_109 == 0x00 || *((word32) eax_109 + 0x0C) != 0x00)
				return eax_109;
			word32 v12_79 = (word32) *eax_109 - 1;
			*eax_109 = v12_79;
			if (v12_79 == 0x00)
			{
				Eq_3 edx_83 = *((word32) eax_109 + 4);
				word32 esp_87;
				(*((word32) edx_83 + 24))();
				esp_100 = esp_87 + 0x04;
			}
		}
		eax_109 = g_tA6DF28;
		if (eax_109 == 0x00)
		{
			esp_100->tFFFFFFFC = eax_109;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg4 = <invalid>;
			word32 ecx_252;
			eax_109 = fn00738BB0(dwArg04, stackArg4, out ecx_252);
			g_tA6DF28 = eax_109;
			if (eax_109 == 0x00)
				return eax_109;
		}
		*eax_109 = (word32) *eax_109 + 1;
		return eax_109;
	}
	else
	{
		word32 ecx_250;
		return fn00738BB0(dwArg04, 0x00, out ecx_250);
	}
}

// 00738D80: void fn00738D80()
// Called from:
//      fn006E8910
void fn00738D80()
{
	struct Eq_148705 * esp_15 = fp;
	ui32 eax_10 = g_dwA6DF24;
	if (eax_10 != 0x00)
	{
		esp_15 = fp;
		do
		{
			ui32 eax_11 = eax_10 - 0x01;
			g_dwA6DF24 = eax_11;
			struct Eq_148705 * esp_16 = esp_15 - 4;
			esp_16->t0000 = *((const char *) g_aA6DDE0 + eax_11 * 0x04);
			fn006FEFD0(esp_16->t0000);
			eax_10 = g_dwA6DF24;
			esp_15 = esp_16;
		} while (eax_10 != 0x00);
	}
	Eq_3 eax_32 = g_tA6DF20;
	if (eax_32 != 0x00)
	{
		word32 v8_36 = (word32) *eax_32 - 1;
		*eax_32 = v8_36;
		g_tA6DF20.u0 = 0x00;
		if (v8_36 == 0x00)
		{
			Eq_3 ecx_41 = *((word32) eax_32 + 4);
			Eq_3 edx_42 = *((word32) ecx_41 + 24);
			esp_15->dwFFFFFFFC = (word32) eax_32;
			word32 edx_51;
			edx_42();
		}
	}
	Eq_3 eax_57 = g_tA6DF28;
	if (eax_57 != 0x00)
	{
		word32 v11_61 = (word32) *eax_57 - 1;
		*eax_57 = v11_61;
		g_tA6DF28.u0 = 0x00;
		if (v11_61 == 0x00)
		{
			Eq_3 ecx_66 = *((word32) eax_57 + 4);
			word32 edx_75;
			(*((word32) ecx_66 + 24))();
		}
	}
}

// 0073A5D0: Register Eq_3 fn0073A5D0(Register out Eq_540 edxOut)
// Called from:
//      fn007367D0
Eq_3 fn0073A5D0(union Eq_540 & edxOut)
{
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_3 stackArg4 = <invalid>;
	word32 ecx_13;
	Eq_3 eax_6 = fn00738BB0(eax, stackArg4, out ecx_13);
	edxOut.u0 = <invalid>;
	return eax_6;
}

// 0073A5E0: Register Eq_3 fn0073A5E0(Stack Eq_3 dwArg04, Register out Eq_540 edxOut)
// Called from:
//      fn007367D0
Eq_3 fn0073A5E0(Eq_3 dwArg04, union Eq_540 & edxOut)
{
	Eq_3 eax_17;
	if (dwArg04 == 0x00)
	{
		word32 ecx_133;
		word32 edx_134;
		eax_17 = fn006DFD20(dwArg04, out ecx_133, out edx_134);
	}
	else
	{
		word32 edx_131;
		word32 ecx_130;
		word32 esi_132;
		eax_17 = fn006DFF80(0x01, out ecx_130, out edx_131, out esi_132);
	}
	if (eax_17 != 0x00)
	{
		Eq_3 eax_50 = fn00738CB0(10663672, dwArg04, 0x00);
		word32 v10_55 = (word32) *eax_17 - 1;
		*eax_17 = v10_55;
		if (v10_55 == 0x00)
		{
			Eq_3 eax_60 = *((word32) eax_17 + 4);
			(*((word32) eax_60 + 24))();
		}
		edxOut.u0 = <invalid>;
		return eax_50;
	}
	else
	{
		edxOut.u0 = <invalid>;
		return eax_17;
	}
}

// 0073AFB0: Register Eq_3 fn0073AFB0(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Stack Eq_3 dwArg0C, Register out Eq_3 edxOut)
// Called from:
//      fn00707850
//      fn0070B600
Eq_3 fn0073AFB0(Eq_3 dwArg04, Eq_3 dwArg08, Eq_3 dwArg0C, union Eq_3 & edxOut)
{
	Eq_3 ebp_111;
	Eq_3 edi_13 = *((word32) dwArg04 + 8);
	if (edi_13 != 0x00 && *((word32) edi_13 + 24) == dwArg0C)
	{
		ebp_111 = *((word32) edi_13 + 20);
		goto l0073AFD0;
	}
	word32 edx_672;
	word32 ecx_671;
	Eq_3 eax_33 = fn006FBCC0(dwArg0C, g_tA6DF2C, out ecx_671, out edx_672);
	ebp_111 = eax_33;
	if (eax_33 == 0x00)
	{
l0073B05E:
		word32 ecx_673;
		Eq_3 edx_108;
		Eq_3 eax_106 = fn006FDCC0(out ecx_673, out edx_108);
		ebp_111 = eax_106;
		if (eax_106 != 0x00)
		{
			word32 ecx_682;
			word32 esi_683;
			if (fn006FD8F0(eax_106, dwArg04, 0x00A163B8, out ecx_682, out edx_108, out esi_683) >= 0x00)
			{
l0073AFD4:
				Eq_3 edx_202;
				struct Eq_148991 * esp_160 = fp - 0x18;
				Eq_3 esi_169 = *((word32) dwArg08 + 64);
				if (esi_169 != 0x00)
				{
					((word32) dwArg08 + 64)->u0 = 0x00;
					*esi_169 = 0x01;
				}
				else
				{
					word32 edi_177 = *((word32) *((word32) dwArg08 + 44) + 8);
					esi_169 = g_tA6DF30;
					word32 eax_182 = Mem168[dwArg08 + 0x10:word32] + Mem168[dwArg08 + 0x0C:word32] + Mem168[Mem168[dwArg08 + 0x28:word32] + 0x08:word32] + edi_177;
					if (esi_169 == 0x00)
					{
						word32 ecx_680;
						Eq_3 eax_247 = fn006FEF50(&g_tA2B8D8, dwArg04, out ecx_680, out edx_202);
						esi_169 = eax_247;
						esp_160 = fp - 0x18;
						if (eax_247 == 0x00)
						{
							word32 v15_303 = (word32) *ebp_111 - 1;
							*ebp_111 = v15_303;
							if (v15_303 == 0x00)
							{
								Eq_3 eax_307 = *((word32) ebp_111 + 4);
								Eq_3 edx_314;
								(*((word32) eax_307 + 24))();
								edxOut = edx_314;
								return 0x00;
							}
							goto l0073B1BB;
						}
					}
					else
					{
						--g_dwA6DF34;
						g_tA6DF30 = *((word32) esi_169 + 0x0C);
						if (*((word32) esi_169 + 8) < eax_182)
						{
							Eq_3 eax_200 = fn006FEF90(esi_169, dwArg04, out edx_202);
							esi_169 = eax_200;
							esp_160 = fp - 0x14;
							if (eax_200 == 0x00)
							{
								word32 v24_216 = (word32) *ebp_111 - 1;
								*ebp_111 = v24_216;
								if (v24_216 == 0x00)
								{
									Eq_3 edx_220 = *((word32) ebp_111 + 4);
									Eq_3 edx_227;
									(*((word32) edx_220 + 24))();
									edxOut = edx_227;
									return 0x00;
								}
l0073B1BB:
								edxOut = edx_202;
								return 0x00;
							}
						}
						*esi_169 = 0x01;
					}
					*((word32) esi_169 + 16) = dwArg08;
					int32 ecx_270 = (word32) *((word32) dwArg08 + 0x0C) + esp_160->dw0010 + edi_177;
					*((word32) esi_169 + 32) = (word32) esi_169 + 312 + ecx_270 * 0x04;
					if (ecx_270 > 0x00)
					{
						word32 * edi_280 = (word32) esi_169 + 312;
						for (; ecx_270 != 0x00; --ecx_270)
						{
							*edi_280 = 0x00;
							++edi_280;
						}
					}
					edi_13 = esp_160->t0014;
					((word32) esi_169 + 28)->u0 = 0x00;
					((word32) esi_169 + 40)->u0 = 0x00;
					*((word32) esi_169 + 52) = 0x00;
					*((word32) esi_169 + 48) = 0x00;
					*((word32) esi_169 + 44) = null;
				}
				*((word32) esi_169 + 36) = *((word32) esi_169 + 32);
				*((word32) esi_169 + 20) = ebp_111;
				if (edi_13 != 0x00)
					*edi_13 = (word32) *edi_13 + 1;
				*((word32) esi_169 + 0x0C) = edi_13;
				*dwArg08 = (word32) *dwArg08 + 1;
				Eq_3 edi_361 = esp_160->t0024;
				*edi_361 = (word32) *edi_361 + 1;
				*((word32) esi_169 + 24) = edi_361;
				Eq_95005 eax_365 = *((word32) dwArg08 + 20);
				byte al_371 = (byte) eax_365;
				if ((byte) (eax_365 & 0x03) != 0x03)
				{
					Eq_3 eax_375;
					if ((al_371 & 0x02) != 0x00)
					{
						word32 ecx_681;
						eax_375 = fn006FDCC0(out ecx_681, out edx_202);
						if (eax_375 == 0x00)
						{
							word32 v21_454 = (word32) *esi_169 - 1;
							*esi_169 = v21_454;
							if (v21_454 == 0x00)
							{
								Eq_3 eax_458 = *((word32) esi_169 + 4);
								Eq_3 ecx_459 = *((word32) eax_458 + 24);
								esp_160->tFFFFFFFC = esi_169;
								ecx_459();
							}
							goto l0073B1BB;
						}
					}
					else
					{
						eax_375 = esp_160->t0028;
						if (eax_375 == 0x00)
							eax_375 = edi_361;
						*eax_375 = (word32) *eax_375 + 1;
					}
					*((word32) esi_169 + 28) = eax_375;
				}
				*((word32) esi_169 + 56) = dwArg04;
				*((word32) esi_169 + 60) = ~0x00;
				*((word32) esi_169 + 64) = *((word32) dwArg08 + 56);
				*((word32) esi_169 + 0x0044) = 0x00;
				Eq_3 edi_417 = esi_169 - 0x10;
				if (*((word32) edi_417 + 8) != ~0x01)
					fn006E86F0(0x008D0E04);
				((word32) edi_417 + 8)->u0 = ~0x02;
				*edi_417 = g_tA1D558;
				Eq_3 edx_435 = g_tA1D558;
				Eq_3 eax_436 = *((word32) edx_435 + 4);
				*((word32) edi_417 + 4) = eax_436;
				*eax_436 = edi_417;
				*((word32) g_tA1D558 + 4) = edi_417;
				edxOut = edx_435;
				return esi_169;
			}
		}
		edxOut = edx_108;
		return 0x00;
	}
	Eq_3 eax_43 = *((word32) eax_33 + 4);
	if (eax_43 != 10622400)
	{
		word32 ecx_676;
		word32 edx_677;
		if (fn006D5670(eax_43, 10622400, out ecx_676, out edx_677) == 0x00)
		{
			Eq_3 eax_76 = *((word32) eax_33 + 4);
			if (eax_76 != 0x00A1D1B8)
			{
				word32 ecx_678;
				word32 edx_679;
				if (fn006D5670(eax_76, 0x00A1D1B8, out ecx_678, out edx_679) == 0x00)
					goto l0073B05E;
			}
l0073B056:
			if (ebp_111 != 0x00)
			{
l0073AFD0:
				*ebp_111 = (word32) *ebp_111 + 1;
				goto l0073AFD4;
			}
			goto l0073B05E;
		}
	}
	word32 ecx_674;
	word32 edx_675;
	ebp_111 = fn00717230(eax_33, out ecx_674, out edx_675);
	goto l0073B056;
}

// 0073B240: void fn0073B240(Stack Eq_3 dwArg04, Stack int32 dwArg08, Stack Eq_3 dwArg0C, Stack Eq_3 dwArg10)
// Called from:
//      fn00708DC0
void fn0073B240(Eq_3 dwArg04, int32 dwArg08, Eq_3 dwArg0C, Eq_3 dwArg10)
{
	if (*((word32) dwArg04 + 0x0044) >= 0x14)
		fn006E86F0(9291668);
	int32 eax_21 = *((word32) dwArg04 + 0x0044);
	*((word32) dwArg04 + 0x0044) = eax_21 + 0x01;
	struct Eq_149296 * ecx_25 = (word32) dwArg04 + ((eax_21 + 0x12) + eax_21 * 0x02) * 0x04;
	ecx_25->dw0000 = dwArg08;
	ecx_25->t0008 = dwArg10;
	ecx_25->t0004 = dwArg0C;
}

// 0073B280: Register ptr32 fn0073B280(Stack Eq_3 dwArg04)
// Called from:
//      fn00708DC0
ptr32 fn0073B280(Eq_3 dwArg04)
{
	if (*((word32) dwArg04 + 0x0044) <= 0x00)
		fn006E86F0(9291696);
	*((word32) dwArg04 + 0x0044) = (word32) *((word32) dwArg04 + 0x0044) - 1;
	int32 eax_24 = *((word32) dwArg04 + 0x0044);
	return (word32) dwArg04 + ((eax_24 + 0x12) + eax_24 * 0x02) * 0x04;
}

// 0073B2B0: Register Eq_3 fn0073B2B0(Register Eq_3 eax, Register Eq_3 ecx, Register word32 ebx, Stack Eq_3 dwArg08, Register out Eq_3 ecxOut)
// Called from:
//      fn0073B3D0
Eq_3 fn0073B2B0(Eq_3 eax, Eq_3 ecx, word32 ebx, Eq_3 dwArg08, union Eq_3 & ecxOut)
{
	int32 esi_13 = (word32) ecx - 1;
	if (ecx >= ~0x00)
	{
		word32 * edi_20 = (word32) eax + 0x0C + ((word32) ecx - 1) * 0x04;
		do
		{
			Eq_3 ecx_26 = *edi_20;
			struct Eq_149363 * eax_29 = *((word32) dwArg08 + esi_13 * 0x04);
			if (ebx != 0x00)
				eax_29 = eax_29->ptr0008;
			if (eax_29 == null)
				eax = fn00704400(dwArg04, ecx_26, out ecx);
			else
				eax = fn00704300(dwArg04, ecx_26, dwArg08, out ecx);
			if (eax != 0x00)
			{
				word32 edx_171;
				eax = fn006E1160(out ecx, out edx_171);
			}
			--esi_13;
			edi_20 -= 0x04;
		} while (esi_13 >= 0x00);
	}
	ecxOut = ecx;
	return eax;
}

// 0073B310: Register Eq_3 fn0073B310(Register Eq_3 eax, Register Eq_3 ecx, Register (arr Eq_3) ebx, Register out Eq_3 ecxOut)
// Called from:
//      fn0073B4E0
Eq_3 fn0073B310(Eq_3 eax, Eq_3 ecx, Eq_3 ebx[], union Eq_3 & ecxOut)
{
	int32 edi_185 = (word32) ecx - 1;
	if (ecx >= ~0x00)
	{
		struct Eq_149407 * esp_109 = fp - 0x0C;
		word32 * ebp_187 = (word32) eax + 0x0C + ((word32) ecx - 1) * 0x04;
		do
		{
			Eq_3 ecx_24 = esp_109[4];
			struct Eq_149418 * esp_25 = esp_109 - 4;
			esp_25->t0000 = *ebp_187;
			esp_25->tFFFFFFFC = ecx_24;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg4 = <invalid>;
			Eq_3 stackArg8 = <invalid>;
			word32 edx_259;
			Eq_3 eax_34 = fn00704220(stackArg4, stackArg8, out ecx, out edx_259);
			esp_109 = (struct Eq_149407 *) ((const char *) &esp_25->t0000 + 4);
			eax = eax_34;
			if (eax_34 == 0x00)
			{
				word32 edx_253;
				eax = fn006E1160(out ecx, out edx_253);
			}
			if (esp_25->dw0018 != 0x00)
			{
				if (eax_34 == 0x00 && esp_25->t001C == eax_34)
					goto l0073B3B8;
				eax = ebx[edi_185];
				if (*((word32) eax + 8) != eax_34)
				{
					esp_25->t0000 = eax_34;
					esp_25->tFFFFFFFC = eax;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_3 stackArg4 = <invalid>;
					Eq_3 stackArg8 = <invalid>;
					eax = fn00750420(stackArg4, stackArg8, out ecx);
					esp_109 = (struct Eq_149407 *) ((const char *) &esp_25->t0000 + 4);
					if (eax < 0x00)
					{
						word32 edx_256;
						eax = fn006E1160(out ecx, out edx_256);
					}
				}
				goto l0073B3A3;
			}
			if (eax_34 != 0x00 || esp_25->t001C != eax_34)
			{
				if (ebx[edi_185] != eax_34)
				{
					if (eax_34 != 0x00)
						*eax_34 = (word32) *eax_34 + 1;
					eax = ebx[edi_185];
					if (eax != 0x00)
					{
						*eax = (word32) *eax - 1;
						eax = ebx[edi_185];
						if (*eax == 0x00)
						{
							Eq_3 edx_87 = *((word32) eax + 4);
							esp_25->t0000 = eax;
							Eq_3 eax_92 = *((word32) edx_87 + 24);
							word32 esp_103;
							eax_92();
							esp_109 = esp_103 + 0x04;
						}
					}
					ebx[edi_185] = eax_34;
				}
l0073B3A3:
				if (eax_34 != 0x00)
				{
					word32 v18_157 = (word32) *eax_34 - 1;
					*eax_34 = v18_157;
					if (v18_157 == 0x00)
					{
						Eq_3 ecx_161 = *((word32) eax_34 + 4);
						Eq_3 edx_162 = *((word32) ecx_161 + 24);
						esp_109->dwFFFFFFFC = (word32) eax_34;
						word32 esp_176;
						word32 edx_179;
						edx_162();
						esp_109 = esp_176 + 0x04;
					}
				}
			}
l0073B3B8:
			--edi_185;
			ebp_187 -= 0x04;
		} while (edi_185 >= 0x00);
	}
	ecxOut = ecx;
	return eax;
}

// 0073B3D0: void fn0073B3D0(Stack Eq_3 dwArg04)
// Called from:
//      fn00708DC0
//      fn0070BCC0
void fn0073B3D0(Eq_3 dwArg04)
{
	if (dwArg04 == 0x00)
		return;
	if (*((word32) dwArg04 + 28) == 0x00)
	{
		word32 ecx_340;
		word32 edx_341;
		Eq_3 eax_20 = fn006FDCC0(out ecx_340, out edx_341);
		*((word32) dwArg04 + 28) = eax_20;
		if (eax_20 == 0x00)
		{
			word32 ecx_342;
			word32 edx_343;
			fn006E1160(out ecx_342, out edx_343);
			return;
		}
	}
	Eq_3 esi_36 = *((word32) dwArg04 + 16);
	Eq_3 edi_41 = *((word32) esi_36 + 36);
	Eq_3 eax_42 = *((word32) edi_41 + 4);
	if (eax_42 != 0x00A16588)
	{
		word32 ecx_344;
		word32 edx_345;
		if (fn006D5670(eax_42, 0x00A16588, out ecx_344, out edx_345) == 0x00)
			return;
	}
	fn006E1130(fp - 0x04, fp - 0x08, fp - 0x0C);
	Eq_3 eax_78 = *((word32) esi_36 + 0x0C);
	*((word32) edi_41 + 8) <= eax_78;
	if (eax_78 != 0x00)
	{
		Eq_3 ecx_112;
		fn0073B2B0(edi_41, ecx_112, 0x00, dwArg04, out ecx_112);
	}
	Eq_3 edi_122 = *((word32) *((word32) esi_36 + 44) + 8);
	Eq_3 ecx_125 = *((word32) *((word32) esi_36 + 40) + 8);
	if (edi_122 != 0x00 || ecx_125 != 0x00)
	{
		word32 ecx_346;
		fn0073B2B0(eax_167, edi_122, 0x01, dwArg04, out ecx_346);
		word32 ecx_347;
		Eq_3 eax_167 = fn0073B2B0(*((word32) esi_36 + 40), ecx_125, 0x01, dwArg04, out ecx_347);
	}
	word32 ecx_348;
	word32 edx_349;
	fn006E0E00(dwLoc0C, out ecx_348, out edx_349);
}

// 0073B4E0: Register Eq_3 fn0073B4E0(Stack Eq_3 dwArg04)
// Called from:
//      fn00708DC0
//      fn0070BCC0
Eq_3 fn0073B4E0(Eq_3 dwArg04)
{
	if (dwArg04 == 0x00)
		return eax;
	Eq_3 esi_21 = *((word32) dwArg04 + 16);
	Eq_3 edi_25 = *((word32) esi_21 + 36);
	if (*((word32) dwArg04 + 28) == 0x00)
		return eax;
	Eq_3 eax_28 = *((word32) edi_25 + 4);
	if (eax_28 != 0x00A16588)
	{
		word32 ecx_300;
		word32 edx_301;
		eax = fn006D5670(eax_28, 0x00A16588, out ecx_300, out edx_301);
		if (eax == 0x00)
			return eax;
	}
	fn006E1130(fp - 0x04, fp - 0x08, fp - 0x0C);
	Eq_3 eax_64 = *((word32) esi_21 + 0x0C);
	*((word32) edi_25 + 8) <= eax_64;
	if (eax_64 != 0x00)
	{
		Eq_3 ecx_97;
		fn0073B310(*((word32) esi_21 + 36), ecx_97, (word32) dwArg04 + 312, out ecx_97);
	}
	Eq_3 edi_107 = *((word32) *((word32) esi_21 + 44) + 8);
	Eq_3 ecx_110 = *((word32) *((word32) esi_21 + 40) + 8);
	if (edi_107 != 0x00 || ecx_110 != 0x00)
	{
		word32 ecx_302;
		fn0073B310(eax_157, edi_107, (word32) dwArg04 + 312 + *((word32) esi_21 + 0x0C) * 0x04, out ecx_302);
		word32 ecx_303;
		word32 eax_157 = fn0073B310(*((word32) esi_21 + 40), ecx_110, dwArg04 + 0x0138 + (Mem131[esi_21 + 0x0C:word32] + edi_107) * 0x04, out ecx_303);
	}
	word32 ecx_304;
	word32 edx_305;
	eax = fn006E0E00(dwLoc0C, out ecx_304, out edx_305);
	return eax;
}

// 0073B5E0: void fn0073B5E0()
// Called from:
//      fn006E8910
void fn0073B5E0()
{
	Eq_3 eax_10 = g_tA6DF30;
	if (eax_10 != 0x00)
	{
		union Eq_3 * esp_13 = fp;
		do
		{
			Eq_3 ecx_12 = *((word32) eax_10 + 0x0C);
			union Eq_3 * esp_14 = esp_13 - 4;
			*esp_14 = (union Eq_3 *) eax_10;
			g_tA6DF30 = ecx_12;
			fn006FEFD0(*esp_14);
			eax_10 = g_tA6DF30;
			--g_dwA6DF34;
			esp_13 = esp_14;
		} while (eax_10 != 0x00);
	}
	Eq_3 eax_33 = g_tA6DF2C;
	if (eax_33 != 0x00)
	{
		word32 v10_37 = (word32) *eax_33 - 1;
		*eax_33 = v10_37;
		if (v10_37 == 0x00)
		{
			Eq_3 edx_41 = *((word32) eax_33 + 4);
			word32 ecx_50;
			(*((word32) edx_41 + 24))();
		}
	}
	g_tA6DF2C.u0 = 0x00;
}

// 0073B660: Register Eq_3 fn0073B660(Stack word16 wArg04, Register out Eq_540 ecxOut)
// Called from:
//      fn007406A0
//      fn007551F0
Eq_3 fn0073B660(word16 wArg04, union Eq_540 & ecxOut)
{
	word32 edx_47;
	word32 ecx_46;
	Eq_3 eax_6 = fn00723860(0x18, out ecx_46, out edx_47);
	if (eax_6 != 0x00)
	{
		*eax_6 = wArg04;
		((word32) eax_6 + 4)->u0 = 0x00;
		((word32) eax_6 + 8)->u0 = 0x00;
		((word32) eax_6 + 16)->u0 = 0x00;
		((word32) eax_6 + 20)->u0 = 0x00;
		ecxOut.u0 = <invalid>;
		return eax_6;
	}
	else
	{
		ecxOut.u0 = <invalid>;
		return 0x00;
	}
}

// 0073B690: Register Eq_149899 fn0073B690(Register Eq_149899 ecx)
// Called from:
//      fn0073B6B0
Eq_149899 fn0073B690(Eq_149899 ecx)
{
	Eq_149899 eax_10 = 0x0100;
	if (ecx <= 0x0100)
		return eax_10;
	do
	{
		eax_10 *= 0x02;
		if (eax_10 <= 0x00)
		{
			eax_10.u0 = ~0x00;
			return eax_10;
		}
	} while (eax_10 < ecx);
	return eax_10;
}

// 0073B6B0: Register word32 fn0073B6B0(Stack (ptr32 Eq_149912) dwArg04, Stack word16 wArg08, Stack Eq_3 dwArg0C, Stack int32 dwArg10, Stack ptr32 dwArg14)
// Called from:
//      fn007552A0
//      fn00755500
word32 fn0073B6B0(struct Eq_149912 * dwArg04, word16 wArg08, Eq_3 dwArg0C, int32 dwArg10, ptr32 dwArg14)
{
	Eq_149899 ecx_8 = dwArg04->t0010;
	if (ecx_8 == 0x7FFFFFFF || ecx_8 < 0x00)
		return 0x13;
	Eq_149899 edx_23;
	if (ecx_8 <= 0x01)
		edx_23 = ecx_8;
	else if (ecx_8 <= 0x80)
		edx_23 = (word32) ecx_8.u0 + 3 & ~0x03;
	else
		edx_23 = fn0073B690(ecx_8);
	Eq_149899 eax_30 = (word32) ecx_8.u0 + 1;
	if (ecx_8 > 0x00)
	{
		if (ecx_8 <= 0x7F)
			eax_30 = (word32) ecx_8.u0 + 4 & ~0x03;
		else
			eax_30 = fn0073B690((word32) ecx_8.u0 + 1);
	}
	if (edx_23 < 0x00 || eax_30 < 0x00)
		return 0x13;
	if (edx_23 < eax_30)
	{
		if (eax_30 > 0x0AAAAAAA)
			return 0x0F;
		word32 ecx_195;
		word32 edx_196;
		Eq_3 eax_79 = fn00723B60(dwArg04->t0014, eax_30 * 0x18, out ecx_195, out edx_196);
		if (eax_79 == 0x00)
			return 0x0F;
		dwArg04->t0014 = eax_79;
	}
	Eq_149899 ecx_93 = dwArg04->t0010;
	struct Eq_149961 * eax_96 = (word32) dwArg04->t0014 + ecx_93 * 0x18;
	dwArg04->t0010 = (word32) ecx_93 + 1;
	eax_96->w0000 = wArg08;
	eax_96->t0004 = dwArg0C;
	eax_96->dw0008 = dwArg10;
	eax_96->ptr000C = dwArg14;
	eax_96->dw0010 = 0x00;
	eax_96->dw0014 = 0x00;
	return 0x00;
}

// 0073B790: void fn0073B790(Stack Eq_3 dwArg04)
// Called from:
//      fn0073B790
//      fn0073B7F0
void fn0073B790(Eq_3 dwArg04)
{
	Eq_3 esi_11 = *((word32) dwArg04 + 16);
	int32 esi_12 = esi_11 - 0x01;
	if (esi_11 >= 0x01)
	{
		ui32 edi_21 = (esi_11 - 0x01 + (esi_11 - 0x01) * 0x02) * 0x08;
		do
		{
			fn0073B790((word32) *((word32) dwArg04 + 20) + edi_21);
			--esi_12;
			edi_21 -= 0x18;
		} while (esi_12 >= 0x00);
	}
	Eq_3 eax_48 = *((word32) dwArg04 + 20);
	if (eax_48 != 0x00)
	{
		word32 ecx_135;
		word32 edx_136;
		fn007239C0(eax_48, out ecx_135, out edx_136);
	}
	Eq_3 ebx_66 = *((word32) dwArg04 + 4);
	if (ebx_66 != 0x00)
	{
		word32 ecx_137;
		word32 edx_138;
		fn007239C0(ebx_66, out ecx_137, out edx_138);
	}
}

// 0073B7F0: void fn0073B7F0(Stack Eq_3 dwArg04)
// Called from:
//      fn006E8AC0
//      fn006E8B50
//      fn00755280
void fn0073B7F0(Eq_3 dwArg04)
{
	if (dwArg04 != 0x00)
	{
		fn0073B790(dwArg04);
		word32 ecx_57;
		word32 edx_58;
		fn007239C0(dwArg04, out ecx_57, out edx_58);
	}
}

// 0073B810: Register Eq_3 fn0073B810()
// Called from:
//      fn0073C870
//      fn0073FAF0
Eq_3 fn0073B810()
{
	word32 ecx_44;
	word32 edx_45;
	Eq_3 eax_11 = fn006F1A70(out ecx_44, out edx_45);
	fn00740DF0(dwArg04, eax_11);
	return eax_11;
}

// 0073B830: Register word32 fn0073B830(Register out ptr32 edxOut)
// Called from:
//      fn0073BBE0
//      fn0073C870
//      fn0073CAE0
//      fn0073DBD0
//      fn0073EB70
//      fn0073F7B0
//      fn00740060
//      fn007403E0
word32 fn0073B830(ptr32 & edxOut)
{
	word32 esi_82;
	ptr32 edx_20;
	Eq_3 eax_19 = fn006EA200(out edx_20, out esi_82);
	if (eax_19 != 0x00)
	{
		word32 ecx_83;
		Eq_3 eax_33 = fn006E0E90(g_tA178F4, eax_19, out ecx_83, out edx_20);
		word32 v11_41 = (word32) *eax_19 - 1;
		*eax_19 = v11_41;
		if (v11_41 == 0x00)
		{
			Eq_3 ecx_45 = *((word32) eax_19 + 4);
			Eq_3 edx_46 = *((word32) ecx_45 + 24);
			edx_46();
		}
	}
	edxOut = edx_20;
	return 0x00;
}

// 0073B870: void fn0073B870(Register Eq_3 esi, Stack Eq_3 dwArg04)
// Called from:
//      fn007403E0
void fn0073B870(Eq_3 esi, Eq_3 dwArg04)
{
	word32 ecx_418;
	word32 edx_419;
	if (fn006E1110(out ecx_418, out edx_419) == 0x00)
		return;
	fn006E1130(fp - 0x04, fp - 0x0C, fp - 0x08);
	Eq_3 eax_49 = fn006DFE60(dwLoc0C, dwArg04);
	if (eax_49 == 0x00)
		return;
	*eax_49 = (word32) *eax_49 + 1;
	word32 esi_422;
	word32 edi_423;
	word32 ecx_420;
	word32 edx_421;
	Eq_3 eax_79 = fn007051A0(eax_49, fn006DFE60(dwLoc0C, dwArg04), out ecx_420, out edx_421, out esi_422, out edi_423);
	struct Eq_150174 * esp_104 = fp - 0x18;
	if (eax_79 != ~0x00)
	{
		*dwLoc0C = (word32) *dwLoc0C - 1;
		if (*dwLoc0C == 0x00)
		{
			Eq_3 edx_94 = *((word32) dwLoc0C + 4);
			word32 esp_98;
			(*((word32) edx_94 + 24))();
			esp_104 = esp_98 + 0x04;
		}
		struct Eq_150203 * esp_107 = esp_104 - 4;
		esp_107->t0000 = esi;
		esp_107->tFFFFFFFC = eax_79;
		esp_107->tFFFFFFF8 = dwArg04;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_3 stackArg4 = <invalid>;
		Eq_3 eax_120 = fn006E1AB0(edx, eax_79, dwArg04, esi, eax_49, es, ds, stackArg4, dwArg04);
		Eq_3 esi_125 = eax_120;
		if (eax_120 == 0x00)
		{
			++g_dwA163B8;
			esi_125.u0 = 0x00A163B8;
		}
		esp_107->tFFFFFFFC = esi_125;
		esp_107->tFFFFFFF8.u0 = 0x00A163B8;
		esp_107->tFFFFFFF4 = eax_79;
		esp_107->tFFFFFFF0 = dwArg04;
		esp_107->dwFFFFFFEC = 0x008DC7D0;
		word32 edx_428;
		word32 esi_429;
		Eq_3 eax_151 = fn006EA200(out edx_428, out esi_429);
		word32 v18_157 = (word32) *esi_125 - 1;
		*esi_125 = v18_157;
		struct Eq_150203 * esp_156 = esp_107;
		if (v18_157 == 0x00)
		{
			Eq_3 ecx_162 = *((word64) esi_125.u0 + 4);
			Eq_3 edx_163 = *((word32) ecx_162 + 24);
			esp_107->tFFFFFFFC = esi_125;
			word32 esp_166;
			edx_163();
			esp_156 = esp_166 + 0x04;
		}
		esp_104 = (struct Eq_150174 *) ((const char *) &esp_156->t0000 + 4);
		if (eax_151 != 0x00)
		{
			esp_104->tFFFFFFFC = eax_151;
			esp_104->tFFFFFFF8 = eax_49;
			esp_104->dwFFFFFFF4 = 0x02;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg4 = <invalid>;
			word32 edx_432;
			word32 esi_433;
			word32 ecx_431;
			esp_104->t000C = fn006DFF80(stackArg4, out ecx_431, out edx_432, out esi_433);
			word32 v19_199 = (word32) *eax_49 - 1;
			*eax_49 = v19_199;
			struct Eq_150174 * esp_197 = esp_104;
			if (v19_199 == 0x00)
			{
				Eq_3 edx_203 = *((word32) eax_49 + 4);
				Eq_3 eax_204 = *((word32) edx_203 + 24);
				esp_104->tFFFFFFFC = eax_49;
				word32 esp_207;
				eax_204();
				esp_197 = esp_207 + 0x04;
			}
			word32 v20_217 = (word32) *eax_151 - 1;
			*eax_151 = v20_217;
			if (v20_217 == 0x00)
			{
				Eq_3 ecx_221 = *((word32) eax_151 + 4);
				Eq_3 edx_222 = *((word32) ecx_221 + 24);
				esp_197->tFFFFFFFC = eax_151;
				word32 esp_230;
				edx_222();
				esp_197 = esp_230 + 0x04;
			}
			Eq_3 eax_240 = esp_197->t000C;
			if (eax_240 != 0x00)
			{
				word32 edx_245 = esp_197->dw0014;
				struct Eq_150390 * esp_246 = esp_197 - 4;
				esp_246->t0000 = esp_197->t0010;
				esp_246->tFFFFFFFC = eax_240;
				esp_246->dwFFFFFFF8 = edx_245;
				word32 ecx_434;
				word32 edx_435;
				fn006E0E00(esp_246->t0000, out ecx_434, out edx_435);
			}
			return;
		}
	}
	word32 v17_263 = (word32) *eax_49 - 1;
	*eax_49 = v17_263;
	if (v17_263 != 0x00)
		return;
	Eq_3 eax_282 = *((word32) eax_49 + 4);
	Eq_3 ecx_283 = *((word32) eax_282 + 24);
	esp_104->tFFFFFFFC = eax_49;
	ecx_283();
}

// 0073B9B0: Register word32 fn0073B9B0(Register Eq_3 edx, Register Eq_3 ebx, Register Eq_3 ebp, Register Eq_3 esi, Register Eq_3 edi, Register (ptr16 Eq_7) es, Register (ptr16 Eq_8) ds, Stack Eq_3 dwArg04, Register out Eq_3 edxOut)
// Called from:
//      fn0073B9B0
//      fn0073CEC0
//      fn007403E0
word32 fn0073B9B0(Eq_3 edx, Eq_3 ebx, Eq_3 ebp, Eq_3 esi, Eq_3 edi, struct Eq_7 * es, struct Eq_8 * ds, Eq_3 dwArg04, union Eq_3 & edxOut)
{
	Eq_3 eax_120;
	Eq_150425 eax_19 = (int32) *dwArg04;
	ui32 eax_7 = g_tA14188 ^ fp - 0x84;
	Eq_3 esi_121 = dwArg04;
	struct Eq_150438 * eax_127 = eax_19 - 0x0100;
	if (eax_19 <= 299)
	{
l0073B9E0:
		switch ((word32) eax_127->b73BAF4)
		{
		case 0x00:
			esi_121 = *((word32) esi_121 + 20);
			if (*esi_121 != 0x04)
				goto l0073BA06;
			goto l0073BA38;
		case 0x01:
			Eq_3 ebx_111 = 0x00;
			Eq_3 ebp_108 = 0x00;
			if (*((word32) esi_121 + 16) > 0x00)
			{
				Eq_3 edi_113 = 0x00;
				do
				{
					Eq_3 edx_104;
					word32 eax_92 = Mem89[esi_121 + 0x14:word32] + edi_113;
					if (*eax_92 == 266)
					{
						ebp_108 += fn0073B9B0(edx_104, ebx_111, ebp_108, esi_121, edi_113, es, ds, eax_92, out edx_104);
						edx = edx_104;
					}
					ebx_111 = (word32) ebx_111 + 1;
					edi_113 = (word32) edi_113 + 24;
				} while (ebx_111 < *((word32) esi_121 + 16));
			}
			eax_120 = ebp_108;
			break;
		case 0x02:
		case 0x03:
		case 0x04:
		case 0x05:
		case 0x06:
		case 0x07:
		case 0x08:
		case 0x09:
		case 0x0C:
		case 0x0D:
		case 0x0E:
		case 0x0F:
		case 0x10:
		case 0x11:
		case 0x12:
		case 0x13:
		case 0x14:
		case 0x15:
		case 22:
		case 0x17:
		case 0x18:
		case 0x19:
		case 0x1A:
		case 0x1B:
		case 0x1C:
		case 0x1D:
		case 0x1E:
		case 0x1F:
		case 0x20:
		case 33:
		case 0x22:
		case 0x24:
		case 0x25:
		case 0x26:
		case 0x27:
		case 0x28:
		case 0x29:
		case 0x2A:
			goto l0073BA13;
		case 0x0A:
			goto l0073BA03;
		case 11:
			int64 edx_eax_71 = (int64) *((word32) esi_121 + 16);
			edx = SLICE(edx_eax_71, word32, 32);
			eax_120 = (word32) edx_eax_71 - edx >> 0x01;
			break;
		case 0x23:
			eax_120.u0 = 0x01;
			break;
		case 0x2B:
			if (*((word32) esi_121 + 16) == 0x01)
			{
l0073BA03:
				esi_121 = *((word32) esi_121 + 20);
l0073BA06:
				Eq_150567 eax_126 = (int32) *esi_121;
				eax_127 = eax_126 - 0x0100;
				if (eax_126 > 299)
					goto l0073BA13;
				goto l0073B9E0;
			}
			Eq_3 edi_34 = 0x02;
			Eq_3 ebp_36 = 0x00;
			if (*((word32) esi_121 + 16) > 0x03)
			{
				Eq_3 ebx_39 = 0x30;
				do
				{
					word32 edx_45 = Mem42[esi_121 + 0x14:word32] + ebx_39;
					ebp_36 += fn0073B9B0(edx_45, ebx_39, ebp_36, esi_121, edi_34, es, ds, edx_45, out edx);
					edi_34 = (word32) edi_34 + 1;
					ebx_39 = (word32) ebx_39 + 24;
				} while (edi_34 < *((word32) esi_121 + 16) - 0x01);
			}
			eax_120 = ebp_36;
			break;
		}
	}
	else
	{
l0073BA13:
		edx = (int32) *esi_121;
		sprintf(fp - 0x84, 0x008DC7D8, edx, *((word32) esi_121 + 16));
		fn006E86F0(fp - 0x84);
l0073BA38:
		eax_120.u0 = 0x00;
	}
	word32 ecx_369;
	word32 eax_265 = fn00694B8E(eax_120, eax_7 ^ fp - 0x0084, edx, ebx, ebp, esi, edi, es, ds, ebx, out ecx_369);
	edxOut = edx;
	return eax_265;
}

// 0073BB20: Register (ptr32 word16) fn0073BB20(Register (ptr32 word16) eax)
// Called from:
//      fn0073C680
word16 * fn0073BB20(word16 * eax)
{
	Eq_150577 eax_6 = (int32) *eax;
	if (eax_6 <= 0x30)
	{
		switch ((word32) eax_6)
		{
		case 0x0E:
			return (word16 *) 0x01;
		case 0x0F:
			return (word16 *) 0x02;
		case 0x10:
			return (word16 *) 0x03;
		case 0x11:
			return (word16 *) 0x04;
		case 0x12:
			return (word16 *) 0x09;
		case 0x13:
			return (word16 *) 11;
		case 0x14:
		case 0x15:
		case 22:
		case 0x17:
		case 0x19:
		case 0x1A:
		case 0x1B:
		case 0x1C:
		case 0x1D:
		case 0x1E:
		case 0x1F:
		case 0x20:
		case 0x24:
		case 0x25:
		case 0x26:
		case 0x27:
		case 0x28:
		case 0x29:
		case 0x2A:
		case 0x2B:
		case 44:
		case 0x2D:
		case 0x2E:
		case 0x2F:
			break;
		case 0x18:
			return (word16 *) 0x05;
		case 33:
			return (word16 *) 0x0A;
		case 0x22:
			return (word16 *) 0x07;
		case 0x23:
			return (word16 *) 0x08;
		case 0x30:
			return (word16 *) 0x0C;
		}
	}
	return null;
}

// 0073BBE0: Register word32 fn0073BBE0(Register Eq_3 ebx, Register Eq_3 ebp, Register Eq_3 esi, Register Eq_3 edi, Register (ptr16 Eq_7) es, Register (ptr16 Eq_8) ds, Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Register out Eq_3 edxOut)
// Called from:
//      fn0073BBE0
//      fn0073C100
//      fn0073C7D0
//      fn0073EB70
//      fn0073F690
//      fn0073FA50
word32 fn0073BBE0(Eq_3 ebx, Eq_3 ebp, Eq_3 esi, Eq_3 edi, struct Eq_7 * es, struct Eq_8 * ds, Eq_3 dwArg04, Eq_3 dwArg08, union Eq_3 & edxOut)
{
	Eq_3 eax_108;
	ui32 eax_7 = g_tA14188 ^ fp - 0x0134;
	Eq_3 edx_10 = *dwArg04;
	if (edx_10 <= 0x13)
	{
		Eq_3 ebx_54;
		switch (edx_10)
		{
		case 0x01:
		case 0x02:
		case 0x03:
			goto l0073BD54;
		case 0x04:
			break;
		case 0x05:
			break;
		case 0x06:
		case 0x0D:
		case 0x0E:
			break;
		case 0x07:
			break;
		case 0x08:
			break;
		case 0x09:
			break;
		case 0x0A:
			break;
		case 11:
			break;
		case 0x0C:
			break;
		case 0x0F:
			edx_10 = dwArg08;
			if (dwArg08 == 0x02)
			{
				byte * esi_151 = (word32) *((word32) dwArg04 + 8) + 20;
				byte * edi_152 = &g_b8ABDD0;
				word32 ecx_153 = 0x05;
				bool v31_438 = false;
				while (ecx_153 != 0x00)
				{
					v31_438 = *esi_620 != *edi_621;
					esi_151 = esi_620 + 1;
					edi_152 = edi_621 + 1;
					--ecx_153;
					esi_620 = esi_151;
					edi_621 = edi_152;
					if (*esi_620 == *edi_621)
						break;
				}
				if (!v31_438)
					goto l0073BC41;
			}
			*((word32) dwArg04 + 0x0C) = dwArg08;
			goto l0073BC57;
		case 0x10:
			*((word32) dwArg04 + 0x0C) = dwArg08;
			eax_108.u0 = 0x01;
			goto l0073BDA9;
		case 0x11:
			edx_10 = dwArg08;
			if (dwArg08 == 0x02)
			{
				byte * esi_118 = (word32) *((word32) dwArg04 + 4) + 20;
				byte * edi_119 = &g_b8ABDD0;
				word32 ecx_120 = 0x05;
				bool v27_434 = true;
				while (ecx_120 != 0x00)
				{
					v27_434 = *esi_618 == *edi_619;
					esi_118 = esi_618 + 1;
					edi_119 = edi_619 + 1;
					--ecx_120;
					esi_618 = esi_118;
					edi_619 = edi_119;
					if (*esi_618 == *edi_619)
						break;
				}
				if (v27_434)
				{
l0073BC41:
					eax_108 = fn0073B830(out edx_10);
					goto l0073BDA9;
				}
			}
			*((word32) dwArg04 + 8) = dwArg08;
			eax_108.u0 = 0x01;
			goto l0073BDA9;
		case 0x12:
			ebx_54 = *((word32) dwArg04 + 4);
			*((word32) dwArg04 + 8) = dwArg08;
			goto l0073BCB1;
		case 0x13:
			Eq_3 ecx_46 = *((word32) dwArg04 + 4);
			if (ecx_46 != 0x00 && *ecx_46 != 0x00)
			{
				*((word32) dwArg04 + 8) = dwArg08;
				ebx_54 = ecx_46;
l0073BCB1:
				if (ebx_54 != 0x00)
				{
					Eq_3 esi_111 = 0x00;
					Eq_3 edi_112 = (word32) ebx_54 + 4;
					while (esi_111 < *ebx_54)
					{
						if (fn0073BBE0(ebx_54, dwArg08, esi_111, edi_112, es, ds, *edi_112, dwArg04, out edx_10) == 0x00)
							goto l0073BDA7;
						esi_111 = (word32) esi_111 + 1;
						edi_112 = (word32) edi_112 + 4;
					}
				}
l0073BC57:
				eax_108.u0 = 0x01;
			}
			else
				eax_108 = fn0073B830(out edx_10);
			goto l0073BDA9;
		}
l0073BD54:
		fn00724FE0(fp - 0x0130, 300, &g_b8DC828);
		eax_108 = fn0073B830(out edx_10);
	}
	else
	{
		word32 ecx_616;
		fn006E15D0(g_tA18720, 9291764, out ecx_616, out edx_10);
l0073BDA7:
		eax_108.u0 = 0x00;
	}
l0073BDA9:
	word32 ecx_617;
	word32 eax_422 = fn00694B8E(eax_108, eax_7 ^ fp - 308, edx_10, ebx, ebp, esi, edi, es, ds, ebx, out ecx_617);
	edxOut = edx_10;
	return eax_422;
}

// 0073BE10: Register (ptr32 Eq_150792) fn0073BE10(Register (ptr32 Eq_150792) eax, Register out (ptr32 Eq_150792) edxOut)
// Called from:
//      fn0073EB70
struct Eq_150792 * fn0073BE10(struct Eq_150792 * eax, struct Eq_150792 & edxOut)
{
	struct Eq_150794 * eax_7 = eax->ptr0014->ptr0004;
	struct Eq_150801 * ecx_8 = (int32) eax_7->b0000;
	if (ecx_8 <= (struct Eq_150801 *) 0x7C)
	{
		switch ((word32) ecx_8->b73BEA3)
		{
		case 0x00:
			edxOut = edx;
			return (struct Eq_150792 *) 0x05;
		case 0x01:
			edxOut = edx;
			return (struct Eq_150792 *) 11;
		case 0x02:
		case 0x03:
		case 0x04:
		case 0x07:
		case 0x09:
		case 11:
		case 0x0C:
		case 0x0D:
		case 0x0E:
		case 0x0F:
		case 0x10:
		case 0x11:
		case 0x12:
		case 0x13:
		case 0x14:
		case 0x15:
		case 22:
		case 0x18:
		case 0x1A:
		case 0x1B:
		case 0x1C:
		case 0x1D:
		case 0x1E:
		case 0x1F:
		case 0x20:
		case 33:
		case 0x22:
		case 0x23:
		case 0x24:
		case 0x25:
		case 0x26:
		case 0x27:
		case 0x28:
		case 0x29:
		case 0x2A:
		case 0x2B:
		case 44:
		case 0x2D:
		case 0x2E:
		case 0x2F:
		case 0x30:
		case 0x31:
		case 0x32:
		case 0x33:
		case 0x34:
		case 0x35:
		case 0x36:
		case 55:
		case 0x38:
		case 0x3A:
		case 0x3B:
		case 0x3C:
		case 0x3D:
		case 0x3E:
		case 0x3F:
		case 0x40:
		case 0x41:
		case 66:
		case 0x43:
		case 0x44:
		case 0x45:
		case 0x46:
		case 0x47:
		case 0x48:
		case 0x49:
		case 0x4A:
		case 0x4B:
		case 0x4C:
		case 77:
		case 0x4E:
		case 0x4F:
		case 0x50:
		case 0x51:
		case 0x52:
		case 0x53:
		case 0x54:
		case 0x55:
		case 0x56:
			break;
		case 0x05:
			struct Eq_150792 * eax_33 = (0x00 - (eax_7->b0001 == 0x2A) & ~0x02) + 0x06;
			edxOut = edx;
			return eax_33;
		case 0x06:
			edxOut = edx;
			return (struct Eq_150792 *) 0x01;
		case 0x08:
			edxOut = edx;
			return (struct Eq_150792 *) 0x02;
		case 0x0A:
			struct Eq_150792 * edx_23 = (uint32) (int8) (eax_7->b0001 == 0x2F) * 0x08 + 0x04;
			edxOut = edx_23;
			return edx_23;
		case 0x17:
			edxOut = edx;
			return (struct Eq_150792 *) 0x07;
		case 0x19:
			edxOut = edx;
			return (struct Eq_150792 *) 0x08;
		case 0x39:
			edxOut = edx;
			return (struct Eq_150792 *) 0x0A;
		case 0x57:
			edxOut = edx;
			return (struct Eq_150792 *) 0x09;
		}
	}
	struct Eq_150792 * edx_48;
	word32 ecx_87;
	fn006E15D0(g_tA18720, 9292008, out ecx_87, out edx_48);
	edxOut = edx_48;
	return null;
}

// 0073BF20: Register word32 fn0073BF20(Register (ptr32 Eq_150856) edx, Register out (ptr32 Eq_150856) edxOut)
// Called from:
//      fn0073E7A0
word32 fn0073BF20(struct Eq_150856 * edx, struct Eq_150856 & edxOut)
{
	word32 eax_6 = edx->dw0010;
	if (eax_6 == 0x01)
	{
		struct Eq_150866 * eax_136 = edx->ptr0014;
		struct Eq_150870 * ecx_137 = (int32) eax_136->w0000;
		if (ecx_137 <= (struct Eq_150870 *) 0x1F)
		{
			switch ((word32) ecx_137->b73C06B)
			{
			case 0x00:
				struct Eq_150856 * edx_184 = eax_136->ptr0004;
				byte * edi_185 = &g_b8DBBCC;
				struct Eq_150856 * esi_186 = edx_184;
				word32 ecx_187 = 0x03;
				bool v23_306 = false;
				while (ecx_187 != 0x00)
				{
					v23_306 = esi_441->b0000 != *edi_442;
					esi_186 = &esi_441->b0000 + 1;
					edi_185 = edi_442 + 1;
					--ecx_187;
					esi_441 = esi_186;
					edi_442 = edi_185;
					if (esi_441->b0000 == *edi_442)
						break;
				}
				if (v23_306)
				{
					struct Eq_150856 * esi_205 = edx_184;
					byte * edi_206 = &g_b8DBB70;
					word32 ecx_207 = 0x03;
					bool v27_310 = false;
					while (ecx_207 != 0x00)
					{
						v27_310 = esi_443->b0000 != *edi_444;
						esi_205 = &esi_443->b0000 + 1;
						edi_206 = edi_444 + 1;
						--ecx_207;
						esi_443 = esi_205;
						edi_444 = edi_206;
						if (esi_443->b0000 == *edi_444)
							break;
					}
					if (v27_310)
						goto l0073BFBA;
					edxOut = null;
					return 0x07;
				}
				else
				{
					edxOut = edx_184;
					return 0x09;
				}
			case 0x01:
			case 0x02:
			case 0x03:
			case 0x04:
			case 0x05:
			case 0x06:
			case 0x07:
			case 0x08:
			case 0x09:
			case 0x0A:
			case 11:
			case 0x0C:
			case 0x0D:
			case 0x0E:
			case 0x0F:
			case 0x10:
			case 0x11:
			case 0x12:
			case 0x15:
			case 22:
			case 0x17:
			case 0x18:
			case 0x19:
			case 0x1A:
				goto l0073BFBA;
			case 0x13:
				edxOut = edx;
				return 0x03;
			case 0x14:
				edxOut = edx;
				return 0x05;
			case 0x1B:
				edxOut = edx;
				return 0x01;
			case 0x1C:
				edxOut = edx;
				return 0x02;
			case 0x1D:
				edxOut = edx;
				return 0x04;
			case 0x1E:
				edxOut = edx;
				return 0x06;
			}
		}
l0073BFBA:
	}
	else if (eax_6 == 0x02)
	{
		struct Eq_150866 * eax_24 = edx->ptr0014;
		if ((int32) eax_24->w0000 == 0x01)
		{
			byte * esi_29 = eax_24->ptr001C;
			byte * edi_30 = &g_b8DBBCC;
			word32 ecx_31 = 0x03;
			bool v15_298 = false;
			while (ecx_31 != 0x00)
			{
				v15_298 = *esi_437 != *edi_438;
				esi_29 = esi_437 + 1;
				edi_30 = edi_438 + 1;
				--ecx_31;
				esi_437 = esi_29;
				edi_438 = edi_30;
				if (*esi_437 == *edi_438)
					break;
			}
			if (!v15_298)
			{
				edxOut = edx;
				return 0x0A;
			}
			struct Eq_150856 * esi_50 = eax_24->ptr0004;
			byte * edi_51 = &g_b8DBB70;
			word32 ecx_52 = 0x03;
			bool v19_302 = false;
			while (ecx_52 != 0x00)
			{
				v19_302 = esi_439->b0000 != *edi_440;
				esi_50 = &esi_439->b0000 + 1;
				edi_51 = edi_440 + 1;
				--ecx_52;
				esi_439 = esi_50;
				edi_440 = edi_51;
				if (esi_439->b0000 == *edi_440)
					break;
			}
			if (!v19_302)
			{
				edxOut = edx;
				return 0x08;
			}
		}
		struct Eq_150856 * edx_108;
		word32 ecx_434;
		fn006E15D0(g_tA18720, 9292068, out ecx_434, out edx_108);
		edxOut = edx_108;
		return 0x00;
	}
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_3 stackArg8 = <invalid>;
	struct Eq_150856 * edx_269;
	word32 ecx_436;
	fn006E15D0(g_tA18720, stackArg8, out ecx_436, out edx_269);
	edxOut = edx_269;
	return 0x00;
}

// 0073C090: Register Eq_3 fn0073C090(Register Eq_3 edi, Stack Eq_3 dwArg04, Register out Eq_151059 edxOut)
// Called from:
//      fn0073C790
//      fn0073D050
//      fn0073DF10
//      fn0073E050
//      fn0073EB20
//      fn0073EB70
Eq_3 fn0073C090(Eq_3 edi, Eq_3 dwArg04, union Eq_151059 & edxOut)
{
	int64 edx_eax_10 = (int64) ((word32) *((word32) edi + 16) + 1);
	Eq_151059 edx_119;
	Eq_3 eax_24 = fn00752E30((word32) edx_eax_10 - SLICE(edx_eax_10, word32, 32) >> 0x01, out edx_119);
	if (eax_24 != 0x00)
	{
		Eq_3 esi_40 = 0x00;
		if (*((word32) edi + 16) > 0x00)
		{
			do
			{
				Eq_151059 edx_64;
				Eq_3 eax_62 = fn0073E7A0(dwArg04, out edx_64);
				if (eax_62 == 0x00)
				{
					edxOut = edx_64;
					return 0x00;
				}
				int64 edx_eax_82 = (int64) esi_40;
				edx_119 = SLICE(edx_eax_82, word32, 32);
				*((word32) eax_24 + (((word32) edx_eax_82 - edx_119 >> 0x01) * 0x04 + 4)) = eax_62;
				esi_40 = (word32) esi_40 + 2;
			} while (esi_40 < *((word32) edi + 16));
		}
		edxOut = edx_119;
		return eax_24;
	}
	else
	{
		edxOut = edx_119;
		return eax_24;
	}
}

// 0073C100: Register ui32 fn0073C100(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08)
// Called from:
//      fn0073C100
//      fn0073FC30
ui32 fn0073C100(Eq_3 dwArg04, Eq_3 dwArg08)
{
	int64 edx_eax_18 = (int64) ((word32) *((word32) dwArg08 + 16) + 1);
	int32 eax_21 = (word32) edx_eax_18 - SLICE(edx_eax_18, word32, 32);
	Eq_3 edi_15 = dwArg08;
	int32 esi_229 = eax_21 >> 0x01;
	word32 edx_476;
	Eq_3 eax_32 = fn00752E30(eax_21 >> 0x01, out edx_476);
	if (eax_32 == 0x00)
		return 0x00;
	word32 dwLoc10_375 = 0x01;
	if (eax_21 >> 0x01 > 0x00)
	{
		word32 * dwLoc0C_377 = (word32) eax_32 + 4;
		do
		{
			Eq_3 eax_223;
			ebx = Mem53[Mem53[edi_15 + 0x14:word32] + dwArg04 + 0x14:word32];
			while (*ebx != 0x01)
			{
				struct Eq_151202 * eax_66 = (word32) ebx + 24;
				if (*((word32) ebx + 40) != 0x01)
				{
					eax_223 = fn0073C100(dwArg04, dwArg04);
					goto l0073C1DD;
				}
				ebx = eax_66->ptr0014->t0014;
			}
			byte * edi_102 = &g_b8ABDD0;
			byte * esi_100 = *((word32) ebx + 4);
			word32 ecx_106 = 0x05;
			bool v22_317 = true;
			while (ecx_106 != 0x00)
			{
				v22_317 = *esi_488 == *edi_489;
				esi_100 = esi_488 + 1;
				edi_102 = edi_489 + 1;
				--ecx_106;
				esi_488 = esi_100;
				edi_489 = edi_102;
				if (*esi_488 == *edi_489)
					break;
			}
			if (v22_317)
			{
				word32 esi_482;
				word32 edx_481;
				Eq_3 eax_135 = fn006EA200(out edx_481, out esi_482);
				if (eax_135 != 0x00)
				{
					word32 edx_487;
					word32 ecx_486;
					fn006E0E90(g_tA178F4, eax_135, out ecx_486, out edx_487);
					word32 v16_158 = (word32) *eax_135 - 1;
					*eax_135 = v16_158;
					if (v16_158 == 0x00)
					{
						Eq_3 edx_162 = *((word32) eax_135 + 4);
						(*((word32) edx_162 + 24))();
					}
				}
				return 0x00;
			}
			Eq_3 edi_187 = *((word32) dwArg04 + 4);
			word32 edx_484;
			word32 ecx_483;
			Eq_3 eax_193 = fn006F1A70(out ecx_483, out edx_484);
			fn00740DF0(edi_187, dwArg04);
			word32 edx_485;
			eax_223 = fn00743EE0(eax_193, dwArg04, dwArg08, *((word32) ebx + 0x0C), out edx_485);
			edi_15 = dwArg08;
			esi_229 = eax_21 >> 0x01;
l0073C1DD:
			*dwLoc0C_377 = (word32) eax_223;
			dwLoc10_375 = dwLoc10_490 + 0x01;
			++dwLoc0C_377;
			dwLoc10_490 = dwLoc10_375;
		} while (dwLoc10_490 + 0x00 < esi_229);
	}
	word32 edx_477;
	Eq_3 eax_274 = fn00743FC0(eax_32, dwArg04, dwArg08, *((word32) edi_15 + 0x0C), out edx_477);
	word32 edx_480;
	return 0x00 - (fn0073BBE0(ebx, dwArg04, eax_274, edi_15, es, ds, eax_274, dwArg04, out edx_480) == 0x00) & eax_274;
}

// 0073C280: Register Eq_3 fn0073C280(Register (ptr32 Eq_151323) ebx, Stack Eq_3 dwArg04, Register out ptr32 edxOut)
// Called from:
//      fn0073DF70
Eq_3 fn0073C280(struct Eq_151323 * ebx, Eq_3 dwArg04, ptr32 & edxOut)
{
	Eq_3 eax_8 = ebx->t0008;
	Eq_3 ecx_10 = ebx->t000C;
	Eq_3 edi_23 = *((word32) dwArg04 + 4);
	word32 ecx_249;
	word32 edx_250;
	Eq_3 eax_28 = fn006F1A70(out ecx_249, out edx_250);
	ptr32 edx_105 = fn00740DF0(edi_23, dwArg04);
	if (eax_28 != 0x00)
	{
		Eq_3 eax_62 = fn00743EE0(eax_28, dwArg04, eax_8, ecx_10, out edx_105);
		Eq_3 edi_134 = eax_62;
		if (eax_62 != 0x00)
		{
			word32 dwLoc08_216 = 0x04;
			if (ebx->dw0010 > 0x02)
			{
				do
				{
					Eq_3 eax_79 = *((word32) dwArg04 + 4);
					word32 edx_252;
					word32 ecx_251;
					Eq_3 eax_92 = fn006F1A70(out ecx_251, out edx_252);
					edx_105 = fn00740DF0(eax_79, dwArg04);
					if (eax_92 == 0x00)
						goto l0073C2B7;
					Eq_3 eax_129 = fn00743D80(edi_134, dwArg04, 0x01, eax_8, ecx_10, out edx_105);
					edi_134 = eax_129;
					if (eax_129 == 0x00)
						goto l0073C2B7;
					dwLoc08_216 = dwLoc08_253 + 0x02;
					dwLoc08_253 = dwLoc08_216;
				} while (dwLoc08_253 + 0x00 < ebx->dw0010);
			}
			edxOut = edx_105;
			return edi_134;
		}
	}
l0073C2B7:
	edxOut = edx_105;
	return 0x00;
}

// 0073C370: Register word32 fn0073C370(Register Eq_3 esi, Register out ptr32 edxOut)
// Called from:
//      fn0073E7A0
word32 fn0073C370(Eq_3 esi, ptr32 & edxOut)
{
	ptr32 edx_124;
	Eq_3 ebx_25;
	if (*((word32) esi + 16) == 0x03)
	{
		Eq_3 eax_47 = fn007441C0(0x00, 0x00, 0x00, 0x00, out edx_124);
		ebx_25 = eax_47;
		if (eax_47 == 0x00)
			goto l0073C3A5;
	}
	else
	{
		Eq_3 eax_20 = fn0073FC30(edi, (word32) *((word32) esi + 20) + 24, out edx_124);
		ebx_25 = eax_20;
		if (eax_20 == 0x00)
			goto l0073C3A5;
	}
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_3 stackArg8 = <invalid>;
	Eq_3 eax_70 = fn0073E7A0(stackArg8, out edx_124);
	if (eax_70 != 0x00)
	{
		ptr32 edx_95;
		word32 eax_93 = fn00743900(ebx_25, eax_70, *((word32) esi + 8), *((word32) esi + 0x0C), out edx_95);
		edxOut = edx_95;
		return eax_93;
	}
l0073C3A5:
	edxOut = edx_124;
	return 0x00;
}

// 0073C3E0: Register Eq_3 fn0073C3E0(Register Eq_3 esi, Register out ptr32 edxOut)
// Called from:
//      fn0073E7A0
Eq_3 fn0073C3E0(Eq_3 esi, ptr32 & edxOut)
{
	ptr32 edx_18;
	Eq_3 eax_16 = fn0073E7A0(*((word32) esi + 20), out edx_18);
	if (eax_16 != 0x00)
	{
		ptr32 edx_113;
		Eq_3 eax_37 = fn0073E7A0((word32) *((word32) esi + 20) + 48, out edx_113);
		if (eax_37 != 0x00)
		{
			Eq_3 eax_55 = fn0073E7A0((word32) *((word32) esi + 20) + 96, out edx_113);
			if (eax_55 != 0x00)
			{
				ptr32 edx_82;
				Eq_3 eax_80 = fn00743980(eax_37, eax_16, eax_55, *((word32) esi + 8), *((word32) esi + 0x0C), out edx_82);
				edxOut = edx_82;
				return eax_80;
			}
		}
		edxOut = edx_113;
		return 0x00;
	}
	else
	{
		edxOut = edx_18;
		return eax_16;
	}
}

// 0073C440: Register Eq_3 fn0073C440(Register Eq_3 eax, Register out ptr32 edxOut)
// Called from:
//      fn0073D7A0
Eq_3 fn0073C440(Eq_3 eax, ptr32 & edxOut)
{
	Eq_3 ecx_6 = *((word32) eax + 20);
	struct Eq_151524 * ecx_15 = (word32) ecx_6 + 24;
	Eq_3 eax_12 = 0x01;
	if (*((word32) ecx_6 + 40) != 0x05)
	{
l0073C4A4:
		edxOut = edx;
		return eax_12;
	}
	else
	{
		do
		{
			ecx_15 = ecx_15->ptr0014->ptr0074;
			ptr32 edx_119 = (word32) ecx_15->w0000;
			while ((word16) edx_119 != 332)
			{
				edx = edx_119;
				if ((word16) edx_119 != 333)
				{
					word32 ecx_121;
					fn006E0F80(g_tA18720, 9292112, out ecx_121, out edx);
					eax_12.u0 = ~0x00;
					goto l0073C4A4;
				}
				if (ecx_15->dw0010 != 0x03)
					goto l0073C4A4;
				ecx_15 = ecx_15->ptr0014->ptr0044;
				edx_119 = (word32) ecx_15->w0000;
			}
			eax_12 = (word32) eax_12 + 1;
		} while (ecx_15->dw0010 == 0x05);
		edxOut = edx_119;
		return eax_12;
	}
}

// 0073C4B0: Register Eq_3 fn0073C4B0(Register Eq_3 eax, Register out ptr32 edxOut)
// Called from:
//      fn0073D9C0
Eq_3 fn0073C4B0(Eq_3 eax, ptr32 & edxOut)
{
	Eq_3 ecx_6 = *((word32) eax + 20);
	struct Eq_151592 * ecx_15 = (word32) ecx_6 + 24;
	Eq_3 eax_12 = 0x01;
	if (*((word32) ecx_6 + 40) != 0x05)
	{
l0073C514:
		edxOut = edx;
		return eax_12;
	}
	else
	{
		do
		{
			ecx_15 = ecx_15->ptr0014->ptr0074;
			ptr32 edx_119 = (word32) ecx_15->w0000;
			while ((word16) edx_119 != 335)
			{
				edx = edx_119;
				if ((word16) edx_119 != 336)
				{
					word32 ecx_121;
					fn006E0F80(g_tA18720, 9292144, out ecx_121, out edx);
					eax_12.u0 = ~0x00;
					goto l0073C514;
				}
				if (ecx_15->dw0010 != 0x03)
					goto l0073C514;
				ecx_15 = ecx_15->ptr0014->ptr0044;
				edx_119 = (word32) ecx_15->w0000;
			}
			eax_12 = (word32) eax_12 + 1;
		} while (ecx_15->dw0010 == 0x05);
		edxOut = edx_119;
		return eax_12;
	}
}

// 0073C520: Register Eq_3 fn0073C520(Register Eq_3 eax, Register Eq_3 esi, Register out ptr32 edxOut)
// Called from:
//      fn0073E390
Eq_3 fn0073C520(Eq_3 eax, Eq_3 esi, ptr32 & edxOut)
{
	Eq_3 edi_16 = *((word32) eax + 20);
	word16 ax_19 = *edi_16;
	Eq_3 ebp_119 = 0x00;
	Eq_3 dwLoc04_276 = 0x00;
	Eq_3 dwLoc08_277 = 0x00;
	if (ax_19 == 0x17)
	{
		ptr32 edx_261;
		Eq_3 eax_259 = fn00744020(out edx_261);
		edxOut = edx_261;
		return eax_259;
	}
	ptr32 edx_116;
	if (*((word32) eax + 16) == 0x01)
	{
		if (ax_19 == 303)
		{
			Eq_3 eax_215 = fn0073E7A0(edi_16, out edx_116);
			if (eax_215 != 0x00)
			{
				ptr32 edx_243;
				Eq_3 eax_241 = fn007440C0(eax_215, out edx_243);
				edxOut = edx_243;
				return eax_241;
			}
			goto l0073C5C2;
		}
	}
	else if (ax_19 == 303)
	{
		Eq_3 eax_34 = fn0073E7A0(edi_16, out edx_116);
		dwLoc04_276 = eax_34;
		if (eax_34 == 0x00)
			goto l0073C5C2;
	}
	Eq_3 eax_54;
	if (*edi_16 == 11)
	{
		if (*((word32) eax + 16) <= 0x01)
			goto l0073C5D9;
		eax_54 = (word32) *((word32) eax + 20) + 24;
	}
	else
	{
		if (*((word32) eax + 16) <= 0x02)
			goto l0073C5D9;
		eax_54 = (word32) *((word32) eax + 20) + 48;
	}
	if (*eax_54 == 303)
	{
		Eq_3 eax_80 = fn0073E7A0(eax_54, out edx_116);
		dwLoc08_277 = eax_80;
		if (eax_80 == 0x00)
			goto l0073C5C2;
	}
l0073C5D9:
	Eq_3 eax_92 = *((word32) eax + 16);
	Eq_3 eax_94 = *((word32) eax + 20);
	struct Eq_151735 * eax_96 = eax_94 - 0x18 + eax_92 * 0x18;
	if ((eax_94 - 0x18)[eax_92].w0000 == 0x0144)
	{
		if (eax_96->dw0010 == 0x01)
		{
			struct Eq_151774 * edi_124 = eax_96->ptr0014;
			Eq_3 ebp_125 = *((word32) esi + 4);
			word32 edx_383;
			word32 ecx_382;
			Eq_3 eax_129 = fn006F1A70(out ecx_382, out edx_383);
			fn00740DF0(ebp_125, eax_129);
			ptr32 edx_161;
			Eq_3 eax_159 = fn00743EE0(eax_129, 0x01, edi_124->t0008, edi_124->t000C, out edx_161);
			ebp_119 = eax_159;
			if (eax_159 == 0x00)
			{
				edxOut = edx_161;
				return eax_159;
			}
		}
		else
		{
			struct Eq_151774 * eax_100 = eax_96->ptr0014;
			if (eax_100->w0018 == 303)
			{
				Eq_3 eax_114 = fn0073E7A0(&eax_100->w0018, out edx_116);
				ebp_119 = eax_114;
				if (eax_114 == 0x00)
				{
l0073C5C2:
					edxOut = edx_116;
					return 0x00;
				}
			}
		}
	}
	ptr32 edx_190;
	Eq_3 eax_188 = fn00744050(dwLoc04_276, dwLoc08_277, ebp_119, out edx_190);
	edxOut = edx_190;
	return eax_188;
}

// 0073C680: Register Eq_3 fn0073C680(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Register out Eq_3 edxOut)
// Called from:
//      fn0073E7A0
Eq_3 fn0073C680(Eq_3 dwArg04, Eq_3 dwArg08, union Eq_3 & edxOut)
{
	Eq_3 edx_237;
	Eq_3 eax_23 = fn0073E7A0(*((word32) dwArg08 + 20), out edx_237);
	if (eax_23 != 0x00)
	{
		word32 edx_308;
		Eq_3 eax_41 = fn0073E7A0(dwArg04, out edx_308);
		edx_237 = eax_41;
		if (eax_41 != 0x00 && fn0073BB20((word32) (*((word32) dwArg08 + 20)) + 24) != 0x00)
		{
			Eq_3 edx_109;
			Eq_3 eax_82 = fn007437D0(eax_23, dwArg04, dwArg08, *((word32) dwArg08 + 8), *((word32) dwArg08 + 0x0C), out edx_109);
			Eq_3 ebx_130 = eax_82;
			if (eax_82 == 0x00)
			{
l0073C784:
				edxOut = edx_109;
				return 0x00;
			}
			else
			{
				int64 edx_eax_94 = (int64) (*((word32) dwArg08 + 16) - 0x01);
				edx_109 = SLICE(edx_eax_94, word32, 32);
				int32 eax_97 = (word32) edx_eax_94 - edx_109;
				word32 dwLoc08_274 = 0x02;
				if (eax_97 >> 0x01 > 0x01)
				{
					do
					{
						edx_109 = Mem105[dwArg08 + 0x14:word32] + dwArg08;
						if (fn0073BB20((word32) edx_109 + 24) == 0x00 || fn0073E7A0(dwArg04, out edx_109) == 0x00)
							goto l0073C784;
						Eq_3 eax_159 = fn007437D0(ebx_130, dwArg04, dwArg08, *((word32) edx_109 + 32), *((word32) edx_109 + 36), out edx_109);
						if (eax_159 == 0x00)
							goto l0073C784;
						ebx_130 = eax_159;
						dwLoc08_274 = dwLoc08_309 + 0x01;
						dwLoc08_309 = dwLoc08_274;
					} while (dwLoc08_309 + 0x00 < eax_97 >> 0x01);
				}
				edxOut = edx_109;
				return ebx_130;
			}
		}
	}
	edxOut = edx_237;
	return 0x00;
}

// 0073C790: Register Eq_3 fn0073C790(Register Eq_3 eax, Register out ptr32 edxOut)
// Called from:
//      fn0073D7A0
//      fn0073E050
//      fn0073E7A0
//      fn0073EB70
//      fn0073EF40
//      fn007403E0
Eq_3 fn0073C790(Eq_3 eax, ptr32 & edxOut)
{
	if (*((word32) eax + 16) != 0x01)
	{
		ptr32 edx_17;
		Eq_3 eax_15 = fn0073C090(eax, esi, out edx_17);
		if (eax_15 != 0x00)
		{
			ptr32 edx_40;
			Eq_3 eax_38 = fn00743FC0(eax_15, 0x01, *((word32) eax + 8), *((word32) eax + 0x0C), out edx_40);
			edxOut = edx_40;
			return eax_38;
		}
		else
		{
			edxOut = edx_17;
			return eax_15;
		}
	}
	else
	{
		ptr32 edx_57;
		Eq_3 eax_55 = fn0073E7A0(*((word32) eax + 20), out edx_57);
		edxOut = edx_57;
		return eax_55;
	}
}

// 0073C7D0: Register Eq_3 fn0073C7D0(Register Eq_3 esi, Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Register out Eq_3 edxOut)
// Called from:
//      fn0073D050
//      fn0073D7A0
//      fn0073D9C0
//      fn00740160
Eq_3 fn0073C7D0(Eq_3 esi, Eq_3 dwArg04, Eq_3 dwArg08, union Eq_3 & edxOut)
{
	int64 edx_eax_12 = (int64) ((word32) *((word32) esi + 16) + 1);
	Eq_3 edx_167;
	Eq_3 eax_106 = fn00752E30((word32) edx_eax_12 - SLICE(edx_eax_12, word32, 32) >> 0x01, out edx_167);
	if (eax_106 != 0x00)
	{
		Eq_3 ebx_122 = 0x00;
		if (*((word32) esi + 16) <= 0x00)
		{
l0073C866:
			edxOut = edx_167;
			return eax_106;
		}
		else
		{
			Eq_3 edi_124 = 0x00;
			do
			{
				Eq_3 eax_67 = fn0073E7A0(dwArg04, out edx_167);
				if (eax_67 == 0x00)
				{
l0073C864:
					eax_106.u0 = 0x00;
					goto l0073C866;
				}
				int64 edx_eax_77 = (int64) ebx_122;
				*((word64) eax_106.u0 + (((word32) edx_eax_77 - SLICE(edx_eax_77, word32, 32) >> 0x01) * 0x04 + 4)) = eax_67;
				edx_167 = eax_106;
				if (dwArg08 != 0x00 && fn0073BBE0(ebx_122, dwArg08, esi, edi_124, es, ds, eax_67, dwArg04, out edx_167) == 0x00)
					goto l0073C864;
				ebx_122 = (word32) ebx_122 + 2;
				edi_124 = (word32) edi_124 + 48;
			} while (ebx_122 < *((word32) esi + 16));
			edxOut = edx_167;
			return eax_106;
		}
	}
	else
	{
		edxOut = edx_167;
		return eax_106;
	}
}

// 0073C870: Register Eq_3 fn0073C870(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Register out ptr32 edxOut)
// Called from:
//      fn0073C870
//      fn0073CAE0
Eq_3 fn0073C870(Eq_3 dwArg04, Eq_3 dwArg08, ptr32 & edxOut)
{
	ptr32 edx_163;
	int32 eax_14 = (int32) *dwArg08;
	Eq_3 ebp_13 = dwArg08;
	bool v18_561 = eax_14 != 0x011C;
	while (eax_14 <= 0x011C)
	{
		if (v18_561)
		{
			if (eax_14 == 0x10)
			{
				word32 edx_820;
				word32 ecx_819;
				fn006F1A70(out ecx_819, out edx_820);
				goto l0073CAB4;
			}
			if (eax_14 != 0x011B)
				goto l0073C8A9;
			word32 ecx_49 = 0x03;
			if (*((word32) ebp_13 + 16) == 0x03)
			{
				Eq_3 esi_54 = *((word32) *((word32) ebp_13 + 20) + 28);
				byte * edi_55 = &g_b8DBBE0;
				bool v21_564 = true;
				while (ecx_49 != 0x00)
				{
					v21_564 = *esi_824 == *edi_825;
					esi_54 = (word32) esi_824 + 1;
					edi_55 = edi_825 + 1;
					--ecx_49;
					esi_824 = esi_54;
					edi_825 = edi_55;
					if (*esi_824 == *edi_825)
						break;
				}
				if (!v21_564)
				{
l0073C900:
					fn0073B830(out edx_163);
					goto l0073C90C;
				}
				fn0073B810();
			}
			Eq_3 edi_102 = *((word32) dwArg04 + 4);
			word32 ecx_821;
			word32 edx_822;
			Eq_3 eax_111 = fn006F1A70(out ecx_821, out edx_822);
			fn00740DF0(edi_102, eax_111);
			ptr32 edx_137;
			Eq_3 eax_136 = fn00744270(eax_111, 0x00, out edx_137);
			edxOut = edx_137;
			return eax_136;
		}
		if (*((word32) ebp_13 + 16) != 0x01)
		{
			Eq_3 eax_162 = fn0073C870(dwArg04, *((word32) ebp_13 + 20), out edx_163);
			if (eax_162 == 0x00)
				goto l0073C90C;
			Eq_3 esi_172 = *((word32) *((word32) ebp_13 + 20) + 28);
			byte * edi_173 = &g_b8DBBE0;
			word32 ecx_174 = 0x03;
			bool v25_568 = false;
			while (ecx_174 != 0x00)
			{
				v25_568 = *esi_826 != *edi_827;
				esi_172 = (word32) esi_826 + 1;
				edi_173 = edi_827 + 1;
				--ecx_174;
				esi_826 = esi_172;
				edi_827 = edi_173;
				if (*esi_826 == *edi_827)
					break;
			}
			if (!v25_568)
			{
				Eq_3 edi_222 = *((word32) dwArg04 + 4);
				word32 ecx_815;
				word32 edx_816;
				Eq_3 eax_227 = fn006F1A70(out ecx_815, out edx_816);
				ptr32 edx_239 = fn00740DF0(edi_222, eax_227);
				*((word32) eax_162 + 4) = eax_227;
				edxOut = edx_239;
				return eax_162;
			}
			goto l0073C900;
		}
		ebp_13 = *((word32) ebp_13 + 20);
		eax_14 = (int32) *ebp_13;
		v18_561 = eax_14 != 0x011C;
	}
	if (eax_14 == 0x011F)
	{
		Eq_3 edi_265 = *((word32) ebp_13 + 16);
		if (edi_265 != 0x01)
		{
			word32 esi_268 = 0x00;
			if (edi_265 > 0x00)
			{
				struct Eq_152196 * ecx_274 = (word32) *((word32) ebp_13 + 20) + 4;
				uint32 edi_275 = ((word32) edi_265 - 1 >> 0x01) + 0x01;
				do
				{
					byte * eax_279 = ecx_274->dw0000;
					eax_281 = eax_279;
					do
					{
						byte * eax_281;
						eax_281 = eax_828 + 1;
						eax_828 = eax_281;
					} while (*eax_828 != 0x00);
					++ecx_274;
					--edi_275;
					esi_268 = esi_268 + 0x01 + (eax_281 - (eax_279 + 1));
				} while (edi_275 != 0x00);
			}
			word32 ecx_817;
			Eq_3 eax_325 = fn006EC9B0(0x00, esi_268 + ~0x00, out ecx_817, out edx_163);
			if (eax_325 != 0x00)
			{
				struct Eq_152234 * ecx_334 = (word32) eax_325 + 20;
				if (eax_325 != 0x14)
				{
					Eq_3 ebx_354 = 0x00;
					if (*((word32) ebp_13 + 16) > 0x00)
					{
						ptr32 dwLoc04_749 = 0x04;
						do
						{
							byte * eax_364 = *((word32) *((word32) ebp_13 + 20) + (dwLoc04_749 + 0x00));
							byte * esi_365 = eax_364;
							struct Eq_152234 * edi_367 = ecx_334;
							do
							{
								byte dl_370 = *esi_365;
								edi_367->b0000 = dl_370;
								++esi_365;
								++edi_367;
							} while (dl_370 != 0x00);
							eax_380 = eax_364;
							do
							{
								byte * eax_380;
								eax_380 = eax_829 + 1;
								eax_829 = eax_380;
							} while (*eax_829 != 0x00);
							byte * ecx_395 = ecx_334 + (eax_380 - (eax_364 + 1));
							*ecx_395 = 0x2E;
							dwLoc04_749 += 0x30;
							ebx_354 = (word32) ebx_354 + 2;
							ecx_334 = (struct Eq_152234 *) (ecx_395 + 1);
						} while (ebx_354 < *((word32) ebp_13 + 16));
					}
					ecx_334->bFFFFFFFF = 0x00;
					word32 edx_818;
					fn006EC890(fp + 0x08, out edx_818);
l0073CAB4:
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_3 stackArg8 = <invalid>;
					fn00740DF0(*((word32) dwArg04 + 4), stackArg8);
					ptr32 edx_458;
					Eq_3 eax_457 = fn00744270(dwArg08, 0x00, out edx_458);
					edxOut = edx_458;
					return eax_457;
				}
			}
l0073C90C:
			edxOut = edx_163;
			return 0x00;
		}
		else
		{
			Eq_3 ebx_476 = *((word32) dwArg04 + 4);
			word32 edx_814;
			word32 ecx_813;
			Eq_3 eax_482 = fn006F1A70(out ecx_813, out edx_814);
			fn00740DF0(ebx_476, dwArg04);
			ptr32 edx_507;
			Eq_3 eax_506 = fn00744270(eax_482, dwArg04, out edx_507);
			edxOut = edx_507;
			return eax_506;
		}
	}
	else
	{
l0073C8A9:
		ptr32 edx_542;
		word32 ecx_812;
		fn006E15D0(g_tA18720, 9292200, out ecx_812, out edx_542);
		edxOut = edx_542;
		return 0x00;
	}
}

// 0073CAE0: Register Eq_3 fn0073CAE0(Register Eq_3 eax, Stack Eq_3 dwArg04, Register out ptr32 edxOut)
// Called from:
//      fn00740160
Eq_3 fn0073CAE0(Eq_3 eax, Eq_3 dwArg04, ptr32 & edxOut)
{
	ptr32 edx_141;
	Eq_3 edi_21 = *((word32) eax + 20);
	Eq_3 ecx_7 = *((word32) eax + 8);
	Eq_3 edx_8 = *((word32) eax + 0x0C);
	word16 ax_23 = *edi_21;
	if (ax_23 == 0x0119)
	{
		Eq_3 esi_454 = *((word32) edi_21 + 20);
		int64 edx_eax_460 = (int64) ((word32) *((word32) esi_454 + 40) + 1);
		Eq_3 eax_472 = fn00752E30((word32) edx_eax_460 - SLICE(edx_eax_460, word32, 32) >> 0x01, out edx_141);
		if (eax_472 != 0x00)
		{
			Eq_3 edi_481 = 0x00;
			if (*((word32) esi_454 + 40) > 0x00)
			{
				do
				{
					Eq_3 eax_505 = fn0073C870(dwArg04, dwArg04, out edx_141);
					if (eax_505 == 0x00)
						goto l0073CDED;
					int64 edx_eax_528 = (int64) edi_481;
					*((word32) eax_472 + (((word32) edx_eax_528 - SLICE(edx_eax_528, word32, 32) >> 0x01) * 0x04 + 4)) = eax_505;
					edi_481 = (word32) edi_481 + 2;
				} while (edi_481 < *((word32) esi_454 + 40));
			}
			ptr32 edx_560;
			Eq_3 eax_559 = fn00743520(eax_472, dwArg04, edx_8, out edx_560);
			edxOut = edx_560;
			return eax_559;
		}
		goto l0073CDED;
	}
	if (ax_23 != 0x011A)
	{
		word32 ecx_798;
		fn006E15D0(g_tA18720, 9292228, out ecx_798, out edx_141);
		goto l0073CDED;
	}
	Eq_3 eax_47 = *((word32) edi_21 + 16);
	Eq_3 ebp_120 = 0x00;
	Eq_3 esi_106 = 0x01;
	Eq_3 dwLoc10_586 = 0x00;
	Eq_3 dwLoc0C_587 = 0x00;
	if (eax_47 > 0x01)
	{
		Eq_3 ebx_54 = *((word32) edi_21 + 20);
		struct Eq_152508 * ecx_55 = (word32) ebx_54 + 24;
		do
		{
			word16 dx_60 = ecx_55->w0000;
			if (dx_60 == 0x011F)
			{
				dwLoc10_586 = ebp_120;
				word32 edx_799;
				dwLoc0C_587 = fn0073C870(dwArg04, (word32) ebx_54 + esi_106 * 0x18, out edx_799);
				esi_106 = (word32) esi_106 + 1;
				goto l0073CBE9;
			}
			if (dx_60 != 0x17)
				break;
			esi_106 = (word32) esi_106 + 1;
			ebp_120 = (word32) ebp_120 + 1;
			++ecx_55;
		} while (esi_106 < eax_47);
		dwLoc10_586 = ebp_120;
	}
l0073CBE9:
	int32 eax_115;
	Eq_3 edx_105 = *((word32) edi_21 + 20);
	int32 esi_109 = (word32) esi_106 + 1;
	int32 eax_111 = (int32) *((word32) edx_105 + esi_109 * 0x18);
	struct Eq_152548 * esi_113 = (word32) edx_105 + esi_109 * 0x18;
	if (eax_111 != 0x07)
	{
		if (eax_111 != 0x10)
		{
			if (eax_111 != 0x011D)
			{
				word32 esi_800;
				Eq_3 eax_406 = fn006EA200(out edx_141, out esi_800);
				if (eax_406 != 0x00)
				{
					word32 ecx_801;
					fn006E0E90(g_tA178F4, eax_406, out ecx_801, out edx_141);
					word32 v18_428 = (word32) *eax_406 - 1;
					*eax_406 = v18_428;
					if (v18_428 == 0x00)
					{
						Eq_3 edx_432 = *((word32) eax_406 + 4);
						Eq_3 eax_433 = *((word32) edx_432 + 24);
						ptr32 edx_439;
						eax_433();
						edxOut = edx_439;
						return 0x00;
					}
				}
				goto l0073CDED;
			}
			eax_115 = esi_113->dw0010;
			bool v23_574 = (eax_115 & 0x80000001) != 0x00;
			if ((eax_115 & 0x80000001) < 0x00)
				v23_574 = ((eax_115 & 0x80000001) - 0x01 | ~0x01) != 0x01;
			if (!v23_574)
			{
				ptr32 edx_383;
				fn0073B830(out edx_383);
				edxOut = edx_383;
				return 0x00;
			}
		}
		else
		{
			eax_115 = 0x01;
			if (ebp_120 != 0x00)
			{
				word32 esi_802;
				Eq_3 eax_140 = fn006EA200(out edx_141, out esi_802);
				if (eax_140 != 0x00)
				{
					word32 ecx_803;
					Eq_3 eax_154 = fn006E0E90(g_tA178F4, eax_140, out ecx_803, out edx_141);
					word32 v20_162 = (word32) *eax_140 - 1;
					*eax_140 = v20_162;
					if (v20_162 == 0x00)
					{
						Eq_3 ecx_166 = *((word32) eax_140 + 4);
						ptr32 edx_173;
						(*((word32) ecx_166 + 24))();
						edxOut = edx_173;
						return 0x00;
					}
				}
l0073CDED:
				edxOut = edx_141;
				return 0x00;
			}
		}
	}
	else
	{
		eax_115 = esi_113->dw0028;
		esi_113 = &esi_113->dw0010 + 2;
	}
	int64 edx_eax_212 = (int64) (eax_115 + 0x01);
	Eq_3 eax_234 = fn00752E30((word32) edx_eax_212 - SLICE(edx_eax_212, word32, 32) >> 0x01, out edx_141);
	if (eax_234 != 0x00)
	{
		if (esi_113->w0000 != 0x10)
		{
			int32 edi_245 = 0x00;
			if (esi_113->dw0010 > 0x00)
			{
				do
				{
					Eq_3 eax_268 = fn0073C870(dwArg04, dwArg04, out edx_141);
					if (eax_268 == 0x00)
						goto l0073CDED;
					int64 edx_eax_278 = (int64) edi_245;
					*((word32) eax_234 + (((word32) edx_eax_278 - SLICE(edx_eax_278, word32, 32) >> 0x01) * 0x04 + 4)) = eax_268;
					edi_245 += 0x02;
				} while (edi_245 < esi_113->dw0010);
			}
			goto l0073CD88;
		}
		Eq_3 eax_295 = fn0073C870(dwArg04, dwArg04, out edx_141);
		if (eax_295 != 0x00)
		{
			*((word32) eax_234 + 4) = eax_295;
l0073CD88:
			Eq_3 esi_323;
			if (dwLoc0C_587 != 0x00)
				esi_323 = *dwLoc0C_587;
			else
			{
				Eq_3 edi_311 = *((word32) dwArg04 + 4);
				word32 edx_805;
				word32 ecx_804;
				esi_323 = fn006F1A70(out ecx_804, out edx_805);
				fn00740DF0(edi_311, dwArg04);
			}
			ptr32 edx_364;
			Eq_3 eax_363 = fn00743560(esi_323, dwArg04, dwLoc10_586, ecx_7, edx_8, out edx_364);
			edxOut = edx_364;
			return eax_363;
		}
	}
	goto l0073CDED;
}

// 0073CE00: Register Eq_3 fn0073CE00(Register Eq_3 edi, Stack Eq_3 dwArg04, Register out ptr32 edxOut)
// Called from:
//      fn00740160
Eq_3 fn0073CE00(Eq_3 edi, Eq_3 dwArg04, ptr32 & edxOut)
{
	int64 edx_eax_10 = (int64) *((word32) edi + 16);
	ptr32 edx_23;
	Eq_3 eax_21 = fn00752E30((word32) edx_eax_10 - SLICE(edx_eax_10, word32, 32) >> 0x01, out edx_23);
	if (eax_21 != 0x00)
	{
		Eq_3 ebx_34 = 0x01;
		if (*((word32) edi + 16) > 0x01)
		{
			do
			{
				Eq_3 eax_48 = *((word32) dwArg04 + 4);
				word32 ecx_197;
				word32 edx_198;
				Eq_3 eax_60 = fn006F1A70(out ecx_197, out edx_198);
				ptr32 edx_74 = fn00740DF0(eax_48, dwArg04);
				if (eax_60 == 0x00)
				{
					edxOut = edx_74;
					return 0x00;
				}
				int64 edx_eax_92 = (int64) ebx_34;
				*((word32) eax_21 + (((word32) edx_eax_92 - SLICE(edx_eax_92, word32, 32) >> 0x01) * 0x04 + 4)) = eax_60;
				ebx_34 = (word32) ebx_34 + 2;
			} while (ebx_34 < *((word32) edi + 16));
		}
		ptr32 edx_126;
		Eq_3 eax_124 = fn00743640(eax_21, dwArg04, *((word32) edi + 0x0C), out edx_126);
		edxOut = edx_126;
		return eax_124;
	}
	else
	{
		edxOut = edx_23;
		return eax_21;
	}
}

// 0073CEC0: Register Eq_3 fn0073CEC0(Register Eq_3 edx, Register Eq_3 ebx, Register Eq_3 edi, Register (ptr16 Eq_7) es, Register (ptr16 Eq_8) ds, Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Register out Eq_3 edxOut)
// Called from:
//      fn0073D050
//      fn0073F2C0
//      fn0073F5B0
//      fn0073F690
//      fn0073F7B0
//      fn0073FA50
//      fn0073FAF0
//      fn00740060
Eq_3 fn0073CEC0(Eq_3 edx, Eq_3 ebx, Eq_3 edi, struct Eq_7 * es, struct Eq_8 * ds, Eq_3 dwArg04, Eq_3 dwArg08, union Eq_3 & edxOut)
{
	Eq_3 ebp_150 = dwArg08;
	Eq_3 esi_12 = 0x00;
	Eq_3 dwLoc10_318 = 0x00;
	word32 edx_473;
	Eq_3 edx_131;
	Eq_3 eax_245 = fn00752E30(fn0073B9B0(edx, ebx, dwArg08, 0x00, edi, es, ds, dwArg08, out edx_473), out edx_131);
	if (eax_245 != 0x00)
	{
		Eq_3 ecx_53 = *((word32) dwArg08 + 20);
		if (*ecx_53 == 0x010B)
		{
			Eq_3 ebp_195 = *((word32) ecx_53 + 16);
			int32 ebp_197 = ebp_195 - 0x01;
			edx_131 = ebp_195 - 0x01 + (ebp_195 - 0x01) * 0x02;
			if ((*((word32) ecx_53 + 20) - 0x18)[edx_131].w0000 == 0x0D)
				ebp_197 = ebp_195 - 0x02;
			int32 esi_203 = 0x00;
			if (ebp_197 > 0x00)
			{
				union Eq_152942 * ebx_211 = (word64) eax_245.u0 + 4;
				do
				{
					Eq_3 eax_238 = fn00740160(dwArg04, out edx_131);
					if (eax_238 == 0x00)
						goto l0073D044;
					*ebx_211 = (union Eq_152942 *) eax_238;
					esi_203 += 0x02;
					ebx_211 = (union Eq_152942 *) ((const char *) ebx_211 + 4);
				} while (esi_203 < ebp_197);
				edxOut = edx_131;
				return eax_245;
			}
		}
		else
		{
			word32 dwLoc04_401 = 0x03;
			if (*((word32) dwArg08 + 16) > 0x03)
			{
				word32 dwLoc08_402 = 0x30;
				do
				{
					Eq_3 edi_72 = (word32) *((word32) ebp_150 + 20) + dwLoc08_402;
					word32 edx_474;
					if (fn0073B9B0(edx_131, ebx, ebp_150, esi_12, edi_72, es, ds, edi_72, out edx_474) == 0x01)
					{
						Eq_3 eax_160 = fn00740160(dwArg04, out edx_131);
						if (eax_160 == 0x00)
						{
l0073D044:
							eax_245.u0 = 0x00;
							goto l0073D046;
						}
						*((word64) eax_245.u0 + (esi_12 * 0x04 + 4)) = eax_160;
						esi_12 = (word32) esi_12 + 1;
						dwLoc10_318 = esi_12;
					}
					else
					{
						ebx = *((word32) edi_72 + 20);
						Eq_3 edi_120 = 0x00;
						if (*((word32) ebx + 16) > 0x00)
						{
							int32 ebp_102 = 0x00;
							word32 * esi_105 = (word64) eax_245.u0 + 4 + esi_12 * 0x04;
							while ((word32) *((word32) ebx + 20) + ebp_102 + 0x10 != 0x00)
							{
								Eq_3 eax_132 = fn00740160(dwArg04, out edx_131);
								if (eax_132 == 0x00)
									goto l0073D044;
								*esi_105 = (word32) eax_132;
								dwLoc10_318 = (word32) dwLoc10_318 + 1;
								edi_120 = (word32) edi_120 + 2;
								++esi_105;
								ebp_102 += 0x30;
								if (edi_120 >= *((word32) ebx + 16))
									break;
							}
							esi_12 = dwLoc10_318;
							ebp_150 = dwArg08;
						}
					}
					Eq_3 edx_176 = *((word32) ebp_150 + 16);
					dwLoc08_402 += 0x18;
					edx_131 = edx_176 - 0x01;
					dwLoc04_401 = dwLoc04_475 + 0x01;
					dwLoc04_475 = dwLoc04_401;
				} while (dwLoc04_475 + 0x00 < edx_176 - 0x01);
				edxOut = edx_176 - 0x01;
				return eax_245;
			}
		}
l0073D046:
		edxOut = edx_131;
		return eax_245;
	}
	else
	{
		edxOut = edx_131;
		return eax_245;
	}
}

// 0073D050: Register Eq_3 fn0073D050(Register Eq_3 ebx, Stack Eq_3 dwArg04, Register out ptr32 edxOut)
// Called from:
//      fn00740160
Eq_3 fn0073D050(Eq_3 ebx, Eq_3 dwArg04, ptr32 & edxOut)
{
	Eq_3 dwLoc04_229 = 0x00;
	if (*((word32) ebx + 16) == 0x09)
	{
		ptr32 edx_25;
		Eq_3 eax_24 = fn0073CEC0(edx, ebx, edi, es, ds, dwArg04, (word32) *((word32) ebx + 20) + 0x00C0, out edx_25);
		dwLoc04_229 = eax_24;
		if (eax_24 == 0x00)
		{
			edxOut = edx_25;
			return eax_24;
		}
	}
	Eq_3 edi_43 = *((word32) ebx + 20);
	ptr32 edx_105;
	Eq_3 eax_56 = fn0073C7D0((word32) edi_43 + 24, dwArg04, dwArg04, out edx_105);
	if (eax_56 != 0x00)
	{
		Eq_3 esi_100;
		if (*((word32) edi_43 + 40) == 0x01)
			esi_100 = *((word32) eax_56 + 4);
		else
		{
			word32 edx_320;
			esi_100 = fn00743FC0(eax_56, dwArg04, *((word32) ebx + 8), *((word32) ebx + 0x0C), out edx_320);
		}
		Eq_3 eax_127;
		Eq_3 edi_91 = *((word32) ebx + 20);
		if (*((word32) edi_91 + 88) == 0x01)
			eax_127 = fn0073E7A0(dwArg04, out edx_105);
		else
		{
			Eq_3 eax_104 = fn0073C090((word32) edi_91 + 72, dwArg04, out edx_105);
			if (eax_104 == 0x00)
				goto l0073D117;
			eax_127 = fn00743FC0(eax_104, dwArg04, *((word32) edi_91 + 80), *((word32) edi_91 + 84), out edx_105);
		}
		if (eax_127 != 0x00)
		{
			Eq_3 eax_167 = fn0073CEC0((word32) *((word32) ebx + 20) + 0x0078, ebx, eax_127, es, ds, dwArg04, dwArg04, out edx_105);
			if (eax_167 != 0x00)
			{
				ptr32 edx_196;
				Eq_3 eax_195 = fn00743200(esi_100, dwArg04, eax_167, dwLoc04_229, *((word32) ebx + 8), *((word32) ebx + 0x0C), out edx_196);
				edxOut = edx_196;
				return eax_195;
			}
		}
	}
l0073D117:
	edxOut = edx_105;
	return 0x00;
}

// 0073D140: Register Eq_3 fn0073D140(Register Eq_3 esi, Register out ptr32 edxOut)
// Called from:
//      fn0073E050
Eq_3 fn0073D140(Eq_3 esi, ptr32 & edxOut)
{
	*_errno() = 0x00;
	Eq_3 eax_19 = esi;
	do
	{
		eax_19 = (word32) eax_332 + 1;
		eax_332 = eax_19;
	} while (*eax_332 != 0x00);
	word32 ebp_104;
	byte * eax_32 = (word32) esi + ((eax_19 - ((word32) esi + 1)) - 0x01);
	byte al_35 = *eax_32;
	if (al_35 != 0x6A && al_35 != 0x4A)
		ebp_104 = 0x00;
	else
		ebp_104 = 0x01;
	if (al_35 != 0x6C && al_35 != 0x4C)
	{
		Eq_3 edi_130;
		if (*esi == 0x30)
		{
			Eq_3 eax_80 = fn007501A0(esi, fp - 0x14, 0x00);
			edi_130 = eax_80;
			if (eax_80 < 0x00 && *_errno() == 0x00)
				goto l0073D1B0;
		}
		else
			edi_130 = fn007502F0(esi, fp - 0x14, 0x00);
		if (*eax_32 != 0x00)
		{
			if (ebp_104 == 0x00)
			{
				Eq_3 rRet0_118;
				fn0074F3B0(esi, out rRet0_118);
				ptr32 edx_133;
				Eq_3 eax_132 = fn006FF060(rRet0_118, out edx_133);
				edxOut = edx_133;
				return eax_132;
			}
			else
			{
				Eq_3 rRet0_157;
				fn0074F3B0(esi, out rRet0_157);
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_3 stackArg8 = <invalid>;
				Eq_3 stackArg16 = <invalid>;
				ptr32 edx_171;
				Eq_3 eax_170 = fn007331D0(0.0, stackArg8, rRet0_157, stackArg16, out edx_171);
				edxOut = edx_171;
				return eax_170;
			}
		}
		if (*_errno() == 0x00)
		{
			ptr32 edx_192;
			word32 ecx_329;
			Eq_3 eax_191 = fn007050A0(edi_130, out ecx_329, out edx_192);
			edxOut = edx_192;
			return eax_191;
		}
	}
l0073D1B0:
	ptr32 edx_222;
	Eq_3 eax_221 = fn007120F0(es, ds, esi, null, 0x00, out edx_222);
	edxOut = edx_222;
	return eax_221;
}

// 0073D240: Register Eq_3 fn0073D240(Register Eq_3 eax, Register (ptr32 byte) edx, Stack Eq_3 dwArg04, Register out ptr32 edxOut)
// Called from:
//      fn0073D2A0
Eq_3 fn0073D240(Eq_3 eax, byte * edx, Eq_3 dwArg04, ptr32 & edxOut)
{
	byte * eax_14 = *eax;
	if (eax_14 < edx)
	{
		while ((*eax_14 & 0x80) != 0x00)
		{
			++eax_14;
			if (eax_14 >= edx)
				break;
		}
	}
	*eax = eax_14;
	ptr32 edx_44;
	Eq_3 eax_43 = fn0071FC80(out edx_44);
	if (eax_43 != 0x00)
	{
		word32 ecx_148;
		ptr32 edx_112;
		Eq_3 eax_66 = fn0071FB20(eax_43, dwArg04, 0x00, out ecx_148, out edx_112);
		word32 v12_72 = (word32) *eax_43 - 1;
		*eax_43 = v12_72;
		if (v12_72 == 0x00)
		{
			struct Eq_153307 * ecx_77 = *((word32) eax_43 + 4);
			<anonymous> * edx_78 = ecx_77->ptr0018;
			edx_78();
		}
		edxOut = edx_112;
		return eax_66;
	}
	else
	{
		edxOut = edx_44;
		return eax_43;
	}
}

// 0073D2A0: Register Eq_3 fn0073D2A0(Register Eq_3 eax, Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Register out (ptr32 byte) edxOut)
// Called from:
//      fn0073D450
Eq_3 fn0073D2A0(Eq_3 eax, Eq_3 dwArg04, Eq_3 dwArg08, byte & edxOut)
{
	struct Eq_153319 * edi_262;
	Eq_3 ebx_105 = dwArg04;
	Eq_3 ebp_12 = dwArg08;
	Eq_3 esi_17 = eax;
	struct Eq_153323 * esp_20 = fp - 0x20;
	if (eax == 0x00)
	{
		edi_262 = null;
		goto l0073D3E7;
	}
	byte * edi_24 = &g_b8DCAA0;
	word32 ecx_25 = 11;
	bool v23_346 = false;
	while (ecx_25 != 0x00)
	{
		v23_346 = *esi_499 != *edi_500;
		esi_17 = (word32) esi_499 + 1;
		edi_24 = edi_500 + 1;
		--ecx_25;
		esi_499 = esi_17;
		edi_500 = edi_24;
		if (*esi_499 == *edi_500)
			break;
	}
	if (v23_346)
	{
		if (dwArg08 <= 0x3FFFFFFF)
		{
			word32 ecx_489;
			Eq_3 eax_61 = fn006EC9B0(0x00, dwArg08 * 0x04, out ecx_489, out edx);
			if (eax_61 != 0x00)
			{
				word32 ecx_490;
				word32 esi_492;
				word32 edx_491;
				Eq_3 eax_252 = fn006ECC50(eax_61, out ecx_490, out edx_491, out esi_492);
				word32 edx_242 = dwArg04 + dwArg08;
				esp_20 = fp - 0x20;
				Eq_3 edi_103 = eax_252;
				if (dwArg04 < edx_242)
				{
					do
					{
						if (*ebx_105 == 0x5C)
						{
							*edi_103 = 0x5C;
							ebx_105 = (word32) ebx_105 + 1;
							esp_20[9] = (struct Eq_153323) ebx_105;
							edi_103 = (word32) edi_103 + 1;
							if ((*ebx_105 & 0x80) != 0x00)
							{
								*edi_103 = g_t8DCA98;
								*((word32) edi_103 + 4) = g_w8DCA9C;
								edi_103 = (word32) edi_103 + 5;
							}
						}
						ci8 al_107 = *ebx_105;
						if (al_107 < 0x00)
						{
							struct Eq_153503 * esp_118 = esp_20 - 4;
							esp_118->ptr0000 = &g_t8DCA8C;
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							Eq_3 stackArg4 = <invalid>;
							struct Eq_153506 * eax_128 = fn0073D240((const char *) &esp_118->ptr001C + 0x0C, edx, stackArg4, out edx);
							esp_118->ptr001C = eax_128;
							if (eax_128 == null)
							{
								struct Eq_153506 * eax_139 = esp_118->ptr0014;
								word32 v21_140 = eax_139->dw0000 + ~0x00;
								eax_139->dw0000 = v21_140;
								if (v21_140 == 0x00)
								{
									struct Eq_153629 * ecx_144 = eax_139->ptr0004;
									<anonymous> * edx_145 = ecx_144->ptr0018;
									esp_118->ptr0000 = eax_139;
									edx_145();
								}
								goto l0073D41C;
							}
							esp_118->ptr0000 = eax_128;
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							Eq_3 stackArg4 = <invalid>;
							word32 esi_497;
							word32 edx_496;
							word32 ecx_495;
							Eq_3 eax_173 = fn006ECC50(stackArg4, out ecx_495, out edx_496, out esi_497);
							esp_118->ptrFFFFFFFC = eax_128;
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							Eq_3 stackArg4 = <invalid>;
							Eq_3 eax_182 = fn006ECC00(stackArg4);
							Eq_3 esi_189 = 0x00;
							if (eax_182 > 0x00)
							{
								do
								{
									word32 eax_197 = CONVERT(Mem195[esi_189 + eax_173:byte], byte, word32);
									esp_118->ptr0000 = (word32) *((word32) eax_173 + ((word32) esi_189 + 1));
									esp_118->ptrFFFFFFFC = eax_197;
									esp_118->tFFFFFFF8.u0 = 0x008DCA80;
									esp_118->tFFFFFFF4 = edi_103;
									sprintf(esp_118->tFFFFFFF4, esp_118->tFFFFFFF8, esp_118->ptrFFFFFFFC, esp_118->ptr0000);
									esi_189 = (word32) esi_189 + 2;
									edi_103 = (word32) edi_103 + 6;
								} while (esi_189 < eax_182);
							}
							struct Eq_153506 * eax_217 = esp_118->ptr001C;
							word32 v20_218 = eax_217->dw0000 + ~0x00;
							eax_217->dw0000 = v20_218;
							esp_20 = (struct Eq_153323 *) ((const char *) &esp_118->ptr0000 + 4);
							if (v20_218 == 0x00)
							{
								struct Eq_153629 * ecx_222 = eax_217->ptr0004;
								<anonymous> * edx_223 = ecx_222->ptr0018;
								esp_118->ptr0000 = eax_217;
								word32 esp_232;
								word32 edx_235;
								edx_223();
								esp_20 = esp_232 + 0x04;
							}
							edx_242 = esp_20[5];
							ebx_105 = esp_20[9];
						}
						else
						{
							*edi_103 = al_107;
							ebx_105 = (word32) ebx_105 + 1;
							esp_20[9] = (struct Eq_153323) ebx_105;
							edi_103 = (word32) edi_103 + 1;
						}
					} while (ebx_105 < edx_242);
					eax_252 = esp_20[7];
				}
				ebp_12 = edi_103 - eax_252;
				edi_262 = (struct Eq_153319 *) esp_20[4];
				ebx_105 = eax_252;
l0073D3E7:
				Eq_3 eax_291;
				byte * edx_293;
				struct Eq_153338 * esp_271 = esp_20 - 4;
				esp_271->dw0000 = 0x00;
				esp_271->tFFFFFFFC = ebp_12;
				esp_271->tFFFFFFF8 = ebx_105;
				if (esp_20[11] != 0x00)
				{
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_3 stackArg4 = <invalid>;
					eax_291 = fn00719870(stackArg4, dwArg04, out edx_293);
				}
				else
				{
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_3 stackArg4 = <invalid>;
					eax_291 = fn00718F10(stackArg4, dwArg04, out edx_293);
				}
				struct Eq_153393 * esp_302 = esp_20 - 0x0C;
				if (edi_262 != null)
				{
					word32 v15_311 = edi_262->dw0000 + ~0x00;
					edi_262->dw0000 = v15_311;
					if (v15_311 == 0x00)
					{
						struct Eq_153446 * eax_315 = edi_262->ptr0004;
						<anonymous> * ecx_316 = eax_315->ptr0018;
						esp_302->ptr0008 = edi_262;
						ecx_316();
					}
				}
				edxOut = edx_293;
				return eax_291;
			}
		}
l0073D41C:
		edxOut = edx;
		return 0x00;
	}
	else
	{
		edi_262 = null;
		goto l0073D3E7;
	}
}

// 0073D450: Register Eq_3 fn0073D450(Register Eq_3 eax, Stack Eq_3 dwArg04, Register out ptr32 edxOut)
// Called from:
//      fn0073D660
Eq_3 fn0073D450(Eq_3 eax, Eq_3 dwArg04, ptr32 & edxOut)
{
	Eq_3 esi_15 = (word32) *eax;
	Eq_3 ebx_14 = eax;
	word32 edi_121 = 0x00;
	word32 dwLoc04_545 = 0x00;
	if (isalpha(esi_15) != 0x00 || esi_15 == 0x5F)
	{
		if (esi_15 == 117 || esi_15 == 0x55)
		{
			esi_15 = (int32) *((word32) eax + 1);
			ebx_14 = (word32) eax + 1;
			edi_121 = 0x01;
		}
		if (esi_15 == 114 || esi_15 == 0x52)
		{
			esi_15 = (int32) *((word32) ebx_14 + 1);
			ebx_14 = (word32) ebx_14 + 1;
			dwLoc04_545 = 0x01;
		}
	}
	if (esi_15 != 0x27 && esi_15 != 0x22)
	{
		ptr32 edx_517;
		fn006E1DC0(out edx_517);
		edxOut = edx_517;
		return 0x00;
	}
	Eq_3 ebx_110 = (word32) ebx_14 + 1;
	Eq_3 ebp_80 = ebx_110;
	do
	{
		ebp_80 = (word32) ebp_755 + 1;
		ebp_755 = ebp_80;
	} while (*ebp_755 != 0x00);
	Eq_153721 ebp_91 = ebp_80 - ((word32) ebx_110 + 1);
	if (ebp_91 > 0x7FFFFFFF)
	{
		ptr32 edx_481;
		word32 ecx_753;
		fn006E0F80(g_tA18598, 0x008DCAAC, out ecx_753, out edx_481);
		edxOut = edx_481;
		return 0x00;
	}
	Eq_3 ebp_115 = ebp_91 - 0x01;
	if (CONVERT(Mem79[ebx_110 - 0x01 + ebp_91:byte], byte, int32) != esi_15)
	{
		ptr32 edx_456;
		fn006E1DC0(out edx_456);
		edxOut = edx_456;
		return 0x00;
	}
	ptr32 edx_318;
	if (ebp_91 >= 0x05 && ((int32) (*ebx_110) == esi_15 && (int32) (*((word32) ebx_110 + 1)) == esi_15))
	{
		ebx_110 += 0x02;
		if (CONVERT(Mem79[ebx_110 - 0x01 + (ebp_91 - 0x01):byte], byte, int32) != esi_15)
		{
l0073D554:
			fn006E1DC0(out edx_318);
			goto l0073D566;
		}
		ebp_115 = ebp_91 - 0x05;
		if (CONVERT(Mem79[ebx_110 + 0x01 + (ebp_91 - 0x04):byte], byte, int32) != esi_15)
			goto l0073D554;
	}
	if (edi_121 != 0x00 || g_dwA6C618 != edi_121)
	{
		ptr32 edx_162;
		Eq_3 eax_161 = fn0073D2A0(dwArg04, ebx_110, ebp_115, out edx_162);
		edxOut = edx_162;
		return eax_161;
	}
	word32 esi_219;
	if (dwArg04 != 0x00)
	{
		byte * edi_181 = &g_t8D9880;
		Eq_3 esi_182 = dwArg04;
		word32 ecx_183 = 0x06;
		bool v21_532 = true;
		while (ecx_183 != 0x00)
		{
			v21_532 = *esi_756 == *edi_757;
			esi_182 = (word32) esi_756 + 1;
			edi_181 = edi_757 + 1;
			--ecx_183;
			esi_756 = esi_182;
			edi_757 = edi_181;
			if (*esi_756 == *edi_757)
				break;
		}
		if (!v21_532)
		{
			Eq_3 esi_201 = dwArg04;
			byte * edi_202 = &g_b8DCAA0;
			word32 ecx_203 = 11;
			bool v25_536 = true;
			while (ecx_203 != 0x00)
			{
				v25_536 = *esi_758 == *edi_759;
				esi_201 = (word32) esi_758 + 1;
				edi_202 = edi_759 + 1;
				--ecx_203;
				esi_758 = esi_201;
				edi_759 = edi_202;
				if (*esi_758 == *edi_759)
					break;
			}
			if (!v25_536)
			{
				esi_219 = 0x01;
l0073D5B7:
				if (dwLoc04_545 == 0x00 && strchr(ebx_110, 0x5C) != null)
				{
					ptr32 edx_390;
					Eq_3 eax_389 = fn006F2090(ebx_110, ebp_115, 0x00 - (esi_219 == 0x00) & dwArg04, out edx_390);
					edxOut = edx_390;
					return eax_389;
				}
				if (esi_219 == 0x00)
				{
					ptr32 edx_294;
					word32 ecx_754;
					Eq_3 eax_293 = fn006EC9B0(ebx_110, ebp_115, out ecx_754, out edx_294);
					edxOut = edx_294;
					return eax_293;
				}
				Eq_3 eax_317 = fn0071FC80(out edx_318);
				if (eax_317 != 0x00)
				{
					word32 ecx_334;
					ptr32 edx_336;
					Eq_3 eax_335 = fn0071FB20(eax_317, dwArg04, 0x00, out ecx_334, out edx_336);
					word32 v16_340 = (word32) *eax_317 - 1;
					*eax_317 = v16_340;
					if (v16_340 == 0x00)
					{
						Eq_3 edx_345 = *((word32) eax_317 + 4);
						<anonymous> * eax_346 = *((word32) edx_345 + 24);
						eax_346();
					}
					edxOut = edx_336;
					return eax_335;
				}
l0073D566:
				edxOut = edx_318;
				return 0x00;
			}
		}
	}
	esi_219 = 0x00;
	goto l0073D5B7;
}

// 0073D660: Register Eq_3 fn0073D660(Register Eq_3 ebx, Stack Eq_3 dwArg04, Register out ptr32 edxOut)
// Called from:
//      fn0073E050
Eq_3 fn0073D660(Eq_3 ebx, Eq_3 dwArg04, ptr32 & edxOut)
{
	ptr32 edx_142;
	Eq_3 eax_219 = fn0073D450(*((word32) *((word32) ebx + 20) + 4), *dwArg04, out edx_142);
	if (eax_219 != 0x00)
	{
		word32 dwLoc04_311 = 0x02;
		if (*((word32) ebx + 16) > 0x01)
		{
			int32 ebp_240 = 0x18;
			do
			{
				Eq_3 eax_54 = fn0073D450((word32) *((word32) ebx + 20) + 4 + ebp_240, *dwArg04, out edx_142);
				if (eax_54 == 0x00)
				{
					if (eax_219 != 0x00)
					{
						*eax_219.u0 = (word32) *eax_219.u0 - 1;
						if (*eax_219.u0 == 0x00)
						{
							Eq_3 ecx_73 = *((word64) eax_219.u0 + 4);
							(*((word32) ecx_73 + 24))();
						}
					}
l0073D795:
					eax_219.u0 = 0x00;
					goto l0073D797;
				}
				Eq_3 eax_145;
				bool v21_259;
				if (*((word32) eax_219 + 4) != 0x00A1B450)
				{
					word32 edx_376;
					word32 ecx_375;
					if (fn006D5670(*((word32) eax_219 + 4), 0x00A1B450, out ecx_375, out edx_376) != 0x00)
						goto l0073D6E2;
					goto l0073D6FE;
				}
l0073D6E2:
				Eq_3 eax_105 = *((word32) eax_54 + 4);
				if (eax_105 != 0x00A1B450)
				{
					word32 edx_378;
					word32 ecx_377;
					if (fn006D5670(eax_105, 0x00A1B450, out ecx_377, out edx_378) != 0x00)
						goto l0073D745;
l0073D6FE:
					Eq_3 eax_162 = fn00721290(eax_219, dwArg04, out edx_142);
					word32 v14_168 = (word32) *eax_54 - 1;
					*eax_54 = v14_168;
					struct Eq_153996 * esp_167 = fp - 0x14;
					if (v14_168 == 0x00)
					{
						Eq_3 edx_173 = *((word32) eax_54 + 4);
						word32 esp_177;
						(*((word32) edx_173 + 24))();
						esp_167 = esp_177 + 0x04;
					}
					Eq_3 eax_187 = esp_167->t000C;
					*eax_187 = (word32) *eax_187 - 1;
					Eq_3 eax_190 = esp_167->t000C;
					if (*eax_190 == 0x00)
					{
						Eq_3 ecx_193 = *((word32) eax_190 + 4);
						Eq_3 edx_194 = *((word32) ecx_193 + 24);
						esp_167->tFFFFFFFC = eax_190;
						word32 esp_202;
						edx_194();
						esp_167 = esp_202 + 0x04;
					}
					esp_167->t000C = eax_162;
					eax_145 = eax_162;
					v21_259 = eax_162 == 0x00;
				}
				else
				{
l0073D745:
					edx_142 = fn006EC4C0(fp - 0x08, dwArg04);
					eax_145 = eax_219;
					v21_259 = eax_219 == 0x00;
				}
				if (v21_259)
					goto l0073D795;
				ebp_240 += 0x18;
				dwLoc04_311 = dwLoc04_379 + 0x01;
				dwLoc04_379 = dwLoc04_311;
			} while (dwLoc04_379 + 0x00 < *((word32) ebx + 16));
			edxOut = edx_142;
			return eax_145;
		}
	}
l0073D797:
	edxOut = edx_142;
	return eax_219;
}

// 0073D7A0: Register Eq_3 fn0073D7A0(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Register out (ptr32 word16) edxOut)
// Called from:
//      fn0073E050
Eq_3 fn0073D7A0(Eq_3 dwArg04, Eq_3 dwArg08, word16 & edxOut)
{
	word16 * edx_22;
	Eq_3 eax_20 = fn0073E7A0(*((word32) dwArg08 + 20), out edx_22);
	if (eax_20 != 0x00)
	{
		word16 * edx_37;
		Eq_3 eax_35 = fn0073C440(dwArg08, out edx_37);
		if (eax_35 != ~0x00)
		{
			Eq_3 eax_50 = fn00752E30(eax_35, out edx_37);
			if (eax_50 != 0x00)
			{
				Eq_154144 edi_179 = (word32) *((word32) dwArg08 + 20) + 24;
				word32 dwLoc18_472 = 0x01;
				if (eax_35 > 0x00)
				{
					word32 * dwLoc14_473 = (word32) eax_50 + 4;
					do
					{
						struct Eq_154186 * ebx_73 = *((word32) edi_179 + 20);
						word16 * edx_103;
						Eq_3 eax_86 = fn0073C7D0((const char *) ebx_73 + 24, dwArg04, dwArg04, out edx_103);
						if (eax_86 == 0x00 || fn0073C790((word32) (*((word32) edi_179 + 20)) + 72, out edx_103) == 0x00)
						{
l0073D9A9:
							edxOut = edx_103;
							return 0x00;
						}
						struct Eq_154184 * dwLoc1C_493;
						struct Eq_154184 * ebp_148;
						if (ebx_73->dw0028 == 0x01)
						{
							struct Eq_154184 * eax_161 = fn00744110(*((word32) eax_86 + 4), dwArg04, dwArg08, out edx_103);
							ebp_148 = eax_161;
							dwLoc1C_493 = eax_161;
						}
						else
						{
							word32 edx_630;
							struct Eq_154184 * eax_142 = fn00744110(fn00743FC0(eax_86, dwArg04, dwArg08, *((word32) edi_179 + 0x0C), out edx_630), dwArg04, dwArg08, out edx_103);
							dwLoc1C_493 = eax_142;
							ebp_148 = eax_142;
						}
						if (ebp_148 == null)
							goto l0073D9A9;
						if (*((word32) edi_179 + 16) == 0x05)
						{
							struct Eq_154234 * edi_178 = *((word32) edi_179 + 20);
							edi_179 = (const char *) edi_178 + 96 + 20;
							struct Eq_154242 * eax_181 = &edi_178->ptr0074;
							Eq_3 esi_182 = 0x00;
							if (*edi_178->ptr0074 == 332)
							{
l0073D8E6:
								Eq_3 eax_229 = fn00752E30(esi_182, out edx_103);
								if (eax_229 == 0x00)
									goto l0073D9A9;
								Eq_3 ebx_239 = 0x00;
								if (esi_182 > 0x00)
								{
									word32 * ebp_242 = (word32) eax_229 + 4;
									do
									{
										edi_179 = *edi_179;
										Eq_3 eax_261 = fn0073E7A0(dwArg04, out edx_103);
										if (eax_261 == 0x00)
											goto l0073D9A9;
										*ebp_242 = (word32) eax_261;
										if (*((word32) edi_179 + 16) == 0x03)
											edi_179 = (word32) *((word32) edi_179 + 20) + 48;
										ebx_239 = (word32) ebx_239 + 1;
										++ebp_242;
									} while (ebx_239 < esi_182);
									ebp_148 = dwLoc1C_493;
								}
								if (*edi_179 == 331)
									edi_179 = *((word32) edi_179 + 20);
								ebp_148->t0008 = eax_229;
								goto l0073D959;
							}
							do
							{
								struct Eq_154264 * eax_188 = eax_181->dw0000;
								esi_182 = (word32) esi_182 + 1;
								if (eax_188->dw0010 == 0x02)
									break;
								struct Eq_154263 * eax_194 = eax_188->ptr0014;
								edx_103 = eax_194->ptr0044;
								eax_181 = (struct Eq_154242 *) &eax_194->ptr0044;
							} while (*edx_103 != 332);
							if (esi_182 != ~0x00)
								goto l0073D8E6;
							goto l0073D9A9;
						}
l0073D959:
						*dwLoc14_473 = ebp_148;
						dwLoc18_472 = dwLoc18_631 + 0x01;
						++dwLoc14_473;
						dwLoc18_631 = dwLoc18_472;
					} while (dwLoc18_631 + 0x00 < eax_35);
				}
				word16 * edx_359;
				Eq_3 eax_357 = fn00743A70(eax_20, dwArg04, dwArg08, *((word32) dwArg08 + 0x0C), out edx_359);
				edxOut = edx_359;
				return eax_357;
			}
		}
		edxOut = edx_37;
		return 0x00;
	}
	else
	{
		edxOut = edx_22;
		return eax_20;
	}
}

// 0073D9C0: Register Eq_3 fn0073D9C0(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Register out (ptr32 word16) edxOut)
// Called from:
//      fn0073DBD0
//      fn0073DF10
//      fn0073E050
Eq_3 fn0073D9C0(Eq_3 dwArg04, Eq_3 dwArg08, word16 & edxOut)
{
	Eq_3 ebp_299 = dwArg04;
	word16 * edx_22;
	Eq_3 eax_20 = fn0073E7A0(*((word32) dwArg08 + 20), out edx_22);
	if (eax_20 != 0x00)
	{
		word16 * edx_37;
		Eq_3 eax_35 = fn0073C4B0(dwArg08, out edx_37);
		if (eax_35 != ~0x00)
		{
			Eq_3 eax_50 = fn00752E30(eax_35, out edx_37);
			if (eax_50 != 0x00)
			{
				Eq_154373 edi_173 = (word32) *((word32) dwArg08 + 20) + 24;
				word32 dwLoc18_465 = 0x01;
				if (eax_35 > 0x00)
				{
					word32 * dwLoc14_466 = (word32) eax_50 + 4;
					do
					{
						struct Eq_154409 * esi_73 = *((word32) edi_173 + 20);
						word16 * edx_105;
						Eq_3 eax_85 = fn0073C7D0((const char *) esi_73 + 24, ebp_299, dwArg04, out edx_105);
						if (eax_85 == 0x00 || fn0073E7A0(dwArg04, out edx_105) == 0x00)
						{
l0073DBB8:
							edxOut = edx_105;
							return 0x00;
						}
						struct Eq_154184 * dwLoc1C_488;
						struct Eq_154184 * ebx_150;
						if (esi_73->dw0028 == 0x01)
						{
							struct Eq_154184 * eax_155 = fn00744110(*((word32) eax_85 + 4), dwArg04, dwArg08, out edx_105);
							ebx_150 = eax_155;
							dwLoc1C_488 = eax_155;
						}
						else
						{
							word32 edx_622;
							struct Eq_154184 * eax_144 = fn00744110(fn00743FC0(eax_85, dwArg04, dwArg08, *((word32) edi_173 + 0x0C), out edx_622), dwArg04, dwArg08, out edx_105);
							dwLoc1C_488 = eax_144;
							ebx_150 = eax_144;
						}
						if (ebx_150 == null)
							goto l0073DBB8;
						if (*((word32) edi_173 + 16) == 0x05)
						{
							struct Eq_154452 * edi_172 = *((word32) edi_173 + 20);
							edi_173 = (const char *) edi_172 + 96 + 20;
							edx_105 = edi_172->ptr0074;
							struct Eq_154463 * eax_175 = &edi_172->ptr0074;
							Eq_3 esi_176 = 0x00;
							if (*edx_105 == 335)
							{
l0073DAF6:
								Eq_3 eax_220 = fn00752E30(esi_176, out edx_105);
								if (eax_220 == 0x00)
									goto l0073DBB8;
								Eq_3 ebp_230 = 0x00;
								if (esi_176 > 0x00)
								{
									word32 * ebx_233 = (word32) eax_220 + 4;
									do
									{
										edi_173 = *edi_173;
										Eq_3 eax_251 = fn0073E7A0(dwArg04, out edx_105);
										if (eax_251 == 0x00)
											goto l0073DBB8;
										*ebx_233 = (word32) eax_251;
										if (*((word32) edi_173 + 16) == 0x03)
											edi_173 = (word32) *((word32) edi_173 + 20) + 48;
										ebp_230 = (word32) ebp_230 + 1;
										++ebx_233;
									} while (ebp_230 < esi_176);
									ebx_150 = dwLoc1C_488;
								}
								if (*edi_173 == 334)
									edi_173 = *((word32) edi_173 + 20);
								ebx_150->t0008 = eax_220;
								ebp_299 = dwArg04;
								goto l0073DB6C;
							}
							do
							{
								struct Eq_154479 * eax_181 = eax_175->dw0000;
								esi_176 = (word32) esi_176 + 1;
								if (eax_181->dw0010 == 0x02)
									break;
								struct Eq_154492 * eax_186 = eax_181->ptr0014;
								eax_175 = (struct Eq_154463 *) &eax_186->ptr0044;
							} while (*eax_186->ptr0044 != 335);
							if (esi_176 != ~0x00)
								goto l0073DAF6;
							goto l0073DBB8;
						}
l0073DB6C:
						*dwLoc14_466 = ebx_150;
						dwLoc18_465 = dwLoc18_623 + 0x01;
						++dwLoc14_466;
						dwLoc18_623 = dwLoc18_465;
					} while (dwLoc18_623 + 0x00 < eax_35);
				}
				word16 * edx_351;
				Eq_3 eax_349 = fn00743AD0(eax_20, dwArg04, dwArg08, *((word32) dwArg08 + 0x0C), out edx_351);
				edxOut = edx_351;
				return eax_349;
			}
		}
		edxOut = edx_37;
		return 0x00;
	}
	else
	{
		edxOut = edx_22;
		return eax_20;
	}
}

// 0073DBD0: Register Eq_3 fn0073DBD0(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Stack Eq_3 dwArg0C, Register out ptr32 edxOut)
// Called from:
//      fn0073DF70
//      fn0073E390
Eq_3 fn0073DBD0(Eq_3 dwArg04, Eq_3 dwArg08, Eq_3 dwArg0C, ptr32 & edxOut)
{
	ptr32 edx_107;
	Eq_3 eax_18 = *((word32) dwArg08 + 16);
	int32 edx_129 = 0x00;
	word32 ebx_132 = 0x00;
	Eq_3 ebp_130 = 0x00;
	Eq_3 dwLoc08_593 = 0x00;
	Eq_3 dwLoc0C_594 = 0x00;
	if (eax_18 > 0x00)
	{
		Eq_3 ecx_26 = *((word32) dwArg08 + 20);
		do
		{
			if (*ecx_26 == 330)
			{
				if (*((word32) ecx_26 + 16) == 0x01)
					++ebx_132;
				else if (*((word32) *((word32) ecx_26 + 20) + 24) == 335)
					++edx_129;
				else
					ebp_130 = (word32) ebp_130 + 1;
			}
			ecx_26 = (word32) ecx_26 + 24;
			--eax_18;
		} while (eax_18 != 0x00);
		if (edx_129 > 0x01 || edx_129 != 0x00 && (ebx_132 != 0x00 || ebp_130 != 0x00))
		{
			word32 esi_862;
			Eq_3 eax_90 = fn006EA200(out edx_107, out esi_862);
			if (eax_90 != 0x00)
			{
				word32 ecx_863;
				fn006E0E90(g_tA178F4, eax_90, out ecx_863, out edx_107);
				word32 v16_113 = (word32) *eax_90 - 1;
				*eax_90 = v16_113;
				if (v16_113 == 0x00)
				{
					Eq_3 edx_117 = *((word32) eax_90 + 4);
					(*((word32) edx_117 + 24))();
				}
			}
			goto l0073DEFD;
		}
	}
	if ((word32) ebp_130 + edx_129 + ebx_132 > 0xFF)
	{
		word32 esi_860;
		Eq_3 eax_522 = fn006EA200(out edx_107, out esi_860);
		if (eax_522 != 0x00)
		{
			word32 ecx_861;
			fn006E0E90(g_tA178F4, eax_522, out ecx_861, out edx_107);
			word32 v14_545 = (word32) *eax_522 - 1;
			*eax_522 = v14_545;
			if (v14_545 == 0x00)
			{
				Eq_3 eax_562 = *((word32) eax_522 + 4);
				ptr32 edx_568;
				(*((word32) eax_562 + 24))();
				edxOut = edx_568;
				return 0x00;
			}
		}
	}
	else
	{
		Eq_3 esi_138 = dwArg04;
		Eq_3 eax_149 = fn00752E30(edx_129 + ebx_132, out edx_107);
		if (eax_149 != 0x00)
		{
			Eq_3 eax_166 = fn00752E30(ebp_130, out edx_107);
			Eq_3 ebp_171 = 0x00;
			if (eax_166 != 0x00)
			{
				ui32 dwLoc1C_686 = 0x00;
				Eq_3 dwLoc18_687 = 0x00;
				if (*((word32) dwArg08 + 16) > 0x00)
				{
					word32 edi_180 = 0x00;
					word32 dwLoc14_688 = 0x00;
					word32 * dwLoc20_689 = (word32) eax_149 + 4;
					do
					{
						struct Eq_154704 * ebx_190 = (word32) *((word32) dwArg08 + 20) + edi_180;
						word16 ax_192 = ebx_190->w0000;
						if (ax_192 == 330)
						{
							Eq_3 eax_395;
							if (ebx_190->dw0010 == 0x01)
							{
								if (dwLoc1C_686 != 0x00)
								{
									ptr32 edx_406;
									fn0073B830(out edx_406);
									edxOut = edx_406;
									return 0x00;
								}
								eax_395 = fn0073E7A0(dwArg04, out edx_107);
								goto l0073DD38;
							}
							if (ebx_190->ptr0014->w0018 == 335)
							{
								eax_395 = fn0073D9C0(esi_138, dwArg04, out edx_107);
l0073DD38:
								if (eax_395 == 0x00)
									goto l0073DEFD;
								*dwLoc20_689 = (word32) eax_395;
								++dwLoc20_689;
							}
							else
							{
								Eq_3 eax_245 = fn0073E7A0(dwArg04, out edx_107);
								if (eax_245 == 0x00)
									goto l0073DEFD;
								word32 ecx_254 = *eax_245;
								if (ecx_254 == 0x04)
								{
									ptr32 edx_261;
									fn0073B830(out edx_261);
									edxOut = edx_261;
									return 0x00;
								}
								if (ecx_254 != 0x11)
								{
									ptr32 edx_282;
									fn0073B830(out edx_282);
									edxOut = edx_282;
									return 0x00;
								}
								Eq_3 ebp_297 = *((word32) eax_245 + 4);
								byte * edi_299 = &g_b8ABDD0;
								byte * esi_300 = (word32) ebp_297 + 20;
								word32 ecx_301 = 0x05;
								bool v21_584 = true;
								while (ecx_301 != 0x00)
								{
									v21_584 = *esi_866 == *edi_867;
									esi_300 = esi_866 + 1;
									edi_299 = edi_867 + 1;
									--ecx_301;
									esi_866 = esi_300;
									edi_867 = edi_299;
									if (*esi_866 == *edi_867)
										break;
								}
								if (v21_584)
								{
									ptr32 edx_330;
									fn0073B830(out edx_330);
									edxOut = edx_330;
									return 0x00;
								}
								esi_138 = dwArg04;
								if (fn0073E7A0(dwArg04, out edx_107) == 0x00)
									goto l0073DEFD;
								Eq_3 eax_373 = fn00744200(ebp_297, dwArg04, out edx_107);
								if (eax_373 == 0x00)
									goto l0073DEFD;
								*((word32) eax_166 + (dwLoc1C_686 * 0x04 + 4)) = eax_373;
								ebp_171 = dwLoc18_687;
								edi_180 = dwLoc14_688;
								++dwLoc1C_686;
							}
							goto l0073DE17;
						}
						if (ax_192 == 0x10)
						{
							word32 edx_864;
							dwLoc08_593 = fn0073E7A0(dwArg04, out edx_864);
							goto l0073DE0E;
						}
						if (ax_192 == 0x24)
						{
							word32 edx_865;
							dwLoc0C_594 = fn0073E7A0(dwArg04, out edx_865);
l0073DE0E:
							ebp_171 = (word32) ebp_171 + 1;
							edi_180 += 0x18;
						}
l0073DE17:
						ebp_171 = (word32) ebp_171 + 1;
						edi_180 += 0x18;
						dwLoc18_687 = ebp_171;
						dwLoc14_688 = edi_180;
					} while (ebp_171 < *((word32) dwArg08 + 16));
				}
				ptr32 edx_498;
				Eq_3 eax_497 = fn00743BE0(dwArg0C, dwArg04, dwArg08, dwLoc08_593, dwLoc0C_594, *((word32) dwArg0C + 24), *((word32) dwArg0C + 28), out edx_498);
				edxOut = edx_498;
				return eax_497;
			}
		}
	}
l0073DEFD:
	edxOut = edx_107;
	return 0x00;
}

// 0073DF10: Register Eq_3 fn0073DF10(Register Eq_3 eax, Register Eq_3 esi, Register out ptr32 edxOut)
// Called from:
//      fn0073E050
Eq_3 fn0073DF10(Eq_3 eax, Eq_3 esi, ptr32 & edxOut)
{
	Eq_3 eax_9 = *((word32) eax + 16);
	if (eax_9 <= 0x01 || *((word32) (*((word32) eax + 20)) + 24) != 335)
	{
		if (eax_9 != 0x01)
		{
			ptr32 edx_30;
			Eq_3 eax_28 = fn0073C090(eax, esi, out edx_30);
			if (eax_28 != 0x00)
			{
				ptr32 edx_53;
				Eq_3 eax_51 = fn00743FC0(eax_28, 0x01, *((word32) eax + 8), *((word32) eax + 0x0C), out edx_53);
				edxOut = edx_53;
				return eax_51;
			}
			else
			{
				edxOut = edx_30;
				return eax_28;
			}
		}
		else
		{
			ptr32 edx_71;
			Eq_3 eax_69 = fn0073E7A0(*((word32) eax + 20), out edx_71);
			edxOut = edx_71;
			return eax_69;
		}
	}
	else
	{
		ptr32 edx_85;
		Eq_3 eax_83 = fn0073D9C0(esi, eax, out edx_85);
		edxOut = edx_85;
		return eax_83;
	}
}

// 0073DF70: Register Eq_3 fn0073DF70(Register Eq_3 edi, Stack Eq_3 dwArg04, Register out ptr32 edxOut)
// Called from:
//      fn00740060
Eq_3 fn0073DF70(Eq_3 edi, Eq_3 dwArg04, ptr32 & edxOut)
{
	ptr32 edx_108;
	Eq_3 eax_19 = fn00752E30(*((word32) dwArg04 + 16), out edx_108);
	if (eax_19 != 0x00)
	{
		word32 dwLoc0C_212 = 0x01;
		if (*((word32) dwArg04 + 16) > 0x00)
		{
			word32 * dwLoc08_214 = (word32) eax_19 + 4;
			do
			{
				word32 esi_46 = Mem43[dwArg04 + 0x14:word32] + dwArg04;
				Eq_3 eax_106 = fn0073C280(esi_46->dw0014 + 0x18, edi, out edx_108);
				if (eax_106 == 0x00)
				{
l0073E03B:
					edxOut = edx_108;
					return 0x00;
				}
				word32 ecx_64 = esi_46->dw0010;
				if (ecx_64 != 0x03)
				{
					if (ecx_64 == 0x05)
						eax_106 = fn00743BE0(eax_106, dwArg04, 0x00, 0x00, 0x00, esi_46->t0008, esi_46->t000C, out edx_108);
					else
						eax_106 = fn0073DBD0(edi, dwArg04, eax_106, out edx_108);
					if (eax_106 != 0x00)
						goto l0073E00E;
					goto l0073E03B;
				}
l0073E00E:
				*dwLoc08_214 = (word32) eax_106;
				dwLoc0C_212 = dwLoc0C_261 + 0x01;
				++dwLoc08_214;
				dwLoc0C_261 = dwLoc0C_212;
			} while (dwLoc0C_261 + 0x00 < *((word32) dwArg04 + 16));
		}
		edxOut = edx_108;
		return eax_19;
	}
	else
	{
		edxOut = edx_108;
		return 0x00;
	}
}

// 0073E050: Register Eq_3 fn0073E050(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Register out ptr32 edxOut)
// Called from:
//      fn0073E590
//      fn0073E6E0
Eq_3 fn0073E050(Eq_3 dwArg04, Eq_3 dwArg08, ptr32 & edxOut)
{
	ptr32 edx_120;
	Eq_3 edi_19 = *((word32) dwArg08 + 20);
	struct Eq_155050 * ecx_20 = (int32) *edi_19;
	if (ecx_20 <= (struct Eq_155050 *) 0x1A)
	{
		switch ((word32) ecx_20->b73E36B)
		{
		case 0x00:
			Eq_3 ebx_570 = *((word32) dwArg04 + 4);
			word32 ecx_851;
			word32 edx_852;
			Eq_3 eax_575 = fn006F1A70(out ecx_851, out edx_852);
			fn00740DF0(ebx_570, dwArg04);
			ptr32 edx_606;
			Eq_3 eax_605 = fn00743EE0(eax_575, dwArg04, dwArg08, *((word32) dwArg08 + 0x0C), out edx_606);
			edxOut = edx_606;
			return eax_605;
		case 0x01:
			Eq_3 eax_508 = fn0073D140(*((word32) edi_19 + 4), out edx_120);
			if (eax_508 != 0x00)
			{
				fn00740DF0(*((word32) dwArg04 + 4), dwArg04);
				ptr32 edx_555;
				Eq_3 eax_554 = fn00743CC0(eax_508, dwArg04, dwArg08, out edx_555);
				edxOut = edx_555;
				return eax_554;
			}
			break;
		case 0x02:
			Eq_3 eax_457 = fn0073D660(dwArg08, dwArg04, out edx_120);
			if (eax_457 != 0x00)
			{
				fn00740DF0(*((word32) dwArg04 + 4), dwArg04);
				ptr32 edx_491;
				Eq_3 eax_490 = fn00743D20(eax_457, dwArg04, dwArg08, out edx_491);
				edxOut = edx_491;
				return eax_490;
			}
			break;
		case 0x03:
		case 0x04:
		case 0x05:
		case 0x07:
		case 0x09:
		case 0x0A:
		case 11:
		case 0x0C:
		case 0x0D:
		case 0x0E:
		case 0x0F:
		case 0x10:
		case 0x11:
		case 0x12:
		case 0x13:
		case 0x14:
		case 0x15:
		case 22:
		case 0x17:
			goto l0073E32D;
		case 0x06:
			Eq_3 cx_323 = *((word32) edi_19 + 24);
			if (cx_323 == 0x08)
			{
				ptr32 edx_415;
				Eq_3 eax_414 = fn00743FC0(0x00, 0x01, *((word32) dwArg08 + 8), *((word32) dwArg08 + 0x0C), out edx_415);
				edxOut = edx_415;
				return eax_414;
			}
			if (cx_323 == 339)
			{
				ptr32 edx_385;
				Eq_3 eax_384 = fn0073E7A0((word32) edi_19 + 24, out edx_385);
				edxOut = edx_385;
				return eax_384;
			}
			if (*((word32) edi_19 + 40) <= 0x01 || *((word32) (*((word32) edi_19 + 44)) + 24) != 335)
			{
				ptr32 edx_343;
				Eq_3 eax_342 = fn0073DF10(eax, dwArg04, out edx_343);
				edxOut = edx_343;
				return eax_342;
			}
			else
			{
				ptr32 edx_364;
				Eq_3 eax_363 = fn0073D9C0(dwArg04, (word32) edi_19 + 24, out edx_364);
				edxOut = edx_364;
				return eax_363;
			}
		case 0x08:
			if (*((word32) edi_19 + 24) == 0x0A)
			{
				ptr32 edx_308;
				Eq_3 eax_307 = fn00743F60(0x00, 0x01, *((word32) dwArg08 + 8), *((word32) dwArg08 + 0x0C), out edx_308);
				edxOut = edx_308;
				return eax_307;
			}
			if (*((word32) edi_19 + 40) != 0x01 && *((word32) (*((word32) edi_19 + 44)) + 24) != 0x0C)
			{
				ptr32 edx_278;
				Eq_3 eax_277 = fn0073D7A0(dwArg04, (word32) edi_19 + 24, out edx_278);
				edxOut = edx_278;
				return eax_277;
			}
			Eq_3 eax_233 = fn0073C090((word32) edi_19 + 24, dwArg04, out edx_120);
			if (eax_233 != 0x00)
			{
				ptr32 edx_257;
				Eq_3 eax_256 = fn00743F60(eax_233, dwArg04, dwArg08, *((word32) dwArg08 + 0x0C), out edx_257);
				edxOut = edx_257;
				return eax_256;
			}
			break;
		case 0x18:
			Eq_3 eax_179 = fn0073C790((word32) edi_19 + 24, out edx_120);
			if (eax_179 != 0x00)
			{
				ptr32 edx_201;
				Eq_3 eax_200 = fn00743C60(eax_179, dwArg04, dwArg08, out edx_201);
				edxOut = edx_201;
				return eax_200;
			}
			break;
		case 0x19:
			int64 edx_eax_27 = (int64) ((word32) *((word32) edi_19 + 40) + 1);
			int32 eax_31 = (word32) edx_eax_27 + (SLICE(edx_eax_27, word32, 32) & 0x03);
			Eq_3 eax_42 = fn00752E30(eax_31 >> 0x02, out edx_120);
			if (eax_42 != 0x00)
			{
				Eq_3 eax_58 = fn00752E30(eax_31 >> 0x02, out edx_120);
				if (eax_58 != 0x00)
				{
					int32 ebx_130 = 0x00;
					if (*((word32) edi_19 + 40) > 0x00)
					{
						do
						{
							Eq_3 eax_88 = fn0073E7A0(dwArg04, out edx_120);
							if (eax_88 == 0x00)
								goto l0073E342;
							int64 edx_eax_98 = (int64) ebx_130;
							ui32 esi_106 = ((word32) edx_eax_98 + (SLICE(edx_eax_98, word32, 32) & 0x03) >> 0x02) * 0x02;
							*((word32) eax_42 + ((word32) (esi_106 * 0x02) + 4)) = eax_88;
							Eq_3 eax_119 = fn0073E7A0(dwArg04, out edx_120);
							if (eax_119 == 0x00)
								goto l0073E342;
							*((word32) eax_58 + ((word32) (esi_106 * 0x02) + 4)) = eax_119;
							ebx_130 += 0x04;
						} while (ebx_130 < *((word32) edi_19 + 40));
					}
					ptr32 edx_161;
					Eq_3 eax_160 = fn00743A30(eax_42, dwArg04, dwArg08, *((word32) dwArg08 + 0x0C), out edx_161);
					edxOut = edx_161;
					return eax_160;
				}
			}
			break;
		}
	}
	else
	{
l0073E32D:
		word32 ecx_850;
		fn006E15D0(g_tA18720, 9292696, out ecx_850, out edx_120);
	}
l0073E342:
	edxOut = edx_120;
	return 0x00;
}

// 0073E390: Register Eq_3 fn0073E390(Register Eq_3 eax, Register Eq_3 ecx, Register out Eq_155360 edxOut)
// Called from:
//      fn0073E6E0
Eq_3 fn0073E390(Eq_3 eax, Eq_3 ecx, union Eq_155360 & edxOut)
{
	Eq_3 edi_16 = *((word32) eax + 20);
	word16 ax_18 = *edi_16;
	if (ax_18 == 0x07)
	{
		if (*((word32) eax + 16) != 0x02)
		{
			Eq_155360 edx_378;
			Eq_3 eax_376 = fn0073DBD0(ecx, (word32) edi_16 + 24, dwArg04, out edx_378);
			edxOut = edx_378;
			return eax_376;
		}
		else
		{
			Eq_155360 edx_413;
			Eq_3 eax_411 = fn00743BE0(dwArg04, 0x00, 0x00, 0x00, 0x00, *((word32) eax + 8), *((word32) eax + 0x0C), out edx_413);
			edxOut = edx_413;
			return eax_411;
		}
	}
	if (ax_18 == 0x17)
	{
		Eq_3 ebp_311 = *((word32) ecx + 4);
		word32 ecx_587;
		word32 edx_588;
		Eq_3 eax_315 = fn006F1A70(out ecx_587, out edx_588);
		fn00740DF0(ebp_311, eax_315);
		Eq_155360 edx_350;
		Eq_3 eax_348 = fn00743D80(dwArg04, eax_315, 0x01, *((word32) eax + 8), *((word32) eax + 0x0C), out edx_350);
		edxOut = edx_350;
		return eax_348;
	}
	Eq_155360 edx_122;
	Eq_3 eax_185;
	int32 eax_28 = *((word32) edi_16 + 40);
	if (eax_28 == 0x01)
	{
		eax_185 = fn0073C520(*((word32) edi_16 + 44), ecx, out edx_122);
		if (eax_185 != 0x00)
			goto l0073E577;
	}
	else
	{
		int64 edx_eax_33 = (int64) (eax_28 + 0x01);
		word32 dwLoc04_431 = 0x01;
		Eq_3 eax_45 = fn00752E30((word32) edx_eax_33 - SLICE(edx_eax_33, word32, 32) >> 0x01, out edx_122);
		if (eax_45 != 0x00)
		{
			if (*((word32) edi_16 + 40) > 0x00)
			{
				word32 dwLoc08_487 = 0x00;
				int32 ebx_58 = 0x00;
				do
				{
					Eq_3 eax_71 = fn0073C520((word32) *((word32) edi_16 + 44) + dwLoc08_487, ecx, out edx_122);
					if (eax_71 == 0x00)
						goto l0073E555;
					if (*eax_71 != 0x04)
						dwLoc04_431 = 0x00;
					int64 edx_eax_89 = (int64) ebx_58;
					*((word32) eax_45 + (((word32) edx_eax_89 - SLICE(edx_eax_89, word32, 32) >> 0x01) * 0x04 + 4)) = eax_71;
					dwLoc08_487 += 0x30;
					ebx_58 += 0x02;
				} while (ebx_58 < *((word32) edi_16 + 40));
				if (dwLoc04_431 == 0x00)
				{
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_3 stackArg12 = <invalid>;
					Eq_3 stackArg16 = <invalid>;
					Eq_3 stackArg20 = <invalid>;
					Eq_155360 edx_231;
					Eq_3 eax_229 = fn00743E30(dwArg04, fn00744090(eax_45), stackArg12, stackArg16, stackArg20, out edx_231);
					edxOut = edx_231;
					return eax_229;
				}
			}
			Eq_3 eax_120 = fn00752E30(*eax_45, out edx_122);
			if (eax_120 != 0x00)
			{
				Eq_3 edx_130 = 0x00;
				struct Eq_155535 * (* ebx_131)[] = eax_45 - eax_120;
				word32 * ecx_133 = (word32) eax_120 + 4;
				while (edx_130 < *eax_45)
				{
					Mem195[ecx_133 + 0x00:word32] = Mem137[Mem137[ebx_131 + ecx_133:word32] + 0x04:word32];
					edx_130 = (word32) edx_130 + 1;
					++ecx_133;
				}
				Eq_3 eax_160 = fn00743FC0(eax_120, 0x01, *((word32) edi_16 + 32), *((word32) edi_16 + 36), out edx_122);
				if (eax_160 != 0x00)
				{
					word32 edx_595;
					eax_185 = fn007440C0(eax_160, out edx_595);
l0073E577:
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_3 stackArg12 = <invalid>;
					Eq_3 stackArg16 = <invalid>;
					Eq_3 stackArg20 = <invalid>;
					Eq_155360 edx_296;
					Eq_3 eax_294 = fn00743E30(dwArg04, eax_185, stackArg12, stackArg16, stackArg20, out edx_296);
					edxOut = edx_296;
					return eax_294;
				}
			}
		}
	}
l0073E555:
	edxOut = edx_122;
	return 0x00;
}

// 0073E590: Register Eq_3 fn0073E590(Register Eq_3 eax, Register out ptr32 edxOut)
// Called from:
//      fn0073E7A0
Eq_3 fn0073E590(Eq_3 eax, ptr32 & edxOut)
{
	ptr32 edx_171;
	Eq_3 eax_16 = *((word32) eax + 20);
	if (*eax_16 == 0x0F && (*((word32) eax + 16) == 0x02 && (*((word32) eax_16 + 24) == 0x013B && *((word32) eax_16 + 40) == 0x01)))
	{
		Eq_3 ecx_29 = *((word32) eax_16 + 44);
		if (*ecx_29 == 0x013C && *((word32) ecx_29 + 16) == 0x01)
		{
			Eq_3 ebx_34 = *((word32) ecx_29 + 20);
			if (*ebx_34 == 0x013D)
			{
				Eq_3 edi_37 = *((word32) ebx_34 + 20);
				if (*edi_37 == 0x02)
				{
					Eq_3 eax_177 = *((word32) edi_37 + 4);
					eax_179 = eax_177;
					do
					{
						Eq_3 eax_179;
						eax_179 = (word32) eax_372 + 1;
						eax_372 = eax_179;
					} while (*eax_372 != 0x00);
					word32 ecx_368;
					Eq_3 eax_193 = fn00723860(eax_179 - ((word32) eax_177 + 1) + 0x02, out ecx_368, out edx_171);
					if (eax_193 != 0x00)
					{
						*eax_193 = 0x2D;
						Eq_3 ecx_220 = *((word32) edi_37 + 4);
						byte * edx_221 = (word32) eax_193 + 1;
						do
						{
							byte al_224 = *ecx_220;
							*edx_221 = al_224;
							ecx_220 = (word32) ecx_220 + 1;
							++edx_221;
						} while (al_224 != 0x00);
						word32 edx_370;
						word32 ecx_369;
						fn007239C0(*((word32) edi_37 + 4), out ecx_369, out edx_370);
						*((word32) edi_37 + 4) = eax_193;
						ptr32 edx_258;
						Eq_3 eax_257 = fn0073E050(dwArg04, ebx_34, out edx_258);
						edxOut = edx_258;
						return eax_257;
					}
l0073E67C:
					edxOut = edx_171;
					return 0x00;
				}
			}
		}
	}
	if (fn0073E7A0((word32) eax_16 + 24, out edx_171) != 0x00)
	{
		int32 edx_64 = (int32) **((word32) eax + 20);
		if (edx_64 == 0x0E)
		{
			ptr32 edx_84;
			Eq_3 eax_83 = fn00743880(0x03, dwArg04, *((word32) eax + 8), *((word32) eax + 0x0C), out edx_84);
			edxOut = edx_84;
			return eax_83;
		}
		if (edx_64 == 0x0F)
		{
			ptr32 edx_116;
			Eq_3 eax_115 = fn00743880(0x04, dwArg04, *((word32) eax + 8), *((word32) eax + 0x0C), out edx_116);
			edxOut = edx_116;
			return eax_115;
		}
		if (edx_64 == 0x20)
		{
			ptr32 edx_148;
			Eq_3 eax_147 = fn00743880(0x01, dwArg04, *((word32) eax + 8), *((word32) eax + 0x0C), out edx_148);
			edxOut = edx_148;
			return eax_147;
		}
		word32 ecx_371;
		fn006E15D0(g_tA18720, dwArg04, out ecx_371, out edx_171);
	}
	goto l0073E67C;
}

// 0073E6E0: Register Eq_3 fn0073E6E0(Register Eq_3 edi, Register out Eq_155778 edxOut)
// Called from:
//      fn0073E7A0
Eq_3 fn0073E6E0(Eq_3 edi, union Eq_155778 & edxOut)
{
	Eq_155778 edx_18;
	Eq_3 eax_16 = fn0073E050(dwArg04, *((word32) edi + 20), out edx_18);
	Eq_3 esi_124 = eax_16;
	if (eax_16 == 0x00)
	{
		edxOut = edx_18;
		return eax_16;
	}
	Eq_3 eax_26 = *((word32) edi + 16);
	if (eax_26 == 0x01)
	{
		edxOut = edx_18;
		return eax_16;
	}
	Eq_155778 edx_117;
	Eq_3 ebx_32 = 0x01;
	if (eax_26 > 0x01)
	{
		int32 ebp_38 = 0x18;
		while (*((word32) *((word32) edi + 20) + ebp_38) == 0x0141)
		{
			Eq_3 eax_54 = fn0073E390(eax, dwArg04, out edx_117);
			if (eax_54 == 0x00)
				goto l0073E790;
			*((word32) eax_54 + 24) = *((word32) esi_124 + 24);
			*((word32) eax_54 + 28) = *((word32) esi_124 + 28);
			ebx_32 = (word32) ebx_32 + 1;
			ebp_38 += 0x18;
			esi_124 = eax_54;
			if (ebx_32 >= *((word32) edi + 16))
				break;
		}
	}
	Eq_3 eax_74 = *((word32) edi + 16);
	edx_117 = eax_74 * 0x03;
	if ((*((word32) edi + 20) - 0x18)[eax_74].w0000 == 0x013B)
	{
		Eq_3 eax_90 = fn0073E7A0(dwArg04, out edx_117);
		if (eax_90 == 0x00)
		{
l0073E790:
			edxOut = edx_117;
			return 0x00;
		}
		Eq_3 eax_115 = fn007437D0(esi_124, dwArg04, eax_90, *((word32) edi + 8), *((word32) edi + 0x0C), out edx_117);
		if (eax_115 == 0x00)
			goto l0073E790;
		esi_124 = eax_115;
	}
	edxOut = edx_117;
	return esi_124;
}

// 0073E7A0: Register Eq_3 fn0073E7A0(Stack Eq_3 dwArg08, Register out (ptr32 word16) edxOut)
// Called from:
//      fn0073C090
//      fn0073C370
//      fn0073C3E0
//      fn0073C520
//      fn0073C680
//      fn0073C790
//      fn0073C7D0
//      fn0073D050
//      fn0073D7A0
//      fn0073D9C0
//      fn0073DBD0
//      fn0073DF10
//      fn0073E050
//      fn0073E590
//      fn0073E6E0
//      fn0073E7A0
//      fn0073EB20
//      fn0073EB70
//      fn0073EE40
//      fn0073EF40
//      fn0073F160
//      fn0073F220
//      fn0073F2C0
//      fn0073F5B0
//      fn0073F690
//      fn0073F9D0
//      fn0073FA50
//      fn0073FC30
Eq_3 fn0073E7A0(Eq_3 dwArg08, word16 & edxOut)
{
	word16 * edx_186;
	Eq_155875 eax_11 = (int32) *dwArg08;
	struct Eq_155880 * eax_15 = eax_11 - 0x012D;
	if (eax_11 <= 339)
	{
		Eq_3 ebx_24 = dwArg08;
		do
		{
			switch ((word32) eax_15->b73EAF0)
			{
			case 0x00:
			case 0x02:
				Eq_3 ecx_387 = *((word32) ebx_24 + 20);
				word16 ax_389 = *ecx_387;
				if (ax_389 == 0x0140 || ax_389 == 0x012E)
				{
					word16 * edx_408;
					Eq_3 eax_407 = fn0073C370(ecx_387, out edx_408);
					edxOut = edx_408;
					return eax_407;
				}
				else
				{
					if (*((word32) ebx_24 + 16) <= 0x01)
						goto l0073E7F2;
					word16 * edx_428;
					Eq_3 eax_427 = fn0073C3E0(ebx_24, out edx_428);
					edxOut = edx_428;
					return eax_427;
				}
			case 0x01:
			case 0x07:
			case 0x10:
			case 0x11:
			case 0x12:
			case 0x13:
			case 0x14:
			case 0x15:
			case 22:
			case 0x17:
			case 0x18:
			case 0x19:
			case 0x1A:
			case 0x1B:
			case 0x1C:
			case 0x1D:
			case 0x1E:
			case 0x1F:
			case 0x20:
			case 33:
			case 0x22:
			case 0x23:
			case 0x24:
			case 0x25:
				goto l0073EA08;
			case 0x03:
			case 0x04:
l0073E7F2:
				if (*((word32) ebx_24 + 16) != 0x01)
				{
					int64 edx_eax_493 = (int64) ((word32) *((word32) ebx_24 + 16) + 1);
					Eq_3 eax_504 = fn00752E30((word32) edx_eax_493 - SLICE(edx_eax_493, word32, 32) >> 0x01, out edx_186);
					if (eax_504 == 0x00)
						goto l0073EA20;
					Eq_3 esi_513 = 0x00;
					if (*((word32) ebx_24 + 16) > 0x00)
					{
						word32 edi_516 = 0x00;
						do
						{
							Eq_3 eax_536 = fn0073E7A0((word32) *((word32) ebx_24 + 20) + edi_516, out edx_186);
							if (eax_536 == 0x00)
								goto l0073EA20;
							int64 edx_eax_561 = (int64) esi_513;
							*((word32) eax_504 + (((word32) edx_eax_561 - SLICE(edx_eax_561, word32, 32) >> 0x01) * 0x04 + 4)) = eax_536;
							esi_513 = (word32) esi_513 + 2;
							edi_516 += 0x30;
						} while (esi_513 < *((word32) ebx_24 + 16));
					}
					byte * esi_574 = *((word32) *((word32) ebx_24 + 20) + 28);
					byte * edi_575 = &g_b8DBB78;
					word32 ecx_576 = 0x04;
					bool v19_671 = false;
					while (ecx_576 != 0x00)
					{
						v19_671 = *esi_933 != *edi_934;
						esi_574 = esi_933 + 1;
						edi_575 = edi_934 + 1;
						--ecx_576;
						esi_933 = esi_574;
						edi_934 = edi_575;
						if (*esi_933 == *edi_934)
							break;
					}
					if (v19_671)
					{
						word16 * edx_623;
						Eq_3 eax_622 = fn00743770(0x02, eax_504, dwArg08, *((word32) ebx_24 + 0x0C), out edx_623);
						edxOut = edx_623;
						return eax_622;
					}
					else
					{
						word16 * edx_655;
						Eq_3 eax_654 = fn00743770(0x01, eax_504, dwArg08, *((word32) ebx_24 + 0x0C), out edx_655);
						edxOut = edx_655;
						return eax_654;
					}
				}
				break;
			case 0x05:
				if (*((word32) ebx_24 + 16) != 0x01)
				{
					Eq_3 eax_346 = fn0073E7A0((word32) *((word32) ebx_24 + 20) + 24, out edx_186);
					if (eax_346 == 0x00)
						goto l0073EA20;
					word16 * edx_370;
					Eq_3 eax_369 = fn00743880(0x02, eax_346, dwArg08, *((word32) ebx_24 + 0x0C), out edx_370);
					edxOut = edx_370;
					return eax_369;
				}
				break;
			case 0x06:
				Eq_3 esi_167 = 0x01;
				if (*((word32) ebx_24 + 16) != 0x01)
				{
					int64 edx_eax_175 = (int64) *((word32) ebx_24 + 16);
					if (fn00752E30((word32) edx_eax_175 - SLICE(edx_eax_175, word32, 32) >> 0x01, out edx_186) == 0x00)
						goto l0073EA20;
					int64 edx_eax_198 = (int64) *((word32) ebx_24 + 16);
					Eq_3 eax_208 = fn00752E30((word32) edx_eax_198 - SLICE(edx_eax_198, word32, 32) >> 0x01, out edx_186);
					if (eax_208 == 0x00)
						goto l0073EA20;
					if (*((word32) ebx_24 + 16) > 0x01)
					{
						word32 edi_220 = 0x18;
						do
						{
							word32 eax_234 = fn0073BF20((word32) *((word32) ebx_24 + 20) + edi_220, out edx_186);
							if (eax_234 == 0x00)
								goto l0073EA20;
							Eq_3 eax_251 = fn0073E7A0((word32) *((word32) ebx_24 + 20) + (edi_220 + 0x18), out edx_186);
							if (eax_251 == 0x00)
								goto l0073EA20;
							int64 edx_eax_261 = (int64) esi_167;
							ui32 eax_267 = ((word32) edx_eax_261 - SLICE(edx_eax_261, word32, 32) >> 0x01) * 0x02;
							*((word32) dwArg08 + (eax_267 * 0x02 + 0x04)) = eax_234;
							*((word32) eax_208 + ((word32) (eax_267 * 0x02) + 4)) = eax_251;
							esi_167 = (word32) esi_167 + 2;
							edi_220 += 0x30;
						} while (esi_167 < *((word32) ebx_24 + 16));
					}
					Eq_3 eax_292 = fn0073E7A0(*((word32) ebx_24 + 20), out edx_186);
					if (eax_292 == 0x00)
						goto l0073EA20;
					word16 * edx_319;
					Eq_3 eax_318 = fn00743B70(eax_292, dwArg08, dwArg08, *((word32) ebx_24 + 8), *((word32) ebx_24 + 0x0C), out edx_319);
					edxOut = edx_319;
					return eax_318;
				}
				break;
			case 0x08:
			case 0x09:
			case 0x0A:
			case 11:
			case 0x0C:
			case 0x0D:
				if (*((word32) ebx_24 + 16) != 0x01)
				{
					word16 * edx_152;
					Eq_3 eax_151 = fn0073C680(dwArg04, ebx_24, out edx_152);
					edxOut = edx_152;
					return eax_151;
				}
				break;
			case 0x0E:
				if (*((word32) ebx_24 + 16) != 0x01)
				{
					word16 * edx_119;
					Eq_3 eax_118 = fn0073E590(ebx_24, out edx_119);
					edxOut = edx_119;
					return eax_118;
				}
				break;
			case 0x0F:
				word16 * edx_95;
				Eq_3 eax_94 = fn0073E6E0(ebx_24, out edx_95);
				edxOut = edx_95;
				return eax_94;
			case 0x26:
				Eq_3 eax_30 = 0x00;
				if (*((word32) ebx_24 + 16) == 0x02)
				{
					eax_30 = fn0073C790((word32) *((word32) ebx_24 + 20) + 24, out edx_186);
					if (eax_30 == 0x00)
						goto l0073EA20;
				}
				word16 * edx_72;
				Eq_3 eax_71 = fn00743B30(eax_30, *((word32) ebx_24 + 8), dwArg08, out edx_72);
				edxOut = edx_72;
				return eax_71;
			}
			ebx_24 = *((word32) ebx_24 + 20);
			Eq_155947 eax_448 = (int32) *ebx_24;
			eax_15 = eax_448 - 0x012D;
		} while (eax_448 <= 339);
	}
l0073EA08:
	word32 ecx_932;
	fn006E15D0(g_tA18720, 9292740, out ecx_932, out edx_186);
l0073EA20:
	edxOut = edx_186;
	return 0x00;
}

// 0073EB20: Register Eq_3 fn0073EB20(Register Eq_3 eax, Register Eq_3 ebx, Register out Eq_540 edxOut)
// Called from:
//      fn0073FAF0
Eq_3 fn0073EB20(Eq_3 eax, Eq_3 ebx, union Eq_540 & edxOut)
{
	if (*((word32) eax + 16) != 0x01)
	{
		word32 edx_107;
		Eq_3 eax_15 = fn0073C090(eax, ebx, out edx_107);
		edxOut.u0 = <invalid>;
		return eax_15;
	}
	else
	{
		word32 edx_108;
		Eq_3 eax_32 = fn00752E30(0x01, out edx_108);
		if (eax_32 != 0x00)
		{
			word32 edx_109;
			Eq_3 eax_47 = fn0073E7A0(*((word32) eax + 20), out edx_109);
			if (eax_47 != 0x00)
			{
				*((word32) eax_32 + 4) = eax_47;
				edxOut.u0 = <invalid>;
				return eax_32;
			}
		}
		edxOut.u0 = <invalid>;
		return 0x00;
	}
}

// 0073EB70: Register Eq_3 fn0073EB70(Register Eq_3 ebx, Stack Eq_3 dwArg04, Register out ptr32 edxOut)
// Called from:
//      fn00740160
Eq_3 fn0073EB70(Eq_3 ebx, Eq_3 dwArg04, ptr32 & edxOut)
{
	Eq_3 eax_8 = *((word32) ebx + 16);
	Eq_3 edi_16 = *((word32) ebx + 20);
	if (eax_8 != 0x01)
	{
		ptr32 edx_108;
		if (*((word32) edi_16 + 24) == 0x010E)
		{
			Eq_3 eax_235 = fn0073C790(edi_16, out edx_108);
			if (eax_235 != 0x00)
			{
				struct Eq_156366 * eax_243 = *eax_235;
				if (eax_243 > (struct Eq_156366 *) 0x11)
				{
l0073ECF3:
					ptr32 edx_428;
					fn0073B830(out edx_428);
					edxOut = edx_428;
					return 0x00;
				}
				switch ((word32) eax_243->b73EE28)
				{
				case 0x00:
					ptr32 edx_467;
					fn0073B830(out edx_467);
					edxOut = edx_467;
					return 0x00;
				case 0x01:
					ptr32 edx_448;
					fn0073B830(out edx_448);
					edxOut = edx_448;
					return 0x00;
				case 0x02:
				case 0x03:
				case 0x04:
				case 0x05:
				case 0x06:
					goto l0073ECF3;
				case 0x07:
				case 0x08:
					break;
				case 0x09:
					struct Eq_156398 * eax_248 = *((word32) eax_235 + 4);
					if (eax_248->b0014 == 0x4E)
					{
						byte * edi_252 = &g_b8ABDD0;
						byte * esi_253 = &eax_248->b0014;
						word32 ecx_254 = 0x05;
						bool v21_579 = false;
						while (ecx_254 != 0x00)
						{
							v21_579 = *esi_781 != *edi_782;
							esi_253 = esi_781 + 1;
							edi_252 = edi_782 + 1;
							--ecx_254;
							esi_781 = esi_253;
							edi_782 = edi_252;
							if (*esi_781 == *edi_782)
								break;
						}
						if (!v21_579)
						{
							ptr32 edx_289;
							fn0073B830(out edx_289);
							edxOut = edx_289;
							return 0x00;
						}
					}
					break;
				}
				if (fn0073BBE0(ebx, eax_235, dwArg04, edi_16, es, ds, eax_235, dwArg04, out edx_108) != 0x00)
				{
					Eq_3 eax_336;
					if (*((word32) *((word32) ebx + 20) + 48) == 0x0146)
						eax_336 = fn0073C790(eax, out edx_108);
					else
						eax_336 = fn0073E7A0(dwArg04, out edx_108);
					if (eax_336 != 0x00 && fn0073BE10((word32) (*((word32) ebx + 20)) + 24, out edx_108) != 0x00)
					{
						ptr32 edx_403;
						Eq_3 eax_402 = fn00743100(eax_235, dwArg04, eax_336, *((word32) ebx + 8), *((word32) ebx + 0x0C), out edx_403);
						edxOut = edx_403;
						return eax_402;
					}
				}
			}
		}
		else
		{
			int64 edx_eax_28 = (int64) eax_8;
			Eq_3 eax_38 = fn00752E30((word32) edx_eax_28 - SLICE(edx_eax_28, word32, 32) >> 0x01, out edx_108);
			if (eax_38 != 0x00)
			{
				Eq_3 edi_153 = 0x00;
				if (*((word32) ebx + 16) > 0x02)
				{
					Eq_3 ebp_155 = 0x00;
					do
					{
						if (Mem56[Mem56[ebx + 0x14:word32] + ebp_155:word16] == 339)
						{
							word32 esi_779;
							Eq_3 eax_75 = fn006EA200(out edx_108, out esi_779);
							if (eax_75 != 0x00)
							{
								word32 ecx_780;
								fn006E0E90(g_tA178F4, eax_75, out ecx_780, out edx_108);
								word32 v17_97 = (word32) *eax_75 - 1;
								*eax_75 = v17_97;
								if (v17_97 == 0x00)
								{
									struct Eq_156627 * eax_101 = *((word32) eax_75 + 4);
									<anonymous> * ecx_102 = eax_101->ptr0018;
									ecx_102();
								}
							}
							goto l0073EDE7;
						}
						Eq_3 eax_116 = fn0073C790(eax, out edx_108);
						if (eax_116 == 0x00 || fn0073BBE0(ebx, ebp_155, eax_116, edi_153, es, ds, eax_116, dwArg04, out edx_108) == 0x00)
							goto l0073EDE7;
						int64 edx_eax_144 = (int64) edi_153;
						*((word32) eax_38 + (((word32) edx_eax_144 - SLICE(edx_eax_144, word32, 32) >> 0x01) * 0x04 + 4)) = eax_116;
						edi_153 = (word32) edi_153 + 2;
						ebp_155 = (word32) ebp_155 + 48;
					} while (edi_153 < *((word32) ebx + 16) - 0x02);
				}
				Eq_3 eax_178;
				if ((*((word32) ebx + 20) - 0x18)[*((word32) ebx + 16)].w0000 == 0x0146)
					eax_178 = fn0073C790(eax, out edx_108);
				else
					eax_178 = fn0073E7A0(dwArg04, out edx_108);
				if (eax_178 != 0x00)
				{
					ptr32 edx_219;
					Eq_3 eax_218 = fn007430A0(eax_38, dwArg04, *((word32) ebx + 8), *((word32) ebx + 0x0C), out edx_219);
					edxOut = edx_219;
					return eax_218;
				}
			}
		}
l0073EDE7:
		edxOut = edx_108;
		return 0x00;
	}
	Eq_3 eax_511;
	ptr32 edx_489;
	if (*((word32) edi_16 + 16) == eax_8)
		eax_511 = fn0073E7A0(*((word32) edi_16 + 20), out edx_489);
	else
	{
		Eq_3 eax_488 = fn0073C090(edi_16, dwArg04, out edx_489);
		if (eax_488 == 0x00)
			goto l0073EBC2;
		eax_511 = fn00743FC0(eax_488, dwArg04, *((word32) edi_16 + 8), *((word32) edi_16 + 0x0C), out edx_489);
	}
	if (eax_511 != 0x00)
	{
		ptr32 edx_557;
		Eq_3 eax_556 = fn00743680(eax_511, dwArg04, *((word32) ebx + 0x0C), out edx_557);
		edxOut = edx_557;
		return eax_556;
	}
l0073EBC2:
	edxOut = edx_489;
	return 0x00;
}

// 0073EE40: Register word32 fn0073EE40(Register Eq_3 esi, Register out ptr32 edxOut)
// Called from:
//      fn00740160
word32 fn0073EE40(Eq_3 esi, ptr32 & edxOut)
{
	ptr32 edx_202;
	Eq_3 dwLoc08_182 = 0x00;
	Eq_3 edi_12 = 0x01;
	if (*((word32) esi + 16) >= 0x02)
	{
		Eq_3 eax_14 = *((word32) esi + 20);
		if (*((word32) eax_14 + 24) == 0x23)
		{
			Eq_3 eax_25 = fn0073E7A0((word32) eax_14 + 48, out edx_202);
			dwLoc08_182 = eax_25;
			if (eax_25 == 0x00)
			{
l0073EE7A:
				edxOut = edx_202;
				return 0x00;
			}
			edi_12.u0 = 0x04;
		}
	}
	int64 edx_eax_47 = (int64) (*((word32) esi + 16) - edi_12 + 0x01);
	Eq_3 eax_57 = fn00752E30((word32) edx_eax_47 - SLICE(edx_eax_47, word32, 32) >> 0x01, out edx_202);
	if (eax_57 != 0x00)
	{
		Eq_3 ebp_119 = edi_12;
		if (edi_12 < *((word32) esi + 16))
		{
			word32 * ebx_121 = (word32) eax_57 + 4;
			do
			{
				ptr32 edx_102;
				Eq_3 eax_100 = fn0073E7A0(dwArg04, out edx_102);
				if (eax_100 == 0x00)
				{
					edxOut = edx_102;
					return 0x00;
				}
				*ebx_121 = (word32) eax_100;
				ebp_119 = (word32) ebp_119 + 2;
				++ebx_121;
			} while (ebp_119 < *((word32) esi + 16));
		}
		ptr32 edx_162;
		word32 eax_160 = fn007431B0(dwLoc08_182, dwArg04, (uint32) (int8) ((*((word32) esi + 20) - 0x18)[*((word32) esi + 16)].w0000 != 0x0C), *((word32) esi + 8), *((word32) esi + 0x0C), out edx_162);
		edxOut = edx_162;
		return eax_160;
	}
	goto l0073EE7A;
}

// 0073EF40: Register Eq_3 fn0073EF40(Register Eq_3 edi, Register out ptr32 edxOut)
// Called from:
//      fn00740160
Eq_3 fn0073EF40(Eq_3 edi, ptr32 & edxOut)
{
	ptr32 edx_102;
	Eq_3 ebx_11 = *((word32) edi + 20);
	Eq_156755 ecx_12 = (int32) *ebx_11;
	if (ecx_12 > 0x0117)
	{
l0073F12E:
		word32 ecx_621;
		fn006E15D0(g_tA18720, 9292964, out ecx_621, out edx_102);
l0073F143:
		edxOut = edx_102;
		return 0x00;
	}
	else
	{
		switch (ecx_12)
		{
		case 0x0113:
			ptr32 edx_446;
			Eq_3 eax_445 = fn00743710(*((word32) edi + 8), *((word32) edi + 0x0C), out edx_446);
			edxOut = edx_446;
			return eax_445;
		case 0x0114:
			ptr32 edx_421;
			Eq_3 eax_420 = fn00743740(*((word32) edi + 8), *((word32) edi + 0x0C), out edx_421);
			edxOut = edx_421;
			return eax_420;
		case 0x0115:
			if (*((word32) ebx_11 + 16) != 0x01)
			{
				Eq_3 eax_335 = fn0073C790((word32) *((word32) ebx_11 + 20) + 24, out edx_102);
				if (eax_335 == 0x00)
					goto l0073F143;
				ptr32 edx_369;
				Eq_3 eax_368 = fn00743020(eax_335, *((word32) edi + 8), *((word32) edi + 0x0C), out edx_369);
				edxOut = edx_369;
				return eax_368;
			}
			else
			{
				ptr32 edx_396;
				Eq_3 eax_395 = fn00743020(0x00, *((word32) edi + 8), *((word32) edi + 0x0C), out edx_396);
				edxOut = edx_396;
				return eax_395;
			}
		case 0x0116:
			Eq_3 eax_293 = fn0073E7A0(*((word32) ebx_11 + 20), out edx_102);
			if (eax_293 == 0x00)
				goto l0073F143;
			ptr32 edx_315;
			Eq_3 eax_314 = fn00743680(eax_293, *((word32) edi + 8), *((word32) edi + 0x0C), out edx_315);
			edxOut = edx_315;
			return eax_314;
		case 0x0117:
			Eq_3 eax_24 = *((word32) ebx_11 + 16);
			if (eax_24 != 0x01)
			{
				if (eax_24 == 0x02)
				{
					Eq_3 eax_216 = fn0073E7A0((word32) *((word32) ebx_11 + 20) + 24, out edx_102);
					if (eax_216 == 0x00)
						goto l0073F143;
					ptr32 edx_242;
					Eq_3 eax_241 = fn007433E0(eax_216, 0x00, 0x00, *((word32) edi + 8), *((word32) edi + 0x0C), out edx_242);
					edxOut = edx_242;
					return eax_241;
				}
				if (eax_24 != 0x04)
				{
					if (eax_24 != 0x06)
						goto l0073F12E;
					Eq_3 eax_65 = fn0073E7A0((word32) *((word32) ebx_11 + 20) + 24, out edx_102);
					if (eax_65 == 0x00)
						goto l0073F143;
					Eq_3 eax_83 = fn0073E7A0((word32) *((word32) ebx_11 + 20) + 72, out edx_102);
					if (eax_83 == 0x00)
						goto l0073F143;
					Eq_3 eax_101 = fn0073E7A0((word32) *((word32) ebx_11 + 20) + 0x0078, out edx_102);
					if (eax_101 == 0x00)
						goto l0073F143;
					ptr32 edx_128;
					Eq_3 eax_127 = fn007433E0(eax_65, eax_83, eax_101, *((word32) edi + 8), *((word32) edi + 0x0C), out edx_128);
					edxOut = edx_128;
					return eax_127;
				}
				else
				{
					Eq_3 eax_150 = fn0073E7A0((word32) *((word32) ebx_11 + 20) + 24, out edx_102);
					if (eax_150 == 0x00)
						goto l0073F143;
					Eq_3 eax_168 = fn0073E7A0((word32) *((word32) ebx_11 + 20) + 72, out edx_102);
					if (eax_168 == 0x00)
						goto l0073F143;
					ptr32 edx_194;
					Eq_3 eax_193 = fn007433E0(eax_150, eax_168, 0x00, *((word32) edi + 8), *((word32) edi + 0x0C), out edx_194);
					edxOut = edx_194;
					return eax_193;
				}
			}
			else
			{
				ptr32 edx_273;
				Eq_3 eax_272 = fn007433E0(0x00, 0x00, 0x00, *((word32) edi + 8), *((word32) edi + 0x0C), out edx_273);
				edxOut = edx_273;
				return eax_272;
			}
		}
	}
}

// 0073F160: Register word32 fn0073F160(Register Eq_3 esi, Register out ptr32 edxOut)
// Called from:
//      fn00740160
word32 fn0073F160(Eq_3 esi, ptr32 & edxOut)
{
	ptr32 edx_152;
	Eq_3 edi_17 = *((word32) esi + 16);
	Eq_3 ebx_117 = 0x00;
	if (edi_17 == 0x02 || (edi_17 == 0x04 || edi_17 == 0x06))
	{
		Eq_3 eax_43 = fn0073E7A0((word32) *((word32) esi + 20) + 24, out edx_152);
		if (eax_43 == 0x00 || edi_17 >= 0x04 && fn0073E7A0(dwArg04, out edx_152) == 0x00)
			goto l0073F18E;
		if (edi_17 == 0x06)
		{
			Eq_3 eax_93 = fn0073E7A0(dwArg04, out edx_152);
			ebx_117 = eax_93;
			if (eax_93 == 0x00)
			{
l0073F18E:
				edxOut = edx_152;
				return 0x00;
			}
		}
		ptr32 edx_129;
		word32 eax_128 = fn007435D0(eax_43, dwArg04, ebx_117, *((word32) esi + 8), *((word32) esi + 0x0C), out edx_129);
		edxOut = edx_129;
		return eax_128;
	}
	else
	{
		word32 ecx_241;
		fn006E15D0(g_tA18720, 9292992, out ecx_241, out edx_152);
		goto l0073F18E;
	}
}

// 0073F220: Register word32 fn0073F220(Register Eq_3 esi, Register out ptr32 edxOut)
// Called from:
//      fn00740160
word32 fn0073F220(Eq_3 esi, ptr32 & edxOut)
{
	ptr32 edx_105;
	Eq_3 eax_6 = *((word32) esi + 16);
	if (eax_6 == 0x02)
	{
		Eq_3 eax_103 = fn0073E7A0((word32) *((word32) esi + 20) + 24, out edx_105);
		if (eax_103 != 0x00)
		{
			ptr32 edx_131;
			word32 eax_129 = fn007434C0(eax_103, 0x00, *((word32) esi + 8), *((word32) esi + 0x0C), out edx_131);
			edxOut = edx_131;
			return eax_129;
		}
	}
	else
	{
		if (eax_6 == 0x04)
		{
			ptr32 edx_154;
			Eq_3 eax_38 = fn0073E7A0((word32) *((word32) esi + 20) + 24, out edx_154);
			if (eax_38 != 0x00)
			{
				Eq_3 eax_56 = fn0073E7A0((word32) *((word32) esi + 20) + 72, out edx_154);
				if (eax_56 != 0x00)
				{
					ptr32 edx_81;
					word32 eax_79 = fn007434C0(eax_38, eax_56, *((word32) esi + 8), *((word32) esi + 0x0C), out edx_81);
					edxOut = edx_81;
					return eax_79;
				}
			}
			edxOut = edx_154;
			return 0x00;
		}
		word32 ecx_202;
		fn006E15D0(g_tA18720, 0x008DCCF8, out ecx_202, out edx_105);
	}
	edxOut = edx_105;
	return 0x00;
}

// 0073F2C0: Register word32 fn0073F2C0(Register Eq_3 esi, Register Eq_3 edi, Register out ptr32 edxOut)
// Called from:
//      fn00740160
word32 fn0073F2C0(Eq_3 esi, Eq_3 edi, ptr32 & edxOut)
{
	Eq_3 eax_6 = *((word32) esi + 16);
	if (eax_6 == 0x04)
	{
		ptr32 edx_452;
		Eq_3 eax_450 = fn0073E7A0((word32) *((word32) esi + 20) + 24, out edx_452);
		if (eax_450 != 0x00)
		{
			Eq_3 eax_468 = fn0073CEC0(edx, eax_450, edi, es, ds, edi, (word32) *((word32) esi + 20) + 72, out edx_452);
			if (eax_468 != 0x00)
			{
				ptr32 edx_495;
				word32 eax_493 = fn00743300(eax_450, eax_468, 0x00, *((word32) esi + 8), *((word32) esi + 0x0C), out edx_495);
				edxOut = edx_495;
				return eax_493;
			}
		}
		edxOut = edx_452;
		return 0x00;
	}
	ptr32 edx_119;
	Eq_3 ecx_13 = *((word32) esi + 20);
	Eq_3 ebx_14 = *((word32) ecx_13 + 100);
	byte dl_15 = *((word32) ebx_14 + 2);
	if (dl_15 == 115)
	{
		Eq_3 eax_360 = fn0073E7A0((word32) ecx_13 + 24, out edx_119);
		if (eax_360 != 0x00)
		{
			Eq_3 eax_378 = fn0073CEC0(edx, ebx_14, edi, es, ds, edi, (word32) *((word32) esi + 20) + 72, out edx_119);
			if (eax_378 != 0x00)
			{
				Eq_3 eax_396 = fn0073CEC0(edx, eax_378, edi, es, ds, edi, (word32) *((word32) esi + 20) + 144, out edx_119);
				if (eax_396 != 0x00)
				{
					ptr32 edx_432;
					word32 eax_430 = fn00743300(eax_360, eax_378, eax_396, *((word32) esi + 8), *((word32) esi + 0x0C), out edx_432);
					edxOut = edx_432;
					return eax_430;
				}
			}
		}
		goto l0073F59F;
	}
	if (dl_15 != 0x69)
	{
		word32 ecx_682;
		fn006E15D0(g_tA18720, 0x008DCD2C, out ecx_682, out edx_119);
		goto l0073F59F;
	}
	ui32 edx_39 = (word32) eax_6 - 4 + ((word32) eax_6 - 4) * 0x02;
	word32 eax_38 = (word32) eax_6 - 4;
	word32 ebp_40 = 0x00;
	struct Eq_157279 * ecx_42 = (word32) ecx_13 + edx_39 * 0x08;
	Eq_3 dwLoc10_515 = 0x00;
	if (*((word32) ecx_13 + (edx_39 * 0x08 + 24)) == 0x01 && (ecx_42->ptr001C)->b0002 == 115)
	{
		ebp_40 = 0x01;
		eax_38 = (word32) eax_6 - 7;
	}
	int64 edx_eax_52 = (int64) eax_38;
	int32 eax_56 = (word32) edx_eax_52 + (SLICE(edx_eax_52, word32, 32) & 0x03);
	int32 ebx_173 = eax_56 >> 0x02;
	int32 dwLoc04_516 = eax_56 >> 0x02;
	if (ebp_40 == 0x00)
	{
l0073F496:
		word32 dwLoc08_588 = 0x01;
		if (ebx_173 > 0x00)
		{
			Eq_3 ebx_184 = ebx_173 * 0x60 + 0x18;
			do
			{
				Eq_3 eax_199 = fn00752E30(0x01, out edx_119);
				if (eax_199 == 0x00)
					goto l0073F59F;
				word32 eax_217 = fn0073E7A0(Mem193[esi + 0x14:word32] + ebx_184, out edx_119);
				if (eax_217 == 0x00)
					goto l0073F59F;
				Eq_3 edx_228 = (word32) *((word32) esi + 20) + ((word32) ebx_184 + 48);
				Eq_3 eax_234 = fn0073CEC0(edx_228, ebx_184, edi, es, ds, edi, edx_228, out edx_119);
				if (eax_234 == 0x00)
					goto l0073F59F;
				Eq_3 ecx_243 = *((word32) esi + 20);
				word32 edx_684;
				Mem269[eax_199 + 0x04:word32] = fn00743300(eax_217, eax_234, dwLoc10_515, Mem246[ecx_243 + ebx_184 + 0x08:word32], Mem246[ecx_243 + 0x0C + ebx_184:word32], out edx_684);
				ebx_184 -= 0x60;
				dwLoc10_515 = eax_199;
				dwLoc08_588 = dwLoc08_685 + 0x01;
				dwLoc08_685 = dwLoc08_588;
			} while (dwLoc08_685 + 0x00 < dwLoc04_516);
		}
		Eq_3 eax_297 = fn0073E7A0((word32) *((word32) esi + 20) + 24, out edx_119);
		if (eax_297 != 0x00)
		{
			Eq_3 edx_307 = *((word32) esi + 20);
			Eq_3 eax_315 = fn0073CEC0((word32) edx_307 + 72, eax_297, edi, es, ds, edi, (word32) edx_307 + 72, out edx_119);
			if (eax_315 != 0x00)
			{
				ptr32 edx_343;
				word32 eax_341 = fn00743300(eax_297, eax_315, dwLoc10_515, *((word32) esi + 8), *((word32) esi + 0x0C), out edx_343);
				edxOut = edx_343;
				return eax_341;
			}
		}
		goto l0073F59F;
	}
	else
	{
		Eq_3 eax_75 = fn00752E30(0x01, out edx_119);
		dwLoc10_515 = eax_75;
		if (eax_75 == 0x00)
			goto l0073F59F;
		Eq_3 eax_85 = *((word32) esi + 16);
		Eq_3 eax_96 = fn0073E7A0((word32) *((word32) esi + 20) + ((eax_85 - 0x06) + (eax_85 - 0x06) * 0x02) * 0x08, out edx_119);
		if (eax_96 != 0x00)
		{
			Eq_3 eax_106 = *((word32) esi + 16);
			Eq_3 edx_111 = (word32) *((word32) esi + 20) + ((eax_106 - 0x04) + (eax_106 - 0x04) * 0x02) * 0x08;
			Eq_3 eax_117 = fn0073CEC0(edx_111, eax_56 >> 0x02, edi, es, ds, edi, edx_111, out edx_119);
			if (eax_117 == 0x00)
				goto l0073F59F;
			Eq_3 edx_130 = *((word32) esi + 20) - 0x18 + *((word32) esi + 16) * 0x18;
			Eq_3 eax_136 = fn0073CEC0(edx_130, eax_56 >> 0x02, edi, es, ds, edi, edx_130, out edx_119);
			if (eax_136 != 0x00)
			{
				struct Eq_157394 * ecx_148 = (word32) *((word32) esi + 20) + *((word32) esi + 16) * 0x18;
				word32 edx_683;
				*((word32) eax_75 + 4) = fn00743300(eax_96, eax_117, eax_136, ecx_148->tFFFFFF78, ecx_148->tFFFFFF7C, out edx_683);
				ebx_173 = (eax_56 >> 0x02) - 0x01;
				dwLoc04_516 = ebx_173;
				goto l0073F496;
			}
		}
l0073F59F:
		edxOut = edx_119;
		return 0x00;
	}
}

// 0073F5B0: Register word32 fn0073F5B0(Register Eq_3 esi, Register out ptr32 edxOut)
// Called from:
//      fn00740160
word32 fn0073F5B0(Eq_3 esi, ptr32 & edxOut)
{
	ptr32 edx_132;
	Eq_3 eax_6 = *((word32) esi + 16);
	if (eax_6 == 0x04)
	{
		Eq_3 eax_130 = fn0073E7A0((word32) *((word32) esi + 20) + 24, out edx_132);
		if (eax_130 != 0x00)
		{
			Eq_3 eax_148 = fn0073CEC0(edx, eax_130, edi, es, ds, edi, (word32) *((word32) esi + 20) + 72, out edx_132);
			if (eax_148 != 0x00)
			{
				ptr32 edx_182;
				word32 eax_180 = fn00743290(eax_130, eax_148, 0x00, *((word32) esi + 8), *((word32) esi + 0x0C), out edx_182);
				edxOut = edx_182;
				return eax_180;
			}
		}
	}
	else
	{
		if (eax_6 == 0x07)
		{
			ptr32 edx_209;
			Eq_3 eax_41 = fn0073E7A0((word32) *((word32) esi + 20) + 24, out edx_209);
			if (eax_41 != 0x00)
			{
				Eq_3 eax_59 = fn0073CEC0(edx, ebx, edi, es, ds, edi, (word32) *((word32) esi + 20) + 72, out edx_209);
				if (eax_59 != 0x00)
				{
					Eq_3 edx_69 = *((word32) esi + 20);
					Eq_3 eax_77 = fn0073CEC0((word32) edx_69 + 144, eax_59, edi, es, ds, edi, (word32) edx_69 + 144, out edx_209);
					if (eax_77 != 0x00)
					{
						ptr32 edx_104;
						word32 eax_102 = fn00743290(eax_41, eax_59, eax_77, *((word32) esi + 8), *((word32) esi + 0x0C), out edx_104);
						edxOut = edx_104;
						return eax_102;
					}
				}
			}
			edxOut = edx_209;
			return 0x00;
		}
		word32 ecx_271;
		fn006E15D0(g_tA18720, 0x008DCD54, out ecx_271, out edx_132);
	}
	edxOut = edx_132;
	return 0x00;
}

// 0073F690: Register Eq_3 fn0073F690(Register Eq_3 esi, Register out ptr32 edxOut)
// Called from:
//      fn0073F7B0
Eq_3 fn0073F690(Eq_3 esi, ptr32 & edxOut)
{
	Eq_3 eax_6 = *((word32) esi + 16);
	if (eax_6 != 0x01)
	{
		ptr32 edx_150;
		if (eax_6 == 0x02)
		{
			Eq_3 eax_149 = fn0073E7A0((word32) *((word32) esi + 20) + 24, out edx_150);
			if (eax_149 != 0x00)
			{
				Eq_3 eax_165 = fn0073CEC0(edx, eax_149, edi, es, ds, edi, dwArg04, out edx_150);
				if (eax_165 != 0x00)
				{
					ptr32 edx_198;
					Eq_3 eax_197 = fn00744180(eax_149, 0x00, eax_165, *((word32) esi + 8), *((word32) esi + 0x0C), out edx_198);
					edxOut = edx_198;
					return eax_197;
				}
			}
		}
		else if (eax_6 == 0x04)
		{
			Eq_3 eax_40 = fn0073E7A0((word32) *((word32) esi + 20) + 72, out edx_150);
			if (eax_40 != 0x00 && fn0073BBE0(eax_40, ebp, esi, edi, es, ds, eax_40, 0x02, out edx_150) != 0x00)
			{
				ptr32 edx_267;
				Eq_3 eax_80 = fn0073E7A0((word32) *((word32) esi + 20) + 24, out edx_267);
				if (eax_80 != 0x00)
				{
					Eq_3 eax_96 = fn0073CEC0(dwArg04, eax_40, edi, es, ds, edi, dwArg04, out edx_267);
					if (eax_96 != 0x00)
					{
						ptr32 edx_122;
						Eq_3 eax_121 = fn00744180(eax_80, eax_40, eax_96, *((word32) esi + 8), *((word32) esi + 0x0C), out edx_122);
						edxOut = edx_122;
						return eax_121;
					}
				}
				edxOut = edx_267;
				return 0x00;
			}
		}
		else
		{
			word32 ecx_350;
			fn006E15D0(g_tA18720, 0x008DCD88, out ecx_350, out edx_150);
		}
		edxOut = edx_150;
		return 0x00;
	}
	else
	{
		ptr32 edx_213;
		Eq_3 eax_212 = fn0073CEC0(edx, ebx, edi, es, ds, edi, dwArg04, out edx_213);
		if (eax_212 != 0x00)
		{
			ptr32 edx_238;
			Eq_3 eax_237 = fn00744180(0x00, dwArg04, eax_212, *((word32) esi + 8), *((word32) esi + 0x0C), out edx_238);
			edxOut = edx_238;
			return eax_237;
		}
		else
		{
			edxOut = edx_213;
			return eax_212;
		}
	}
}

// 0073F7B0: Register word32 fn0073F7B0(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Register out ptr32 edxOut)
// Called from:
//      fn00740160
word32 fn0073F7B0(Eq_3 dwArg04, Eq_3 dwArg08, ptr32 & edxOut)
{
	Eq_3 ebp_17 = *((word32) dwArg08 + 16);
	Eq_3 edx_29 = SLICE((ebp_17 - 0x03) *s64 0x55555556, word32, 32);
	Eq_3 ebx_155 = (word32) edx_29 + (edx_29 >> 0x1F);
	ptr32 edx_147;
	Eq_3 eax_40 = fn0073CEC0(edx_29, ebx_155, ebp_17 - 0x03, es, ds, dwArg04, (word32) *((word32) dwArg08 + 20) + 48, out edx_147);
	Eq_3 dwLoc14_385 = 0x00;
	Eq_3 dwLoc10_441 = eax_40;
	if (eax_40 == 0x00)
	{
l0073F884:
		edxOut = edx_147;
		return 0x00;
	}
	ptr32 edx_111;
	Eq_3 eax_49 = *((word32) dwArg08 + 20);
	word16 cx_52 = *((word32) eax_49 + ((ebp_17 - 0x03) + (ebp_17 - 0x03) * 0x02) * 0x08);
	if (cx_52 == 0x01)
	{
		byte * esi_69 = *((word32) eax_49 + (ebp_17 * 0x18 - 0x44));
		Eq_3 edi_105 = 0x008DBB98;
		word32 ecx_72 = 0x08;
		bool v18_374 = false;
		while (ecx_72 != 0x00)
		{
			v18_374 = *esi_563 != *edi_105;
			esi_69 = esi_563 + 1;
			edi_105 = (word32) edi_105 + 1;
			--ecx_72;
			esi_563 = esi_69;
			if (*esi_563 == *edi_105)
				break;
		}
		if (!v18_374)
		{
			if (ebp_17 >= 0x09 && *((word32) eax_49 + ((ebp_17 - 0x12) + ebp_17 * 0x02) * 0x08) == 0x01)
			{
				if (fn0073CEC0(ebp_17 - 0x0C + ebp_17 * 0x02, ebx_155, edi_105, es, ds, dwArg04, dwArg04, out edx_147) == 0x00)
					goto l0073F884;
				--ebx_155;
			}
			Eq_3 eax_175 = fn0073CEC0((word32) *((word32) dwArg08 + 20) + (ebp_17 * 0x18 - 0x18), ebx_155, edi_105, es, ds, dwArg04, dwArg04, out edx_147);
			dwLoc14_385 = eax_175;
			if (eax_175 == 0x00)
				goto l0073F884;
l0073F8B0:
			--ebx_155;
l0073F8B7:
			if (ebx_155 <= 0x00)
			{
l0073F9A6:
				ptr32 edx_337;
				word32 eax_336 = fn00743480(dwLoc10_441, dwArg04, dwArg08, *((word32) dwArg08 + 0x0C), out edx_337);
				edxOut = edx_337;
				return eax_336;
			}
			Eq_3 eax_208 = fn00752E30(ebx_155, out edx_147);
			word32 ebp_212 = 0x00;
			if (eax_208 != 0x00)
			{
				word32 dwLoc0C_480 = 0x01;
				if (ebx_155 > 0x00)
				{
					word32 * dwLoc08_481 = (word32) eax_208 + 4;
					do
					{
						word32 eax_239 = fn0073F690((word32) *((word32) dwArg08 + 20) + ebp_212 + 0x48, out edx_147);
						if (eax_239 == 0x00)
							goto l0073F884;
						*dwLoc08_481 = eax_239;
						ebp_212 += 0x48;
						dwLoc0C_480 = dwLoc0C_565 + 0x01;
						++dwLoc08_481;
						dwLoc0C_565 = dwLoc0C_480;
					} while (dwLoc0C_565 + 0x00 < ebx_155);
				}
				ptr32 edx_288;
				word32 eax_287 = fn00743430(eax_40, dwArg04, dwArg08, *((word32) dwArg08 + 8), *((word32) dwArg08 + 0x0C), out edx_288);
				if (dwLoc14_385 == 0x00)
				{
					edxOut = edx_288;
					return eax_287;
				}
				Eq_3 eax_302 = fn00752E30(0x01, out edx_147);
				dwLoc10_441 = eax_302;
				if (eax_302 != 0x00)
				{
					*((word32) eax_302 + 4) = eax_287;
					goto l0073F9A6;
				}
			}
			goto l0073F884;
		}
		if (fn0073CEC0((word32) eax_49 + (ebp_17 * 0x18 - 0x18), ebx_155, edi_105, es, ds, dwArg04, dwArg04, out edx_111) != 0x00)
			goto l0073F8B0;
	}
	else
	{
		if (cx_52 == 0x012A)
			goto l0073F8B7;
		fn0073B830(out edx_111);
	}
	edxOut = edx_111;
	return 0x00;
}

// 0073F9D0: Register Eq_3 fn0073F9D0(Register (ptr32 Eq_158007) edx, Stack Eq_3 dwArg04, Register out ptr32 edxOut)
// Called from:
//      fn0073FA50
Eq_3 fn0073F9D0(struct Eq_158007 * edx, Eq_3 dwArg04, ptr32 & edxOut)
{
	struct Eq_158010 * eax_6 = edx->ptr0014;
	byte * esi_13 = eax_6->ptr0004;
	byte * edi_17 = &g_b8DBBE0;
	word32 ecx_18 = 0x03;
	bool v17_126 = true;
	while (ecx_18 != 0x00)
	{
		v17_126 = *esi_183 == *edi_184;
		esi_13 = esi_183 + 1;
		edi_17 = edi_184 + 1;
		--ecx_18;
		esi_183 = esi_13;
		edi_184 = edi_17;
		if (*esi_183 == *edi_184)
			break;
	}
	if (v17_126)
	{
		ptr32 edx_56;
		Eq_3 eax_55 = fn0073E7A0((const char *) &eax_6->ptr0004 + 20, out edx_56);
		edxOut = edx_56;
		return eax_55;
	}
	else
	{
		word32 esi_181;
		ptr32 edx_109;
		Eq_3 eax_76 = fn006EA200(out edx_109, out esi_181);
		if (eax_76 != 0x00)
		{
			word32 ecx_182;
			fn006E0E90(g_tA178F4, eax_76, out ecx_182, out edx_109);
			word32 v13_99 = (word32) *eax_76 - 1;
			*eax_76 = v13_99;
			if (v13_99 == 0x00)
			{
				struct Eq_158083 * edx_103 = *((word32) eax_76 + 4);
				edx_103->ptr0018();
			}
		}
		edxOut = edx_109;
		return 0x00;
	}
}

// 0073FA50: Register word32 fn0073FA50(Register Eq_3 esi, Register out ptr32 edxOut)
// Called from:
//      fn00740160
word32 fn0073FA50(Eq_3 esi, ptr32 & edxOut)
{
	Eq_3 ebx_21 = 0x00;
	ui32 ebp_24 = 0x03;
	ptr32 edx_147;
	Eq_3 eax_27 = fn0073E7A0((word32) *((word32) esi + 20) + 24, out edx_147);
	if (eax_27 != 0x00)
	{
		if (*((word32) *((word32) esi + 20) + 48) == 0x0129)
		{
			Eq_3 eax_44 = fn0073F9D0(edx, edi, out edx_147);
			ebx_21 = eax_44;
			if (eax_44 == 0x00 || fn0073BBE0(eax_44, 0x03, esi, edi, es, ds, eax_44, 0x02, out edx_147) == 0x00)
				goto l0073FA72;
			ebp_24 = 0x04;
		}
		Eq_3 edx_72 = *((word32) esi + 20);
		Eq_3 eax_86 = fn0073CEC0(edx_72, ebx_21, edi, es, ds, edi, (word32) edx_72 + ebp_24 * 0x18, out edx_147);
		if (eax_86 != 0x00)
		{
			ptr32 edx_113;
			word32 eax_112 = fn00743370(eax_27, ebx_21, eax_86, *((word32) esi + 8), *((word32) esi + 0x0C), out edx_113);
			edxOut = edx_113;
			return eax_112;
		}
		goto l0073FA72;
	}
	else
	{
l0073FA72:
		edxOut = edx_147;
		return 0x00;
	}
}

// 0073FAF0: Register Eq_3 fn0073FAF0(Register Eq_3 eax, Stack Eq_3 dwArg04, Register out ptr32 edxOut)
// Called from:
//      fn00740160
Eq_3 fn0073FAF0(Eq_3 eax, Eq_3 dwArg04, ptr32 & edxOut)
{
	Eq_3 edx_11 = *((word32) dwArg04 + 20);
	byte * esi_15 = *((word32) edx_11 + 28);
	Eq_3 edi_21 = 0x008ABDD0;
	word32 ecx_22 = 0x05;
	bool v18_292 = false;
	while (ecx_22 != 0x00)
	{
		v18_292 = *esi_409 != *edi_21;
		esi_15 = esi_409 + 1;
		edi_21 = (word32) edi_21 + 1;
		--ecx_22;
		esi_409 = esi_15;
		if (*esi_409 == *edi_21)
			break;
	}
	ptr32 edx_160;
	if (!v18_292)
	{
		word32 esi_400;
		Eq_3 eax_241 = fn006EA200(out edx_160, out esi_400);
		if (eax_241 != 0x00)
		{
			word32 ecx_401;
			fn006E0E90(g_tA178F4, eax_241, out ecx_401, out edx_160);
			word32 v14_263 = (word32) *eax_241 - 1;
			*eax_241 = v14_263;
			if (v14_263 == 0x00)
			{
				struct Eq_158242 * eax_267 = *((word32) eax_241 + 4);
				eax_267->ptr0018();
			}
		}
		goto l0073FB4D;
	}
	Eq_3 edi_138;
	if (*((word32) dwArg04 + 16) == 0x04)
	{
		Eq_3 eax_161 = fn0073CEC0((word32) edx_11 + 72, eax, edi_21, es, ds, eax, (word32) edx_11 + 72, out edx_160);
		edi_138 = eax_161;
		if (eax_161 != 0x00)
			goto l0073FB6D;
	}
	else
	{
		if (*((word32) edx_11 + 72) == 0x08)
		{
			ptr32 edx_133;
			Eq_3 eax_134 = fn0073CEC0((word32) edx_11 + 0x0078, eax, edi_21, es, ds, eax, (word32) edx_11 + 0x0078, out edx_133);
			edi_138 = eax_134;
			if (eax_134 == 0x00)
			{
				edxOut = edx_133;
				return eax_134;
			}
l0073FB6D:
			Eq_3 edx_175 = *((word32) eax + 4);
			word32 edx_405;
			word32 ecx_404;
			Eq_3 eax_185 = fn006F1A70(out ecx_404, out edx_405);
			fn00740DF0(edx_175, dwArg04);
			ptr32 edx_217;
			Eq_3 eax_218 = fn00742FB0(eax_185, dwArg04, edi_138, *((word32) dwArg04 + 8), *((word32) dwArg04 + 0x0C), out edx_217);
			edxOut = edx_217;
			return eax_218;
		}
		if (fn0073EB20((word32) edx_11 + 72, eax, out edx_160) != 0x00 && fn0073CEC0((word32) (*((word32) dwArg04 + 20)) + 144, eax, edi_21, es, ds, eax, dwArg04, out edx_160) != 0x00)
		{
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg12 = <invalid>;
			Eq_3 stackArg16 = <invalid>;
			Eq_3 stackArg20 = <invalid>;
			ptr32 edx_111;
			Eq_3 eax_112 = fn00742FB0(fn0073B810(), dwArg04, stackArg12, stackArg16, stackArg20, out edx_111);
			edxOut = edx_111;
			return eax_112;
		}
	}
l0073FB4D:
	edxOut = edx_160;
	return 0x00;
}

// 0073FC30: Register Eq_3 fn0073FC30(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Register out ptr32 edxOut)
// Called from:
//      fn0073C370
//      fn00740060
Eq_3 fn0073FC30(Eq_3 dwArg04, Eq_3 dwArg08, ptr32 & edxOut)
{
	Eq_3 ebp_14 = 0x00;
	Eq_3 edi_149 = dwArg08;
	Eq_3 esi_19 = 0x00;
	Eq_3 ebx_108 = 0x00;
	word32 dwLoc04_1225 = 0x00;
	if (*dwArg08 == 262)
	{
		if (*((word32) dwArg08 + 16) == 0x02)
		{
			ptr32 edx_788;
			Eq_3 eax_786 = fn007441C0(0x00, 0x00, 0x00, 0x00, out edx_788);
			edxOut = edx_788;
			return eax_786;
		}
		Eq_3 edx_28 = *((word32) dwArg08 + 20);
		dwArg08 = (word32) edx_28 + 24;
		edi_149 = (word32) edx_28 + 24;
	}
	Eq_3 dwLoc14_1117;
	Eq_3 esi_103;
	ptr32 edx_100;
	Eq_3 eax_35 = *((word32) edi_149 + 16);
	if (eax_35 > 0x00)
	{
		Eq_3 edx_39 = *((word32) edi_149 + 20);
		do
		{
			word16 cx_45 = *edx_39;
			if (cx_45 == 0x0108)
				esi_19 = (word32) esi_19 + 1;
			if (cx_45 == 22)
				ebx_108 = (word32) ebx_108 + 1;
			edx_39 = (word32) edx_39 + 24;
			--eax_35;
		} while (eax_35 != 0x00);
		if (esi_19 != 0x00)
		{
			Eq_3 eax_98 = fn00752E30(esi_19, out edx_100);
			esi_103 = eax_98;
			dwLoc14_1117 = eax_98;
			if (eax_98 == 0x00)
				goto l00740055;
l0073FCD1:
			Eq_3 dwLoc10_1128;
			if (ebx_108 != 0x00)
			{
				Eq_3 eax_129 = fn00752E30(ebx_108, out edx_100);
				dwLoc10_1128 = eax_129;
				if (eax_129 == 0x00)
					goto l00740055;
			}
			else
				dwLoc10_1128.u0 = 0x00;
			ui32 dwLoc1C_1211 = 0x00;
			if (*((word32) edi_149 + 16) <= 0x00)
			{
l0073FEF2:
				ptr32 edx_758;
				Eq_3 eax_756 = fn007441C0(esi_103, dwArg04, dwArg08, dwLoc10_1128, out edx_758);
				edxOut = edx_758;
				return eax_756;
			}
			word32 * dwLoc20_1109 = (word64) esi_103.u0 + 4;
l0073FD24:
			struct Eq_158424 * esp_273;
			word32 esp_298;
			ui32 esi_153 = ebp_14 * 0x03;
			Eq_3 ecx_151 = *((word32) edi_149 + 20);
			Eq_158433 esi_156 = esi_153 * 0x08;
			int32 eax_157 = (int32) *((word32) ecx_151 + esi_153 * 0x08);
			struct Eq_158440 * ebx_159 = (word32) ecx_151 + esi_153 * 0x08;
			if (eax_157 != 0x10)
			{
				if (eax_157 != 0x24)
				{
					if (eax_157 != 0x0108)
					{
						word32 ecx_1253;
						fn006E15D0(g_tA18720, dwArg04, out ecx_1253, out edx_100);
						esp_273 = fp - 0x30;
						goto l00740023;
					}
					Eq_3 dwLoc18_1223 = (word32) ebp_14 + 1;
					word32 * edi_355 = (word64) dwLoc10_1128.u0 + 4 + dwLoc1C_1211 * 0x04;
l0073FD70:
					if (dwLoc18_1223 < *((word32) dwArg08 + 16) && *((word32) (*((word32) dwArg08 + 20)) + ((word32) esi_156 + 24)) == 22)
					{
						Eq_3 eax_440 = fn0073E7A0(dwArg04, out edx_100);
						esp_273 = fp - 0x30;
						if (eax_440 == 0x00)
							goto l00740023;
						*edi_355 = (word32) eax_440;
						dwLoc18_1223 = (word32) dwLoc18_1223 + 2;
						++dwLoc1C_1211;
						++edi_355;
						ebp_14 = (word32) ebp_14 + 2;
						esi_156 = (word32) esi_156 + 48;
						dwLoc04_1225 = 0x01;
l0073FDD1:
						if (ebx_159->dw0010 == 0x03)
						{
							struct Eq_158597 * ebx_464 = ebx_159->ptr0014;
							ebx_159 = (struct Eq_158440 *) ((const char *) &ebx_464->ptr0004 + 20);
							if (ebx_464->dw0028 == 0x01)
							{
								ebx_159 = ebx_464->ptr002C;
								goto l0073FD70;
							}
							*dwLoc20_1109 = (word32) fn0073C100(dwArg04, dwArg04);
							++dwLoc20_1109;
						}
						struct Eq_158597 * eax_494 = ebx_159->ptr0014;
						if (eax_494->w0000 != 0x01)
						{
l0073FE6E:
							ebp_14 = (word32) ebp_14 + 2;
l0073FEE1:
							if (ebp_14 >= *((word32) dwArg08 + 16))
							{
								esi_103 = dwLoc14_1117;
								goto l0073FEF2;
							}
							edi_149 = dwArg08;
							goto l0073FD24;
						}
						byte * edi_501 = &g_b8ABDD0;
						byte * esi_502 = eax_494->ptr0004;
						word32 ecx_503 = 0x05;
						bool v34_811 = true;
						while (ecx_503 != 0x00)
						{
							v34_811 = *esi_1270 == *edi_1271;
							esi_502 = esi_1270 + 1;
							edi_501 = edi_1271 + 1;
							--ecx_503;
							esi_1270 = esi_502;
							edi_1271 = edi_501;
							if (*esi_1270 == *edi_1271)
								break;
						}
						if (!v34_811)
						{
							Eq_3 edi_583 = *((word32) dwArg04 + 4);
							word32 edx_1259;
							word32 ecx_1258;
							Eq_3 eax_589 = fn006F1A70(out ecx_1258, out edx_1259);
							fn00740DF0(edi_583, dwArg04);
							Eq_3 eax_620 = fn00743EE0(eax_589, dwArg04, dwArg08, ebx_159->t000C, out edx_100);
							esp_273 = fp - 0x30;
							if (eax_620 != 0x00)
							{
								*dwLoc20_1109 = (word32) eax_620;
								++dwLoc20_1109;
								goto l0073FE6E;
							}
							goto l00740023;
						}
						word32 esi_1257;
						Eq_3 eax_542 = fn006EA200(out edx_100, out esi_1257);
						esp_273 = fp - 0x30;
						if (eax_542 == 0x00)
							goto l00740023;
						word32 ecx_1261;
						fn006E0E90(g_tA178F4, eax_542, out ecx_1261, out edx_100);
						word32 v21_565 = (word32) *eax_542 - 1;
						*eax_542 = v21_565;
						esp_273 = fp - 0x30;
						if (v21_565 == 0x00)
						{
							struct Eq_158803 * ecx_569 = *((word32) eax_542 + 4);
							ecx_569->ptr0018();
							goto l00740020;
						}
l00740023:
						struct Eq_158524 * eax_632 = esp_273->ptr0028;
						if (eax_632 != null)
						{
							word32 v18_636 = eax_632->dw0000 + ~0x00;
							eax_632->dw0000 = v18_636;
							if (v18_636 == 0x00)
							{
								struct Eq_158644 * edx_640 = eax_632->ptr0004;
								esp_273->ptrFFFFFFFC = eax_632;
								word32 esp_654;
								edx_640->ptr0018();
								esp_273 = esp_654 + 0x04;
							}
						}
						struct Eq_158524 * eax_664 = esp_273->ptr0024;
						if (eax_664 != null)
						{
							word32 v19_668 = eax_664->dw0000 + ~0x00;
							eax_664->dw0000 = v19_668;
							if (v19_668 == 0x00)
							{
								struct Eq_158644 * ecx_672 = eax_664->ptr0004;
								<anonymous> * edx_673 = ecx_672->ptr0018;
								esp_273->ptrFFFFFFFC = eax_664;
								edx_673();
							}
						}
l00740055:
						edxOut = edx_100;
						return 0x00;
					}
					if (dwLoc04_1225 == 0x00)
						goto l0073FDD1;
l0073FFEF:
					word32 esi_1264;
					Eq_3 eax_395 = fn006EA200(out edx_100, out esi_1264);
					esp_273 = fp - 0x30;
					if (eax_395 != 0x00)
					{
						word32 ecx_1265;
						fn006E0E90(g_tA178F4, eax_395, out ecx_1265, out edx_100);
						word32 v22_418 = (word32) *eax_395 - 1;
						*eax_395 = v22_418;
						esp_273 = fp - 0x30;
						if (v22_418 == 0x00)
						{
							struct Eq_158880 * eax_422 = *((word32) eax_395 + 4);
							eax_422->ptr0018();
l00740020:
							esp_273 = esp_298 + 0x04;
							goto l00740023;
						}
					}
					goto l00740023;
				}
				byte * edi_226 = &g_b8ABDD0;
				byte * esi_227 = ebx_159->ptr001C;
				word32 ecx_228 = 0x05;
				bool v30_807 = true;
				while (ecx_228 != 0x00)
				{
					v30_807 = *esi_1268 == *edi_1269;
					esi_227 = esi_1268 + 1;
					edi_226 = edi_1269 + 1;
					--ecx_228;
					esi_1268 = esi_227;
					edi_1269 = edi_226;
					if (*esi_1268 == *edi_1269)
						break;
				}
				if (v30_807)
				{
					word32 esi_1254;
					Eq_3 eax_267 = fn006EA200(out edx_100, out esi_1254);
					esp_273 = fp - 0x30;
					if (eax_267 == 0x00)
						goto l00740023;
					word32 ecx_1260;
					fn006E0E90(g_tA178F4, eax_267, out ecx_1260, out edx_100);
					word32 v20_290 = (word32) *eax_267 - 1;
					*eax_267 = v20_290;
					esp_273 = fp - 0x30;
					if (v20_290 == 0x00)
					{
						struct Eq_158774 * edx_294 = *((word32) eax_267 + 4);
						edx_294->ptr0018();
						goto l00740020;
					}
					goto l00740023;
				}
				Eq_3 edi_305 = *((word32) dwArg04 + 4);
				word32 edx_1256;
				word32 ecx_1255;
				fn006F1A70(out ecx_1255, out edx_1256);
				fn00740DF0(edi_305, dwArg04);
			}
			else
			{
				byte * edi_162 = &g_b8ABDD0;
				byte * esi_163 = ebx_159->ptr001C;
				word32 ecx_164 = 0x05;
				bool v26_803 = true;
				while (ecx_164 != 0x00)
				{
					v26_803 = *esi_1266 == *edi_1267;
					esi_163 = esi_1266 + 1;
					edi_162 = edi_1267 + 1;
					--ecx_164;
					esi_1266 = esi_163;
					edi_1267 = edi_162;
					if (*esi_1266 == *edi_1267)
						break;
				}
				if (v26_803)
					goto l0073FFEF;
				Eq_3 edi_196 = *((word32) dwArg04 + 4);
				word32 edx_1263;
				word32 ecx_1262;
				fn006F1A70(out ecx_1262, out edx_1263);
				fn00740DF0(edi_196, dwArg04);
			}
			ebp_14 = (word32) ebp_14 + 3;
			goto l0073FEE1;
		}
	}
	dwLoc14_1117.u0 = 0x00;
	esi_103.u0 = 0x00;
	goto l0073FCD1;
}

// 00740060: Register Eq_3 fn00740060(Register Eq_3 ebx, Stack Eq_3 dwArg04, Register out ptr32 edxOut)
// Called from:
//      fn00740160
Eq_3 fn00740060(Eq_3 ebx, Eq_3 dwArg04, ptr32 & edxOut)
{
	ui32 ebp_16;
	Eq_3 dwLoc0C_210 = 0x00;
	if (*((word32) ebx + 16) == 0x06)
	{
		ptr32 edx_24;
		Eq_3 eax_22 = fn0073DF70(dwArg04, *((word32) ebx + 20), out edx_24);
		dwLoc0C_210 = eax_22;
		if (eax_22 == 0x00)
		{
			edxOut = edx_24;
			return eax_22;
		}
		ebp_16 = 0x02;
	}
	else
		ebp_16 = 0x01;
	Eq_3 edx_38 = *((word32) dwArg04 + 4);
	word32 ecx_294;
	word32 edx_295;
	Eq_3 eax_56 = fn006F1A70(out ecx_294, out edx_295);
	ui32 esi_44 = ebp_16 * 0x03;
	ptr32 edx_120 = fn00740DF0(edx_38, dwArg04);
	if (eax_56 != 0x00)
	{
		word32 esi_80 = Mem67[esi_44 * 0x08 + Mem67[ebx + 0x14:word32] + 0x04:word32];
		byte * edi_81 = &g_b8ABDD0;
		word32 ecx_82 = 0x05;
		bool v15_204 = false;
		while (ecx_82 != 0x00)
		{
			v15_204 = *esi_296 != *edi_297;
			esi_80 = esi_296 + 1;
			edi_81 = edi_297 + 1;
			--ecx_82;
			esi_296 = esi_80;
			edi_297 = edi_81;
			if (*esi_296 == *edi_297)
				break;
		}
		if (!v15_204)
			fn0073B830(out edx_120);
		else
		{
			Eq_3 eax_118 = fn0073FC30(dwArg04, dwArg04, out edx_120);
			if (eax_118 != 0x00)
			{
				Eq_3 eax_136 = fn0073CEC0((word32) *((word32) ebx + 20) + ((ebp_16 + 0x09) + ebp_16 * 0x02) * 0x08, ebx, eax_118, es, ds, dwArg04, dwArg04, out edx_120);
				if (eax_136 != 0x00)
				{
					ptr32 edx_167;
					Eq_3 eax_165 = fn00742F20(eax_56, dwArg04, eax_136, dwLoc0C_210, *((word32) ebx + 8), *((word32) ebx + 0x0C), out edx_167);
					edxOut = edx_167;
					return eax_165;
				}
			}
		}
	}
	edxOut = edx_120;
	return 0x00;
}

// 00740160: Register word32 fn00740160(Stack Eq_3 dwArg08, Register out Eq_152914 edxOut)
// Called from:
//      fn0073CEC0
//      fn007403E0
word32 fn00740160(Eq_3 dwArg08, union Eq_152914 & edxOut)
{
	Eq_3 eax_13 = dwArg08;
	if (*dwArg08 == 266)
		eax_13 = *((word32) dwArg08 + 20);
	if (*eax_13 == 0x010B)
		eax_13 = *((word32) eax_13 + 20);
	Eq_152914 edx_286;
	if (*eax_13 == 0x010C)
	{
		Eq_3 edi_166 = *((word32) eax_13 + 20);
		struct Eq_159058 * eax_167 = (int32) *edi_166;
		if (eax_167 <= (struct Eq_159058 *) 0x0122)
		{
			switch ((word32) eax_167->b74024F)
			{
			case 0x00:
				Eq_152914 edx_389;
				word32 eax_388 = fn0073EB70(edi_166, dwArg04, out edx_389);
				edxOut = edx_389;
				return eax_388;
			case 0x01:
			case 0x06:
			case 0x07:
			case 0x08:
			case 0x09:
			case 0x0A:
			case 0x0C:
			case 0x0D:
			case 0x0E:
			case 0x0F:
			case 0x10:
			case 0x11:
			case 0x12:
				break;
			case 0x02:
				Eq_152914 edx_325;
				word32 eax_324 = fn0073EE40(edi_166, out edx_325);
				edxOut = edx_325;
				return eax_324;
			case 0x03:
				Eq_3 eax_285 = fn0073C7D0((word32) *((word32) edi_166 + 20) + 24, dwArg04, 0x03, out edx_286);
				if (eax_285 == 0x00)
					goto l0074032C;
				Eq_152914 edx_307;
				word32 eax_306 = fn00743060(eax_285, dwArg04, dwArg08, out edx_307);
				edxOut = edx_307;
				return eax_306;
			case 0x04:
				Eq_152914 edx_264;
				word32 eax_263 = fn007436E0(*((word32) edi_166 + 8), *((word32) edi_166 + 0x0C), out edx_264);
				edxOut = edx_264;
				return eax_263;
			case 0x05:
				Eq_152914 edx_242;
				word32 eax_241 = fn0073EF40(edi_166, out edx_242);
				edxOut = edx_242;
				return eax_241;
			case 11:
				Eq_152914 edx_227;
				word32 eax_226 = fn0073CAE0(edi_166, dwArg04, out edx_227);
				edxOut = edx_227;
				return eax_226;
			case 0x13:
				Eq_152914 edx_209;
				word32 eax_208 = fn0073CE00(edi_166, dwArg04, out edx_209);
				edxOut = edx_209;
				return eax_208;
			case 0x14:
				Eq_152914 edx_192;
				word32 eax_191 = fn0073F160(edi_166, out edx_192);
				edxOut = edx_192;
				return eax_191;
			case 0x15:
				Eq_152914 edx_176;
				word32 eax_175 = fn0073F220(edi_166, out edx_176);
				edxOut = edx_176;
				return eax_175;
			}
		}
	}
	else
	{
		Eq_3 esi_37 = *((word32) eax_13 + 20);
		struct Eq_159047 * ecx_38 = (int32) *esi_37;
		if (ecx_38 <= (struct Eq_159047 *) ~0x0147)
		{
			switch ((word32) ecx_38->b74028F)
			{
			case 0x00:
				Eq_152914 edx_154;
				word32 eax_153 = fn00740060(esi_37, dwArg04, out edx_154);
				edxOut = edx_154;
				return eax_153;
			case 0x01:
			case 0x02:
			case 0x03:
			case 0x04:
			case 0x05:
			case 0x06:
			case 0x07:
			case 0x08:
			case 0x09:
			case 0x0A:
			case 11:
			case 0x0C:
			case 0x0D:
			case 0x0E:
			case 0x0F:
			case 0x10:
			case 0x11:
			case 0x12:
			case 0x13:
			case 0x14:
			case 0x15:
			case 22:
			case 0x17:
			case 0x18:
			case 0x19:
			case 0x1A:
			case 0x1B:
			case 0x1C:
			case 0x1D:
			case 0x1E:
			case 0x24:
			case 0x25:
			case 0x26:
			case 0x27:
			case 0x28:
			case 0x29:
			case 0x2A:
			case 0x2B:
			case 44:
			case 0x2D:
			case 0x2E:
			case 0x2F:
			case 0x30:
			case 0x31:
			case 0x32:
			case 0x33:
			case 0x34:
			case 0x35:
			case 0x36:
			case 55:
			case 0x38:
			case 0x39:
			case 0x3A:
			case 0x3B:
			case 0x3C:
			case 0x3D:
			case 0x3E:
			case 0x3F:
			case 0x40:
			case 0x41:
			case 66:
				break;
			case 0x1F:
				Eq_152914 edx_128;
				word32 eax_127 = fn0073F2C0(esi_37, dwArg04, out edx_128);
				edxOut = edx_128;
				return eax_127;
			case 0x20:
				Eq_152914 edx_115;
				word32 eax_114 = fn0073F5B0(esi_37, out edx_115);
				edxOut = edx_115;
				return eax_114;
			case 33:
				Eq_152914 edx_100;
				word32 eax_99 = fn0073D050(esi_37, dwArg04, out edx_100);
				edxOut = edx_100;
				return eax_99;
			case 0x22:
				Eq_152914 edx_82;
				word32 eax_81 = fn0073F7B0(dwArg04, esi_37, out edx_82);
				edxOut = edx_82;
				return eax_81;
			case 0x23:
				Eq_152914 edx_65;
				word32 eax_64 = fn0073FA50(esi_37, out edx_65);
				edxOut = edx_65;
				return eax_64;
			case 0x43:
				Eq_152914 edx_50;
				word32 eax_49 = fn0073FAF0(dwArg04, esi_37, out edx_50);
				edxOut = edx_50;
				return eax_49;
			}
		}
	}
	word32 ecx_572;
	fn006E15D0(g_tA18720, 9293392, out ecx_572, out edx_286);
l0074032C:
	edxOut = edx_286;
	return 0x00;
}

// 007403E0: Register word32 fn007403E0(Register Eq_3 edx, Register Eq_3 edi, Register (ptr16 Eq_7) es, Register (ptr16 Eq_8) ds, Stack Eq_3 dwArg04, Stack (ptr32 ui32) dwArg08)
// Called from:
//      fn006E8AC0
//      fn006E8B50
word32 fn007403E0(Eq_3 edx, Eq_3 edi, struct Eq_7 * es, struct Eq_8 * ds, Eq_3 dwArg04, ui32 * dwArg08)
{
	Eq_3 ebx_326;
	__align(fp - 4);
	Eq_3 esi_104 = 0x00;
	if (dwArg08 != null && (*dwArg08 & 0x0100) != 0x00)
	{
		ebx_326 = dwArg04;
		if (*dwArg04 == 338)
		{
			word32 edx_807;
			fn0073B830(out edx_807);
			goto l0074041B;
		}
	}
	else if (*dwArg04 == 338)
	{
		edx = *((word32) dwArg04 + 20);
		dwArg04 = edx;
		ebx_326 = edx;
	}
	else
		ebx_326 = dwArg04;
	int32 eax_49 = (int32) *ebx_326;
	Eq_3 dwLoc20_586 = 0x00;
	if (eax_49 != 0x0100)
	{
		if (eax_49 == 0x0101)
		{
			word32 edx_809;
			word32 edx_808;
			Eq_3 eax_310 = fn00752E30(fn0073B9B0(edx, ebx_326, fp - 4, 0x00, edi, es, ds, ebx_326, out edx_808), out edx_809);
			if (eax_310 == 0x00)
				return 0x00;
			Eq_3 edx_320 = *((word32) ebx_326 + 16);
			Eq_3 edx_321 = edx_320 - 0x01;
			word32 dwLoc18_742 = 0x01;
			if (edx_320 > 0x01)
			{
				word32 dwLoc1C_743 = 0x00;
				do
				{
					Eq_3 edi_330 = (word32) *((word32) ebx_326 + 20) + dwLoc1C_743;
					if (*edi_330 != 0x04)
					{
						word32 edx_811;
						Eq_3 eax_344 = fn0073B9B0(edx_321, ebx_326, fp - 4, esi_104, edi_330, es, ds, edi_330, out edx_811);
						if (eax_344 == 0x01)
						{
							Eq_3 eax_416 = fn00740160(dwArg04, out edx_321);
							if (eax_416 == 0x00)
								goto l0074041B;
							*((word32) eax_310 + (esi_104 * 0x04 + 4)) = eax_416;
							++esi_104;
							dwLoc20_586 = esi_104;
						}
						else
						{
							edx_321 = *((word32) edi_330 + 20);
							Eq_3 edi_358 = 0x00;
							if (eax_344 > 0x00)
							{
								esi_104 = (word32) eax_310 + 4 + esi_104 * 0x04;
								do
								{
									Eq_3 eax_390 = fn00740160(dwArg04, out edx_321);
									if (eax_390 == 0x00)
										goto l0074041B;
									word32 v16_399 = dwLoc20_586 + 0x01;
									*esi_104.u0 = eax_390;
									dwLoc20_586 = v16_399;
									edi_358 = (word32) edi_358 + 1;
									esi_104 += 0x04;
								} while (edi_358 < eax_344);
								esi_104 = v16_399;
								ebx_326 = dwArg04;
							}
						}
					}
					dwLoc1C_743 += 0x18;
					dwLoc18_742 = dwLoc18_818 + 0x01;
					dwLoc18_818 = dwLoc18_742;
				} while (dwLoc18_818 + 0x00 < *((word32) ebx_326 + 16) - 0x01);
			}
			return fn00742E70(eax_310);
		}
		if (eax_49 == 0x0102)
		{
			esi_104 = fp - 0x0C;
			word32 edx_810;
			Eq_3 eax_494 = fn0073C790(*((word32) ebx_326 + 20), out edx_810);
			if (eax_494 != 0x00)
				return fn00742ED0(eax_494);
		}
	}
	else
	{
		Eq_3 edi_55 = *((word32) ebx_326 + 20);
		if (*edi_55 == 0x04)
		{
			word32 edx_814;
			Eq_3 eax_241 = fn00752E30(0x01, out edx_814);
			if (eax_241 != 0x00)
			{
				word32 edx_815;
				*((word32) eax_241 + 4) = fn007436E0(*((word32) ebx_326 + 8), dwArg04, out edx_815);
				return fn00742EA0(eax_241);
			}
		}
		else
		{
			word32 edx_812;
			Eq_3 eax_81 = fn0073B9B0(edx, ebx_326, fp - 4, 0x00, edi_55, es, ds, edi_55, out edx_812);
			word32 edx_813;
			Eq_3 eax_99 = fn00752E30(eax_81, out edx_813);
			esi_104 = eax_99;
			if (eax_99 != 0x00)
			{
				if (eax_81 != 0x01)
				{
					esi_104.u0 = 0x00;
					if (*((word32) edi_55 + 16) > 0x00)
					{
						int32 ebx_115 = 0x00;
						while (*((word32) *((word32) edi_55 + 20) + ebx_115) != 0x04)
						{
							word32 edx_817;
							Eq_3 eax_141 = fn00740160(dwArg04, out edx_817);
							if (eax_141 == 0x00)
								goto l0074041B;
							int64 edx_eax_152 = (int64) esi_104;
							*((word32) eax_99 + (((word32) edx_eax_152 - SLICE(edx_eax_152, word32, 32) >> 0x01) * 0x04 + 4)) = eax_141;
							esi_104 += 0x02;
							ebx_115 += 0x30;
							if (esi_104 >= *((word32) edi_55 + 16))
								return fn00742EA0(eax_99);
						}
					}
					return fn00742EA0(eax_99);
				}
				word32 edx_816;
				Eq_3 eax_205 = fn00740160(dwArg04, out edx_816);
				if (eax_205 != 0x00)
				{
					*((word32) eax_99 + 4) = eax_205;
					return fn00742EA0(eax_99);
				}
			}
		}
	}
l0074041B:
	fn0073B870(esi_104, dwArg0C);
	return 0x00;
}

// 007406A0: Register (ptr32 Eq_147235) fn007406A0(Register (ptr32 Eq_147235) eax, Register (ptr32 Eq_147156) ecx, Stack Eq_3 dwArg04, Stack (ptr32 Eq_65917) dwArg08, Stack Eq_3 bArg0C)
// Called from:
//      fn00740A90
//      fn00740B40
struct Eq_147235 * fn007406A0(struct Eq_147235 * eax, struct Eq_147156 * ecx, Eq_3 dwArg04, struct Eq_65917 * dwArg08, Eq_3 bArg0C)
{
	word32 esi_22 = 0x00;
	word32 dwLoc10_1187 = 0x00;
	word32 dwLoc0C_1198 = 0x00;
	word32 ecx_28;
	Eq_3 eax_27 = fn007551F0(ecx, eax, out ecx_28);
	if (eax_27 == 0x00)
	{
		word32 eax_685;
		_iob_func();
		fprintf(eax_685 + 0x40, 9293496, 0x00);
		dwArg08->t0000.u0 = 0x0F;
		fn007539D0(dwArg04);
		return null;
	}
	if ((bArg0C & 0x03) != 0x00)
		*((word32) eax_27 + 0x0000177C) |= 0x8000;
	struct Eq_147235 * ebx_480;
	struct Eq_65917 * edi_476;
	struct Eq_159524 * esp_140;
	word32 eax_63 = fn00754FA0(dwArg04);
	word32 dwLoc1C_838 = eax_63;
	if (eax_63 != 0x34)
	{
		while (true)
		{
			word32 dwLoc08_840;
			if (dwLoc1C_838 == 0x00 && esi_22 != 0x00)
			{
				word32 eax_83 = *((word32) dwArg04 + 32);
				dwLoc1C_838 = 0x04;
				dwLoc10_1187 = 0x00;
				dwLoc0C_1198 = 0x00;
				dwLoc08_840 = 0x00;
				if (eax_83 != 0x00 && (bArg0C & 0x02) == 0x00)
				{
					*((word32) dwArg04 + 440) = -eax_83;
					*((word32) dwArg04 + 32) = 0x00;
				}
			}
			else
				dwLoc08_840 = 0x01;
			Eq_3 ebx_101 = dwLoc04 - dwLoc14;
			word32 ecx_107;
			word32 edx_1207;
			Eq_3 eax_106 = fn00723860((word32) ebx_101 + 1, out ecx_107, out edx_1207);
			Eq_3 esi_113 = eax_106;
			if (eax_106 == 0x00)
				break;
			if (ebx_101 > 0x00)
				strncpy(eax_106, dwLoc14, ebx_101);
			Mem164[eax_106 + ebx_101:byte] = 0x00;
			if (dwLoc1C_838 == 0x01)
			{
				if (ebx_101 == 0x06 && *eax_106 == 0x69)
				{
					byte * edi_170 = &g_b8DBBEC;
					word32 ecx_171 = 0x07;
					bool v19_714 = false;
					while (ecx_171 != 0x00)
					{
						v19_714 = *esi_1214 != *edi_1215;
						esi_113 = (word32) esi_1214 + 1;
						edi_170 = edi_1215 + 1;
						--ecx_171;
						esi_1214 = esi_113;
						edi_1215 = edi_170;
						if (*esi_1214 == *edi_1215)
							break;
					}
					if (!v19_714)
						dwLoc10_1187 = 0x01;
				}
				Eq_3 esi_203 = eax_106;
				if ((*((word32) eax_27 + 0x0000177C) & 0x8000) == 0x00)
				{
					if (ebx_101 == 0x04 && *eax_106 == 0x77)
					{
						const char * edi_232 = "with";
						word32 ecx_233 = 0x05;
						bool v27_722 = false;
						while (ecx_233 != 0x00)
						{
							v27_722 = *esi_1218 != *edi_1219;
							esi_203 = (word32) esi_1218 + 1;
							edi_232 = edi_1219 + 1;
							--ecx_233;
							esi_1218 = esi_203;
							edi_1219 = edi_232;
							if (*esi_1218 == *edi_1219)
								break;
						}
						if (v27_722)
							goto l00740849;
						dwArg08->t0004 != 0x00;
						goto l00740827;
					}
l00740849:
					Eq_3 esi_264 = eax_106;
					if (dwLoc10_1187 == 0x00 && (dwLoc0C_1198 == 0x00 && (ebx_101 == 0x02 && *eax_106 == 0x61)))
					{
						const char * edi_267 = "as";
						word32 ecx_268 = 0x03;
						bool v31_726 = false;
						while (ecx_268 != 0x00)
						{
							v31_726 = *esi_1220 != *edi_1221;
							esi_264 = (word32) esi_1220 + 1;
							edi_267 = edi_1221 + 1;
							--ecx_268;
							esi_1220 = esi_264;
							edi_1221 = edi_267;
							if (*esi_1220 == *edi_1221)
								break;
						}
						if (!v31_726)
						{
							dwArg08->t0004 != 0x00;
l00740827:
							word32 edx_1210;
							fn00716B20(out edx_1210);
						}
					}
				}
				else if (ebx_101 == 0x04 && *eax_106 == 0x77)
				{
					const char * edi_206 = "with";
					word32 ecx_207 = 0x05;
					bool v23_718 = false;
					while (ecx_207 != 0x00)
					{
						v23_718 = *esi_1216 != *edi_1217;
						esi_203 = (word32) esi_1216 + 1;
						edi_206 = edi_1217 + 1;
						--ecx_207;
						esi_1216 = esi_203;
						edi_1217 = edi_206;
						if (*esi_1216 == *edi_1217)
							break;
					}
					if (!v23_718)
						dwLoc0C_1198 = 0x01;
				}
			}
			ptr32 eax_383;
			Eq_3 ecx_378 = *((word32) dwArg04 + 896);
			if (dwLoc14 >= ecx_378)
				eax_383 = dwLoc14 - ecx_378;
			else
				eax_383 = ~0x00;
			Eq_3 eax_411 = fn00755500(eax_27, dwLoc1C_838, eax_106, *((word32) dwArg04 + 452), eax_383, &dwArg08->dw0018);
			dwArg08->t0000 = eax_411;
			if (eax_411 != 0x0A)
			{
				if (eax_411 == 0x10)
					goto l00740A06;
				word32 ecx_1212;
				word32 edx_1213;
				fn007239C0(eax_106, out ecx_1212, out edx_1213);
				dwArg08->dw0014 = dwLoc1C_838;
				goto l007409F9;
			}
			word32 eax_452 = fn00754FA0(dwArg04);
			dwLoc1C_838 = eax_452;
			if (eax_452 == 0x34)
				goto l0074090E;
			esi_22 = dwLoc08_840;
		}
		struct Eq_159647 * esp_129;
		word32 eax_130;
		_iob_func();
		esp_129->tFFFFFFFC = eax_130 + 0x40;
		fprintf(esp_129->tFFFFFFFC, esp_129->t0000, 0x00);
		*esp_129->ptr003C = 0x0F;
		esp_140 = (struct Eq_159524 *) ((const char *) &esp_129->t0000 + 4);
	}
	else
	{
l0074090E:
		dwArg08->t0000 = *((word32) dwArg04 + 20);
l007409F9:
		esp_140 = fp - 0x30;
		if (dwArg08->t0000 == 0x10)
		{
l00740A06:
			ebx_480 = (struct Eq_147235 *) *((word32) eax_27 + 6008);
			*((word32) eax_27 + 6008) = null;
			edi_476 = dwArg08;
l00740944:
			fn00755280(eax_27);
			if (ebx_480 == null)
			{
				if (*((word32) dwArg04 + 452) <= 0x01 && *((word32) dwArg04 + 20) == 11)
					edi_476->t0000.u0 = 11;
				edi_476->dw0008 = (int32) *((word32) dwArg04 + 452);
				Eq_3 ecx_563 = *dwArg04;
				if (ecx_563 != 0x00)
				{
					edi_476->dw000C = *((word32) dwArg04 + 4) - ecx_563;
					Eq_3 esi_596 = *((word32) dwArg04 + 8) - *dwArg04;
					Eq_3 eax_611 = fn00755020(dwArg04, dwArg04);
					Eq_3 edi_616 = eax_611;
					if (eax_611 == 0x00)
					{
						word32 ecx_1208;
						word32 edx_1209;
						Eq_3 eax_624 = fn00723860((word32) esi_596 + 1, out ecx_1208, out edx_1209);
						edi_616 = eax_624;
						if (eax_624 != 0x00)
						{
							if (esi_596 > 0x00)
								strncpy(eax_624, *dwArg04, esi_596);
							Mem652[esi_596 + eax_624:byte] = 0x00;
						}
					}
					dwArg08->t0010 = edi_616;
					fn007539D0(dwArg04);
					return ebx_480;
				}
			}
			else if (*((word32) dwArg04 + 888) != 0x00)
			{
				word32 ecx_1211;
				struct Eq_147235 * eax_511 = fn0073B660(338, out ecx_1211);
				if (eax_511 == null)
				{
					edi_476->t0000.u0 = 0x0F;
					fn007539D0(dwArg04);
					return null;
				}
				Eq_3 ecx_522 = *((word32) dwArg04 + 888);
				eax_511->ptr0014 = ebx_480;
				eax_511->t0004 = ecx_522;
				eax_511->dw0010 = 0x01;
				((word32) dwArg04 + 888)->u0 = 0x00;
				ebx_480 = eax_511;
			}
			fn007539D0(dwArg04);
			return ebx_480;
		}
	}
	ebx_480 = null;
	edi_476 = esp_140->ptr0038;
	goto l00740944;
}

// 00740A90: Register Eq_3 fn00740A90(Stack Eq_3 dwArg08, Stack (ptr32 Eq_65873) dwArg14)
// Called from:
//      fn006E8AC0
Eq_3 fn00740A90(Eq_3 dwArg08, struct Eq_65873 * dwArg14)
{
	dwArg14->dw0014 = ~0x00;
	dwArg14->dw0018 = ~0x00;
	dwArg14->dw0000 = 0x0A;
	dwArg14->t0004 = dwArg08;
	dwArg14->dw0008 = 0x00;
	dwArg14->dw000C = 0x00;
	dwArg14->dw0010 = 0x00;
	Eq_3 edi_18 = dwArg08;
	Eq_3 eax_27 = fn00755100();
	if (eax_27 != 0x00)
	{
		if (dwArg08 == 0x00)
			edi_18.u0 = 0x008D3F0C;
		*((word32) eax_27 + 0x01CC) = edi_18;
		if (g_dwA74AEC != 0x00 || g_tA74AF0 != 0x00)
		{
			*((word32) eax_27 + 464) = (uint32) (int8) (edi_18 != 0x00);
			if (g_dwA74AEC >= 0x02)
				*((word32) eax_27 + 468) = (word32) *((word32) eax_27 + 468) + 1;
		}
		return fn007406A0(dwArg10, dwArg0C, eax_27, dwArg04, dwArg08);
	}
	else
	{
		dwArg14->dw0000 = (0x00 - (fn006E0FC0() == 0x00) & 0x07) + 0x0F;
		return 0x00;
	}
}

// 00740B40: Register Eq_3 fn00740B40(Stack (ptr32 ui32) dwArg04, Stack Eq_3 dwArg08, Stack word32 dwArg14, Stack word32 dwArg18, Stack (ptr32 Eq_65917) dwArg1C)
// Called from:
//      fn006E8B50
Eq_3 fn00740B40(ui32 * dwArg04, Eq_3 dwArg08, word32 dwArg14, word32 dwArg18, struct Eq_65917 * dwArg1C)
{
	dwArg1C->dw0014 = ~0x00;
	dwArg1C->dw0018 = ~0x00;
	dwArg1C->t0000.u0 = 0x0A;
	dwArg1C->t0004 = dwArg08;
	dwArg1C->dw0008 = 0x00;
	dwArg1C->dw000C = 0x00;
	dwArg1C->t0010.u0 = 0x00;
	Eq_3 eax_33 = fn00755140(dwArg04, dwArg14, dwArg18);
	if (eax_33 != 0x00)
	{
		*((word32) eax_33 + 0x01CC) = dwArg08;
		if (g_dwA74AEC != 0x00 || g_tA74AF0 != 0x00)
		{
			*((word32) eax_33 + 464) = (uint32) (int8) (dwArg08 != 0x00);
			if (g_dwA74AEC >= 0x02)
				*((word32) eax_33 + 468) = (word32) *((word32) eax_33 + 468) + 1;
		}
		return fn007406A0(dwArg10, dwArg0C, eax_33, dwArg1C, dwArg20);
	}
	else
	{
		dwArg1C->t0000.u0 = 0x0F;
		return eax_33;
	}
}

// 00740C20: void fn00740C20(Register Eq_3 eax)
// Called from:
//      fn00740CC0
void fn00740C20(Eq_3 eax)
{
	if (eax != 0x00)
	{
		do
		{
			Eq_3 esi_18 = *((word32) eax + 8);
			free(eax);
			eax = esi_18;
		} while (esi_18 != 0x00);
	}
}

// 00740C50: Register (ptr32 Eq_160165) fn00740C50(Register (ptr32 Eq_160165) eax, Register Eq_3 ecx, Register out ptr32 edxOut)
// Called from:
//      fn00740DC0
struct Eq_160165 * fn00740C50(struct Eq_160165 * eax, Eq_3 ecx, ptr32 & edxOut)
{
	uint32 esi_19 = (word32) ecx + 7 & ~0x07;
	struct Eq_160165 * edi_16 = eax;
	if (eax->ptr0004 + esi_19 > eax->dw0000)
	{
		uint32 ebx_24 = 0x2000;
		if (esi_19 >= 0x2000)
			ebx_24 = esi_19;
		struct Eq_160165 * eax_32 = malloc(ebx_24 + 0x10);
		if (eax_32 == null)
		{
			edxOut = edx;
			return null;
		}
		eax_32->dw0000 = ebx_24;
		eax_32->ptr000C = &eax_32->ptr000C + 1;
		eax_32->ptr0008 = null;
		edx = (eax_32 + 0x17 & ~0x07) - (eax_32 + 0x10);
		eax_32->ptr0004 = edx;
		eax->ptr0008 = eax_32;
		edi_16 = eax_32;
	}
	ptr32 ecx_60 = edi_16->ptr0004;
	struct Eq_160165 * eax_62 = edi_16->ptr000C + ecx_60;
	edi_16->ptr0004 = ecx_60 + esi_19;
	edxOut = edx;
	return eax_62;
}

// 00740CC0: Register Eq_3 fn00740CC0()
// Called from:
//      fn006E9040
//      fn006E90B0
//      fn006F67C0
Eq_3 fn00740CC0()
{
	Eq_3 eax_13 = malloc(0x0C);
	if (eax_13 != 0x00)
	{
		Eq_3 esi_35;
		Eq_3 eax_21 = malloc(0x2010);
		if (eax_21 == 0x00)
			esi_35.u0 = 0x00;
		else
		{
			*eax_21 = 0x2000;
			*((word32) eax_21 + 0x0C) = (word32) eax_21 + 16;
			((word32) eax_21 + 8)->u0 = 0x00;
			Mem34[eax_21 + 0x04:word32] = (eax_21 + 0x17 & ~0x07) - (eax_21 + 0x10);
			esi_35 = eax_21;
		}
		*eax_13 = esi_35;
		*((word32) eax_13 + 4) = esi_35;
		if (esi_35 != 0x00)
		{
			word32 edx_154;
			Eq_3 eax_51 = fn006F2650(0x00, out edx_154);
			*((word32) eax_13 + 8) = eax_51;
			if (eax_51 != 0x00)
				return eax_13;
			fn00740C20(esi_35);
			free(eax_13);
			word32 ecx_157;
			word32 edx_158;
			return fn006E1210(out ecx_157, out edx_158);
		}
		else
		{
			free(eax_13);
			word32 ecx_155;
			word32 edx_156;
			return fn006E1210(out ecx_155, out edx_156);
		}
	}
	else
	{
		word32 ecx_152;
		word32 edx_153;
		return fn006E1210(out ecx_152, out edx_153);
	}
}

// 00740D60: void fn00740D60(Stack Eq_3 dwArg04)
// Called from:
//      fn006E9040
//      fn006E90B0
//      fn006F67C0
void fn00740D60(Eq_3 dwArg04)
{
	Eq_3 eax_12 = *dwArg04;
	if (eax_12 != 0x00)
	{
		do
		{
			Eq_3 esi_21 = *((word32) eax_12 + 8);
			free(eax_12);
			eax_12 = esi_21;
		} while (esi_21 != 0x00);
	}
	fn006F34B0(*((word32) dwArg04 + 8));
	Eq_3 eax_57 = *((word32) dwArg04 + 8);
	*eax_57 = (word32) *eax_57 - 1;
	Eq_3 edx_60 = *((word32) dwArg04 + 8);
	if (*edx_60 == 0x00)
	{
		struct Eq_160356 * ecx_65 = *((word32) edx_60 + 4);
		ecx_65->ptr0018();
	}
	free(dwArg04);
}

// 00740DC0: Register Eq_3 fn00740DC0(Stack (ptr32 Eq_160364) dwArg04, Stack Eq_3 dwArg08, Register out ptr32 edxOut)
// Called from:
//      fn00742E70
//      fn00742EA0
//      fn00742ED0
//      fn00742F20
//      fn00742FB0
//      fn00743020
//      fn00743060
//      fn007430A0
//      fn00743100
//      fn007431B0
//      fn00743200
//      fn00743290
//      fn00743300
//      fn00743370
//      fn007433E0
//      fn00743430
//      fn00743480
//      fn007434C0
//      fn00743520
//      fn00743560
//      fn007435D0
//      fn00743640
//      fn00743680
//      fn007436E0
//      fn00743710
//      fn00743740
//      fn00743770
//      fn007437D0
//      fn00743880
//      fn00743900
//      fn00743980
//      fn00743A30
//      fn00743A70
//      fn00743AD0
//      fn00743B30
//      fn00743B70
//      fn00743BE0
//      fn00743C60
//      fn00743CC0
//      fn00743D20
//      fn00743D80
//      fn00743E30
//      fn00743EE0
//      fn00743F60
//      fn00743FC0
//      fn00744020
//      fn00744050
//      fn00744090
//      fn007440C0
//      fn00744110
//      fn00744180
//      fn007441C0
//      fn00744200
//      fn00744270
//      fn00752E30
Eq_3 fn00740DC0(struct Eq_160364 * dwArg04, Eq_3 dwArg08, ptr32 & edxOut)
{
	ptr32 edx_13;
	Eq_3 eax_11 = fn00740C50(dwArg04->ptr0004, dwArg08, out edx_13);
	if (eax_11 != 0x00)
	{
		struct Eq_160165 * ecx_22 = dwArg04->ptr0004->ptr0008;
		if (ecx_22 != null)
			dwArg04->ptr0004 = ecx_22;
		edxOut = edx_13;
		return eax_11;
	}
	else
	{
		ptr32 edx_37;
		word32 ecx_70;
		Eq_3 eax_35 = fn006E1210(out ecx_70, out edx_37);
		edxOut = edx_37;
		return eax_35;
	}
}

// 00740DF0: Register word32 fn00740DF0(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08)
// Called from:
//      fn0072DD60
//      fn0073B810
//      fn0073C100
//      fn0073C280
//      fn0073C520
//      fn0073C870
//      fn0073CAE0
//      fn0073CE00
//      fn0073E050
//      fn0073E390
//      fn0073FAF0
//      fn0073FC30
//      fn00740060
word32 fn00740DF0(Eq_3 dwArg04, Eq_3 dwArg08)
{
	word32 ecx_82;
	word32 edx_21;
	if (fn006F2A10(*((word32) dwArg04 + 8), dwArg08, out ecx_82, out edx_21) >= 0x00)
	{
		word32 v11_29 = (word32) *dwArg08 - 1;
		*dwArg08 = v11_29;
		if (v11_29 == 0x00)
		{
			struct Eq_160420 * edx_33 = *((word32) dwArg08 + 4);
			edx_33->ptr0018();
		}
	}
	return edx_21;
}

