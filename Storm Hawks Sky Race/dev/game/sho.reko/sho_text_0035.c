// sho_text_0035.c
// Generated by decompiling sho.exe
// using Reko decompiler version 0.10.0.0.

#include "sho.h"

// 007514B0: Register (ptr32 Eq_138891) fn007514B0(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Register out Eq_3 edxOut)
// Called from:
//      fn0071FEB0
struct Eq_138891 * fn007514B0(Eq_3 dwArg04, Eq_3 dwArg08, union Eq_3 & edxOut)
{
	Eq_3 edx_36;
	if (dwArg08 < 0x00 && dwArg08 != ~0x00)
	{
		word32 ecx_111;
		fn006E0F80(g_tA17E2C, 0x008DF684, out ecx_111, out edx_36);
	}
	else
	{
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_3 stackArg8 = <invalid>;
		word32 edx_109;
		word32 ecx_108;
		struct Eq_138891 * eax_34 = fn006DDD30(fn00723860(g_tA34F98, out ecx_108, out edx_109), stackArg8, out edx_36);
		if (eax_34 != null)
		{
			eax_34->t0010 = dwArg08;
			eax_34->t0008.u0 = 0x00;
			eax_34->t000C = dwArg04;
			eax_34->t0014.u0 = 0x00;
			eax_34->t0018.u0 = 0x01;
			eax_34->t001C.u0 = ~0x00;
			edxOut = dwArg04;
			return eax_34;
		}
	}
	edxOut = edx_36;
	return null;
}

// 00752B30: Register word32 fn00752B30(Stack Eq_3 dwArg04, Stack (ptr32 Eq_170969) dwArg08)
// Called from:
//      fn00752CA0
word32 fn00752B30(Eq_3 dwArg04, struct Eq_170969 * dwArg08)
{
	struct Eq_170970 * eax_8 = dwArg08->ptr0008;
	struct Eq_170970 * dwLoc08_398 = null;
	union Eq_3 ** ebx_24 = (const char *) &eax_8->ptr0000 + 4;
	while (true)
	{
		struct Eq_170970 * eax_25 = eax_8;
		if (eax_8 != null)
			eax_25 = eax_8->ptr0000;
		if (dwLoc08_398 >= eax_25)
			break;
		word32 edx_610;
		word32 ecx_609;
		word32 esi_611;
		Eq_3 eax_63 = fn006ECC50(**ebx_24, out ecx_609, out edx_610, out esi_611);
		if (eax_63 == 0x00)
			return 0x00;
		byte * edi_72 = &g_b8DF928;
		Eq_3 esi_73 = eax_63;
		word32 ecx_74 = 0x0E;
		bool v22_367 = true;
		while (ecx_74 != 0x00)
		{
			v22_367 = *esi_618 == *edi_619;
			esi_73 = (word32) esi_618 + 1;
			edi_72 = edi_619 + 1;
			--ecx_74;
			esi_618 = esi_73;
			edi_619 = edi_72;
			if (*esi_618 == *edi_619)
				break;
		}
		if (!v22_367)
		{
			byte * edi_101 = &g_b8DCF50;
			Eq_3 esi_103 = eax_63;
			word32 ecx_105 = 11;
			bool v26_371 = true;
			while (ecx_105 != 0x00)
			{
				v26_371 = *esi_620 == *edi_621;
				esi_103 = (word32) esi_620 + 1;
				edi_101 = edi_621 + 1;
				--ecx_105;
				esi_620 = esi_103;
				edi_621 = edi_101;
				if (*esi_620 == *edi_621)
					break;
			}
			if (v26_371)
				goto l00752C04;
			byte * edi_110 = &g_b8DF91C;
			Eq_3 esi_113 = eax_63;
			word32 ecx_114 = 0x09;
			bool v30_375 = false;
			while (ecx_114 != 0x00)
			{
				v30_375 = *esi_622 != *edi_623;
				esi_113 = (word32) esi_622 + 1;
				edi_110 = edi_623 + 1;
				--ecx_114;
				esi_622 = esi_113;
				edi_623 = edi_110;
				if (*esi_622 == *edi_623)
					break;
			}
			if (!v30_375)
			{
				*dwArg04 |= 0x2000;
				dwLoc08_398 = (struct Eq_170970 *) ((const char *) &dwLoc08_398->ptr0000 + 1);
				ebx_24 = (union Eq_3 **) ((const char *) ebx_24 + 4);
				continue;
			}
			byte * edi_130 = &g_b8DF90C;
			Eq_3 esi_133 = eax_63;
			word32 ecx_134 = 0x10;
			bool v34_379 = false;
			while (ecx_134 != 0x00)
			{
				v34_379 = *esi_624 != *edi_625;
				esi_133 = (word32) esi_624 + 1;
				edi_130 = edi_625 + 1;
				--ecx_134;
				esi_624 = esi_133;
				edi_625 = edi_130;
				if (*esi_624 == *edi_625)
					break;
			}
			if (!v34_379)
			{
				*dwArg04 |= 0x4000;
				dwLoc08_398 = (struct Eq_170970 *) ((const char *) &dwLoc08_398->ptr0000 + 1);
				ebx_24 = (union Eq_3 **) ((const char *) ebx_24 + 4);
				continue;
			}
			byte * edi_150 = &g_b8DF8FC;
			Eq_3 esi_153 = eax_63;
			word32 ecx_154 = 0x0F;
			bool v38_383 = false;
			while (ecx_154 != 0x00)
			{
				v38_383 = *esi_626 != *edi_627;
				esi_153 = (word32) esi_626 + 1;
				edi_150 = edi_627 + 1;
				--ecx_154;
				esi_626 = esi_153;
				edi_627 = edi_150;
				if (*esi_626 == *edi_627)
					break;
			}
			if (!v38_383)
			{
				*dwArg04 |= 0x8000;
				goto l00752C04;
			}
			byte * edi_170 = &g_b8DF8F4;
			Eq_3 esi_173 = eax_63;
			word32 ecx_174 = 0x07;
			bool v42_387 = false;
			while (ecx_174 != 0x00)
			{
				v42_387 = *esi_628 != *edi_629;
				esi_173 = (word32) esi_628 + 1;
				edi_170 = edi_629 + 1;
				--ecx_174;
				esi_628 = esi_173;
				edi_629 = edi_170;
				if (*esi_628 == *edi_629)
					break;
			}
			if (v42_387)
			{
				word32 ecx_612;
				word32 edx_613;
				fn006E15D0(g_tA178F4, dwArg04, out ecx_612, out edx_613);
				word32 edx_614;
				fn006E1DE0(dwArg04, out edx_614);
				return 0x00;
			}
			word32 edx_616;
			word32 ecx_615;
			fn006E0F80(g_tA178F4, dwArg04, out ecx_615, out edx_616);
			word32 edx_617;
			fn006E1DE0(dwArg04, out edx_617);
			return 0x00;
		}
l00752C04:
		dwLoc08_398 = (struct Eq_170970 *) ((const char *) &dwLoc08_398->ptr0000 + 1);
		ebx_24 = (union Eq_3 **) ((const char *) ebx_24 + 4);
	}
	return 0x01;
}

// 00752CA0: Register word32 fn00752CA0(Stack Eq_3 dwArg04, Stack (ptr32 Eq_171254) dwArg08)
// Called from:
//      fn00752DC0
word32 fn00752CA0(Eq_3 dwArg04, struct Eq_171254 * dwArg08)
{
	Eq_3 eax_111 = g_tA6E4C8;
	int32 ebx_107 = 0x00;
	word32 edi_114 = 0x00;
	Eq_3 ebp_19 = 0x00;
	word32 dwLoc04_228 = 0x00;
	if (eax_111 == 0x00)
	{
		word32 ecx_346;
		word32 edx_347;
		eax_111 = fn006F1A70(out ecx_346, out edx_347);
		g_tA6E4C8 = eax_111;
		if (eax_111 == 0x00)
			return 0x00;
	}
	word32 ecx_38 = dwArg08->dw0000;
	if (ecx_38 != 0x01 && ecx_38 != 0x02)
		return 0x01;
	while (true)
	{
		int32 edx_56;
		struct Eq_171288 * ecx_52 = dwArg08->ptr0004;
		if (ecx_52 == null)
			edx_56 = 0x00;
		else
			edx_56 = ecx_52->dw0000;
		if (ebx_107 >= edx_56)
			break;
		struct Eq_170969 * esi_71 = ecx_52->a0004[ebx_107].dw0000;
		if (edi_114 != 0x00 && esi_71->t0014 > ebp_19)
			return 0x01;
		word32 ecx_93 = esi_71->dw0000;
		ebp_19 = esi_71->t0014;
		if (ecx_93 == 0x11)
		{
			if (esi_71->t0004 == eax_111)
			{
				if (edi_114 == 0x00)
				{
					if (fn00752B30(dwArg04, esi_71) != 0x00)
					{
						*((word32) dwArg04 + 4) = esi_71->t0014;
						eax_111 = g_tA6E4C8;
						++ebx_107;
						continue;
					}
				}
				else
				{
					word32 ecx_348;
					word32 edx_349;
					fn006E0F80(g_tA178F4, 0x008DA8B0, out ecx_348, out edx_349);
					word32 edx_350;
					fn006E1DE0(esi_71->t0014, out edx_350);
				}
				return 0x00;
			}
		}
		else if (ecx_93 == 0x14 && (dwLoc04_228 == 0x00 && *esi_71->t0004 == 0x0E))
		{
			dwLoc04_228 = 0x01;
			++ebx_107;
			continue;
		}
		edi_114 = 0x01;
		++ebx_107;
	}
	return 0x01;
}

// 00752DC0: Register Eq_3 fn00752DC0()
// Called from:
//      fn0072E790
Eq_3 fn00752DC0()
{
	word32 ecx_100;
	word32 edx_101;
	Eq_3 eax_9 = fn00723860(0x08, out ecx_100, out edx_101);
	if (eax_9 != 0x00)
	{
		*eax_9 = 0x00;
		((word32) eax_9 + 4)->u0 = ~0x00;
		if (fn00752CA0(eax_9, dwArg04) != 0x00)
			return eax_9;
		word32 ecx_104;
		word32 edx_105;
		fn007239C0(eax_9, out ecx_104, out edx_105);
		return 0x00;
	}
	else
	{
		word32 ecx_102;
		word32 edx_103;
		fn006E1210(out ecx_102, out edx_103);
		return 0x00;
	}
}

// 00752E10: Register word32 fn00752E10(Stack (ptr32 Eq_147156) dwArg04, Stack (ptr32 Eq_147235) dwArg08)
// Called from:
//      fn007379B0
//      fn007551F0
//      fn00755500
word32 fn00752E10(struct Eq_147156 * dwArg04, struct Eq_147235 * dwArg08)
{
	return dwArg04->dw0004 + ((dwArg08 - 0x0300) + dwArg08 * 0x02) * 0x08;
}

// 00752E30: Register Eq_3 fn00752E30(Stack Eq_3 dwArg04, Register out Eq_540 edxOut)
// Called from:
//      fn0073C090
//      fn0073C100
//      fn0073C7D0
//      fn0073CAE0
//      fn0073CE00
//      fn0073CEC0
//      fn0073D7A0
//      fn0073D9C0
//      fn0073DBD0
//      fn0073DF70
//      fn0073E050
//      fn0073E390
//      fn0073E7A0
//      fn0073EB20
//      fn0073EB70
//      fn0073EE40
//      fn0073F2C0
//      fn0073F7B0
//      fn0073FC30
//      fn007403E0
Eq_3 fn00752E30(Eq_3 dwArg04, union Eq_540 & edxOut)
{
	uint32 edi_14;
	if (dwArg04 != 0x00)
	{
		edi_14 = (dwArg04 - 0x01) * 0x04;
		if (dwArg04 < 0x00 || (dwArg04 == 0x80000000 || (dwArg04 > 0x40000000 || edi_14 > ~0x08)))
		{
			word32 edx_147;
			word32 ecx_146;
			fn006E1210(out ecx_146, out edx_147);
			edxOut.u0 = <invalid>;
			return 0x00;
		}
	}
	else
		edi_14 = 0x00;
	Eq_3 edi_36 = edi_14 + 0x08;
	word32 edx_148;
	Eq_3 eax_45 = fn00740DC0(dwArg08, edi_36, out edx_148);
	if (eax_45 != 0x00)
	{
		memset(eax_45, 0x00, edi_36);
		*eax_45 = dwArg04;
		edxOut.u0 = <invalid>;
		return eax_45;
	}
	else
	{
		word32 ecx_149;
		word32 edx_150;
		fn006E1210(out ecx_149, out edx_150);
		edxOut.u0 = <invalid>;
		return 0x00;
	}
}

// 00752EA0: Register (ptr32 Eq_171477) fn00752EA0()
// Called from:
//      fn00755100
//      fn00755140
struct Eq_171477 * fn00752EA0()
{
	struct Eq_171477 * eax_6 = malloc(0x0394);
	if (eax_6 == null)
		return null;
	eax_6->dw0010 = 0x00;
	eax_6->dw0008 = 0x00;
	eax_6->dw000C = 0x00;
	eax_6->dw0004 = 0x00;
	eax_6->dw0000 = 0x00;
	eax_6->dw0014 = 0x0A;
	eax_6->dw0018 = 0x00;
	eax_6->dw001C = 0x08;
	eax_6->dw0020 = 0x00;
	eax_6->dw0024 = 0x00;
	eax_6->dw01B4 = 0x01;
	eax_6->dw01B8 = 0x00;
	eax_6->dw01C0 = 0x00;
	eax_6->dw01BC = 0x00;
	eax_6->dw01C4 = 0x00;
	eax_6->dw01C8 = 0x00;
	eax_6->dw01CC = 0x00;
	eax_6->dw01D0 = 0x00;
	eax_6->dw01D4 = 0x00;
	eax_6->dw01D8 = 0x01;
	eax_6->dw01DC = 0x00;
	eax_6->dw036C = 0x00;
	eax_6->dw0370 = 0x00;
	eax_6->dw0374 = 0x00;
	eax_6->dw0378 = 0x00;
	eax_6->dw037C = 0x00;
	eax_6->dw0384 = 0x00;
	eax_6->dw0388 = 0x00;
	return eax_6;
}

// 00752F50: Register word32 fn00752F50(Register Eq_3 esi)
// Called from:
//      fn00753600
//      fn007537F0
word32 fn00752F50(Eq_3 esi)
{
	*((word32) esi + 880) = 0x01;
	if (*((word32) esi + 24) != 0x00)
	{
		Eq_3 eax_9 = *esi;
		if (eax_9 != 0x00)
			free(eax_9);
	}
	esi->u0 = 0x00;
	return 0x00;
}

// 00752F80: void fn00752F80(Register Eq_3 edi, Stack Eq_3 dwArg04)
// Called from:
//      fn00753360
//      fn00753A60
void fn00752F80(Eq_3 edi, Eq_3 dwArg04)
{
	Eq_3 eax_16 = (word32) edi + 1;
	if (edi == 0x01)
		eax_16.u0 = 0x01;
	Eq_3 eax_18 = malloc(eax_16);
	if (eax_18 != 0x00)
	{
		memcpy(eax_18, dwArg04, edi);
		Mem35[eax_18 + edi:byte] = 0x00;
	}
}

// 00752FC0: Register word32 fn00752FC0(Register Eq_3 ebx, Register Eq_3 ebp, Register Eq_3 esi, Register Eq_3 edi, Register (ptr16 Eq_7) es, Register (ptr16 Eq_8) ds, Stack Eq_3 dwArg04, Register out Eq_3 edxOut)
// Called from:
//      fn00753110
word32 fn00752FC0(Eq_3 ebx, Eq_3 ebp, Eq_3 esi, Eq_3 edi, struct Eq_7 * es, struct Eq_8 * ds, Eq_3 dwArg04, union Eq_3 & edxOut)
{
	ui32 eax_7 = g_tA14188 ^ fp - 0x14;
	Eq_171655 esi_25;
	Eq_171657 edi_26 = dwArg04 - (fp - 0x14);
	for (esi_25 = 0x00; esi_25 < 0x0C; ++esi_25)
	{
		word32 eax_33 = CONVERT(Mem32[fp - 0x14 + (edi_26 + esi_25):byte], byte, int32);
		if (eax_33 == 0x00)
			break;
		if (eax_33 == 0x5F)
			Mem54[fp - 0x14 + esi_25:byte] = 0x2D;
		else
			Mem53[fp - 0x14 + esi_25:byte] = SLICE(tolower(eax_33), byte, 0);
	}
	Mem62[fp - 0x14 + esi_25:byte] = 0x00;
	struct Eq_171661 * edi_63 = &g_t8D9880;
	Eq_171668 esi_64 = fp - 0x14;
	word32 ecx_65 = 0x06;
	bool v27_383 = true;
	while (ecx_65 != 0x00)
	{
		v27_383 = *esi_525 == edi_526->t0000;
		esi_64 = (word32) esi_525 + 1;
		edi_63 = edi_526 + 1;
		--ecx_65;
		esi_525 = esi_64;
		edi_526 = edi_63;
		if (*esi_525 == edi_526->t0000)
			break;
	}
	if (v27_383 || strncmp(fp - 0x14, 9304984, 0x06) == 0x00)
	{
		word32 ecx_522;
		word32 eax_157 = fn00694B8E(0x008D9880, eax_7 ^ fp - 0x14, 0x00, ebx, ebp, esi, edi, es, ds, ebx, out ecx_522);
		edxOut.u0 = 0x00;
		return eax_157;
	}
	else
	{
		struct Eq_171661 * edi_167 = &g_t8D9674;
		Eq_171739 esi_168 = fp - 0x14;
		word32 ecx_169 = 0x08;
		Eq_3 edx_170 = 0x00;
		bool v31_387 = true;
		while (ecx_169 != 0x00)
		{
			v31_387 = *esi_527 == edi_528->t0000;
			esi_168 = (word32) esi_527 + 1;
			edi_167 = edi_528 + 1;
			--ecx_169;
			esi_527 = esi_168;
			edi_528 = edi_167;
			if (*esi_527 == edi_528->t0000)
				break;
		}
		if (!v31_387)
		{
			struct Eq_171661 * edi_185 = &g_b8DCAA0;
			Eq_171783 esi_188 = fp - 0x14;
			word32 ecx_189 = 11;
			bool v35_391 = true;
			while (ecx_189 != 0x00)
			{
				v35_391 = *esi_529 == edi_530->t0000;
				esi_188 = (word32) esi_529 + 1;
				edi_185 = edi_530 + 1;
				--ecx_189;
				esi_529 = esi_188;
				edi_530 = edi_185;
				if (*esi_529 == edi_530->t0000)
					break;
			}
			if (!v35_391)
			{
				struct Eq_171661 * edi_205 = &g_t8DFB8C;
				Eq_171816 esi_208 = fp - 0x14;
				word32 ecx_209 = 0x0C;
				edx_170.u0 = 0x00;
				bool v39_395 = true;
				while (ecx_209 != 0x00)
				{
					v39_395 = *esi_531 == edi_532->t0000;
					esi_208 = (word32) esi_531 + 1;
					edi_205 = edi_532 + 1;
					--ecx_209;
					esi_531 = esi_208;
					edi_532 = edi_205;
					if (*esi_531 == edi_532->t0000)
						break;
				}
				if (!v39_395 && (strncmp(fp - 0x14, 0x008DFB80, 0x08) != 0x00 && strncmp(fp - 0x14, 9304948, 11) != 0x00))
				{
					edx_170 = fp - 0x14;
					if (strncmp(fp - 0x14, 9304932, 0x0C) != 0x00)
					{
						word32 ecx_524;
						word32 eax_369 = fn00694B8E(dwArg04, eax_7 ^ fp - 0x14, fp - 0x14, ebx, ebp, esi, edi, es, ds, ebx, out ecx_524);
						edxOut = fp - (const char *) 0x14;
						return eax_369;
					}
				}
			}
		}
		word32 ecx_523;
		word32 eax_336 = fn00694B8E(9292448, eax_7 ^ fp - 0x14, edx_170, ebx, ebp, esi, edi, es, ds, ebx, out ecx_523);
		edxOut = edx_170;
		return eax_336;
	}
}

// 00753110: Register Eq_3 fn00753110(Register Eq_3 eax, Register Eq_3 ecx, Register (ptr16 Eq_7) es, Register (ptr16 Eq_8) ds, Register out ptr32 edxOut)
// Called from:
//      fn00753250
Eq_3 fn00753110(Eq_3 eax, Eq_3 ecx, struct Eq_7 * es, struct Eq_8 * ds, ptr32 & edxOut)
{
	int32 ebx_12 = (word32) eax - 6;
	int32 ebp_16 = 0x00;
	if (eax > ~0x05)
	{
		do
		{
			byte al_23 = *((word32) ecx + ebp_16);
			if (al_23 == 0x23)
				break;
			if (al_23 != 0x20 && (al_23 != 0x09 && al_23 != 0x0C))
			{
				edxOut = edx;
				return 0x00;
			}
			++ebp_16;
		} while (ebp_16 < (word32) eax - 6);
	}
	if (ebp_16 >= (word32) eax - 6)
	{
l007531BC:
		edxOut = edx;
		return 0x00;
	}
	Eq_3 edi_256 = (word32) ecx + 6 + ebp_16;
l00753146:
	if (strncmp(edi_256 - 0x06, 9304992, 0x06) != 0x00)
	{
l007531B2:
		++ebp_16;
		edi_256 = (word32) edi_256 + 1;
		if (ebp_16 >= ebx_12)
			goto l007531BC;
		goto l00753146;
	}
	else
	{
		byte al_83 = *edi_256;
		Eq_3 esi_85 = edi_256;
		if (al_83 != 0x3A && al_83 != 0x3D)
			goto l007531B2;
		do
		{
			byte al_93 = *((word32) esi_85 + 1);
			esi_85 = (word32) esi_85 + 1;
		} while (al_93 == 0x20 || al_93 == 0x09);
		esi_100 = esi_85;
		while (true)
		{
			Eq_3 esi_100;
			if (isalnum((word32) *esi_100) == 0x00)
			{
				byte al_111 = *esi_100;
				if (al_111 != 0x2D && (al_111 != 0x5F && al_111 != 0x2E))
				{
					if (esi_85 < esi_100)
					{
						Eq_3 esi_121 = esi_100 - esi_85;
						Eq_3 eax_122 = (word32) esi_121 + 1;
						if (esi_121 == 0x01)
							eax_122.u0 = 0x01;
						Eq_3 eax_132 = malloc(eax_122);
						if (eax_132 != 0x00)
						{
							memcpy(eax_132, esi_85, esi_121);
							Mem149[eax_132 + esi_121:byte] = 0x00;
						}
						Eq_3 esi_154 = eax_132;
						ptr32 edx_177;
						Eq_3 eax_175 = fn00752FC0(esi_85, malloc, eax_132, eax_132, es, ds, eax_132, out edx_177);
						if (eax_132 != eax_175)
						{
							free(eax_132);
							Eq_3 eax_190 = eax_175;
							edx_177 = (word32) eax_175 + 1;
							do
							{
								eax_190 = (word32) eax_508 + 1;
								eax_508 = eax_190;
							} while (*eax_508 != 0x00);
							Eq_3 eax_202 = eax_190 - ((word32) eax_175 + 1);
							Eq_3 eax_204 = (word32) eax_202 + 1;
							if (eax_202 == 0x01)
								eax_204.u0 = 0x01;
							Eq_3 eax_216 = malloc(eax_204);
							esi_154 = eax_216;
							if (eax_216 != 0x00)
							{
								memcpy(eax_216, eax_175, eax_202);
								Mem234[eax_202 + eax_216:byte] = 0x00;
							}
						}
						edxOut = edx_177;
						return esi_154;
					}
					ebx_12 = (word32) eax - 6;
					goto l007531B2;
				}
			}
			esi_100 = (word32) esi_100 + 1;
		}
	}
}

// 00753250: Register uint32 fn00753250(Register Eq_3 ecx, Register (ptr16 Eq_7) es, Register (ptr16 Eq_8) ds, Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Stack (ptr32 code) dwArg0C, Register out ptr32 edxOut)
// Called from:
//      fn00753600
//      fn007537F0
uint32 fn00753250(Eq_3 ecx, struct Eq_7 * es, struct Eq_8 * ds, Eq_3 dwArg04, Eq_3 dwArg08, <anonymous> * dwArg0C, ptr32 & edxOut)
{
	uint32 ebx_12 = 0x01;
	if (*((word32) dwArg08 + 892) != 0x00)
	{
l00753355:
		edxOut = edx;
		return ebx_12;
	}
	Eq_3 eax_25 = fn00753110(dwArg04, ecx, es, ds, out edx);
	word24 edx_24_8_437 = SLICE(edx, word24, 8);
	if (eax_25 == 0x00)
	{
l00753354:
		goto l00753355;
	}
	ptr32 esp_197;
	Eq_3 eax_36 = *((word32) dwArg08 + 888);
	*((word32) dwArg08 + 884) = 0x01;
	if (eax_36 != 0x00)
	{
		Eq_3 ecx_44 = eax_25;
		do
		{
			word32 eax_63;
			cu8 dl_47 = *eax_36;
			edx = SEQ(edx_24_8_437, dl_47);
			if (dl_47 != *ecx_44)
			{
l00753315:
				up32 eax_60 = 0x00 - (dl_47 < *ecx_44);
				eax_63 = eax_60 - ~0x00 - (eax_60 < 0x00);
				goto l0075331A;
			}
			edx = SEQ(edx_24_8_437, dl_47);
			if (dl_47 == 0x00)
				break;
			byte dl_54 = *((word32) eax_36 + 1);
			edx = SEQ(edx_24_8_437, dl_54);
			if (dl_54 != *((word32) ecx_44 + 1))
				goto l00753315;
			eax_36 = (word32) eax_36 + 2;
			ecx_44 = (word32) ecx_44 + 2;
			edx = SEQ(edx_24_8_437, dl_54);
		} while (dl_54 != 0x00);
		eax_63 = 0x00;
l0075331A:
		free(eax_25);
		esp_197 = fp - 0x10;
		ebx_12 = (uint32) (int8) (eax_63 == 0x00);
		goto l0075332B;
	}
	else
	{
		byte * edi_102 = &g_t8D9880;
		Eq_3 esi_101 = eax_25;
		word32 ecx_103 = 0x06;
		bool v26_326 = true;
		while (ecx_103 != 0x00)
		{
			v26_326 = *esi_521 == *edi_522;
			esi_101 = (word32) esi_521 + 1;
			edi_102 = edi_522 + 1;
			--ecx_103;
			esi_521 = esi_101;
			edi_522 = edi_102;
			if (*esi_521 == *edi_522)
				break;
		}
		if (!v26_326)
		{
			byte * edi_108 = &g_b8DCAA0;
			Eq_3 esi_111 = eax_25;
			word32 ecx_112 = 11;
			edx = 0x00;
			bool v30_330 = true;
			while (ecx_112 != 0x00)
			{
				v30_330 = *esi_523 == *edi_524;
				esi_111 = (word32) esi_523 + 1;
				edi_108 = edi_524 + 1;
				--ecx_112;
				esi_523 = esi_111;
				edi_524 = edi_108;
				if (*esi_523 == *edi_524)
					break;
			}
			if (!v30_330)
			{
				struct Eq_172149 * esp_190;
				uint32 eax_191;
				dwArg0C();
				ebx_12 = eax_191;
				esp_197 = (const char *) &esp_190->t0004 + 4;
				if (eax_191 == 0x00)
				{
					esp_190->t0004 = eax_25;
					free(esp_190->t0004);
					esp_197 = (const char *) &esp_190->t0004 + 4;
					goto l0075332F;
				}
				*((word32) dwArg08 + 888) = eax_25;
				*((word32) dwArg08 + 876) = ~0x00;
l0075332B:
				if (ebx_12 != 0x00)
					goto l00753353;
l0075332F:
				Eq_3 eax_221 = *((word32) dwArg08 + 888);
				if (eax_221 == 0x00)
					eax_221.u0 = 0x008DFBC0;
				Eq_3 ecx_227 = g_tA178F4;
				struct Eq_172182 * esp_231 = esp_197 - 4;
				esp_231->t0000 = eax_221;
				esp_231->dwFFFFFFFC = 9305000;
				esp_231->tFFFFFFF8 = ecx_227;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_3 stackArg4 = <invalid>;
				word32 ecx_520;
				fn006E15D0(stackArg4, dwArg04, out ecx_520, out edx);
l00753353:
				goto l00753354;
			}
		}
		*((word32) dwArg08 + 888) = eax_25;
		edxOut = edx;
		return 0x01;
	}
}

// 00753360: Register Eq_3 fn00753360(Register Eq_3 esi, Register out ptr32 edxOut)
// Called from:
//      fn00753600
//      fn007537F0
Eq_3 fn00753360(Eq_3 esi, ptr32 & edxOut)
{
	ptr32 edx_14;
	word32 eax_12 = fn00753750(esi, out edx_14);
	*((word32) esi + 876) = 0x01;
	if (eax_12 != ~0x00)
	{
		if (eax_12 == 0xEF)
		{
			ptr32 edx_128;
			if (fn00753750(esi, out edx_128) != 0xBB || fn00753750(esi, out edx_128) != 191)
			{
				fn00753770(esi);
				edxOut = edx_128;
				return <invalid>;
			}
			else
			{
				Eq_3 eax_63 = *((word32) esi + 888);
				if (eax_63 != 0x00)
					free(eax_63);
				fn00752F80(0x05, 0x008D9880);
				*((word32) esi + 888) = eax_63;
				edxOut = edx_128;
				return <invalid>;
			}
		}
		fn00753770(esi);
	}
	edxOut = edx_14;
	return <invalid>;
}

// 007533F0: Register Eq_3 fn007533F0(Register Eq_3 eax, Stack Eq_3 dwArg08, Register out ptr32 edxOut)
// Called from:
//      fn00753600
Eq_3 fn007533F0(Eq_3 eax, Eq_3 dwArg08, ptr32 & edxOut)
{
	ptr32 edx_117;
	Eq_3 ebx_27;
	struct Eq_172310 * esp_16 = fp - 16;
	Eq_3 edi_19 = *((word32) eax + 0x0388);
	if (edi_19 == 0x00)
	{
		word32 ecx_346;
		Eq_3 eax_34 = fn007036F0(out ecx_346, out edx_117);
		edi_19 = eax_34;
		esp_16 = fp - 0x10;
		if (eax_34 == 0x00)
			goto l0075341D;
	}
	else
	{
		((word32) eax + 0x0388)->u0 = 0x00;
		if (*((word32) edi_19 + 4) == 0x00A1B450)
		{
			ebx_27 = edi_19;
			goto l00753481;
		}
	}
	word32 ecx_347;
	Eq_3 eax_54 = fn00718B50(edi_19, out ecx_347, out edx_117);
	word32 v16_60 = (word32) *edi_19 - 1;
	*edi_19 = v16_60;
	esp_16 = fp - 0x10;
	ebx_27 = eax_54;
	if (v16_60 == 0x00)
	{
		Eq_3 ecx_65 = *((word32) edi_19 + 4);
		word32 esp_69;
		(*((word32) ecx_65 + 24))();
		esp_16 = esp_69 + 0x04;
	}
	if (eax_54 == 0x00)
	{
l0075341D:
		*((word32) eax + 880) = 0x01;
		if (*((word32) eax + 24) != 0x00)
		{
			Eq_3 eax_226 = *eax;
			if (eax_226 != 0x00)
			{
				union Eq_3 * esp_231 = esp_16 - 4;
				*esp_231 = (union Eq_3 *) eax_226;
				free(*esp_231);
			}
		}
		goto l0075343D;
	}
l00753481:
	struct Eq_172389 * esp_83 = esp_16 - 4;
	esp_83->t0000 = ebx_27;
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_3 stackArg4 = <invalid>;
	word32 ecx_349;
	word32 esi_350;
	Eq_3 eax_125 = fn006ECC50(stackArg4, out ecx_349, out edx_117, out esi_350);
	Eq_3 edi_102 = *((word32) ebx_27 + 8);
	esp_83->t001C = eax_125;
	if (edi_102 > dwArg08 - 0x01)
	{
		esp_83->t0000 = edi_102 - (dwArg08 - 0x01);
		Mem113[esp_83 + -4:word32] = eax_125 + (dwArg08 - 0x01);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_3 stackArg4 = <invalid>;
		Eq_3 stackArg8 = <invalid>;
		word32 ecx_353;
		Eq_3 eax_115 = fn006EC9B0(stackArg4, stackArg8, out ecx_353, out edx_117);
		*((word32) eax + 0x0388) = eax_115;
		if (eax_115 == 0x00)
		{
			word32 v12_179 = (word32) *ebx_27 - 1;
			*ebx_27 = v12_179;
			if (v12_179 == 0x00)
			{
				Eq_3 eax_183 = *((word32) ebx_27 + 4);
				Eq_3 ecx_184 = *((word32) eax_183 + 24);
				esp_83->t0000 = ebx_27;
				ecx_184();
			}
			*((word32) eax + 880) = 0x01;
			if (*((word32) eax + 24) != 0x00)
			{
				Eq_3 eax_200 = *eax;
				if (eax_200 != 0x00)
				{
					free(eax_200);
					eax->u0 = 0x00;
					edxOut = edx_117;
					return 0x00;
				}
			}
l0075343D:
			eax->u0 = 0x00;
			edxOut = edx_117;
			return 0x00;
		}
		eax_125 = esp_83->t001C;
		edi_102 = dwArg08 - 0x01;
	}
	Eq_3 esi_129 = esp_16->t0014;
	struct Eq_172418 * esp_130 = esp_16 - 4;
	esp_130->t0000 = edi_102;
	esp_130->tFFFFFFFC = eax_125;
	esp_130->tFFFFFFF8 = esi_129;
	memcpy(esp_130->tFFFFFFF8, esp_130->tFFFFFFFC, esp_130->t0000);
	Mem140[edi_102 + esi_129:byte] = 0x00;
	word32 v14_142 = (word32) *ebx_27 - 1;
	*ebx_27 = v14_142;
	if (v14_142 == 0x00)
	{
		Eq_3 edx_146 = *((word32) ebx_27 + 4);
		Eq_3 eax_147 = *((word32) edx_146 + 24);
		esp_130->t0000 = ebx_27;
		eax_147();
	}
	edxOut = edx_117;
	return 0x00 - (edi_102 == 0x00) & esi_129;
}

<anonymous> g_t753530 = <code>; // 00753530
// 00753600: Register word32 fn00753600(Register Eq_3 ecx, Register Eq_3 edx, Register Eq_3 ebx, Register Eq_3 ebp, Register Eq_3 esi, Register Eq_3 edi, Register (ptr16 Eq_7) es, Register (ptr16 Eq_8) ds, Stack Eq_3 dwArg04, Register out (ptr32 charconst ) ecxOut, Register out Eq_3 edxOut)
// Called from:
//      fn00753C30
word32 fn00753600(Eq_3 ecx, Eq_3 edx, Eq_3 ebx, Eq_3 ebp, Eq_3 esi, Eq_3 edi, struct Eq_7 * es, struct Eq_8 * ds, Eq_3 dwArg04, const char & ecxOut, union Eq_3 & edxOut)
{
	Eq_3 edx_130;
	Eq_3 eax_207;
	Eq_3 eax_43;
	ui32 eax_7 = g_tA14188 ^ fp - 0x01F8;
	bool v29_331 = *((word32) edx + 876) > 0x00;
	while (*((word32) edx + 876) >= 0x00)
	{
		if (v29_331)
		{
			eax_43 = fn00731F90(ecx, dwArg04, *((word32) edx + 24), null, out edx_130);
			goto l0075366C;
		}
		if (fn00753360(edx, out edx_130) == 0x00)
		{
l00753711:
			*((word32) edx + 880) = 0x01;
			if (*((word32) edx + 24) != 0x00)
			{
				Eq_3 eax_198 = *edx;
				if (eax_198 != 0x00)
					free(eax_198);
			}
			edx->u0 = 0x00;
			eax_207.u0 = 0x00;
			goto l00753735;
		}
		v29_331 = *((word32) edx + 876) > 0x00;
	}
	eax_43 = fn007533F0(edx, dwArg04, out edx_130);
l0075366C:
	if (eax_43 != 0x00)
	{
		if (*((word32) edx + 452) < 0x02 && *((word32) edx + 884) == 0x00)
		{
			word32 edx_99 = (word32) eax_43 + 1;
			eax_100 = eax_43;
			do
			{
				Eq_3 eax_100;
				eax_100 = (word32) eax_433 + 1;
				eax_433 = eax_100;
			} while (*eax_433 != 0x00);
			if (fn00753250(eax_43, es, ds, eax_100 - edx_99, dwArg04, &g_t753530, out edx_130) == 0x00)
			{
				eax_207 = fn00752F50(edx);
l00753735:
				const char * ecx_317;
				word32 eax_316 = fn00694B8E(eax_207, eax_7 ^ fp - 504, edx_130, ebx, ebp, esi, edi, es, ds, ebx, out ecx_317);
				ecxOut = ecx_317;
				edxOut = edx_130;
				return eax_316;
			}
		}
		if (*((word32) edx + 888) == 0x00)
		{
			cu8 al_143 = *eax_43;
			Eq_3 ecx_146 = eax_43;
			while (al_143 != 0x00)
			{
				if (al_143 > 0x7F)
				{
					uint32 eax_153 = (word32) *ecx_146;
					if (eax_153 == 0x00)
						break;
					sprintf(fp - 0x01F8, 9305040, eax_153, *((word32) edx + 0x01CC), (word32) *((word32) edx + 452) + 1);
					word32 ecx_432;
					fn006E0F80(g_tA178F4, dwArg04, out ecx_432, out edx_130);
					goto l00753711;
				}
				al_143 = (cu8) *((word32) ecx_146 + 1);
				ecx_146 = (word32) ecx_146 + 1;
			}
		}
	}
	eax_207 = eax_43;
	goto l00753735;
}

// 00753750: Register word32 fn00753750(Stack Eq_3 dwArg04, Register out Eq_3 edxOut)
// Called from:
//      fn00753360
word32 fn00753750(Eq_3 dwArg04, union Eq_3 & edxOut)
{
	byte * ecx_6 = *((word32) dwArg04 + 912);
	word32 eax_7 = (word32) *ecx_6;
	*((word32) dwArg04 + 912) = ecx_6 + 1;
	edxOut = dwArg04;
	return eax_7;
}

// 00753770: void fn00753770(Stack Eq_3 dwArg08)
// Called from:
//      fn00753360
void fn00753770(Eq_3 dwArg08)
{
	*((word32) dwArg08 + 912) = (word32) *((word32) dwArg08 + 912) - 1;
}

<anonymous> g_t753780 = <code>; // 00753780
// 007537A0: Register Eq_3 fn007537A0(Register Eq_3 edx, Stack Eq_3 dwArg04)
// Called from:
//      fn007537F0
Eq_3 fn007537A0(Eq_3 edx, Eq_3 dwArg04)
{
	Eq_3 eax_10 = edx;
	do
	{
		eax_10 = (word32) eax_131 + 1;
		eax_131 = eax_10;
	} while (*eax_131 != 0x00);
	word32 edx_128;
	Eq_3 eax_33 = fn0071FEB0(edx, eax_10 - ((word32) edx + 1), dwArg04, 0x00, out edx_128);
	if (eax_33 == 0x00)
		return eax_33;
	word32 edx_130;
	word32 ecx_129;
	Eq_3 eax_50 = fn00718B50(eax_33, out ecx_129, out edx_130);
	word32 v13_56 = (word32) *eax_33 - 1;
	*eax_33 = v13_56;
	if (v13_56 == 0x00)
	{
		Eq_3 edx_61 = *((word32) eax_33 + 4);
		(*((word32) edx_61 + 24))();
	}
	return eax_50;
}

// 007537F0: Register Eq_3 fn007537F0(Register Eq_3 eax, Register Eq_3 ecx)
// Called from:
//      fn00755100
Eq_3 fn007537F0(Eq_3 eax, Eq_3 ecx)
{
	*((word32) ecx + 912) = eax;
	((word32) ecx + 908)->u0 = 0x00;
	ui32 ebp_16 = 0x00;
	word32 edx_537;
	if (fn00753360(ecx, out edx_537) == 0x00)
	{
		*((word32) ecx + 880) = 0x01;
		if (*((word32) ecx + 24) != 0x00)
		{
			Eq_3 eax_364 = *ecx;
			if (eax_364 != 0x00)
				free(eax_364);
		}
		ecx->u0 = 0x00;
		return 0x00;
	}
	Eq_3 ebx_122;
	Eq_3 eax_36 = *((word32) ecx + 908);
	Eq_3 edi_272 = *((word32) ecx + 912);
	if (eax_36 != 0x00)
	{
		Eq_3 eax_50 = fn007537A0(edi_272, eax_36);
		ebx_122 = eax_50;
		if (eax_50 == 0x00)
			return fn00752F50(ecx);
		word32 edx_539;
		word32 esi_540;
		word32 ecx_538;
		edi_272 = fn006ECC50(eax_50, out ecx_538, out edx_539, out esi_540);
	}
	else
		ebx_122.u0 = 0x00;
	byte cl_72 = *edi_272;
	Eq_3 eax_75 = edi_272;
	while (cl_72 != 0x00)
	{
		if (cl_72 == 0x0A)
		{
			(fp - 0x08)[ebp_16] = eax_75;
			++ebp_16;
			if (ebp_16 == 0x02)
				break;
		}
		cl_72 = (byte) *((word32) eax_75 + 1);
		eax_75 = (word32) eax_75 + 1;
	}
	((word32) ecx + 908)->u0 = 0x00;
	if (false)
	{
		word32 edx_543;
		if (fn00753250(edi_272, es, ds, 0x00 - edi_272, ecx, &g_t753780, out edx_543) == 0x00)
			goto l0075397D;
		if (*((word32) ecx + 908) == 0x00 && false)
		{
			word32 edx_544;
			if (fn00753250(0x01, es, ds, 0x00, ecx, &g_t753780, out edx_544) == 0x00)
				return fn00752F50(ecx);
		}
	}
	Eq_3 edx_167 = *((word32) ecx + 908);
	if (edx_167 != 0x00)
	{
		Eq_3 eax_172 = edi_272;
		byte * ebp_173 = (word32) edi_272 + 1;
		do
		{
			eax_172 = (word32) eax_555 + 1;
			eax_555 = eax_172;
		} while (*eax_555 != 0x00);
		word32 edx_545;
		Eq_3 eax_214 = fn0071FEB0(edi_272, eax_172 - ebp_173, edx_167, 0x00, out edx_545);
		struct Eq_172974 * esp_219 = fp - 0x1C;
		if (eax_214 == 0x00)
		{
l00753962:
			Eq_3 edx_293 = g_tA178F4;
			struct Eq_172982 * esp_295 = esp_219 - 4;
			esp_295->t0000 = *((word32) ecx + 908);
			esp_295->dwFFFFFFFC = 9300316;
			esp_295->tFFFFFFF8 = edx_293;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg4 = <invalid>;
			Eq_3 stackArg8 = <invalid>;
			word32 ecx_548;
			word32 edx_549;
			fn006E15D0(stackArg4, stackArg8, out ecx_548, out edx_549);
l0075397D:
			*((word32) ecx + 880) = 0x01;
			if (*((word32) ecx + 24) != 0x00)
			{
				Eq_3 eax_319 = *ecx;
				if (eax_319 != 0x00)
					free(eax_319);
			}
			ecx->u0 = 0x00;
			return 0x00;
		}
		word32 ecx_226;
		word32 edx_550;
		Eq_3 eax_227 = fn00718B50(eax_214, out ecx_226, out edx_550);
		word32 v15_232 = (word32) *eax_214 - 1;
		*eax_214 = v15_232;
		esp_219 = fp - 0x1C;
		if (v15_232 == 0x00)
		{
			Eq_3 edx_237 = *((word32) eax_214 + 4);
			Eq_3 eax_238 = *((word32) edx_237 + 24);
			word32 esp_241;
			eax_238();
			esp_219 = esp_241 + 0x04;
		}
		esp_219->t0010 = eax_227;
		if (eax_227 == 0x00)
			goto l00753962;
		struct Eq_173042 * esp_255 = esp_219 - 4;
		esp_255->t0000 = eax_227;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_3 stackArg4 = <invalid>;
		word32 esi_554;
		word32 ecx_552;
		word32 edx_553;
		Eq_3 eax_265 = fn006ECC50(stackArg4, out ecx_552, out edx_553, out esi_554);
		ebx_122 = esp_255->t0014;
		edi_272 = eax_265;
	}
	*((word32) ecx + 0x0388) = ebx_122;
	return edi_272;
}

// 007539D0: void fn007539D0(Stack Eq_3 dwArg04)
// Called from:
//      fn007406A0
//      fn00755100
//      fn00755140
void fn007539D0(Eq_3 dwArg04)
{
	Eq_3 eax_8 = *((word32) dwArg04 + 888);
	if (eax_8 != 0x00)
		free(eax_8);
	struct Eq_173067 * esp_32 = fp - 8;
	if (*((word32) dwArg04 + 900) != null)
	{
		struct Eq_173073 * eax_24 = *((word32) dwArg04 + 900);
		eax_24->dw0000 += ~0x00;
		struct Eq_173073 * eax_27 = *((word32) dwArg04 + 900);
		if (eax_27->dw0000 == 0x00)
		{
			struct Eq_173104 * ecx_30 = eax_27->ptr0004;
			word32 esp_37;
			word32 edx_40;
			ecx_30->ptr0018();
			esp_32 = esp_37 + 0x04;
		}
	}
	if (*((word32) dwArg04 + 0x0388) != null)
	{
		struct Eq_173080 * eax_49 = *((word32) dwArg04 + 0x0388);
		eax_49->dw0000 += ~0x00;
		struct Eq_173080 * eax_52 = *((word32) dwArg04 + 0x0388);
		if (eax_52->dw0000 == 0x00)
		{
			struct Eq_173141 * ecx_55 = eax_52->ptr0004;
			<anonymous> * edx_56 = ecx_55->ptr0018;
			esp_32->ptrFFFFFFFC = eax_52;
			word32 edx_65;
			edx_56();
		}
	}
	if (*((word32) dwArg04 + 24) != 0x00)
	{
		Eq_3 eax_74 = *dwArg04;
		if (eax_74 != 0x00)
			free(eax_74);
	}
	free(dwArg04);
}

// 00753A60: Register word32 fn00753A60(Stack Eq_3 dwArg08, Register out Eq_3 ecxOut, Register out Eq_3 edxOut)
// Called from:
//      fn00753C30
word32 fn00753A60(Eq_3 dwArg08, union Eq_3 & ecxOut, union Eq_3 & edxOut)
{
	struct Eq_173167 * esp_23;
	word32 eax_25;
	Eq_3 edx_26;
	_iob_func();
	word32 ecx_15;
	if (fn00715DF0(out ecx_15) != eax_25)
	{
l00753A7D:
		ecxOut = ecx;
		edxOut = edx_26;
		return 0x00;
	}
	esp_23->dwFFFFFFFC = 9262172;
	word32 ecx_593;
	Eq_3 eax_35 = fn00715DD0(out ecx_593, out edx_26);
	if (eax_35 == 0x00)
		goto l00753A7D;
	Eq_3 eax_44 = *((word32) eax_35 + 4);
	if (eax_44 != 0x00A26EF0)
	{
		word32 ecx_594;
		if (fn006D5670(eax_44, 0x00A26EF0, out ecx_594, out edx_26) == 0x00)
			goto l00753A7D;
	}
	Eq_3 ebp_68 = *((word32) eax_35 + 60);
	if (ebp_68 != 0x00)
	{
		Eq_3 eax_72 = *((word32) ebp_68 + 4);
		if (eax_72 == 0x00A1B450)
		{
l00753ADD:
			*ebp_68 = (word32) *ebp_68 + 1;
			word32 edx_596;
			word32 esi_597;
			word32 ecx_595;
			Eq_3 eax_121 = fn006ECC50(ebp_68, out ecx_595, out edx_596, out esi_597);
			Eq_3 ecx_127 = *dwArg08;
			Eq_3 eax_128 = ecx_127;
			do
			{
				eax_128 = (word32) eax_602 + 1;
				eax_602 = eax_128;
			} while (*eax_602 != 0x00);
			Eq_3 edx_210;
			word32 edx_599;
			Eq_3 eax_165 = fn0071FEB0(ecx_127, eax_128 - ((word32) ecx_127 + 1), eax_121, 0x00, out edx_599);
			struct Eq_173267 * esp_170 = fp - 0x14;
			if (eax_165 != 0x00)
			{
				Eq_3 eax_198;
				word32 ecx_181;
				word32 edx_600;
				Eq_3 eax_182 = fn0071FB20(eax_165, 0x008D9880, 0x00, out ecx_181, out edx_600);
				word32 v15_187 = (word32) *eax_165 - 1;
				*eax_165 = v15_187;
				word24 ecx_24_8_357 = SLICE(ecx_181, word24, 8);
				esp_170 = fp - 0x14;
				eax_198 = eax_182;
				if (v15_187 == 0x00)
				{
					Eq_3 ecx_192 = *((word32) eax_165 + 4);
					word32 esp_196;
					word32 ecx_197;
					(*((word32) ecx_192 + 24))();
					ecx_24_8_357 = SLICE(ecx_197, word24, 8);
					esp_170 = esp_196 + 0x04;
				}
				if (eax_182 != 0x00)
				{
					Eq_3 edi_209 = *((word32) eax_182 + 8);
					union Eq_3 * esp_212 = esp_170 - 4;
					*esp_212 = (word32) eax_182 + 20;
					fn00752F80(edi_209, *esp_212);
					word32 v18_219 = (word32) *eax_182 - 1;
					*eax_182 = v18_219;
					edx_210 = (word32) eax_182 + 20;
					struct Eq_173350 * esp_218 = (const char *) esp_212 + 4;
					if (v18_219 == 0x00)
					{
						Eq_3 eax_225 = *((word32) eax_182 + 4);
						Eq_3 ecx_226 = *((word32) eax_225 + 24);
						*esp_212 = (union Eq_3 *) eax_182;
						word32 esp_232;
						word32 ecx_233;
						ecx_226();
						ecx_24_8_357 = SLICE(ecx_233, word24, 8);
						esp_218 = esp_232 + 0x04;
					}
					struct Eq_173371 * esi_246;
					if (eax_198 != 0x00)
					{
						union Eq_3 * esi_247 = esp_218->ptr001C;
						struct Eq_173397 * esp_250 = esp_218 - 4;
						esp_250->t0000 = *esi_247;
						free(esp_250->t0000);
						*esi_247 = (union Eq_3 *) eax_198;
						esi_246 = esp_250->ptr001C;
						Eq_3 eax_254 = esi_246->t0378;
						if (eax_254 != 0x00)
						{
							esp_250->t0000 = eax_254;
							free(esp_250->t0000);
						}
						edx_210 = esp_218->t0010;
						Eq_3 eax_266 = edx_210;
						do
						{
							byte cl_271 = *eax_266;
							eax_266 = (word32) eax_266 + 1;
							word32 ecx_362 = SEQ(ecx_24_8_357, cl_271);
						} while (cl_271 != 0x00);
						union Eq_3 * esp_280 = esp_218 - 4;
						*esp_280 = (union Eq_3 *) edx_210;
						Eq_3 eax_277 = eax_266 - ((word32) edx_210 + 1);
						fn00752F80(eax_277, *esp_280);
						esi_246->t0378 = eax_277;
						if (eax_277 != 0x00)
						{
							word32 v21_347 = (word32) *ebp_68 - 1;
							*ebp_68 = v21_347;
							if (v21_347 == 0x00)
							{
								Eq_3 edx_351 = *((word32) ebp_68 + 4);
								Eq_3 eax_352 = *((word32) edx_351 + 24);
								*esp_280 = (union Eq_3 *) ebp_68;
								Eq_3 edx_366;
								eax_352();
								ecxOut = eax_121;
								edxOut = edx_366;
								return 0x00;
							}
							goto l00753B5D;
						}
					}
					else
						esi_246 = esp_218->ptr0018;
					word32 v19_300 = (word32) *ebp_68 - 1;
					*ebp_68 = v19_300;
					if (v19_300 == 0x00)
					{
						Eq_3 eax_304 = *((word32) ebp_68 + 4);
						Eq_3 ecx_305 = *((word32) eax_304 + 24);
						esp_218->tFFFFFFFC = ebp_68;
						ecx_305();
					}
					esi_246->dw0014 = 0x0F;
					ecxOut = eax_121;
					edxOut = edx_210;
					return ~0x00;
				}
			}
			word32 v17_385 = (word32) *ebp_68 - 1;
			*ebp_68 = v17_385;
			if (v17_385 == 0x00)
			{
				Eq_3 eax_389 = *((word32) ebp_68 + 4);
				Eq_3 ecx_390 = *((word32) eax_389 + 24);
				esp_170->tFFFFFFFC = ebp_68;
				ecx_390();
			}
			word32 ecx_601;
			fn006E1160(out ecx_601, out edx_210);
l00753B5D:
			ecxOut = eax_121;
			edxOut = edx_210;
			return 0x00;
		}
		word32 ecx_598;
		if (fn006D5670(eax_72, 0x00A1B450, out ecx_598, out edx_26) != 0x00)
			goto l00753ADD;
	}
	ecxOut = ecx;
	edxOut = edx_26;
	return 0x00;
}

// 00753C30: Register word32 fn00753C30(Register Eq_3 esi, Register out Eq_3 ecxOut, Register out Eq_3 edxOut)
// Called from:
//      fn007544F0
word32 fn00753C30(Eq_3 esi, union Eq_3 & ecxOut, union Eq_3 & edxOut)
{
	while (*((word32) esi + 4) == *((word32) esi + 8))
	{
		if (*((word32) esi + 20) != 0x0A)
		{
l0075405E:
			ecxOut = ecx;
			edxOut = edx;
			return ~0x00;
		}
		Eq_3 ecx_24 = *((word32) esi + 24);
		if (ecx_24 == 0x00)
		{
			Eq_3 eax_45;
			ecx = *((word32) esi + 8);
			Eq_3 eax_35 = strchr(ecx, 0x0A);
			if (eax_35 != 0x00)
			{
				eax_45 = (word32) eax_35 + 1;
				goto l00754019;
			}
			edx = *((word32) esi + 8);
			eax_45 = strchr(edx, 0x00);
			if (eax_45 != *((word32) esi + 8))
			{
l00754019:
				if (*((word32) esi + 16) == 0x00)
					*esi = *((word32) esi + 4);
				Eq_3 ecx_60 = *((word32) esi + 4);
				*((word32) esi + 452) = (word32) *((word32) esi + 452) + 1;
				*((word32) esi + 896) = ecx_60;
				*((word32) esi + 8) = eax_45;
				word32 eax_71 = (word32) *ecx_60;
				*((word32) esi + 4) = (word32) ecx_60 + 1;
				ecxOut = (word32) ecx_60 + 1;
				edxOut = edx;
				return eax_71;
			}
			*((word32) esi + 20) = 11;
			goto l0075405E;
		}
		struct Eq_173567 * esp_130;
		word32 eax_80 = *((word32) esi + 444);
		if (eax_80 != 0x00)
		{
			struct Eq_173581 * esp_390;
			word32 eax_391;
			_iob_func();
			esp_390->dwFFFFFFFC = eax_391 + 0x20;
			struct Eq_173590 * esp_400;
			word32 eax_401;
			_iob_func();
			esp_400->dwFFFFFFFC = eax_401;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg4 = <invalid>;
			Eq_3 eax_409 = fn007558B0(stackArg4, out edx);
			word32 ecx_414 = *((word32) esi + 448);
			esp_400->t0014 = eax_409;
			esp_130 = (struct Eq_173567 *) ((const char *) &esp_400->t0004 + 4);
			if (ecx_414 != 0x00)
				*((word32) esi + 444) = ecx_414;
			if (eax_409 != 0x00)
			{
				if (*eax_409 != 0x00)
				{
					esp_400->t0004 = &esp_400->t0014;
					esp_400->t0000 = esi;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_3 stackArg8 = <invalid>;
					if (fn00753A60(stackArg8, out ecx, out edx) != 0x00)
					{
						edx = esp_400->t0014;
						esp_400->t0004 = edx;
						free(esp_400->t0004);
						esp_130 = (struct Eq_173567 *) ((const char *) &esp_400->t0004 + 4);
						goto l00753F9E;
					}
					ptr32 eax_455 = *((word32) esi + 16);
					if (eax_455 == 0x00)
					{
						Eq_3 eax_459 = *esi;
						*((word32) esi + 452) = (word32) *((word32) esi + 452) + 1;
						if (eax_459 != 0x00)
						{
							esp_400->t0004 = eax_459;
							free(esp_400->t0004);
						}
						Eq_3 eax_471 = esp_400->t0014;
						esp_400->t0004.u0 = 0x00;
						esp_400->t0000 = eax_471;
						*esi = eax_471;
						*((word32) esi + 4) = eax_471;
						*((word32) esi + 896) = eax_471;
						Eq_3 eax_480 = strchr(esp_400->t0000, esp_400->t0004);
						*((word32) esi + 8) = eax_480;
						*((word32) esi + 0x0C) = (word32) eax_480 + 1;
						esp_130 = (struct Eq_173567 *) ((const char *) &esp_400->t0004 + 4);
						goto l00753F9E;
					}
					ecx_24 = *esi;
					ebp = esp_400->t0014;
					Eq_3 edi_488 = *((word32) esi + 4);
					esp_400->t0018 = eax_455 - ecx_24;
					Eq_3 eax_491 = ebp;
					int32 edi_492 = edi_488 - ecx_24;
					do
					{
						eax_491 = (word32) eax_878 + 1;
						eax_878 = eax_491;
					} while (*eax_878 != 0x00);
					word32 ebx_506 = eax_491 - ((word32) ebp + 1) + edi_492;
					Eq_3 eax_507 = ebx_506 + 0x01;
					if (ebx_506 == 0x01)
						eax_507.u0 = 0x01;
					esp_400->t0004 = eax_507;
					esp_400->t0000 = ecx_24;
					Eq_3 eax_521 = realloc(esp_400->t0000, esp_400->t0004);
					*((word32) esi + 452) = (word32) *((word32) esi + 452) + 1;
					if (eax_521 != 0x00)
					{
						*esi = eax_521;
						Eq_3 ecx_556 = (word32) eax_521 + edi_492;
						*((word32) esi + 4) = ecx_556;
						*((word32) esi + 896) = ecx_556;
						Eq_3 eax_561 = ebp;
						edx = ecx_556 - ebp;
						do
						{
							byte cl_566 = *eax_561;
							Mem568[edx + eax_561:byte] = cl_566;
							eax_561 = (word32) eax_561 + 1;
						} while (cl_566 != 0x00);
						esp_400->t0004 = ebp;
						free(esp_400->t0004);
						Eq_3 eax_578 = *esi;
						Eq_3 ecx_581 = (word32) eax_578 + ebx_506;
						*((word32) esi + 8) = ecx_581;
						*((word32) esi + 0x0C) = (word32) ecx_581 + 1;
						ecx = esp_400->t0018;
						Mem589[esi + 0x10:word32] = eax_578 + ecx;
						esp_130 = (struct Eq_173567 *) ((const char *) &esp_400->t0004 + 4);
						goto l00753F9E;
					}
					edx = *esi;
					esp_400->t0004 = edx;
					free(esp_400->t0004);
					esp_400->t0000 = ebp;
					esi->u0 = 0x00;
					free(esp_400->t0000);
l0075407F:
					*((word32) esi + 20) = 0x0F;
					ecxOut = ecx_24;
					edxOut = edx;
					return ~0x00;
				}
				esp_400->t0004 = eax_409;
				free(esp_400->t0004);
				*((word32) esi + 20) = 11;
				esp_130 = (struct Eq_173567 *) ((const char *) &esp_400->t0004 + 4);
			}
			else
				*((word32) esi + 20) = 0x0C;
l00753FC9:
			if (*((word32) esi + 444) != 0x00)
			{
				esp_130->dwFFFFFFFC = 0x008A6DE8;
				fn00716B20(out edx);
			}
			Eq_3 ecx_649 = *((word32) esi + 8);
			*((word32) esi + 4) = ecx_649;
			ecxOut = ecx_649;
			edxOut = edx;
			return ~0x00;
		}
		uint32 edi_150 = 0x00;
		if (*((word32) esi + 16) == 0x00)
		{
			if (*esi == 0x00)
			{
				Eq_3 eax_174 = malloc(0x0200);
				*esi = eax_174;
				if (eax_174 == 0x00)
					goto l0075407F;
				*((word32) esi + 0x0C) = (word32) eax_174 + 0x0200;
			}
			Eq_3 ecx_185 = *esi;
			esp_130 = fp - 0x14;
			word32 ecx_876;
			if (fn00753600(ecx_185, esi, 0x0A, ebp, esi, 0x00, es, ds, *((word32) esi + 0x0C) - ecx_185, out ecx_876, out edx) == 0x00)
			{
				*((word32) esi + 20) = 11;
				edi_150 = 0x01;
			}
			else
			{
				Eq_3 eax_207 = *esi;
				*((word32) esi + 20) = 0x0A;
				Eq_3 eax_213 = strchr(eax_207, 0x00);
				*((word32) esi + 8) = eax_213;
				esp_130 = fp - 0x14;
				edi_150 = (uint32) (int8) (*((word32) eax_213 - 1) == 0x0A);
			}
			goto l00753EC2;
		}
		word32 eax_134;
		Eq_3 edx_156;
		if (*((word32) esi + 876) >= 0x00)
		{
			word32 esp_153;
			word32 ecx_155;
			MSVCR80.dll!feof();
			esp_130 = esp_153 + 0x04;
			edx = edx_156;
			goto l00753EAD;
		}
		Eq_3 eax_105 = *((word32) esi + 0x0388);
		if (eax_105 == 0x00)
		{
			word32 ecx_877;
			eax_105 = fn007036F0(out ecx_877, out edx);
			if (eax_105 == 0x00)
			{
				*((word32) esi + 880) = 0x01;
				if (*((word32) esi + 24) != eax_105)
				{
					Eq_3 eax_139 = *esi;
					if (eax_139 != 0x00)
						free(eax_139);
				}
				esi->u0 = 0x00;
				*((word32) esi + 20) = 11;
				esp_130 = fp - 0x14;
				edi_150 = 0x01;
				goto l00753EC2;
			}
			*((word32) esi + 0x0388) = eax_105;
		}
		esp_130 = fp - 0x14;
		eax_134 = !fn00704080(eax_105, out edx);
l00753EAD:
		if (eax_134 != 0x00)
		{
			*((word32) esi + 20) = 11;
			edi_150 = 0x01;
		}
		else
			*((word32) esi + 20) = 0x0A;
l00753EC2:
		*((word32) esi + 452) = (word32) *((word32) esi + 452) + 1;
		if (edi_150 == 0x00)
		{
			do
			{
				Eq_3 ebx_243;
				ptr32 eax_237 = *((word32) esi + 16);
				if (eax_237 == 0x00)
					ebx_243.u0 = ~0x00;
				else
					ebx_243 = eax_237 - *esi;
				Eq_3 eax_250 = *esi;
				Eq_3 edi_252 = *((word32) esi + 8) - eax_250;
				ebp = (word32) edi_252 + 0x0200;
				Eq_3 ecx_256 = (word32) edi_252 + 0x0200;
				if (edi_252 == 0x0200)
					ecx_256.u0 = 0x01;
				Eq_3 eax_268 = realloc(eax_250, ecx_256);
				if (eax_268 == 0x00)
				{
					*((word32) esi + 4) = *((word32) esi + 8);
					*((word32) esi + 20) = 0x0F;
					ecxOut = ecx_256;
					edxOut = edx;
					return ~0x00;
				}
				ptr32 eax_298;
				*esi = eax_268;
				word32 ecx_291 = eax_268 + edi_252;
				*((word32) esi + 8) = ecx_291;
				Eq_173711 edx_293 = (word32) eax_268 + ((word32) edi_252 + 0x0200);
				*((word32) esi + 0x0C) = edx_293;
				if (ebx_243 < 0x00)
					eax_298 = 0x00;
				else
					eax_298 = eax_268 + ebx_243;
				*((word32) esi + 16) = eax_298;
				word32 eax_322 = fn00753600(ecx, esi, ebx_243, (word32) edi_252 + 0x0200, esi, edi_252, es, ds, edx_293 - ecx_291, out ecx, out edx);
				if (eax_322 == 0x00)
				{
					if (*((word32) esi + 880) != eax_322)
						goto l0075405E;
					**((word32) esi + 8) = 0x0A;
				}
				Eq_3 eax_356 = strchr(*((word32) esi + 8), 0x00);
				*((word32) esi + 8) = eax_356;
				esp_130 = fp - 0x14;
			} while (*((word32) eax_356 - 1) != 0x0A);
		}
		ecx = *esi;
		if (ecx != 0x00)
		{
			edx = esp_130->t000C;
			word32 eax_373 = ecx + edx;
			*((word32) esi + 4) = eax_373;
			*((word32) esi + 896) = eax_373;
			Eq_3 eax_376 = *((word32) esi + 8);
			if (eax_376 - 0x02 >= ecx && *((word32) eax_376 - 2) == 0x0D)
			{
				*((word32) eax_376 - 2) = 0x0A;
				*((word32) eax_376 - 1) = 0x00;
				*((word32) esi + 8) = eax_376 - 0x01;
			}
		}
l00753F9E:
		if (*((word32) esi + 20) != 0x0A)
			goto l00753FC9;
	}
	Eq_3 ecx_672 = *((word32) esi + 4);
	word32 eax_673 = (word32) *ecx_672;
	*((word32) esi + 4) = (word32) ecx_672 + 1;
	ecxOut = (word32) ecx_672 + 1;
	edxOut = edx;
	return eax_673;
}

// 007540B0: void fn007540B0(Register Eq_3 eax, Register Eq_3 ebx)
// Called from:
//      fn007544F0
void fn007540B0(Eq_3 eax, Eq_3 ebx)
{
	byte bl_33 = (byte) ebx;
	if (ebx != ~0x00)
	{
		*((word32) eax + 4) = (word32) *((word32) eax + 4) - 1;
		if (*((word32) eax + 4) < *eax)
			fn006E86F0(0x008DFC5C);
		Eq_3 esi_28 = *((word32) eax + 4);
		if ((int32) *esi_28 != ebx)
			*esi_28 = bl_33;
	}
}

// 007540E0: Register word32 fn007540E0(Stack Eq_3 dwArg04)
// Called from:
//      fn007544F0
word32 fn007540E0(Eq_3 dwArg04)
{
	if (dwArg04 <= 0x7E)
	{
		switch ((word32) *((word32) dwArg04 + 7684563))
		{
		case 0x00:
			return 0x18;
		case 0x01:
			return 0x13;
		case 0x02:
		case 11:
		case 0x0C:
		case 0x0D:
		case 0x0E:
		case 0x0F:
		case 0x10:
		case 0x11:
		case 0x12:
		case 0x13:
		case 0x14:
		case 0x1A:
		case 0x1C:
		case 0x1D:
		case 0x1E:
		case 0x1F:
		case 0x20:
		case 33:
		case 0x22:
		case 0x23:
		case 0x24:
		case 0x25:
		case 0x26:
		case 0x27:
		case 0x28:
		case 0x29:
		case 0x2A:
		case 0x2B:
		case 44:
		case 0x2D:
		case 0x2E:
		case 0x2F:
		case 0x30:
		case 0x31:
		case 0x32:
		case 0x33:
		case 0x34:
		case 0x35:
		case 55:
		case 0x3A:
		case 0x3C:
		case 0x3D:
		case 0x3E:
		case 0x3F:
		case 0x40:
		case 0x41:
		case 66:
		case 0x43:
		case 0x44:
		case 0x45:
		case 0x46:
		case 0x47:
		case 0x48:
		case 0x49:
		case 0x4A:
		case 0x4B:
		case 0x4C:
		case 77:
		case 0x4E:
		case 0x4F:
		case 0x50:
		case 0x51:
		case 0x52:
		case 0x53:
		case 0x54:
		case 0x55:
			break;
		case 0x03:
			return 0x07;
		case 0x04:
			return 0x08;
		case 0x05:
			return 0x10;
		case 0x06:
			return 0x0E;
		case 0x07:
			return 0x0C;
		case 0x08:
			return 0x0F;
		case 0x09:
			return 0x17;
		case 0x0A:
			return 0x11;
		case 0x15:
			return 11;
		case 22:
			return 0x0D;
		case 0x17:
			return 0x14;
		case 0x18:
			return 22;
		case 0x19:
			return 0x15;
		case 0x1B:
			return 0x32;
		case 0x36:
			return 0x09;
		case 0x38:
			return 0x0A;
		case 0x39:
			return 33;
		case 0x3B:
			return 0x19;
		case 0x56:
			return 0x1A;
		case 0x57:
			return 0x12;
		case 88:
			return 0x1B;
		case 0x59:
			return 0x20;
		}
	}
	return 0x33;
}

// 00754260: Register word32 fn00754260(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08)
// Called from:
//      fn007544F0
word32 fn00754260(Eq_3 dwArg04, Eq_3 dwArg08)
{
	word32 eax_14;
	if (dwArg04 <= 0x7C)
	{
		switch ((word32) *((word32) dwArg04 + 0x00754383))
		{
		case 0x00:
			if (dwArg08 == 0x3D)
				return 0x1D;
			break;
		case 0x01:
		case 0x02:
		case 0x03:
		case 0x06:
		case 0x07:
		case 0x08:
		case 11:
		case 0x0D:
		case 0x0F:
		case 0x10:
		case 0x11:
		case 0x12:
		case 0x13:
		case 0x14:
		case 0x15:
		case 22:
		case 0x17:
		case 0x18:
		case 0x19:
		case 0x1A:
		case 0x1E:
		case 0x1F:
		case 0x20:
		case 33:
		case 0x22:
		case 0x23:
		case 0x24:
		case 0x25:
		case 0x26:
		case 0x27:
		case 0x28:
		case 0x29:
		case 0x2A:
		case 0x2B:
		case 44:
		case 0x2D:
		case 0x2E:
		case 0x2F:
		case 0x30:
		case 0x31:
		case 0x32:
		case 0x33:
		case 0x34:
		case 0x35:
		case 0x36:
		case 55:
		case 0x38:
		case 0x39:
		case 0x3A:
		case 0x3B:
		case 0x3C:
		case 0x3E:
		case 0x3F:
		case 0x40:
		case 0x41:
		case 66:
		case 0x43:
		case 0x44:
		case 0x45:
		case 0x46:
		case 0x47:
		case 0x48:
		case 0x49:
		case 0x4A:
		case 0x4B:
		case 0x4C:
		case 77:
		case 0x4E:
		case 0x4F:
		case 0x50:
		case 0x51:
		case 0x52:
		case 0x53:
		case 0x54:
		case 0x55:
		case 0x56:
		case 0x57:
		case 88:
		case 0x59:
		case 0x5A:
			break;
		case 0x04:
			if (dwArg08 == 0x3D)
				return 0x29;
			break;
		case 0x05:
			if (dwArg08 == 0x3D)
				return 0x2A;
			break;
		case 0x09:
			if (dwArg08 == 0x2A)
				return 0x24;
			if (dwArg08 == 0x3D)
				return 0x27;
			break;
		case 0x0A:
			if (dwArg08 == 0x3D)
				return 0x25;
			break;
		case 0x0C:
			if (dwArg08 == 0x3D)
				return 0x26;
			break;
		case 0x0E:
			if (dwArg08 == 0x2F)
				return 0x30;
			if (dwArg08 == 0x3D)
				return 0x28;
			break;
		case 0x1B:
			if (dwArg08 == 0x3C)
				return 0x22;
			if (dwArg08 == 0x3D)
				return 0x1E;
			if (dwArg08 == 0x3E)
				return 0x1D;
			break;
		case 0x1C:
			if (dwArg08 == 0x3D)
				return 0x1C;
			break;
		case 0x1D:
			if (dwArg08 == 0x3D)
				return 0x1F;
			if (dwArg08 == 0x3E)
				return 0x23;
			break;
		case 0x3D:
			eax_14 = 44;
			if (dwArg08 == 0x3D)
				return eax_14;
			break;
		case 0x5B:
			if (dwArg08 == 0x3D)
				return 0x2B;
			break;
		}
	}
	eax_14 = 0x33;
	return eax_14;
}

// 00754400: Register word32 fn00754400(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Stack Eq_3 dwArg0C)
// Called from:
//      fn007544F0
word32 fn00754400(Eq_3 dwArg04, Eq_3 dwArg08, Eq_3 dwArg0C)
{
	word32 eax_23;
	if (dwArg04 <= ~0x3D)
	{
		switch ((word32) *((word32) dwArg04 + 0x0075445A))
		{
		case 0x00:
			if (dwArg08 == 0x2A && dwArg0C == 0x3D)
				return 0x2F;
			break;
		case 0x01:
		case 0x02:
		case 0x03:
		case 0x04:
		case 0x06:
		case 0x07:
		case 0x08:
		case 0x09:
		case 0x0A:
		case 11:
		case 0x0C:
		case 0x0D:
		case 0x0E:
		case 0x0F:
		case 0x10:
		case 0x11:
		case 0x13:
			break;
		case 0x05:
			if (dwArg08 == 0x2F)
			{
				eax_23 = 0x31;
				if (dwArg0C == 0x3D)
					return eax_23;
			}
			break;
		case 0x12:
			if (dwArg08 == 0x3C && dwArg0C == 0x3D)
				return 0x2D;
			break;
		case 0x14:
			if (dwArg08 == 0x3E && dwArg0C == 0x3D)
				return 0x2E;
			break;
		}
	}
	eax_23 = 0x33;
	return eax_23;
}

// 007544A0: Register word32 fn007544A0(Register Eq_3 esi, Register out Eq_540 edxOut)
// Called from:
//      fn007544F0
word32 fn007544A0(Eq_3 esi, union Eq_540 & edxOut)
{
	if (*((word32) esi + 468) == 0x00)
	{
		if (*((word32) esi + 464) != 0x00)
		{
			word32 edx_53;
			fn00716B20(out edx_53);
			*((word32) esi + 464) = 0x00;
		}
		edxOut.u0 = <invalid>;
		return 0x00;
	}
	else
	{
		*((word32) esi + 4) = *((word32) esi + 8);
		((word32) esi + 20)->u0 = 0x12;
		edxOut.u0 = <invalid>;
		return 0x01;
	}
}

// 007544F0: Register word32 fn007544F0(Register Eq_3 ecx, Register Eq_3 edx, Register Eq_3 ebx, Register Eq_3 ebp, Register Eq_3 esi, Register Eq_3 edi, Register (ptr16 Eq_7) es, Register (ptr16 Eq_8) ds, Stack Eq_3 dwArg04)
// Called from:
//      fn00754FA0
word32 fn007544F0(Eq_3 ecx, Eq_3 edx, Eq_3 ebx, Eq_3 ebp, Eq_3 esi, Eq_3 edi, struct Eq_7 * es, struct Eq_8 * ds, Eq_3 dwArg04)
{
	ui32 eax_7 = g_tA14188 ^ fp - 100;
	ecx->u0 = 0x00;
	dwArg04->u0 = 0x00;
	edx_2159 = edx;
l00754520:
	Eq_3 edx_2159;
	((word32) edx + 16)->u0 = 0x00;
	int32 edi_2240 = 0x00;
	int32 dwLoc64_2563 = 0x00;
	if (*((word32) edx + 436) == 0x00)
	{
l0075467C:
		*((word32) edx + 16) = *((word32) edx + 4);
		if (*((word32) edx + 440) != 0x00)
		{
			int32 eax_343 = *((word32) edx + 440);
			if (eax_343 >= 0x00)
			{
				*((word32) edx + 440) = eax_343 + ~0x00;
				word32 ecx_3252;
				return fn00694B8E(0x05, eax_7 ^ fp - 100, edx_2159, ebx, ebp, esi, edi, es, ds, ebx, out ecx_3252);
			}
			else
			{
				*((word32) edx + 440) = eax_343 + 0x01;
				word32 ecx_3253;
				return fn00694B8E(0x06, eax_7 ^ fp - 100, edx_2159, ebx, ebp, esi, edi, es, ds, ebx, out ecx_3253);
			}
		}
		else
		{
			while (true)
			{
				((word32) edx + 16)->u0 = 0x00;
				do
				{
					word32 ecx_3204;
					word32 edx_3205;
					Eq_3 eax_438 = fn00753C30(edx, out ecx_3204, out edx_3205);
					Eq_3 ebx_2162 = eax_438;
				} while (eax_438 == 0x20 || (eax_438 == 0x09 || eax_438 == 0x0C));
				Eq_3 edx_451 = *((word32) edx + 4);
				*((word32) edx + 16) = edx_451 - 0x01;
				edx_2159 = edx_451 - 0x01;
				if (eax_438 == 0x23)
					break;
l00754791:
				if (ebx_2162 == ~0x00)
					goto l00754771;
				if (isalpha(ebx_2162) != 0x00 || ebx_2162 == 0x5F)
				{
					Eq_174671 eax_578 = ebx_2162 - 0x52;
					if (eax_578 <= 0x23)
					{
						switch (eax_578)
						{
						case 0x00:
						case 0x20:
							word32 edx_3224;
							word32 ecx_3223;
							Eq_3 eax_643 = fn00753C30(edx, out ecx_3223, out edx_3224);
							ebx_2162 = eax_643;
							if (eax_643 == 0x22)
								goto l0075498D;
							break;
						case 0x01:
						case 0x02:
						case 0x04:
						case 0x05:
						case 0x06:
						case 0x07:
						case 0x08:
						case 0x09:
						case 0x0A:
						case 11:
						case 0x0C:
						case 0x0D:
						case 0x0E:
						case 0x0F:
						case 0x10:
						case 0x11:
						case 0x12:
						case 0x13:
						case 0x14:
						case 0x15:
						case 22:
						case 0x17:
						case 0x18:
						case 0x19:
						case 0x1A:
						case 0x1B:
						case 0x1C:
						case 0x1D:
						case 0x1E:
						case 0x1F:
						case 33:
						case 0x22:
							goto l00754E98;
						case 0x03:
						case 0x23:
							word32 ecx_3225;
							word32 edx_3226;
							Eq_3 eax_606 = fn00753C30(edx, out ecx_3225, out edx_3226);
							ebx_2162 = eax_606;
							if (eax_606 == 114 || eax_606 == 0x52)
							{
								word32 edx_3228;
								word32 ecx_3227;
								ebx_2162 = fn00753C30(edx, out ecx_3227, out edx_3228);
							}
							if (ebx_2162 == 0x22)
								goto l007548E7;
							break;
						}
						if (ebx_2162 == 0x27)
						{
l0075498D:
							word32 ebp_945 = *((word32) edx + 4) - *((word32) edx + 16);
							word32 edi_1019 = 0x00;
							word32 dwLoc64_2733 = 0x00;
l007549A0:
							word32 ebx_1155 = dwLoc64_2733;
							do
							{
								Eq_3 edx_971;
								word32 ecx_3229;
								Eq_3 eax_969 = fn00753C30(edx, out ecx_3229, out edx_971);
								if (eax_969 == 0x0A)
								{
									if (ebx_1155 == 0x00)
									{
										*((word32) edx + 4) = (word32) *((word32) edx + 4) - 1;
										Eq_3 eax_1165 = *((word32) edx + 4);
										((word32) edx + 20)->u0 = 0x18;
										if (eax_1165 < *edx)
											fn006E86F0(0x008DFC5C);
										Eq_3 esi_1180 = *((word32) edx + 4);
										if (*esi_1180 != 0x0A)
											*esi_1180 = 0x0A;
										word32 ecx_3239;
										return fn00694B8E(0x34, eax_7 ^ fp - 100, edx_971, ebx, ebp, esi, edi, es, ds, ebx, out ecx_3239);
									}
									else
									{
										*((word32) edx + 892) = 0x01;
										edi_1019 = 0x00;
										continue;
									}
								}
								if (eax_969 == ~0x00)
								{
									Eq_3 edx_979 = *((word32) edx + 8);
									*((word32) edx + 20) = 0x00 - (ebx_1155 == 0x00) + 0x18;
									*((word32) edx + 4) = edx_979;
									word32 ecx_3240;
									return fn00694B8E(0x34, eax_7 ^ fp - 100, edx_979, ebx, ebp, esi, edi, es, ds, ebx, out ecx_3240);
								}
								if (eax_969 == ebx_2162)
								{
									++edi_1019;
									if (*((word32) edx + 4) - *((word32) edx + 16) == ebp_945 + 0x01)
									{
										word32 edx_3242;
										word32 ecx_3241;
										Eq_3 eax_1062 = fn00753C30(edx, out ecx_3241, out edx_3242);
										byte bl_1093 = (byte) eax_1062;
										if (eax_1062 == ebx_2162)
										{
											ebx_1155 = 0x01;
											dwLoc64_2733 = 0x01;
l00754D8A:
											edi_1019 = 0x00;
											continue;
										}
										if (eax_1062 != ~0x00)
										{
											*((word32) edx + 4) = (word32) *((word32) edx + 4) - 1;
											if (*((word32) edx + 4) < *edx)
												fn006E86F0(0x008DFC5C);
											Eq_3 eax_1088 = *((word32) edx + 4);
											if ((int32) *eax_1088 != eax_1062)
												*eax_1088 = bl_1093;
										}
									}
									if (dwLoc64_2733 != 0x00 && edi_1019 != 0x03)
										goto l007549A0;
									*dwArg04 = *((word32) edx + 16);
									Eq_3 edx_1111 = *((word32) edx + 4);
									*ecx = edx_1111;
									word32 ecx_3243;
									return fn00694B8E(0x03, eax_7 ^ fp - 100, edx_1111, ebx, ebp, esi, edi, es, ds, ebx, out ecx_3243);
								}
								if (eax_969 != 0x5C)
									goto l00754D8A;
								edi_1019 = 0x00;
								word32 ecx_3244;
								Eq_3 edx_1025;
							} while (fn00753C30(edx, out ecx_3244, out edx_1025) != ~0x00);
							Eq_3 ecx_1030 = *((word32) edx + 8);
							((word32) edx + 20)->u0 = 0x18;
							*((word32) edx + 4) = ecx_1030;
							word32 ecx_3245;
							return fn00694B8E(0x34, eax_7 ^ fp - 100, edx_1025, ebx, ebp, esi, edi, es, ds, ebx, out ecx_3245);
						}
					}
l00754E98:
					while (true)
					{
						byte bl_701 = (byte) ebx_2162;
						if (isalnum(ebx_2162) == 0x00 && ebx_2162 != 0x5F)
							break;
						word32 edx_3231;
						word32 ecx_3230;
						ebx_2162 = fn00753C30(edx, out ecx_3230, out edx_3231);
					}
					if (ebx_2162 != ~0x00)
					{
						*((word32) edx + 4) = (word32) *((word32) edx + 4) - 1;
						if (*((word32) edx + 4) < *edx)
							fn006E86F0(0x008DFC5C);
						Eq_3 eax_696 = *((word32) edx + 4);
						if ((int32) *eax_696 != ebx_2162)
							*eax_696 = bl_701;
					}
					*dwArg04 = *((word32) edx + 16);
					Eq_3 edx_710 = *((word32) edx + 4);
					*ecx = edx_710;
					word32 ecx_3235;
					return fn00694B8E(0x01, eax_7 ^ fp - 100, edx_710, ebx, ebp, esi, edi, es, ds, ebx, out ecx_3235);
				}
				if (ebx_2162 == 0x0A)
				{
					*((word32) edx + 436) = 0x01;
					if (dwLoc64_2563 != 0x00 || *((word32) edx + 456) > 0x00)
						goto l00754520;
					*dwArg04 = *((word32) edx + 16);
					*ecx = *((word32) edx + 4) - 0x01;
					*((word32) edx + 892) = 0x00;
					word32 ecx_3251;
					return fn00694B8E(0x04, eax_7 ^ fp - 100, ecx, ebx, ebp, esi, edi, es, ds, ebx, out ecx_3251);
				}
				Eq_3 ebx_1556;
				bool v50_2389;
				Eq_174689 esp_1560;
				Eq_3 (* edi_1689)(Eq_3);
				if (ebx_2162 == 0x2E)
				{
					word32 edx_3211;
					word32 ecx_3210;
					Eq_3 eax_836 = fn00753C30(edx, out ecx_3210, out edx_3211);
					edi_1689 = isdigit;
					byte bl_873 = (byte) eax_836;
					esp_1560 = fp - 116;
					if (isdigit(eax_836) == 0x00)
					{
						if (eax_836 != ~0x00)
						{
							*((word32) edx + 4) = (word32) *((word32) edx + 4) - 1;
							if (*((word32) edx + 4) < *edx)
								fn006E86F0(0x008DFC5C);
							Eq_3 eax_868 = *((word32) edx + 4);
							if ((int32) *eax_868 != eax_836)
								*eax_868 = bl_873;
						}
						*dwArg04 = *((word32) edx + 16);
						*ecx = *((word32) edx + 4);
						word32 ecx_3250;
						return fn00694B8E(0x17, eax_7 ^ fp - 100, ecx, ebx, ebp, esi, edi, es, ds, ebx, out ecx_3250);
					}
					goto l00754B20;
				}
				edi_1689 = isdigit;
				if (isdigit(ebx_2162) != 0x00)
				{
					if (ebx_2162 != 0x30)
					{
						do
						{
							word32 ecx_3212;
							word32 edx_3213;
							Eq_3 eax_1551 = fn00753C30(edx, out ecx_3212, out edx_3213);
							ebx_1556 = eax_1551;
							esp_1560 = fp - 116;
						} while (isdigit(eax_1551) != 0x00);
						if (eax_1551 == 0x6C || eax_1551 == 0x4C)
							goto l00754BCB;
						if (eax_1551 == 0x2E)
							goto l00754B20;
						goto l00754B31;
					}
					word32 ecx_3214;
					word32 edx_3215;
					Eq_3 eax_1572 = fn00753C30(edx, out ecx_3214, out edx_3215);
					esp_1560 = fp - 116;
					ebx_1556 = eax_1572;
					if (eax_1572 == 0x2E)
						goto l00754B20;
					if (eax_1572 == 0x6A || eax_1572 == 0x4A)
						goto l00754BCB;
					if (eax_1572 == 0x78 || eax_1572 == 88)
					{
						do
						{
							word32 edx_3249;
							word32 ecx_3248;
							Eq_3 eax_1598 = fn00753C30(edx, out ecx_3248, out edx_3249);
							ebx_1556 = eax_1598;
						} while (isxdigit(eax_1598) != 0x00);
						goto l00754AE1;
					}
					word32 ebp_1611 = 0x00;
					if (eax_1572 >= 0x30)
					{
						while (ebx_1556 < 0x38)
						{
							word32 edx_3219;
							word32 ecx_3218;
							Eq_3 eax_1626 = fn00753C30(edx, out ecx_3218, out edx_3219);
							ebx_1556 = eax_1626;
							if (eax_1626 < 0x30)
								break;
						}
					}
					Eq_3 edx_1647 = <invalid>;
					if (isdigit(ebx_1556) != 0x00)
					{
						ebp_1611 = 0x01;
						do
						{
							word32 ecx_3220;
							word32 edx_3221;
							Eq_3 eax_1664 = fn00753C30(edx, out ecx_3220, out edx_3221);
							ebx_1556 = eax_1664;
							edx_1647.u0 = <invalid>;
						} while (isdigit(eax_1664) != 0x00);
					}
					esp_1560 = fp - 116;
					if (ebx_1556 != 0x2E)
					{
						if (ebx_1556 == 101 || ebx_1556 == 0x45)
							goto l00754B3F;
						if (ebx_1556 == 0x6A || ebx_1556 == 0x4A)
							goto l00754BCB;
						if (ebp_1611 != 0x00)
						{
							((word32) edx + 20)->u0 = 0x0D;
							fn007540B0(edx, ebx_1556);
							word32 ecx_3222;
							return fn00694B8E(0x34, eax_7 ^ fp - 100, edx_1647, ebx, ebp, esi, edi, es, ds, ebx, out ecx_3222);
						}
l00754AE1:
						if (ebx_1556 == 0x6C)
							goto l00754BCB;
						v50_2389 = ebx_1556 != 0x4C;
						goto l00754BC9;
					}
l00754B20:
					do
					{
						word32 ecx_1695;
						word32 edx_1696;
						Eq_3 eax_1694 = fn00753C30(edx, out ecx_1695, out edx_1696);
						*((word32) esp_1560 - 4) = eax_1694;
						word32 esp_1702;
						word32 eax_1703;
						edi_1689();
						ebx_1556 = eax_1694;
						esp_1560 = esp_1702 + 0x04;
					} while (eax_1703 != 0x00);
l00754B31:
					if (ebx_1556 == 101 || ebx_1556 == 0x45)
					{
l00754B3F:
						word32 ecx_1745;
						word32 edx_1746;
						Eq_3 eax_1744 = fn00753C30(edx, out ecx_1745, out edx_1746);
						Eq_3 ebx_1749 = eax_1744;
						if (eax_1744 == 0x2B || eax_1744 == 0x2D)
							ebx_1749 = fn00753C30(edx, out ecx_1745, out edx_1746);
						*((word32) esp_1560 - 4) = ebx_1749;
						word32 eax_1780;
						Eq_3 edx_1782;
						edi_1689();
						byte bl_1844 = (byte) ebx_1749;
						Eq_175415 esp_1785 = fp - 116;
						if (eax_1780 == 0x00)
						{
							((word32) edx + 20)->u0 = 0x0D;
							if (ebx_1749 != ~0x00)
							{
								*((word32) edx + 4) = (word32) *((word32) edx + 4) - 1;
								if (*((word32) edx + 4) < *edx)
									fn006E86F0(0x008DFC5C);
								Eq_3 esi_1839 = *((word32) edx + 4);
								if ((int32) *esi_1839 != ebx_1749)
									*esi_1839 = bl_1844;
							}
							word32 ecx_3247;
							return fn00694B8E(0x34, eax_7 ^ fp - 100, edx_1782, ebx, ebp, esi, edi, es, ds, ebx, out ecx_3247);
						}
						do
						{
							word32 ecx_1799;
							word32 edx_1800;
							Eq_3 eax_1798 = fn00753C30(edx, out ecx_1799, out edx_1800);
							*((word32) esp_1785 - 4) = eax_1798;
							word32 esp_1806;
							word32 eax_1807;
							edi_1689();
							ebx_1556 = eax_1798;
							esp_1785 = esp_1806 + 0x04;
						} while (eax_1807 != 0x00);
					}
					if (ebx_1556 != 0x6A)
					{
						v50_2389 = ebx_1556 != 0x4A;
l00754BC9:
						if (!v50_2389)
							goto l00754BCB;
					}
					else
					{
l00754BCB:
						word32 ecx_3216;
						word32 edx_3217;
						ebx_1556 = fn00753C30(edx, out ecx_3216, out edx_3217);
					}
					byte bl_2030 = (byte) ebx_1556;
					if (ebx_1556 != ~0x00)
					{
						*((word32) edx + 4) = (word32) *((word32) edx + 4) - 1;
						if (*((word32) edx + 4) < *edx)
							fn006E86F0(0x008DFC5C);
						Eq_3 eax_2025 = *((word32) edx + 4);
						if ((int32) *eax_2025 != ebx_1556)
							*eax_2025 = bl_2030;
					}
					*dwArg04 = *((word32) edx + 16);
					*ecx = *((word32) edx + 4);
					word32 ecx_3234;
					return fn00694B8E(0x02, eax_7 ^ fp - 100, ecx, ebx, ebp, esi, edi, es, ds, ebx, out ecx_3234);
				}
l007548E7:
				if (ebx_2162 == 0x27 || ebx_2162 == 0x22)
					goto l0075498D;
				Eq_3 edx_1241;
				word32 ecx_3232;
				Eq_3 eax_1239 = fn00753C30(edx, out ecx_3232, out edx_1241);
				if (ebx_2162 != 0x5C)
				{
					Eq_3 eax_1252 = fn00754260(ebx_2162, eax_1239);
					Eq_3 edi_1257 = eax_1252;
					if (eax_1252 == 0x33)
					{
						if (eax_1239 != ~0x00)
						{
							*((word32) edx + 4) = (word32) *((word32) edx + 4) - 1;
							if (*((word32) edx + 4) < *edx)
								fn006E86F0(0x008DFC5C);
							Eq_3 eax_1280 = *((word32) edx + 4);
							byte cl_1285 = (byte) eax_1239;
							if ((int32) *eax_1280 != eax_1239)
								*eax_1280 = cl_1285;
						}
						struct Eq_175171 * eax_1289 = ebx_2162 - 0x28;
						if (eax_1289 <= (struct Eq_175171 *) 0x55)
						{
							switch ((word32) eax_1289->b754F48)
							{
							case 0x00:
							case 0x33:
							case 0x53:
								*((word32) edx + 456) = (word32) *((word32) edx + 456) + 1;
								break;
							case 0x01:
							case 0x35:
							case 0x55:
								*((word32) edx + 456) = (word32) *((word32) edx + 456) - 1;
								break;
							case 0x02:
							case 0x03:
							case 0x04:
							case 0x05:
							case 0x06:
							case 0x07:
							case 0x08:
							case 0x09:
							case 0x0A:
							case 11:
							case 0x0C:
							case 0x0D:
							case 0x0E:
							case 0x0F:
							case 0x10:
							case 0x11:
							case 0x12:
							case 0x13:
							case 0x14:
							case 0x15:
							case 22:
							case 0x17:
							case 0x18:
							case 0x19:
							case 0x1A:
							case 0x1B:
							case 0x1C:
							case 0x1D:
							case 0x1E:
							case 0x1F:
							case 0x20:
							case 33:
							case 0x22:
							case 0x23:
							case 0x24:
							case 0x25:
							case 0x26:
							case 0x27:
							case 0x28:
							case 0x29:
							case 0x2A:
							case 0x2B:
							case 44:
							case 0x2D:
							case 0x2E:
							case 0x2F:
							case 0x30:
							case 0x31:
							case 0x32:
							case 0x34:
							case 0x36:
							case 55:
							case 0x38:
							case 0x39:
							case 0x3A:
							case 0x3B:
							case 0x3C:
							case 0x3D:
							case 0x3E:
							case 0x3F:
							case 0x40:
							case 0x41:
							case 66:
							case 0x43:
							case 0x44:
							case 0x45:
							case 0x46:
							case 0x47:
							case 0x48:
							case 0x49:
							case 0x4A:
							case 0x4B:
							case 0x4C:
							case 77:
							case 0x4E:
							case 0x4F:
							case 0x50:
							case 0x51:
							case 0x52:
							case 0x54:
								break;
							}
						}
						*dwArg04 = *((word32) edx + 16);
						*ecx = *((word32) edx + 4);
						word32 ecx_3246;
						return fn00694B8E(fn007540E0(ebx_2162), eax_7 ^ fp - 100, dwArg04, ebx, ebp, esi, edi, es, ds, ebx, out ecx_3246);
					}
					else
					{
						word32 edx_3237;
						word32 ecx_3236;
						Eq_3 eax_1415 = fn00753C30(edx, out ecx_3236, out edx_3237);
						Eq_3 eax_1429 = fn00754400(ebx_2162, eax_1239, eax_1415);
						if (eax_1429 != 0x33)
							edi_1257 = eax_1429;
						else if (eax_1415 != ~0x00)
						{
							*((word32) edx + 4) = (word32) *((word32) edx + 4) - 1;
							if (*((word32) edx + 4) < *edx)
								fn006E86F0(0x008DFC5C);
							Eq_3 eax_1456 = *((word32) edx + 4);
							byte cl_1461 = (byte) eax_1415;
							if ((int32) *eax_1456 != eax_1415)
								*eax_1456 = cl_1461;
						}
						*dwArg04 = *((word32) edx + 16);
						Eq_3 edx_1471 = *((word32) edx + 4);
						*ecx = edx_1471;
						word32 ecx_3238;
						return fn00694B8E(edi_1257, eax_7 ^ fp - 100, edx_1471, ebx, ebp, esi, edi, es, ds, ebx, out ecx_3238);
					}
				}
				if (eax_1239 != 0x0A)
				{
					*((word32) edx + 4) = *((word32) edx + 8);
					((word32) edx + 20)->u0 = 0x19;
					word32 ecx_3233;
					return fn00694B8E(0x34, eax_7 ^ fp - 100, edx_1241, ebx, ebp, esi, edi, es, ds, ebx, out ecx_3233);
				}
				*((word32) edx + 892) = 0x01;
			}
			byte * edi_456 = fp - 0x54;
			int32 ebp_459 = 0x01 - (fp - 0x54);
			do
			{
				word32 edx_3207;
				word32 ecx_3206;
				Eq_3 eax_471 = fn00753C30(edx, out ecx_3206, out edx_3207);
				*edi_456 = (byte) eax_471;
				ebx_2162 = eax_471;
				++edi_456;
			} while (eax_471 != ~0x00 && (eax_471 != 0x0A && edi_456 + ebp_459 < 0x50));
			*edi_456 = 0x00;
			word32 * ebp_489 = g_aA35120;
			do
			{
				edx_2159 = *ebp_489;
				word24 edx_24_8_538 = SLICE(edx_2159, word24, 8);
				const char * eax_499 = strstr(fp - 0x54, edx_2159);
				if (eax_499 != null)
				{
					Eq_3 ecx_504 = *ebp_489;
					ecx_506 = ecx_504;
					do
					{
						Eq_3 ecx_506;
						byte dl_508 = *ecx_506;
						ecx_506 = (word32) ecx_506 + 1;
						edx_2159 = SEQ(edx_24_8_538, dl_508);
					} while (dl_508 != 0x00);
					Eq_3 eax_520 = atoi(eax_499 + (ecx_506 - ((word32) ecx_504 + 1)));
					if (eax_520 <= 0x28)
					{
						*((word32) edx + 28) = eax_520;
						if (g_tA74AF0 != 0x00)
							fn00716B20(out edx_2159);
					}
				}
				++ebp_489;
			} while (ebp_489 < &g_dwA35130);
			if (eax_471 != ~0x00)
			{
				do
				{
					if (ebx_2162 == 0x0A)
						goto l00754791;
					word32 ecx_3209;
					Eq_3 eax_2157 = fn00753C30(edx, out ecx_3209, out edx_2159);
					ebx_2162 = eax_2157;
				} while (eax_2157 != ~0x00);
			}
l00754771:
			word32 ecx_3208;
			return fn00694B8E(0x00 - (*((word32) edx + 20) == 11) & 0x34, eax_7 ^ fp - 100, edx_2159, ebx, ebp, esi, edi, es, ds, ebx, out ecx_3208);
		}
	}
	else
	{
		*((word32) edx + 436) = 0x00;
		int32 ebp_2239 = 0x00;
		while (true)
		{
			while (true)
			{
				while (true)
				{
					word32 ecx_3203;
					Eq_3 eax_55 = fn00753C30(edx, out ecx_3203, out edx_2159);
					byte bl_91 = (byte) eax_55;
					if (eax_55 != 0x20)
						break;
					++edi_2240;
					++ebp_2239;
				}
				if (eax_55 != 0x09)
					break;
				Eq_3 ecx_2243 = *((word32) edx + 28);
				int32 ecx_2252 = *((word32) edx + 472);
				edi_2240 = ((int32) ((int64) edi_2240 /32 ecx_2243) + 0x01) *s ecx_2243;
				ebp_2239 = ((int32) ((int64) ebp_2239 /32 ecx_2252) + 0x01) *s ecx_2252;
			}
			if (eax_55 != 0x0C)
				break;
			ebp_2239 = 0x00;
			edi_2240 = 0x00;
		}
		if (eax_55 != ~0x00)
		{
			*((word32) edx + 4) = (word32) *((word32) edx + 4) - 1;
			if (*((word32) edx + 4) < *edx)
				fn006E86F0(0x008DFC5C);
			Eq_3 eax_86 = *((word32) edx + 4);
			if ((int32) *eax_86 != eax_55)
				*eax_86 = bl_91;
		}
		if (eax_55 == 0x23 || eax_55 == 0x0A)
		{
			if (edi_2240 != 0x00 || (eax_55 != 0x0A || *((word32) edx + 444) == edi_2240))
			{
				dwLoc64_2563 = 0x01;
				goto l0075467C;
			}
			dwLoc64_2563 = edi_2240;
		}
		if (*((word32) edx + 456) != 0x00)
			goto l0075467C;
		int32 eax_123 = *((word32) edx + 32);
		int32 ecx_124 = *((word32) edx + (eax_123 * 0x04 + 36));
		if (edi_2240 != ecx_124)
		{
			if (edi_2240 > ecx_124)
			{
				edx_2159 = eax_123 + 0x01;
				if (eax_123 >= 99)
				{
					Eq_3 eax_270 = *((word32) edx + 8);
					((word32) edx + 20)->u0 = 0x14;
					*((word32) edx + 4) = eax_270;
					goto l007549D5;
				}
				if (ebp_2239 <= *((word32) edx + (eax_123 * 0x04 + 476)) && fn007544A0(edx, out edx_2159) != 0x00)
				{
l007549D5:
					word32 ecx_3254;
					return fn00694B8E(0x34, eax_7 ^ fp - 100, edx_2159, ebx, ebp, esi, edi, es, ds, ebx, out ecx_3254);
				}
				*((word32) edx + 440) = (word32) *((word32) edx + 440) + 1;
				*((word32) edx + 32) = (word32) *((word32) edx + 32) + 1;
				*((word32) edx + (*((word32) edx + 32) * 0x04 + 36)) = edi_2240;
				*((word32) edx + (*((word32) edx + 32) * 0x04 + 476)) = ebp_2239;
				goto l0075467C;
			}
			if (eax_123 > 0x00)
			{
				do
				{
					int32 eax_136 = *((word32) edx + 32);
					if (edi_2240 >= *((word32) edx + (eax_136 * 0x04 + 36)))
						break;
					*((word32) edx + 440) = (word32) *((word32) edx + 440) - 1;
					*((word32) edx + 32) = eax_136 + ~0x00;
				} while (eax_136 > ~0x00);
			}
			eax_123 = (int32) *((word32) edx + 32);
			if (edi_2240 != *((word32) edx + (eax_123 * 0x04 + 36)))
			{
				Eq_3 ecx_153 = *((word32) edx + 8);
				((word32) edx + 20)->u0 = 0x15;
				*((word32) edx + 4) = ecx_153;
				word32 ecx_3255;
				return fn00694B8E(0x34, eax_7 ^ fp - 100, edx_2159, ebx, ebp, esi, edi, es, ds, ebx, out ecx_3255);
			}
		}
		if (ebp_2239 != *((word32) edx + (eax_123 * 0x04 + 476)) && fn007544A0(edx, out edx_2159) != 0x00)
			goto l007549D5;
		goto l0075467C;
	}
}

// 00754FA0: Register word32 fn00754FA0(Stack Eq_3 dwArg04)
// Called from:
//      fn007406A0
word32 fn00754FA0(Eq_3 dwArg04)
{
	word32 eax_15 = fn007544F0(dwArg0C, dwArg04, ebx, ebp, dwArg04, edi, es, ds, dwArg08);
	if (*((word32) dwArg04 + 880) != 0x00)
	{
		((word32) dwArg04 + 20)->u0 = 22;
		eax_15 = 0x34;
	}
	return eax_15;
}

// 00754FD0: Register Eq_3 fn00754FD0(Stack Eq_3 dwArg04)
// Called from:
//      fn00755020
Eq_3 fn00754FD0(Eq_3 dwArg04)
{
	Eq_3 edi_18 = 0x00;
	word32 edx_121;
	Eq_3 eax_22 = fn0071FC80(out edx_121);
	if (eax_22 != 0x00)
	{
		word32 ecx_124;
		word32 edx_125;
		Eq_3 eax_40 = fn0071FB20(eax_22, dwArg04, 0x008D46D8, out ecx_124, out edx_125);
		word32 v12_46 = (word32) *eax_22 - 1;
		*eax_22 = v12_46;
		edi_18 = eax_40;
		if (v12_46 == 0x00)
		{
			Eq_3 eax_51 = *((word32) eax_22 + 4);
			Eq_3 ecx_52 = *((word32) eax_51 + 24);
			ecx_52();
		}
		if (eax_40 != 0x00)
			return edi_18;
	}
	word32 ecx_122;
	word32 edx_123;
	fn006E1160(out ecx_122, out edx_123);
	return edi_18;
}

// 00755020: Register Eq_3 fn00755020(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08)
// Called from:
//      fn007406A0
Eq_3 fn00755020(Eq_3 dwArg04, Eq_3 dwArg08)
{
	Eq_3 eax_6 = *((word32) dwArg04 + 888);
	if (eax_6 == 0x00)
		return 0x00;
	Eq_3 eax_26 = fn00754FD0(eax_6);
	if (eax_26 == 0x00)
		return 0x00;
	Eq_3 eax_50 = fn006ECC00(eax_26);
	word32 ecx_283;
	word32 edx_284;
	word32 esi_285;
	Eq_3 eax_59 = fn006ECC50(eax_26, out ecx_283, out edx_284, out esi_285);
	word32 edx_287;
	word32 ecx_286;
	Eq_3 eax_67 = fn00723860((word32) eax_50 + 1, out ecx_286, out edx_287);
	if (eax_67 != 0x00 && eax_59 != 0x00)
	{
		if (eax_50 != 0x00)
			strncpy(eax_67, eax_59, eax_50);
		Mem96[eax_50 + eax_67:byte] = 0x00;
	}
	word32 v13_100 = (word32) *eax_26 - 1;
	*eax_26 = v13_100;
	struct Eq_175959 * esp_106 = fp - 0x10;
	if (v13_100 == 0x00)
	{
		Eq_3 ecx_104 = *((word32) eax_26 + 4);
		word32 esp_116;
		word32 edx_119;
		(*((word32) ecx_104 + 24))();
		esp_106 = esp_116 + 0x04;
	}
	int32 * edi_126 = esp_106->ptr001C;
	if (*edi_126 > 0x01)
	{
		union Eq_3 * esp_135 = esp_106 - 4;
		*esp_135 = (union Eq_3 *) esp_106->ptr0014->t0378;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_3 stackArg4 = <invalid>;
		Eq_3 eax_143 = fn00754FD0(stackArg4);
		if (eax_143 != 0x00)
		{
			*esp_135 = (union Eq_3 *) eax_143;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg4 = <invalid>;
			*edi_126 = (word32) fn006ECC00(stackArg4) + 1;
			word32 v15_163 = (word32) *eax_143 - 1;
			*eax_143 = v15_163;
			if (v15_163 == 0x00)
			{
				struct Eq_176034 * eax_167 = *((word32) eax_143 + 4);
				<anonymous> * ecx_168 = eax_167->ptr0018;
				*esp_135 = (union Eq_3 *) eax_143;
				word32 edx_174;
				ecx_168();
			}
		}
	}
	return eax_67;
}

// 00755100: Register Eq_3 fn00755100()
// Called from:
//      fn00740A90
Eq_3 fn00755100()
{
	Eq_3 eax_7 = fn00752EA0();
	if (eax_7 == 0x00)
		return 0x00;
	struct Eq_176034 * eax_21 = fn007537F0(dwArg04, eax_7);
	if (eax_21 != null)
	{
		*((word32) eax_7 + 8) = eax_21;
		*((word32) eax_7 + 0x0C) = eax_21;
		*((word32) eax_7 + 4) = eax_21;
		*eax_7 = eax_21;
		return eax_7;
	}
	else
	{
		fn007539D0(eax_7);
		return 0x00;
	}
}

// 00755140: Register Eq_3 fn00755140(Stack (ptr32 ui32) dwArg04, Stack word32 dwArg08, Stack word32 dwArg0C)
// Called from:
//      fn00740B40
Eq_3 fn00755140(ui32 * dwArg04, word32 dwArg08, word32 dwArg0C)
{
	Eq_3 eax_7 = fn00752EA0();
	if (eax_7 == 0x00)
		return 0x00;
	struct Eq_176034 * eax_20 = malloc(0x0200);
	*eax_7 = eax_20;
	if (eax_20 != null)
	{
		*((word32) eax_7 + 8) = eax_20;
		*((word32) eax_7 + 4) = eax_20;
		*((word32) eax_7 + 0x0C) = (const char *) &eax_20->ptr0018 + 488;
		*((word32) eax_7 + 24) = dwArg04;
		*((word32) eax_7 + 444) = dwArg08;
		*((word32) eax_7 + 448) = dwArg0C;
		return eax_7;
	}
	else
	{
		fn007539D0(eax_7);
		return 0x00;
	}
}

// 007551A0: Register Eq_3 fn007551A0(Register Eq_3 ecx, Stack Eq_3 dwArg04, Stack (ptr32 Eq_147235) dwArg08)
// Called from:
//      fn007551F0
Eq_3 fn007551A0(Eq_3 ecx, Eq_3 dwArg04, struct Eq_147235 * dwArg08)
{
	struct Eq_176116 * eax_6 = *ecx;
	if (eax_6 != (word32) ecx + 4)
	{
		*ecx = &eax_6->dwFFFFFFF4;
		eax_6->tFFFFFFF8 = dwArg04;
		eax_6->ptrFFFFFFFC = dwArg08;
		eax_6->dwFFFFFFF4 = 0x00;
		return dwArg04;
	}
	else
	{
		word32 eax_23;
		Eq_3 ecx_24;
		_iob_func();
		fprintf(eax_23 + 0x40, 0x008DFCC4, 0x00);
		return ecx_24;
	}
}

// 007551F0: Register Eq_3 fn007551F0(Stack (ptr32 Eq_147156) dwArg04, Stack (ptr32 Eq_147235) dwArg08, Register out ptr32 ecxOut)
// Called from:
//      fn007406A0
Eq_3 fn007551F0(struct Eq_147156 * dwArg04, struct Eq_147235 * dwArg08, ptr32 & ecxOut)
{
	if (dwArg04->dw0014 == 0x00)
		ecx = fn00737BE0(dwArg04);
	Eq_3 eax_26 = malloc(6016);
	if (eax_26 != 0x00)
	{
		*((word32) eax_26 + 6004) = dwArg04;
		*((word32) eax_26 + 0x0000177C) = 0x00;
		ptr32 ecx_48;
		struct Eq_147235 * eax_47 = fn0073B660((word16) dwArg08, out ecx_48);
		*((word32) eax_26 + 6008) = eax_47;
		if (eax_47 != null)
		{
			*eax_26 = (word32) eax_26 + 6004;
			ecxOut = fn007551A0(eax_26, fn00752E10(dwArg04, dwArg08), eax_47);
			return eax_26;
		}
		else
		{
			free(eax_26);
			ecxOut = ecx_48;
			return 0x00;
		}
	}
	else
	{
		ecxOut = ecx;
		return eax_26;
	}
}

// 00755280: void fn00755280(Stack Eq_3 dwArg04)
// Called from:
//      fn007406A0
void fn00755280(Eq_3 dwArg04)
{
	fn0073B7F0(*((word32) dwArg04 + 6008));
	free(dwArg04);
}

// 007552A0: Register int32 fn007552A0(Register ptr32 ecx, Register int32 edx, Register Eq_3 esi, Stack (ptr32 Eq_147235) dwArg04, Stack Eq_3 dwArg08, Stack ui32 dwArg0C)
// Called from:
//      fn00755500
int32 fn007552A0(ptr32 ecx, int32 edx, Eq_3 esi, struct Eq_147235 * dwArg04, Eq_3 dwArg08, ui32 dwArg0C)
{
	struct Eq_149912 * edi_10 = *((word32) *esi + 8);
	int32 eax_24 = fn0073B6B0(edi_10, (word16) dwArg04, 0x00, edx, ecx);
	if (eax_24 != 0x00)
		return eax_24;
	**esi = dwArg0C;
	word32 ecx_41 = edi_10->t0014 - 0x18 + edi_10->t0010 * 0x18;
	struct Eq_176210 * eax_42 = *esi;
	if (eax_42 != (word32) esi + 4)
	{
		*esi = &eax_42->dwFFFFFFF4;
		eax_42->tFFFFFFF8 = dwArg08;
		eax_42->dwFFFFFFFC = ecx_41;
		eax_42->dwFFFFFFF4 = 0x00;
		eax_24 = 0x00;
		return eax_24;
	}
	else
	{
		word32 eax_62;
		_iob_func();
		fprintf(eax_62 + 0x40, 0x008DFCC4, 0x00);
		return 0x0F;
	}
}

// 00755320: Register int32 fn00755320(Stack Eq_3 dwArg04, Stack word32 dwArg08, Stack Eq_3 dwArg0C)
// Called from:
//      fn00755500
int32 fn00755320(Eq_3 dwArg04, word32 dwArg08, Eq_3 dwArg0C)
{
	struct Eq_147156 * eax_9 = *((word32) dwArg04 + 6004);
	Eq_147158 ebx_13 = eax_9->t0008;
	if (dwArg08 == 0x01)
	{
		struct Eq_147256 * esi_180 = eax_9->ptr000C;
		Eq_147158 ebp_157 = ebx_13;
		if (ebx_13 > 0x00)
		{
			do
			{
				if (esi_180->t0000 == 0x01)
				{
					struct Eq_176306 * ecx_34 = esi_180->dw0004;
					if (ecx_34 == null || ecx_34->b0000 != *dwArg0C)
						goto l00755395;
					Eq_3 edx_43 = dwArg0C;
					do
					{
						word32 ecx_62;
						cu8 bl_46 = ecx_34->b0000;
						if (bl_46 != *edx_43)
						{
l00755388:
							up32 ecx_59 = 0x00 - (bl_46 < *edx_43);
							ecx_62 = ecx_59 - ~0x00 - (ecx_59 < 0x00);
							goto l0075538D;
						}
						if (bl_46 == 0x00)
							break;
						byte bl_53 = ecx_34->b0001;
						if (bl_53 != *((word32) edx_43 + 1))
							goto l00755388;
						++ecx_34;
						edx_43 = (word32) edx_43 + 2;
					} while (bl_53 != 0x00);
					ecx_62 = 0x00;
l0075538D:
					if (ecx_62 != 0x00)
						goto l00755395;
					if ((*((word32) dwArg04 + 0x0000177C) & 0x8000) == 0x00)
					{
						byte dl_91 = *dwArg0C;
						if (dl_91 == 0x77)
						{
							Eq_3 esi_101 = dwArg0C;
							byte * edi_103 = g_str8DBB90;
							word32 ecx_100 = 0x05;
							bool v17_257 = true;
							while (ecx_100 != 0x00)
							{
								v17_257 = *esi_440 == *edi_441;
								esi_101 = (word32) esi_440 + 1;
								edi_103 = edi_441 + 1;
								--ecx_100;
								esi_440 = esi_101;
								edi_441 = edi_103;
								if (*esi_440 == *edi_441)
									break;
							}
							if (!v17_257)
								goto l007553CC;
							goto l007553F1;
						}
l007553CC:
						if (dl_91 == 0x61)
						{
							Eq_3 esi_122 = dwArg0C;
							byte * edi_123 = g_str8DBBE0;
							word32 ecx_124 = 0x03;
							bool v21_261 = true;
							while (ecx_124 != 0x00)
							{
								v21_261 = *esi_442 == *edi_443;
								esi_122 = (word32) esi_442 + 1;
								edi_123 = edi_443 + 1;
								--ecx_124;
								esi_442 = esi_122;
								edi_443 = edi_123;
								if (*esi_442 == *edi_443)
									break;
							}
							if (v21_261)
							{
l007553F1:
								break;
							}
						}
					}
					return ebx_13 - ebp_157;
				}
l00755395:
				--ebp_157;
				++esi_180;
			} while (ebp_157 > 0x00);
		}
	}
	struct Eq_147256 * edx_203 = eax_9->ptr000C;
	Eq_147158 ecx_204 = ebx_13;
	if (ebx_13 > 0x00)
	{
		do
		{
			if (edx_203->t0000 == dwArg08 && edx_203->dw0004 == 0x00)
				return ebx_13 - ecx_204;
			--ecx_204;
			++edx_203;
		} while (ecx_204 > 0x00);
	}
	return ~0x00;
}

// 00755430: void fn00755430(Stack Eq_3 dwArg04)
// Called from:
//      fn00755500
void fn00755430(Eq_3 dwArg04)
{
	struct Eq_176461 * eax_8 = *((word32) *((word32) *dwArg04 + 8) + 20);
	if (eax_8->dw0010 < 0x04)
		return;
	struct Eq_176476 * eax_11 = eax_8->ptr0014;
	byte * esi_15 = eax_11->ptr0004;
	if (esi_15 == null)
		return;
	byte * edi_22 = &g_b8DBBE4;
	word32 ecx_23 = 0x05;
	bool v18_184 = false;
	while (ecx_23 != 0x00)
	{
		v18_184 = *esi_362 != *edi_363;
		esi_15 = esi_362 + 1;
		edi_22 = edi_363 + 1;
		--ecx_23;
		esi_362 = esi_15;
		edi_363 = edi_22;
		if (*esi_362 == *edi_363)
			break;
	}
	if (v18_184)
		return;
	if (eax_11->dw0028 == 0x01)
	{
		byte * esi_45 = eax_11->ptr002C->ptr0004;
		if (esi_45 != null)
		{
			byte * edi_49 = &g_b8DA8F0;
			word32 ecx_50 = 11;
			bool v22_188 = false;
			while (ecx_50 != 0x00)
			{
				v22_188 = *esi_364 != *edi_365;
				esi_45 = esi_364 + 1;
				edi_49 = edi_365 + 1;
				--ecx_50;
				esi_364 = esi_45;
				edi_365 = edi_49;
				if (*esi_364 == *edi_365)
					break;
			}
			if (v22_188)
				return;
		}
	}
	word16 dx_72 = eax_11->w0048;
	struct Eq_176525 * ecx_74 = &eax_11->w0048;
	if (dx_72 == 0x10)
		return;
	if (dx_72 == 0x07)
		ecx_74 = (struct Eq_176525 *) (&eax_11->w0048 + 0x0C);
	int32 ebx_95 = ecx_74->dw0010;
	int32 edx_160 = 0x00;
	if (ebx_95 <= 0x00)
	{
l007554F0:
	}
	else
	{
		struct Eq_176581 * eax_100 = ecx_74->dw0014 + 0x14;
		do
		{
			if (eax_100->dwFFFFFFFC >= 0x01)
			{
				struct Eq_176592 * ecx_115 = eax_100->dw0000;
				if (ecx_115->w0000 == 0x01)
				{
					byte * esi_118 = ecx_115->ptr0004;
					byte * edi_119 = &g_b8DF8FC;
					word32 ecx_120 = 0x0F;
					bool v26_192 = true;
					while (ecx_120 != 0x00)
					{
						v26_192 = *esi_366 == *edi_367;
						esi_118 = esi_366 + 1;
						edi_119 = edi_367 + 1;
						--ecx_120;
						esi_366 = esi_118;
						edi_367 = edi_119;
						if (*esi_366 == *edi_367)
							break;
					}
					if (v26_192)
					{
						*((word32) dwArg04 + 0x0000177C) |= 0x8000;
						goto l007554F0;
					}
				}
			}
			edx_160 += 0x02;
			++eax_100;
		} while (edx_160 < ebx_95);
	}
}

// 00755500: Register int32 fn00755500(Stack Eq_3 dwArg04, Stack word32 dwArg08, Stack Eq_3 dwArg0C, Stack int32 dwArg10, Stack ptr32 dwArg14, Stack (ptr32 word32) dwArg18)
// Called from:
//      fn007406A0
int32 fn00755500(Eq_3 dwArg04, word32 dwArg08, Eq_3 dwArg0C, int32 dwArg10, ptr32 dwArg14, word32 * dwArg18)
{
	int32 eax_19 = fn00755320(dwArg04, dwArg08, dwArg0C);
	if (eax_19 < 0x00)
		return 0x0E;
	eax_128 = eax_19;
	do
	{
		int32 eax_172;
		int32 eax_128;
		struct Eq_176685 * ecx_43 = *dwArg04;
		struct Eq_176715 * esi_190 = ecx_43->ptr0004;
		struct Eq_176657 * ecx_48 = esi_190->ptr0010 + (ecx_43->ptr0000 * 0x18) / 20;
		int32 edx_49 = ecx_48->dw0008;
		if (edx_49 <= eax_128 && eax_128 < ecx_48->dw000C)
		{
			int32 ebx_58 = ecx_48->ptr0010[eax_128 - edx_49];
			ci8 bl_152 = (byte) ebx_58;
			if (ebx_58 == ~0x00)
				goto l007555A2;
			if (bl_152 < 0x00)
			{
				struct Eq_147235 * esi_271 = (ebx_58 >> 0x08) + 0x0100;
				eax_172 = fn007552A0(dwArg14, dwArg10, dwArg04, esi_271, fn00752E10(*((word32) dwArg04 + 6004), esi_271), ebx_58 & 0x7F);
				if (eax_172 <= 0x00)
				{
					eax_128 = eax_19;
					continue;
				}
				return eax_172;
			}
			eax_172 = fn0073B6B0(*((word32) *dwArg04 + 8), (word16) dwArg08, dwArg0C, dwArg10, dwArg14);
			if (eax_172 == 0x00)
				**dwArg04 = ebx_58;
			else if (eax_172 > 0x00)
				return eax_172;
			while (true)
			{
				ui32 eax_188 = **dwArg04;
				struct Eq_176721 * eax_191 = esi_190->ptr0010;
				word32 * eax_193 = eax_191 + (eax_188 * 0x18) / 20;
				if (eax_191->a0014[eax_188].dw0000 == 0x00 || *eax_193 != 0x01)
					break;
				byte * esi_211 = esi_190->ptr0004;
				if (*esi_211 == 0x69)
				{
					byte * edi_214 = &g_b8DC148;
					word32 ecx_215 = 0x0C;
					bool v25_330 = false;
					while (ecx_215 != 0x00)
					{
						v25_330 = *esi_519 != *edi_520;
						esi_211 = esi_519 + 1;
						edi_214 = edi_520 + 1;
						--ecx_215;
						esi_519 = esi_211;
						edi_520 = edi_214;
						if (*esi_519 == *edi_520)
							break;
					}
					if (!v25_330)
						fn00755430(dwArg04);
				}
				*dwArg04 = (word32) *dwArg04 + 0x0C;
				struct Eq_176685 * eax_251 = *dwArg04;
				if (eax_251 == (word32) dwArg04 + 6004)
					return 0x10;
				esi_190 = eax_251->ptr0004;
			}
			return 0x0A;
		}
l007555A2:
		if (ecx_48->dw0014 == 0x00)
		{
			if (dwArg18 != null)
			{
				int32 eax_71 = ecx_48->dw0008;
				if (eax_71 == ecx_48->dw000C - 0x01)
				{
					*dwArg18 = (word32) *((word32) *((word32) *((word32) dwArg04 + 6004) + 0x0C) + eax_71 * 0x08);
					return 0x0E;
				}
				*dwArg18 = ~0x00;
			}
			eax_172 = 0x0E;
			return eax_172;
		}
		byte * esi_104 = esi_190->ptr0004;
		if (*esi_104 == 0x69)
		{
			byte * edi_106 = &g_b8DC148;
			word32 ecx_103 = 0x0C;
			bool v21_326 = false;
			while (ecx_103 != 0x00)
			{
				v21_326 = *esi_517 != *edi_518;
				esi_104 = esi_517 + 1;
				edi_106 = edi_518 + 1;
				--ecx_103;
				esi_517 = esi_104;
				edi_518 = edi_106;
				if (*esi_517 == *edi_518)
					break;
			}
			if (!v21_326)
			{
				fn00755430(dwArg04);
				eax_128 = eax_19;
			}
		}
		*dwArg04 = (word32) *dwArg04 + 0x0C;
	} while (*dwArg04 != (word32) dwArg04 + 6004);
	return 0x0E;
}

// 007556D0: Register ui32 fn007556D0(Register Eq_3 edi, Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Register out Eq_3 ecxOut, Register out ptr32 edxOut)
// Called from:
//      fn00755780
ui32 fn007556D0(Eq_3 edi, Eq_3 dwArg04, Eq_3 dwArg08, union Eq_3 & ecxOut, ptr32 & edxOut)
{
	<anonymous> * eax_5 = g_ptrA6E54C;
	if (eax_5 != null)
		eax_5();
	*_errno() = 0x00;
	Eq_3 ecx_133 = dwArg04;
	if (fgets(dwArg04, dwArg08, edi) != 0x00)
	{
		ecxOut = dwArg04;
		edxOut = edx;
		return 0x00;
	}
	if (GetLastError() == 0x03E3)
	{
		Sleep(0x01);
		if (fn0072ED00() != 0x00)
			goto l00755724;
	}
	word32 eax_60;
	MSVCR80.dll!feof();
	if (eax_60 != 0x00)
	{
		ecxOut = ecx_133;
		edxOut = edx;
		return ~0x00;
	}
	if (*_errno() == 0x04)
	{
		fn00706C20(g_tA74AE4);
		word32 edi_191;
		word32 esi_190;
		word32 ebp_189;
		word32 ebx_188;
		Eq_3 eax_84 = fn0072EC10(out edx, out ebx_188, out ebp_189, out esi_190, out edi_191);
		ecx_133 = fn00706BE0();
		if (eax_84 < 0x00)
		{
l00755724:
			ecxOut = ecx_133;
			edxOut = edx;
			return 0x01;
		}
	}
	ui32 eax_107 = (0x00 - (fn0072ED00() == 0x00) & 0x03) + ~0x01;
	ecxOut = ecx_133;
	edxOut = edx;
	return eax_107;
}

// 00755780: Register Eq_3 fn00755780(Stack Eq_3 dwArg08, Register out ptr32 edxOut)
// Called from:
//      fn007558B0
Eq_3 fn00755780(Eq_3 dwArg08, ptr32 & edxOut)
{
	Eq_3 eax_9 = malloc(100);
	Eq_3 ebx_10 = eax_9;
	if (eax_9 != 0x00)
	{
		struct Eq_177006 * esp_25;
		word32 edx_27;
		word32 ecx_28;
		MSVCR80.dll!fflush();
		word32 eax_31 = esp_25->dw001C;
		if (eax_31 != 0x00)
		{
			esp_25->dw0000 = eax_31;
			esp_25->dwFFFFFFFC = 9080676;
			struct Eq_177059 * esp_41;
			word32 eax_42;
			word32 edx_43;
			word32 ecx_44;
			_iob_func();
			esp_41->tFFFFFFFC = eax_42 + 0x40;
			fprintf(esp_41->tFFFFFFFC, esp_41->t0000, 0x00);
		}
		struct Eq_177018 * esp_58;
		word32 eax_59;
		_iob_func();
		esp_58->dwFFFFFFFC = eax_59 + 0x40;
		struct Eq_177027 * esp_68;
		MSVCR80.dll!fflush();
		Eq_3 edi_74 = esp_68->t0014;
		esp_68->dwFFFFFFFC = 100;
		esp_68->tFFFFFFF8 = eax_9;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_3 stackArg4 = <invalid>;
		Eq_3 stackArg8 = <invalid>;
		ptr32 edx_81;
		word32 ecx_82;
		word32 eax_80 = fn007556D0(edi_74, stackArg4, stackArg8, out ecx_82, out edx_81);
		if (eax_80 != 0x00)
		{
			if (eax_80 == 0x01)
			{
				free(eax_9);
				edxOut = edx_81;
				return 0x00;
			}
			*eax_9 = 0x00;
		}
		Eq_3 eax_106 = eax_9;
		ptr32 edx_107 = (word32) eax_9 + 1;
		do
		{
			eax_106 = (word32) eax_382 + 1;
			eax_382 = eax_106;
		} while (*eax_382 != 0x00);
		int32 eax_116 = eax_106 - ((word32) eax_9 + 1);
		int32 ebp_126 = eax_116;
		if (eax_116 != 0x00)
		{
			while ((&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(ebx_10 - 0x01)[ebp_126].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] != 0x0A)
			{
				Eq_3 edi_133 = ebp_126 + 0x02;
				Eq_3 eax_134 = (word32) edi_133 + ebp_126;
				if (eax_134 == 0x00)
					eax_134.u0 = 0x01;
				Eq_3 eax_147 = realloc(ebx_10, eax_134);
				ebx_10 = eax_147;
				if (eax_147 == 0x00)
				{
					edxOut = edx_107;
					return 0x00;
				}
				if (edi_133 > 0x7FFFFFFF)
				{
					word32 edx_381;
					word32 ecx_380;
					fn006E0F80(g_tA18598, 9305316, out ecx_380, out edx_381);
				}
				Eq_3 esi_192 = (word32) eax_147 + ebp_126;
				word32 ecx_379;
				if (fn007556D0(dwArg04, esi_192, edi_133, out ecx_379, out edx_107) != 0x00)
					break;
				Eq_3 eax_206 = esi_192;
				edx_107 = (word32) esi_192 + 1;
				do
				{
					eax_206 = (word32) eax_383 + 1;
					eax_383 = eax_206;
				} while (*eax_383 != 0x00);
				ebp_126 += eax_206 - ((word32) esi_192 + 1);
				if (ebp_126 == 0x00)
					break;
			}
		}
		Eq_3 ebp_222 = ebp_126 + 0x01;
		if (ebp_222 == 0x00)
			ebp_222.u0 = 0x01;
		Eq_3 eax_238 = realloc(ebx_10, ebp_222);
		edxOut = edx_107;
		return eax_238;
	}
	else
	{
		edxOut = edx;
		return eax_9;
	}
}

// 007558B0: Register word32 fn007558B0(Stack Eq_3 dwArg04, Register out ptr32 edxOut)
// Called from:
//      fn00753C30
word32 fn007558B0(Eq_3 dwArg04, ptr32 & edxOut)
{
	Eq_3 eax_17 = g_tA74AE4;
	if (eax_17 == g_tA6D67C)
	{
		ptr32 edx_192;
		word32 ecx_260;
		fn006E0F80(g_tA175E0, 9305336, out ecx_260, out edx_192);
		edxOut = edx_192;
		return 0x00;
	}
	if (g_ptrA74AE8 == null)
		g_ptrA74AE8 = &g_t755780;
	if (g_tA6E548 == 0x00)
	{
		eax_17 = fn0074F6A0();
		g_tA6E548 = eax_17;
	}
	ptr32 edx_131;
	word32 eax_130;
	g_tA74AE4 = g_tA6D67C;
	fn00706BE0();
	word32 ecx_62;
	fn0074F540(g_tA6E548, 0x01, out ecx_62);
	struct Eq_177214 * esp_73;
	word32 ecx_74;
	word32 eax_75;
	fileno();
	esp_73->dwFFFFFFFC = eax_75;
	struct Eq_177222 * esp_82;
	word32 ecx_83;
	word32 eax_84;
	isatty();
	word32 ebp_88 = esp_82->dw002C;
	struct Eq_177231 * esp_109 = &esp_82->dw000C + 1;
	if (eax_84 != 0x00)
	{
		esp_82->dw000C = ebp_88;
		struct Eq_177262 * esp_95;
		word32 ecx_96;
		word32 eax_97;
		fileno();
		esp_95->dwFFFFFFFC = eax_97;
		struct Eq_177269 * esp_103;
		word32 eax_105;
		isatty();
		esp_109 = (struct Eq_177231 *) (&esp_103->dw0004 + 1);
		if (eax_105 != 0x00)
		{
			word32 ecx_134 = esp_103->dw0028;
			esp_103->dw0004 = ecx_134;
			esp_103->dw0000 = ebp_88;
			esp_103->tFFFFFFFC = dwArg04;
			g_ptrA74AE8();
l0075596B:
			fn00706C20(eax_17);
			fn0074F570(g_tA6E548);
			g_tA74AE4.u0 = 0x00;
			edxOut = edx_131;
			return eax_130;
		}
	}
	struct Eq_177240 * esp_116 = esp_109 - 4;
	esp_116->dw0000 = esp_109->dw0020;
	esp_116->dwFFFFFFFC = ebp_88;
	esp_116->tFFFFFFF8 = dwArg04;
	eax_130 = fn00755780(dwArg04, out edx_131);
	goto l0075596B;
}

