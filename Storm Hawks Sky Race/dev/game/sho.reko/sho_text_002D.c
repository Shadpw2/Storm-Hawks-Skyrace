// sho_text_002D.c
// Generated by decompiling sho.exe
// using Reko decompiler version 0.10.0.0.

#include "sho.h"

// 006D5670: Register word32 fn006D5670(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Register out Eq_3 ecxOut, Register out (ptr32 Eq_51340) edxOut)
// Called from:
//      fn00656570
//      fn006DDEB0
//      fn006DDF70
//      fn006DE0F0
//      fn006DE330
//      fn006DE430
//      fn006DFE20
//      fn006DFE60
//      fn006E0FD0
//      fn006E1780
//      fn006E1BD0
//      fn006E5710
//      fn006E5960
//      fn006E5AD0
//      fn006E5C60
//      fn006E7660
//      fn006E7D90
//      fn006E8060
//      fn006E8D90
//      fn006E9FA0
//      fn006EA420
//      fn006EA9D0
//      fn006EC440
//      fn006EC4F0
//      fn006EC890
//      fn006ECC00
//      fn006ECC50
//      fn006F1AA0
//      fn006F2750
//      fn006F2790
//      fn006F2A10
//      fn006F31C0
//      fn006F34B0
//      fn006F3930
//      fn006F4F00
//      fn006F5DD0
//      fn006F62D0
//      fn006F63A0
//      fn006F6EA0
//      fn006F7100
//      fn006F7890
//      fn006F8C70
//      fn006F9120
//      fn006FBCC0
//      fn006FBD90
//      fn006FBE60
//      fn006FBF30
//      fn006FC050
//      fn006FC0E0
//      fn006FCC90
//      fn006FCF20
//      fn006FDE60
//      fn006FE400
//      fn006FF3E0
//      fn00701B50
//      fn00701D30
//      fn00702AF0
//      fn00703780
//      fn00703B60
//      fn00703BF0
//      fn00703D00
//      fn00703F10
//      fn00704BA0
//      fn007051A0
//      fn007052C0
//      fn00705340
//      fn00707020
//      fn00707680
//      fn00707BD0
//      fn00707D70
//      fn00707E00
//      fn00707F70
//      fn00708210
//      fn00708C10
//      fn00708DC0
//      fn0070B600
//      fn0070BCC0
//      fn0070C700
//      fn007108F0
//      fn007109D0
//      fn00710B80
//      fn007114E0
//      fn00711700
//      fn00715DF0
//      fn00717230
//      fn00717280
//      fn007173A0
//      fn00717900
//      fn00717CB0
//      fn00718B50
//      fn00719F20
//      fn0071A550
//      fn0071A7D0
//      fn0071AAE0
//      fn0071FB20
//      fn0071FEB0
//      fn00720070
//      fn007203E0
//      fn00721290
//      fn00725010
//      fn00725150
//      fn007251F0
//      fn00726150
//      fn007276E0
//      fn0072F830
//      fn0072FBB0
//      fn0072FC60
//      fn0072FC90
//      fn00731A20
//      fn00731B10
//      fn00731D30
//      fn00731F90
//      fn00733250
//      fn00733290
//      fn007332C0
//      fn00734BB0
//      fn00735890
//      fn007389B0
//      fn0073AFB0
//      fn0073B3D0
//      fn0073B4E0
//      fn0073D660
//      fn0074E280
//      fn0074EB10
//      fn0074ED80
//      fn0074EE90
//      fn00753A60
word32 fn006D5670(Eq_3 dwArg04, Eq_3 dwArg08, union Eq_3 & ecxOut, struct Eq_51340 & edxOut)
{
	Eq_3 eax_16 = dwArg04;
	if ((*((word32) dwArg04 + 84) & 0x0100) != 0x00)
	{
		Eq_3 ecx_36 = *((word32) dwArg04 + 0x00AC);
		if (ecx_36 == 0x00)
		{
			do
			{
				if (eax_16 == dwArg08)
					goto l006D5690;
				eax_16 = *((word32) eax_16 + 0x0080);
				word24 eax_24_8_82 = SLICE(eax_16, word24, 8);
			} while (eax_16 != 0x00);
			ecxOut = dwArg08;
			edxOut = edx;
			return SEQ(eax_24_8_82, (int8) (dwArg08 == 10572952));
		}
		else
		{
			struct Eq_51340 * edx_28 = *((word32) ecx_36 + 8);
			struct Eq_51340 * eax_29 = null;
			if (edx_28 > null)
			{
				ecx_36 = (word32) ecx_36 + 0x0C;
				do
				{
					if (*ecx_36 == dwArg08)
					{
						ecxOut = ecx_36;
						edxOut = edx_28;
						return 0x01;
					}
					eax_29 = (struct Eq_51340 *) ((const char *) eax_29 + 1);
					ecx_36 = (word32) ecx_36 + 4;
				} while (eax_29 < edx_28);
			}
			ecxOut = ecx_36;
			edxOut = edx_28;
			return 0x00;
		}
	}
	else if (dwArg08 == dwArg04 || dwArg08 == 10572952)
	{
l006D5690:
		ecxOut = dwArg08;
		edxOut = edx;
		return 0x01;
	}
	else
	{
		ecxOut = dwArg08;
		edxOut = edx;
		return 0x00;
	}
}

// 006D6060: Register Eq_3 fn006D6060(Stack Eq_3 dwArg04)
// Called from:
//      fn006D9ED0
Eq_3 fn006D6060(Eq_3 dwArg04)
{
	Eq_3 eax_6 = *((word32) dwArg04 + 0x00AC);
	if (eax_6 == 0x00)
		return eax_6;
	Eq_3 eax_52;
	Eq_3 ebx_13 = *((word32) eax_6 + 8);
	Eq_3 esi_20 = 0x00;
	if (ebx_13 > 0x00)
	{
		word32 * edi_27 = (word32) eax_6 + 0x0C;
		do
		{
			Eq_3 eax_33;
			struct Eq_53307 * eax_30 = *edi_27;
			if (eax_30->dw0004 == 10611048)
				eax_33 = eax_30->t000C;
			else
				eax_33 = eax_30->t0084;
			word32 ecx_133;
			word32 edx_134;
			eax_52 = fn006FBCC0(eax_33, dwArg04, out ecx_133, out edx_134);
			if (eax_52 != 0x00)
				return eax_52;
			esi_20 = (word32) esi_20 + 1;
			++edi_27;
		} while (esi_20 < ebx_13);
	}
	eax_52.u0 = 0x00;
	return eax_52;
}

// 006D9ED0: Register (ptr32 Eq_53341) fn006D9ED0(Register (ptr32 Eq_53342) ecx, Register (ptr32 Eq_3) edi)
// Called from:
//      fn006DC1B0
struct Eq_53341 * fn006D9ED0(struct Eq_53342 * ecx, union Eq_3 * edi)
{
	struct Eq_53341 * esi_105;
	ptr32 esp_22;
	if (*edi == 0x00)
	{
		word32 ecx_149;
		word32 edx_150;
		Eq_3 eax_18 = fn006F1A70(out ecx_149, out edx_150);
		*edi = (union Eq_3 *) eax_18;
		esp_22 = fp - 0x04;
		if (eax_18 == 0x00)
		{
			esi_105 = null;
			goto l006D9F21;
		}
	}
	struct Eq_53341 * eax_41 = fn006D6060(ecx->t0004);
	esp_22 = fp - 0x04;
	if (eax_41 != null)
	{
		<anonymous> * ecx_50 = eax_41->ptr0004->ptr0088;
		if (ecx_50 == null)
			++eax_41->dw0000;
		else
		{
			Eq_3 edx_54 = ecx->t0004;
			word32 esp_61;
			ecx_50();
			esp_22 = esp_61 + 0x0C;
		}
	}
	esi_105 = eax_41;
	if (eax_41 != null)
		return esi_105;
l006D9F21:
	if (fn006E0FC0() == 0x00)
	{
		Eq_3 ecx_89 = g_tA178F0;
		struct Eq_53414 * esp_92 = esp_22 - 4;
		esp_92->t0000 = *edi;
		esp_92->tFFFFFFFC = ecx_89;
		word32 ecx_151;
		word32 edx_152;
		fn006E0E90(esp_92->tFFFFFFFC, esp_92->t0000, out ecx_151, out edx_152);
	}
	return esi_105;
}

// 006DC1B0: Register uint32 fn006DC1B0(Stack Eq_3 dwArg04)
// Called from:
//      fn006DC290
uint32 fn006DC1B0(Eq_3 dwArg04)
{
	Eq_3 eax_16 = fn006D9ED0(ecx, &g_tA6C30C);
	if (eax_16 != 0x00)
	{
		Eq_3 esi_57;
		word32 esi_316;
		word32 edx_315;
		word32 ecx_314;
		Eq_3 eax_31 = fn006DFF80(0x01, out ecx_314, out edx_315, out esi_316);
		struct Eq_53469 * esp_106 = fp - 0x0C;
		if (eax_31 == 0x00)
			esi_57.u0 = 0x00;
		else
		{
			word32 edx_320;
			word32 ecx_319;
			Eq_3 eax_48 = fn00703710(eax_16, eax_31, 0x00, out ecx_319, out edx_320);
			word32 v11_54 = (word32) *eax_31 - 1;
			*eax_31 = v11_54;
			esp_106 = fp - 0x0C;
			esi_57 = eax_48;
			if (v11_54 == 0x00)
			{
				struct Eq_53521 * ecx_59 = *((word32) eax_31 + 4);
				word32 esp_63;
				ecx_59->ptr0018();
				esp_106 = esp_63 + 0x04;
			}
		}
		word32 v14_76 = (word32) *eax_16 - 1;
		*eax_16 = v14_76;
		if (v14_76 == 0x00)
		{
			struct Eq_53533 * eax_80 = *((word32) eax_16 + 4);
			<anonymous> * ecx_81 = eax_80->ptr0018;
			esp_106->tFFFFFFFC = eax_16;
			word32 esp_88;
			ecx_81();
			esp_106 = esp_88 + 0x04;
		}
		if (esi_57 == 0x00A16480)
		{
			word32 v16_100 = (word32) *esi_57.u0 - 1;
			*esi_57.u0 = v16_100;
			if (v16_100 == 0x00)
			{
				struct Eq_53592 * ecx_104 = *((word64) esi_57.u0 + 4);
				<anonymous> * edx_105 = ecx_104->ptr0018;
				esp_106->tFFFFFFFC = esi_57;
				edx_105();
			}
			return 0x02;
		}
		else
		{
			if (esi_57 == 0x00)
				return ~0x01;
			union Eq_3 * esp_132 = esp_106 - 4;
			*esp_132 = (union Eq_3 *) esi_57;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg4 = <invalid>;
			word32 edi_325;
			word32 ecx_322;
			word32 edx_323;
			word32 esi_324;
			Eq_3 eax_135 = fn007051A0(eax_31, stackArg4, out ecx_322, out edx_323, out esi_324, out edi_325);
			word32 v15_141 = (word32) *esi_57.u0 - 1;
			*esi_57.u0 = v15_141;
			if (v15_141 == 0x00)
			{
				struct Eq_53592 * edx_146 = *((word64) esi_57.u0 + 4);
				<anonymous> * eax_147 = edx_146->ptr0018;
				*esp_132 = (union Eq_3 *) esi_57;
				eax_147();
			}
			if (eax_135 != ~0x00)
			{
				if (eax_135 >= 0x00)
					return (uint32) (int8) (eax_135 > 0x00);
				return ~0x00;
			}
			else
			{
				if (fn006E0FC0() == 0x00)
					return ~0x00;
				return ~0x01;
			}
		}
	}
	else
	{
		word32 edx_318;
		word32 ecx_317;
		fn006E1160(out ecx_317, out edx_318);
		return 0x02;
	}
}

// 006DC290: Register int32 fn006DC290(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Register out Eq_540 edxOut)
// Called from:
//      fn006DF230
int32 fn006DC290(Eq_3 dwArg04, Eq_3 dwArg08, union Eq_540 & edxOut)
{
	int32 eax_19;
	if (*((word32) *((word32) dwArg04 + 4) + 40) == 7193232)
	{
		eax_19 = fn006DC1B0(dwArg08);
		if (eax_19 <= 0x01)
			goto l006DC2ED;
	}
	int32 eax_38;
	if (*((word32) *((word32) dwArg08 + 4) + 40) == 7193232)
	{
		eax_38 = fn006DC1B0(dwArg04);
		if (eax_38 < ~0x00)
		{
			edxOut.u0 = <invalid>;
			return ~0x01;
		}
		if (eax_38 <= 0x01)
		{
l006DC2EB:
			eax_19 = -eax_38;
l006DC2ED:
			edxOut.u0 = <invalid>;
			return eax_19;
		}
	}
	if (dwArg08 > dwArg04)
	{
		edxOut.u0 = <invalid>;
		return ~0x00;
	}
	eax_38 = 0x00 - (dwArg08 < dwArg04);
	goto l006DC2EB;
}

// 006DDD30: Register Eq_3 fn006DDD30(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Register out Eq_540 edxOut)
// Called from:
//      fn0072E920
//      fn00734BB0
//      fn007514B0
Eq_3 fn006DDD30(Eq_3 dwArg04, Eq_3 dwArg08, union Eq_540 & edxOut)
{
	if (dwArg04 != 0x00)
	{
		*((word32) dwArg04 + 4) = dwArg08;
		*dwArg04 = 0x01;
		edxOut.u0 = <invalid>;
		return dwArg04;
	}
	else
	{
		word32 ecx_36;
		word32 edx_37;
		Eq_3 eax_13 = fn006E1210(out ecx_36, out edx_37);
		edxOut.u0 = <invalid>;
		return eax_13;
	}
}

// 006DDD50: Register Eq_3 fn006DDD50(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Stack Eq_3 dwArg0C, Register out Eq_3 ecxOut, Register out Eq_3 edxOut)
// Called from:
//      fn007105C0
//      fn00710690
//      fn00710CB0
//      fn00711280
//      fn00711330
//      fn00711400
//      fn00711F50
//      fn007120F0
Eq_3 fn006DDD50(Eq_3 dwArg04, Eq_3 dwArg08, Eq_3 dwArg0C, union Eq_3 & ecxOut, union Eq_3 & edxOut)
{
	if (dwArg04 != 0x00)
	{
		*((word32) dwArg04 + 8) = dwArg0C;
		*((word32) dwArg04 + 4) = dwArg08;
		*dwArg04 = 0x01;
		ecxOut = dwArg0C;
		edxOut = dwArg08;
		return dwArg04;
	}
	else
	{
		Eq_3 ecx_16;
		Eq_3 edx_17;
		Eq_3 eax_15 = fn006E1210(out ecx_16, out edx_17);
		ecxOut = ecx_16;
		edxOut = edx_17;
		return eax_15;
	}
}

// 006DDD80: Register Eq_3 fn006DDD80(Stack (ptr32 Eq_53715) dwArg04, Register out ptr32 ecxOut, Register out ptr32 edxOut)
// Called from:
//      fn00717740
//      fn0072F1E0
//      fn0072F230
//      fn00747330
Eq_3 fn006DDD80(struct Eq_53715 * dwArg04, ptr32 & ecxOut, ptr32 & edxOut)
{
	ptr32 ecx_12;
	ptr32 edx_13;
	Eq_3 eax_11 = fn00723860(dwArg04->t0010, out ecx_12, out edx_13);
	if (eax_11 != 0x00)
	{
		*((word32) eax_11 + 4) = dwArg04;
		*eax_11 = 0x01;
		ecxOut = ecx_12;
		edxOut = edx_13;
		return eax_11;
	}
	else
	{
		ptr32 ecx_31;
		ptr32 edx_32;
		Eq_3 eax_29 = fn006E1210(out ecx_31, out edx_32);
		ecxOut = ecx_31;
		edxOut = edx_32;
		return eax_29;
	}
}

// 006DDDB0: Register Eq_3 fn006DDDB0(Register Eq_3 eax, Register Eq_3 edx, Register Eq_3 ebx, Register Eq_3 esi, Register Eq_3 edi, Register (ptr16 Eq_7) es, Register (ptr16 Eq_8) ds, Stack Eq_3 dwArg04, Register out Eq_3 edxOut, Register out Eq_540 ediOut)
// Called from:
//      fn006DDEB0
//      fn006DEEA0
//      fn00708DC0
//      fn007120F0
//      fn00726760
//      fn00727910
//      fn00729040
//      fn00731B10
Eq_3 fn006DDDB0(Eq_3 eax, Eq_3 edx, Eq_3 ebx, Eq_3 esi, Eq_3 edi, struct Eq_7 * es, struct Eq_8 * ds, Eq_3 dwArg04, union Eq_3 & edxOut, union Eq_540 & ediOut)
{
	word32 edi_339;
	word32 edx_335;
	word32 ebx_336;
	word32 ebp_337;
	word32 esi_338;
	fn0072EC10(out edx_335, out ebx_336, out ebp_337, out esi_338, out edi_339);
	if (eax != 0x00)
	{
l006DDDD5:
		edxOut = edx;
		ediOut.u0 = <invalid>;
		return 0x00;
	}
	Eq_3 eax_18 = fn006E8800(edx, ebx, esi, edi, es, ds);
	if (eax_18 != 0x00)
	{
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_3 stackArg4 = <invalid>;
		Eq_3 stackArg8 = <invalid>;
		word32 ecx_342;
		word32 edx_343;
		fn006E0F80(stackArg4, stackArg8, out ecx_342, out edx_343);
		goto l006DDDD5;
	}
	if (dwArg04 == 0x00)
	{
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_3 stackArg4 = <invalid>;
		word32 ecx_345;
		word32 edx_346;
		fn006ECAC0(stackArg4, out ecx_345, out edx_346);
		edxOut = edx;
		ediOut.u0 = <invalid>;
		return eax_18;
	}
	Eq_3 edx_34 = *((word32) dwArg04 + 4);
	Eq_3 eax_35 = *((word32) edx_34 + 44);
	if (eax_35 == 0x00)
	{
		fn006F2070();
		edxOut = edx_34;
		ediOut.u0 = <invalid>;
		return eax_35;
	}
	Eq_3 eax_44;
	word32 ecx_45;
	Eq_3 edx_104;
	eax_35();
	Eq_3 esi_113 = eax_44;
	if (eax_44 == 0x00)
	{
		edxOut = edx_104;
		ediOut.u0 = <invalid>;
		return eax_44;
	}
	Eq_3 eax_54 = *((word32) eax_44 + 4);
	if (eax_54 != 0x00A23B20)
	{
		word32 ecx_347;
		eax_54 = fn006D5670(eax_54, 0x00A23B20, out ecx_347, out edx_104);
		if (eax_54 == 0x00)
			goto l006DDE5C;
	}
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_3 stackArg4 = <invalid>;
	Eq_3 stackArg8 = <invalid>;
	Eq_3 stackArg12 = <invalid>;
	word32 ecx_351;
	word32 edx_352;
	fn0071FB20(stackArg4, stackArg8, stackArg12, out ecx_351, out edx_352);
	word32 v12_83 = (word32) *eax_44 - 1;
	*eax_44 = v12_83;
	if (v12_83 == 0x00)
	{
		Eq_3 edx_89 = *((word32) eax_44 + 4);
		<anonymous> * eax_90 = *((word32) edx_89 + 24);
		word32 ecx_103;
		eax_90();
	}
	if (eax_54 == 0x00)
	{
l006DDEA3:
		edxOut = edx_104;
		ediOut.u0 = <invalid>;
		return 0x00;
	}
	esi_113 = eax_54;
l006DDE5C:
	Eq_3 eax_117 = *((word32) esi_113 + 4);
	if (eax_117 != 0x00A1B450)
	{
		word32 ecx_353;
		if (fn006D5670(eax_117, 0x00A1B450, out ecx_353, out edx_104) == 0x00)
		{
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			edx_104 = *((word32) *((word32) esi_113 + 4) + 0x0C);
			Eq_3 eax_147 = g_tA16B7C;
			Eq_3 stackArg4 = <invalid>;
			Eq_3 stackArg8 = <invalid>;
			word32 ecx_356;
			word32 edx_357;
			fn006E15D0(stackArg4, stackArg8, out ecx_356, out edx_357);
			word32 v13_155 = (word32) *esi_113 - 1;
			*esi_113 = v13_155;
			if (v13_155 == 0x00)
			{
				Eq_3 ecx_159 = *((word32) esi_113 + 4);
				<anonymous> * edx_160 = *((word32) ecx_159 + 24);
				edx_160();
			}
			goto l006DDEA3;
		}
	}
	edxOut = edx_104;
	ediOut.u0 = <invalid>;
	return esi_113;
}

// 006DDEB0: Register Eq_3 fn006DDEB0(Register Eq_3 edx, Register Eq_3 ebx, Register Eq_3 esi, Register Eq_3 edi, Register (ptr16 Eq_7) es, Register (ptr16 Eq_8) ds, Stack Eq_3 dwArg04, Register out Eq_3 edxOut)
// Called from:
//      fn006DDF70
Eq_3 fn006DDEB0(Eq_3 edx, Eq_3 ebx, Eq_3 esi, Eq_3 edi, struct Eq_7 * es, struct Eq_8 * ds, Eq_3 dwArg04, union Eq_3 & edxOut)
{
	if (dwArg04 == 0x00)
	{
		Eq_3 edx_144;
		word32 ecx_241;
		Eq_3 eax_142 = fn006ECAC0(9247428, out ecx_241, out edx_144);
		edxOut = edx_144;
		return eax_142;
	}
	struct Eq_53944 * ecx_9 = *((word32) dwArg04 + 4);
	if (ecx_9 == &g_tA1B450 || ecx_9 == &g_tA23B20)
	{
		*dwArg04 = (word32) *dwArg04 + 1;
		edxOut = edx;
		return dwArg04;
	}
	<anonymous> * ecx_14 = ecx_9->ptr0044;
	if (ecx_14 == null)
	{
		Eq_3 edx_128;
		word32 edi_245;
		Eq_3 eax_125 = fn006DDDB0(dwArg04, edx, ebx, esi, edi, es, ds, dwArg04, out edx_128, out edi_245);
		edxOut = edx_128;
		return eax_125;
	}
	Eq_3 eax_24;
	Eq_3 edx_103;
	ecx_14();
	if (eax_24 == 0x00)
	{
l006DDF5D:
		edxOut = edx_103;
		return 0x00;
	}
	else
	{
		Eq_3 eax_34 = *((word32) eax_24 + 4);
		if (eax_34 != 0x00A1B450)
		{
			word32 ecx_242;
			if (fn006D5670(eax_34, 0x00A1B450, out ecx_242, out edx_103) == 0x00)
			{
				Eq_3 eax_52 = *((word32) eax_24 + 4);
				if (eax_52 != 0x00A23B20)
				{
					word32 ecx_243;
					if (fn006D5670(eax_52, 0x00A23B20, out ecx_243, out edx_103) == 0x00)
					{
						word32 ecx_244;
						fn006E15D0(g_tA16B7C, dwArg04, out ecx_244, out edx_103);
						word32 v12_92 = (word32) *eax_24 - 1;
						*eax_24 = v12_92;
						if (v12_92 == 0x00)
						{
							Eq_3 eax_96 = *((word32) eax_24 + 4);
							(*((word32) eax_96 + 24))();
						}
						goto l006DDF5D;
					}
				}
			}
		}
		edxOut = edx_103;
		return eax_24;
	}
}

// 006DDF70: Register Eq_3 fn006DDF70(Stack Eq_3 dwArg04, Register out ptr32 edxOut, Register out Eq_540 ediOut)
// Called from:
//      fn00657140
//      fn006DEEA0
//      fn006E1DE0
//      fn006E8060
//      fn006E8430
//      fn00731B10
Eq_3 fn006DDF70(Eq_3 dwArg04, ptr32 & edxOut, union Eq_540 & ediOut)
{
	ptr32 edx_14;
	Eq_3 eax_12 = fn006DDEB0(edx, ebx, esi, edi, es, ds, dwArg04, out edx_14);
	Eq_3 esi_17 = eax_12;
	if (eax_12 == 0x00)
	{
		edxOut = edx_14;
		ediOut.u0 = <invalid>;
		return eax_12;
	}
	ptr32 edx_113;
	Eq_3 eax_22 = *((word32) eax_12 + 4);
	if (eax_22 != 0x00A23B20)
	{
		word32 ecx_160;
		if (fn006D5670(eax_22, 0x00A23B20, out ecx_160, out edx_113) == 0x00)
			goto l006DDFC9;
	}
	word32 ecx_159;
	Eq_3 eax_54 = fn0071FB20(eax_12, dwArg04, 0x00, out ecx_159, out edx_113);
	word32 v10_60 = (word32) *eax_12 - 1;
	*eax_12 = v10_60;
	if (v10_60 == 0x00)
	{
		Eq_3 ecx_65 = *((word32) eax_12 + 4);
		(*((word32) ecx_65 + 24))();
	}
	if (eax_54 == 0x00)
	{
		edxOut = edx_113;
		ediOut.u0 = <invalid>;
		return 0x00;
	}
	esi_17 = eax_54;
l006DDFC9:
	edxOut = edx_113;
	ediOut.u0 = <invalid>;
	return esi_17;
}

// 006DDFE0: Register Eq_54099 fn006DDFE0(Register Eq_54099 esi, Register out ptr32 edxOut)
// Called from:
//      fn006DF230
//      fn006DF4C0
Eq_54099 fn006DDFE0(Eq_54099 esi, ptr32 & edxOut)
{
	if (fn006E0FC0() != 0x00)
	{
		if (esi != ~0x00 && esi != ~0x01)
		{
			fn006E1130(fp - 0x04, fp - 0x08, fp - 0x0C);
			struct Eq_54123 * esp_118 = fp - 0x0C;
			if (fn006E1970(g_tA18D40, 9247532, 0x01, out edx) < 0x00)
			{
				if (dwLoc04 != null)
				{
					dwLoc04->dw0000 += ~0x00;
					if (dwLoc04->dw0000 == 0x00)
					{
						struct Eq_54168 * ecx_108 = dwLoc04->ptr0004;
						word32 esp_112;
						ecx_108->ptr0018();
						esp_118 = esp_112 + 0x04;
					}
				}
				struct Eq_54149 * eax_122 = esp_118->ptr0004;
				if (eax_122 != null)
				{
					eax_122->dw0000 += ~0x00;
					struct Eq_54149 * eax_128 = esp_118->ptr0004;
					if (eax_128->dw0000 == 0x00)
					{
						struct Eq_54210 * ecx_131 = eax_128->ptr0004;
						<anonymous> * edx_132 = ecx_131->ptr0018;
						esp_118->ptrFFFFFFFC = eax_128;
						word32 esp_137;
						edx_132();
						esp_118 = esp_137 + 0x04;
					}
				}
				struct Eq_54149 * eax_147 = esp_118->ptr0000;
				if (eax_147 != null)
				{
					eax_147->dw0000 += ~0x00;
					struct Eq_54149 * eax_153 = esp_118->ptr0000;
					if (eax_153->dw0000 == 0x00)
					{
						struct Eq_54210 * ecx_160 = eax_153->ptr0004;
						<anonymous> * edx_161 = ecx_160->ptr0018;
						esp_118->ptrFFFFFFFC = eax_153;
						ptr32 edx_169;
						edx_161();
						edxOut = edx_169;
						return ~0x01;
					}
				}
			}
			else
			{
				word32 ecx_241;
				fn006E0E00(dwLoc0C, out ecx_241, out edx);
			}
		}
	}
	else
	{
		if (esi <= 0x01)
		{
			edxOut = edx;
			return esi;
		}
		if (fn006E1970(g_tA18D40, 0x008D1B08, 0x01, out edx) >= 0x00)
		{
			edxOut = edx;
			uint32 eax_37 = (uint32) (int8) (esi >= ~0x00);
			return eax_37 - 0x01 + eax_37;
		}
	}
	edxOut = edx;
	return ~0x01;
}

// 006DE0F0: Register (ptr32 Eq_54262) fn006DE0F0(Register Eq_3 esi, Register Eq_3 edi, Stack Eq_3 dwArg04, Register out ptr32 edxOut)
// Called from:
//      fn006DF460
struct Eq_54262 * fn006DE0F0(Eq_3 esi, Eq_3 edi, Eq_3 dwArg04, ptr32 & edxOut)
{
	struct Eq_54262 * eax_129;
	Eq_3 eax_6 = *((word32) edi + 4);
	Eq_3 ecx_8 = *((word32) esi + 4);
	ptr32 esp_10 = fp - 4;
	if (eax_6 != ecx_8)
	{
		esp_10 = fp - 0x04;
		word32 ecx_216;
		if (fn006D5670(ecx_8, eax_6, out ecx_216, out edx) != 0x00)
		{
			Eq_3 eax_30 = *((word32) esi + 4);
			if ((*((word32) eax_30 + 84) & 0x20) != 0x00)
			{
				<anonymous> * eax_34 = *((word32) eax_30 + 100);
				if (eax_34 != null)
				{
					word32 ecx_38 = g_aA162C8[dwArg04 * 0x04];
					struct Eq_54324 * esp_45;
					eax_34();
					esp_10 = (const char *) &esp_45->ptr0008 + 4;
					if (eax_129 != &g_dwA16480)
						goto l006DE1A1;
					word32 v12_54 = eax_129->dw0000 + ~0x00;
					eax_129->dw0000 = v12_54;
					if (v12_54 == 0x00)
					{
						struct Eq_54340 * edx_58 = eax_129->ptr0004;
						esp_45->ptr0008 = eax_129;
						word32 esp_62;
						edx_58->ptr0018();
						esp_10 = esp_62 + 0x04;
					}
				}
			}
		}
	}
	Eq_3 eax_72 = *((word32) edi + 4);
	if ((*((word32) eax_72 + 84) & 0x20) != 0x00)
	{
		<anonymous> * eax_76 = *((word32) eax_72 + 100);
		if (eax_76 != null)
		{
			struct Eq_54370 * esp_81 = esp_10 - 4;
			esp_81->t0000 = dwArg04;
			esp_81->tFFFFFFFC = esi;
			esp_81->tFFFFFFF8 = edi;
			struct Eq_54382 * esp_90;
			eax_76();
			esp_10 = (const char *) &esp_90->ptr0008 + 4;
			if (eax_129 != &g_dwA16480)
				goto l006DE1A1;
			word32 v14_99 = eax_129->dw0000 + ~0x00;
			eax_129->dw0000 = v14_99;
			if (v14_99 == 0x00)
			{
				struct Eq_54340 * ecx_103 = eax_129->ptr0004;
				<anonymous> * edx_104 = ecx_103->ptr0018;
				esp_90->ptr0008 = eax_129;
				word32 esp_107;
				edx_104();
				esp_10 = esp_107 + 0x04;
			}
		}
	}
	Eq_3 eax_117 = *((word32) esi + 4);
	if ((*((word32) eax_117 + 84) & 0x20) != 0x00)
	{
		<anonymous> * eax_121 = *((word32) eax_117 + 100);
		if (eax_121 != null)
		{
			word32 ecx_137 = g_aA162C8[dwArg04 * 0x04];
			struct Eq_54430 * esp_138 = esp_10 - 4;
			esp_138->dw0000 = ecx_137;
			esp_138->tFFFFFFFC = edi;
			esp_138->tFFFFFFF8 = esi;
			struct Eq_54262 * eax_147;
			ptr32 edx_149;
			eax_121();
			edxOut = edx_149;
			return eax_147;
		}
	}
	++g_dwA16480;
	eax_129 = (struct Eq_54262 *) &g_dwA16480;
l006DE1A1:
	edxOut = edx;
	return eax_129;
}

// 006DE1B0: Register Eq_54444 fn006DE1B0(Register Eq_3 ebx, Register Eq_3 edi, Register out ptr32 edxOut)
// Called from:
//      fn006DF460
Eq_54444 fn006DE1B0(Eq_3 ebx, Eq_3 edi, ptr32 & edxOut)
{
	word24 edx_24_8_143 = SLICE(edx, word24, 8);
	if (*((word32) edi + 4) != *((word32) ebx + 4))
	{
		if (edi == 0x00A163B8)
			goto l006DE1C9;
		if (ebx != 0x00A163B8)
		{
			struct Eq_54465 * esi_29;
			if (fn00701B20(edi) != 0x00)
				esi_29 = (struct Eq_54465 *) g_str8A698F;
			else
				esi_29 = (struct Eq_54465 *) *((word32) *((word32) edi + 4) + 0x0C);
			struct Eq_54465 * ecx_119;
			if (fn00701B20(ebx) != 0x00)
				ecx_119 = (struct Eq_54465 *) g_str8A698F;
			else
			{
				struct Eq_54453 * edx_44 = *((word32) ebx + 4);
				edx_24_8_143 = SLICE(edx_44, word24, 8);
				ecx_119 = edx_44->ptr000C;
			}
			struct Eq_54465 * eax_49 = esi_29;
			do
			{
				int32 eax_72;
				cu8 dl_56 = eax_49->b0000;
				edx = SEQ(edx_24_8_143, dl_56);
				if (dl_56 != ecx_119->b0000)
				{
l006DE233:
					up32 eax_69 = 0x00 - (dl_56 < ecx_119->b0000);
					eax_72 = eax_69 - ~0x00 - (eax_69 < 0x00);
					goto l006DE238;
				}
				edx = SEQ(edx_24_8_143, dl_56);
				if (dl_56 == 0x00)
					break;
				byte dl_63 = eax_49->b0001;
				edx = SEQ(edx_24_8_143, dl_63);
				if (dl_63 != ecx_119->b0001)
					goto l006DE233;
				++eax_49;
				++ecx_119;
				edx = SEQ(edx_24_8_143, dl_63);
			} while (dl_63 != 0x00);
			eax_72 = 0x00;
l006DE238:
			if (eax_72 < 0x00)
			{
l006DE1C9:
				edxOut = edx;
				return ~0x00;
			}
			if (eax_72 <= 0x00)
			{
				Eq_54444 eax_105 = (0x00 - (*((word32) edi + 4) < *((word32) ebx + 4)) & ~0x01) + 0x01;
				edxOut = edx;
				return eax_105;
			}
		}
		edxOut = edx;
		return 0x01;
	}
	else
	{
		if (ebx <= edi)
		{
			edxOut = edx;
			return ebx < edi;
		}
		goto l006DE1C9;
	}
}

// 006DE250: Register (ptr32 word32) fn006DE250(Register (ptr32 word32) eax, Register Eq_3 ecx)
// Called from:
//      fn006DF460
//      fn006DF4C0
word32 * fn006DE250(word32 * eax, Eq_3 ecx)
{
	if (ecx <= 0x05)
	{
		word32 * edx_37;
		switch (ecx)
		{
		case 0x00:
			eax = (uint32) (int8) (eax < null);
			break;
		case 0x01:
			edx_37 = (uint32) (int8) (eax <= null);
			goto l006DE296;
		case 0x02:
			eax = (uint32) (int8) (eax == null);
			break;
		case 0x03:
			edx_37 = (uint32) (int8) (eax != null);
			goto l006DE296;
		case 0x04:
			eax = (uint32) (int8) (eax > null);
			break;
		case 0x05:
			edx_37 = (uint32) (int8) (eax >= null);
l006DE296:
			eax = edx_37;
			break;
		}
	}
	word32 * eax_56 = &g_dwA191E4;
	if (eax == null)
		eax_56 = &g_dwA191D8;
	++*eax_56;
	return eax_56;
}

// 006DE2E0: Register Eq_3 fn006DE2E0(Stack Eq_3 dwArg04, Register out (ptr32 Eq_54599) ecxOut, Register out (ptr32 code) edxOut)
// Called from:
//      fn006FBCC0
//      fn006FBD90
//      fn006FBE60
//      fn00738130
Eq_3 fn006DE2E0(Eq_3 dwArg04, struct Eq_54599 & ecxOut, <anonymous> & edxOut)
{
	struct Eq_54599 * ecx_32 = *((word32) dwArg04 + 4);
	Eq_3 eax_37 = dwArg04;
	<anonymous> * edx_33 = ecx_32->ptr003C;
	if (edx_33 == null)
	{
		if (ecx_32->dw0028 != 0x00 || (ecx_32->b0054 & 0x20) != 0x00 && ecx_32->dw0064 != 0x00)
		{
			fn006E15D0(g_tA16B7C, 9246324, out ecx_32, out edx_33);
			eax_37.u0 = ~0x00;
		}
		ecxOut = ecx_32;
		edxOut = edx_33;
		return eax_37;
	}
	else
	{
		Eq_3 eax_42;
		struct Eq_54599 * ecx_43;
		<anonymous> * edx_44;
		edx_33();
		ecxOut = ecx_43;
		edxOut = edx_44;
		return eax_42;
	}
}

// 006DE330: Register word32 fn006DE330(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Register out ptr32 ecxOut, Register out ptr32 edxOut)
// Called from:
//      fn006DE3F0
//      fn006DF760
//      fn006F9120
//      fn00703B60
//      fn00703D00
//      fn007081C0
//      fn00708210
//      fn00708DC0
word32 fn006DE330(Eq_3 dwArg04, Eq_3 dwArg08, ptr32 & ecxOut, ptr32 & edxOut)
{
	ptr32 edx_100;
	ptr32 ecx_190;
	Eq_3 eax_12 = *((word32) dwArg08 + 4);
	struct Eq_54651 * edi_17 = *((word32) dwArg04 + 4);
	if (eax_12 != 0x00A1B450)
	{
		word32 edx_239;
		word32 ecx_238;
		if (fn006D5670(eax_12, 0x00A1B450, out ecx_238, out edx_239) == 0x00)
		{
			Eq_3 eax_34 = *((word32) dwArg08 + 4);
			if (eax_34 != 0x00A23B20)
			{
				word32 edx_241;
				word32 ecx_240;
				if (fn006D5670(eax_34, 0x00A23B20, out ecx_240, out edx_241) == 0x00)
				{
					ptr32 ecx_151;
					ptr32 edx_152;
					fn006E15D0(g_tA16B7C, 0x008D1B88, out ecx_151, out edx_152);
					ecxOut = ecx_151;
					edxOut = edx_152;
					return 0x00;
				}
			}
			if (fn0071FC50(dwArg08, 0x00, out ecx_190, out edx_100) == 0x00)
				goto l006DE3DD;
		}
	}
	<anonymous> * eax_122 = edi_17->ptr0048;
	if (eax_122 != null)
	{
l006DE3B0:
		word32 eax_127;
		ptr32 ecx_128;
		ptr32 edx_129;
		eax_122();
		ecxOut = ecx_128;
		edxOut = edx_129;
		return eax_127;
	}
	eax_122 = edi_17->ptr0020;
	if (eax_122 != null)
		goto l006DE3B0;
	fn006E15D0(g_tA178F0, dwArg04, out ecx_190, out edx_100);
l006DE3DD:
	ecxOut = ecx_190;
	edxOut = edx_100;
	return 0x00;
}

// 006DE3F0: Register word32 fn006DE3F0(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08)
// Called from:
//      fn006F8C70
word32 fn006DE3F0(Eq_3 dwArg04, Eq_3 dwArg08)
{
	word32 ecx_83;
	word32 edx_84;
	Eq_3 eax_12 = fn006DE330(dwArg04, dwArg08, out ecx_83, out edx_84);
	if (eax_12 == 0x00)
	{
		word32 ecx_85;
		word32 edx_86;
		fn006E1160(out ecx_85, out edx_86);
		return 0x00;
	}
	else
	{
		word32 v9_31 = (word32) *eax_12 - 1;
		*eax_12 = v9_31;
		if (v9_31 == 0x00)
		{
			struct Eq_54756 * edx_35 = *((word32) eax_12 + 4);
			edx_35->ptr0018();
		}
		return 0x01;
	}
}

// 006DE430: Register word32 fn006DE430(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Stack Eq_3 dwArg0C, Register out ptr32 ecxOut, Register out ptr32 edxOut)
// Called from:
//      fn006DF800
//      fn00708DC0
word32 fn006DE430(Eq_3 dwArg04, Eq_3 dwArg08, Eq_3 dwArg0C, ptr32 & ecxOut, ptr32 & edxOut)
{
	struct Eq_54769 * esi_14 = *((word32) dwArg04 + 4);
	if (*((word32) dwArg08 + 4) != 0x00A1B450)
	{
		word32 ecx_411;
		word32 edx_412;
		if (fn006D5670(*((word32) dwArg08 + 4), 0x00A1B450, out ecx_411, out edx_412) == 0x00)
		{
			if (*((word32) dwArg08 + 4) != 0x00A23B20)
			{
				word32 ecx_413;
				word32 edx_414;
				if (fn006D5670(*((word32) dwArg08 + 4), 0x00A23B20, out ecx_413, out edx_414) == 0x00)
				{
					ptr32 ecx_288;
					ptr32 edx_289;
					fn006E15D0(g_tA16B7C, 0x008D1B88, out ecx_288, out edx_289);
					ecxOut = ecx_288;
					edxOut = edx_289;
					return ~0x00;
				}
			}
			ptr32 ecx_70;
			ptr32 edx_71;
			if (fn0071FB20(dwArg08, 0x00, 0x00, out ecx_70, out edx_71) == 0x00)
			{
				ecxOut = ecx_70;
				edxOut = edx_71;
				return ~0x00;
			}
l006DE4C4:
			word32 edx_415;
			fn006EC890(fp + 0x08, out edx_415);
			<anonymous> * eax_101 = esi_14->ptr004C;
			struct Eq_54870 * esp_122 = fp - 0x08;
			if (eax_101 == null)
			{
				eax_101 = esi_14->ptr0024;
				if (eax_101 == null)
				{
					*dwArg08 = (word32) *dwArg08 - 1;
					Eq_3 eax_108 = dwArg08;
					if (*dwArg08 == 0x00)
					{
						Eq_3 ecx_111 = *((word32) dwArg08 + 4);
						struct Eq_54919 * esp_115;
						(*((word32) ecx_111 + 24))();
						eax_108 = esp_115->t0014;
						esp_122 = (struct Eq_54870 *) ((const char *) esp_115 + 4);
					}
					if (esi_14->dw0020 != 0x00 || esi_14->dw0048 != 0x00)
					{
						word32 ecx_134 = 9247788;
						if (esp_122->dw0014 != 0x00)
							ecx_134 = 9247776;
						word32 edx_140 = esi_14->dw000C;
						struct Eq_54988 * esp_147 = esp_122 - 4;
						esp_147->ptr0000 = (word32) eax_108 + 20;
						Eq_3 eax_149 = g_tA16B7C;
						esp_147->dwFFFFFFFC = ecx_134;
						esp_147->dwFFFFFFF8 = edx_140;
						esp_147->dwFFFFFFF4 = 0x008D1BB4;
						esp_147->tFFFFFFF0 = eax_149;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_3 stackArg4 = <invalid>;
						ptr32 ecx_167;
						ptr32 edx_168;
						fn006E15D0(stackArg4, dwArg04, out ecx_167, out edx_168);
						ecxOut = ecx_167;
						edxOut = edx_168;
						return ~0x00;
					}
					else
					{
						word32 ecx_180 = 9247788;
						if (esp_122->dw0014 != 0x00)
							ecx_180 = 9247776;
						struct Eq_54947 * esp_187 = esp_122 - 4;
						esp_187->ptr0000 = (word32) eax_108 + 20;
						word32 eax_190 = esi_14->dw000C;
						esp_187->dwFFFFFFFC = ecx_180;
						Eq_3 ecx_194 = g_tA16B7C;
						esp_187->dwFFFFFFF8 = eax_190;
						esp_187->dwFFFFFFF4 = 9247728;
						esp_187->tFFFFFFF0 = ecx_194;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_3 stackArg4 = <invalid>;
						ptr32 ecx_205;
						ptr32 edx_206;
						fn006E15D0(stackArg4, dwArg04, out ecx_205, out edx_206);
						ecxOut = ecx_205;
						edxOut = edx_206;
						return ~0x00;
					}
				}
			}
			struct Eq_54853 * esp_235;
			word32 eax_236;
			ptr32 ecx_237;
			ptr32 edx_238;
			eax_101();
			struct Eq_54845 * eax_242 = esp_235->ptr001C;
			eax_242->dw0000 += ~0x00;
			struct Eq_54845 * eax_245 = esp_235->ptr001C;
			if (eax_245->dw0000 == 0x00)
			{
				struct Eq_54844 * ecx_249 = eax_245->ptr0004;
				<anonymous> * edx_250 = ecx_249->ptr0018;
				esp_235->ptr0008 = eax_245;
				edx_250();
			}
			ecxOut = ecx_237;
			edxOut = edx_238;
			return eax_236;
		}
	}
	*dwArg08 = (word32) *dwArg08 + 1;
	goto l006DE4C4;
}

// 006DEA90: Register int32 fn006DEA90(Stack Eq_3 dwArg04, Register out (ptr32 (ptr32 code)) ecxOut, Register out Eq_3 edxOut)
// Called from:
//      fn006DF5A0
//      fn006F8EC0
//      fn00708DC0
//      fn00726760
//      fn00726930
//      fn007282B0
int32 fn006DEA90(Eq_3 dwArg04, <anonymous> & ecxOut, union Eq_3 & edxOut)
{
	int32 eax_52;
	Eq_3 edx_5 = dwArg04;
	if (dwArg04 == 0x00A191E4)
	{
l006DEAEB:
		eax_52 = 0x01;
		goto l006DEAF0;
	}
	if (dwArg04 == 0x00A191D8 || dwArg04 == 0x00A163B8)
	{
		ecxOut = ecx;
		edxOut = dwArg04;
		return 0x00;
	}
	<anonymous> * ecx_17;
	struct Eq_55037 * eax_12 = *((word32) dwArg04 + 4);
	struct Eq_55041 * ecx_13 = eax_12->ptr0030;
	if (ecx_13 != null)
	{
		ecx_17 = ecx_13->ptr0028;
		if (ecx_17 != null)
			goto l006DEAE1;
	}
	ecx = eax_12->ptr0038;
	if (ecx != null && *ecx != null)
	{
		(*ecx)();
l006DEAE4:
		if (eax_52 <= 0x00)
		{
l006DEAF0:
			ecxOut = ecx;
			edxOut = edx_5;
			return eax_52;
		}
		goto l006DEAEB;
	}
	<anonymous> ** eax_31 = eax_12->ptr0034;
	if (eax_31 == null || *eax_31 == null)
		goto l006DEAEB;
	ecx_17 = (<anonymous> *) *eax_31;
l006DEAE1:
	ecx_17();
	goto l006DEAE4;
}

// 006DEB20: Register int32 fn006DEB20(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08)
// Called from:
//      fn006DEB90
//      fn006DF230
//      fn00701B50
int32 fn006DEB20(Eq_3 dwArg04, Eq_3 dwArg08)
{
	struct Eq_55084 * eax_16 = *dwArg04;
	struct Eq_55088 * esi_11 = *dwArg08;
	ptr32 esp_12 = fp - 0x0C;
	struct Eq_55096 * ecx_17 = eax_16->ptr0004;
	if (ecx_17 != esi_11->ptr0004 || (ecx_17->b0054 & 0x10) != 0x00)
	{
		int32 eax_116;
		struct Eq_55105 * ecx_25 = ecx_17->ptr0030;
		if (ecx_25 != null)
		{
			<anonymous> * eax_29 = ecx_25->ptr0044;
			if (eax_29 != null)
			{
				word32 esp_42;
				eax_29();
				esp_12 = esp_42 + 0x08;
				if (eax_116 <= 0x00)
					return eax_116;
			}
		}
		struct Eq_55105 * eax_53 = esi_11->ptr0004->ptr0030;
		if (eax_53 != null)
		{
			<anonymous> * eax_57 = eax_53->ptr0044;
			if (eax_57 != null)
			{
				struct Eq_55162 * esp_62 = esp_12 - 4;
				esp_62->t0000 = dwArg04;
				esp_62->tFFFFFFFC = dwArg08;
				eax_57();
				if (eax_116 <= 0x00)
					return eax_116;
			}
		}
		eax_116 = 0x01;
		return eax_116;
	}
	else
	{
		++eax_16->dw0000;
		++esi_11->dw0000;
		return 0x00;
	}
}

// 006DEB90: Register int32 fn006DEB90(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08)
// Called from:
//      fn00701D30
int32 fn006DEB90(Eq_3 dwArg04, Eq_3 dwArg08)
{
	int32 eax_11 = fn006DEB20(dwArg04, dwArg08);
	if (eax_11 > 0x00)
	{
		word32 ecx_59;
		word32 edx_60;
		fn006E0F80(g_tA16B7C, 0x008D1C8C, out ecx_59, out edx_60);
		eax_11 = ~0x00;
	}
	return eax_11;
}

// 006DECD0: Register (ptr32 void) fn006DECD0(Stack Eq_3 dwArg04)
// Called from:
//      fn00726840
//      fn00726930
//      fn00748670
void * fn006DECD0(Eq_3 dwArg04)
{
	Eq_3 eax_10 = dwArg04;
	if (dwArg04 == 0x00)
		eax_10.u0 = 0x01;
	return malloc(eax_10);
}

// 006DEEA0: Register word32 fn006DEEA0(Register Eq_3 esi, Register Eq_3 edi, Register (ptr16 Eq_7) es, Register (ptr16 Eq_8) ds, Stack Eq_3 dwArg08, Stack Eq_3 dwArg10, Register out Eq_3 edxOut)
// Called from:
//      fn006DEEA0
//      fn006DEFC0
word32 fn006DEEA0(Eq_3 esi, Eq_3 edi, struct Eq_7 * es, struct Eq_8 * ds, Eq_3 dwArg08, Eq_3 dwArg10, union Eq_3 & edxOut)
{
	Eq_3 edx_17;
	word32 ebx_11 = 0x00;
	if (dwArg10 > 0x0A)
	{
		word32 ecx_432;
		fn006E0F80(g_tA175E0, 0x008D1DAC, out ecx_432, out edx_17);
l006DEEC0:
		edxOut = edx_17;
		return ~0x00;
	}
	word32 ebp_429;
	word32 edi_431;
	word32 esi_430;
	word32 ebx_428;
	if (fn0072EC10(out edx_17, out ebx_428, out ebp_429, out esi_430, out edi_431) != 0x00)
		goto l006DEEC0;
	if (fn006E8800(edx_17, 0x00, esi, edi, es, ds) != 0x00)
	{
		Eq_3 edx_261;
		word32 ecx_433;
		fn006E0F80(g_tA188A8, 0x008D1ACC, out ecx_433, out edx_261);
		edxOut = edx_261;
		return ~0x00;
	}
	Eq_3 edx_103;
	struct Eq_55243 * esp_139;
	struct Eq_55244 * esp_49;
	MSVCR80.dll!clearerr();
	Eq_3 edi_121 = dwArg08;
	Eq_3 eax_55 = esp_49->t0018;
	if (eax_55 == 0x00)
	{
		esp_49->t0000.u0 = 0x008D1DA4;
		esp_49->tFFFFFFFC = dwArg08;
		fprintf(esp_49->tFFFFFFFC, esp_49->t0000, 0x00);
		esp_139 = (struct Eq_55243 *) ((const char *) &esp_49->t0000 + 4);
	}
	else
	{
		Eq_3 ecx_60 = *eax_55;
		if (ecx_60 <= 0x00)
		{
			esp_49->t0000 = eax_55;
			esp_49->tFFFFFFFC = ecx_60;
			esp_49->tFFFFFFF8.u0 = 9248144;
			esp_49->tFFFFFFF4 = dwArg08;
			fprintf(esp_49->tFFFFFFF4, esp_49->tFFFFFFF8, 0x00);
			esp_139 = (struct Eq_55243 *) ((const char *) &esp_49->t0000 + 4);
		}
		else
		{
			Eq_3 edx_63 = *((word32) eax_55 + 4);
			<anonymous> * ecx_64 = *((word32) edx_63 + 28);
			if (ecx_64 == null)
			{
				struct Eq_55244 * esp_100;
				Eq_3 eax_101;
				esp_49->t0000 = eax_55;
				if ((esp_49->t0020 & 0x01) != 0x00)
				{
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_3 stackArg4 = <invalid>;
					word32 edi_435;
					eax_101 = fn006DDF70(stackArg4, out edx_103, out edi_435);
					esp_100 = esp_49;
				}
				else
				{
					eax_101 = fn006DDDB0(eax_55, edx_63, 0x00, esi, dwArg08, es, ds, esp_49->t0000, out edx_103, out edi_121);
					esp_100 = (struct Eq_55244 *) ((const char *) &esp_49->t0000 + 4);
				}
				struct Eq_55243 * esp_109 = (const char *) &esp_100->t0000 + 4;
				if (eax_101 == 0x00)
					goto l006DEFB5;
				esp_109->tFFFFFFFC = (word32) dwArg10 + 1;
				esp_109->dwFFFFFFF8 = 0x01;
				esp_109->tFFFFFFF4 = edi_121;
				esp_109->tFFFFFFF0 = eax_101;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_3 stackArg8 = <invalid>;
				Eq_3 stackArg16 = <invalid>;
				word32 eax_134 = fn006DEEA0(eax_101, edi_121, es, ds, stackArg8, stackArg16, out edx_103);
				word32 v14_140 = (word32) *eax_101 - 1;
				*eax_101 = v14_140;
				esp_139 = esp_109;
				ebx_11 = eax_134;
				if (v14_140 == 0x00)
				{
					struct Eq_55430 * eax_145 = *((word32) eax_101 + 4);
					<anonymous> * ecx_146 = eax_145->ptr0018;
					esp_109->tFFFFFFFC = eax_101;
					word32 esp_149;
					ecx_146();
					esp_139 = esp_149 + 0x04;
				}
			}
			else
			{
				Eq_3 edx_68 = esp_49->t0020;
				esp_49->t0000 = edx_68;
				esp_49->tFFFFFFFC = dwArg08;
				esp_49->tFFFFFFF8 = eax_55;
				word32 esp_75;
				word32 eax_76;
				ecx_64();
				esp_139 = esp_75 + 0x0C;
				ebx_11 = eax_76;
			}
			if (ebx_11 != 0x00)
			{
l006DEFB8:
				edxOut = edx_103;
				return ebx_11;
			}
		}
	}
	esp_139->tFFFFFFFC = edi_121;
	struct Eq_55291 * esp_204;
	word32 eax_205;
	MSVCR80.dll!ferror();
	if (eax_205 == 0x00)
		goto l006DEFB8;
	esp_204->dw0000 = g_dwA17258;
	fn006E13F0();
	esp_204->tFFFFFFFC = edi_121;
	MSVCR80.dll!clearerr();
l006DEFB5:
	ebx_11 = ~0x00;
	goto l006DEFB8;
}

// 006DEFC0: Register word32 fn006DEFC0(Register out ptr32 edxOut)
// Called from:
//      fn006E8D90
//      fn00731B10
word32 fn006DEFC0(ptr32 & edxOut)
{
	ptr32 edx_19;
	word32 eax_17 = fn006DEEA0(esi, edi, es, ds, dwArg08, 0x00, out edx_19);
	edxOut = edx_19;
	return eax_17;
}

// 006DF230: Register (ptr32 word32) fn006DF230(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Register out Eq_3 edxOut)
// Called from:
//      fn006DF460
word32 * fn006DF230(Eq_3 dwArg04, Eq_3 dwArg08, union Eq_3 & edxOut)
{
	<anonymous> * ecx_8 = *((word32) *((word32) dwArg04 + 4) + 40);
	if (*((word32) dwArg04 + 4) != &g_tA1EB98)
	{
		if (*((word32) dwArg08 + 4) != &g_tA1EB98)
		{
			if (ecx_8 == null || ecx_8 != *((word32) (*((word32) dwArg08 + 4)) + 40))
			{
				if (ecx_8 == &g_t6DC290 || *((word32) (*((word32) dwArg08 + 4)) + 40) == &g_t6DC290)
				{
					Eq_3 edx_45;
					word32 * eax_47 = fn006DC290(dwArg04, dwArg08, out edx_45);
					edxOut = edx_45;
					return eax_47;
				}
				else
				{
					Eq_3 edx_117 = fp + 0x08;
					int32 eax_60 = fn006DEB20(fp + 0x04, fp + 0x08);
					struct Eq_55531 * esp_100 = fp - 0x04;
					if (eax_60 >= 0x00)
					{
						if (eax_60 <= 0x00)
						{
							<anonymous> * ecx_72 = *((word32) *((word32) dwArg04 + 4) + 40);
							if (ecx_72 != null)
							{
								edx_117 = dwArg08;
								if (ecx_72 == *((word32) (*((word32) dwArg08 + 4)) + 40))
								{
									struct Eq_55570 * esp_133;
									Eq_54099 eax_136;
									ecx_72();
									struct Eq_55572 * eax_140 = esp_133->ptr0010;
									eax_140->dw0000 += ~0x00;
									struct Eq_55572 * eax_143 = esp_133->ptr0010;
									struct Eq_55588 * esp_144 = (const char *) &esp_133->ptr0004 + 4;
									if (eax_143->dw0000 == 0x00)
									{
										struct Eq_55617 * edx_147 = eax_143->ptr0004;
										esp_133->ptr0004 = eax_143;
										word32 esp_151;
										edx_147->ptr0018();
										esp_144 = esp_151 + 0x04;
									}
									struct Eq_55596 * eax_161 = esp_144->ptr000C;
									eax_161->dw0000 += ~0x00;
									struct Eq_55596 * eax_164 = esp_144->ptr000C;
									if (eax_164->dw0000 == 0x00)
									{
										struct Eq_55635 * ecx_167 = eax_164->ptr0004;
										<anonymous> * edx_168 = ecx_167->ptr0018;
										esp_144->ptrFFFFFFFC = eax_164;
										edx_168();
									}
									Eq_3 edx_185;
									word32 * eax_187 = fn006DDFE0(eax_136, out edx_185);
									edxOut = edx_185;
									return eax_187;
								}
							}
							*dwArg04 = (word32) *dwArg04 - 1;
							if (*dwArg04 == 0x00)
							{
								struct Eq_55464 * ecx_88 = *((word32) dwArg04 + 4);
								word32 esp_94;
								ecx_88->ptr0018();
								esp_100 = esp_94 + 0x04;
							}
							struct Eq_55646 * eax_104 = esp_100->ptr000C;
							eax_104->dw0000 += ~0x00;
							struct Eq_55646 * eax_107 = esp_100->ptr000C;
							if (eax_107->dw0000 == 0x00)
							{
								struct Eq_55677 * ecx_110 = eax_107->ptr0004;
								<anonymous> * edx_111 = ecx_110->ptr0018;
								esp_100->ptrFFFFFFFC = eax_107;
								edx_111();
							}
						}
						edxOut = edx_117;
						return (word32 *) 0x02;
					}
					else
					{
						edxOut = fp + 0x08;
						return (word32 *) ~0x01;
					}
				}
			}
			else
			{
				Eq_54099 eax_203;
				ecx_8();
				Eq_3 edx_210;
				word32 * eax_212 = fn006DDFE0(eax_203, out edx_210);
				edxOut = edx_210;
				return eax_212;
			}
		}
		else
		{
			struct Eq_55475 * ecx_217 = *((word32) dwArg08 + 4);
			Eq_3 edx_224;
			word32 * eax_226;
			ecx_217->ptr0028();
			edxOut = edx_224;
			return eax_226;
		}
	}
	else
	{
		Eq_3 edx_238;
		word32 * eax_240;
		ecx_8();
		edxOut = edx_238;
		return eax_240;
	}
}

// 006DF460: Register Eq_3 fn006DF460(Register Eq_3 eax, Register Eq_3 ecx, Stack Eq_3 dwArg04, Register out ptr32 edxOut)
// Called from:
//      fn006DF4C0
Eq_3 fn006DF460(Eq_3 eax, Eq_3 ecx, Eq_3 dwArg04, ptr32 & edxOut)
{
	ptr32 edx_130;
	Eq_3 eax_120 = fn006DE0F0(eax, ecx, dwArg04, out edx_130);
	ptr32 esp_27 = fp - 0x0C;
	if (eax_120 == 0x00A16480)
	{
		word32 v10_30 = (word32) *eax_120 - 1;
		*eax_120 = v10_30;
		if (v10_30 == 0x00)
		{
			struct Eq_55732 * ecx_34 = *((word32) eax_120 + 4);
			word32 esp_38;
			ecx_34->ptr0018();
			esp_27 = esp_38 + 0x04;
		}
		struct Eq_55715 * esp_47 = esp_27 - 4;
		esp_47->t0000 = eax;
		esp_47->tFFFFFFFC = ecx;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_3 stackArg4 = <invalid>;
		word32 * eax_58 = fn006DF230(stackArg4, dwArg04, out edx_130);
		if (eax_58 >= (word32 *) 0x02)
			eax_58 = fn006DE1B0(eax, ecx, out edx_130);
		if (eax_58 > (word32 *) ~0x01)
		{
			Eq_3 eax_93 = fn006DE250(eax_58, dwArg04);
			edxOut = edx_130;
			return eax_93;
		}
		eax_120.u0 = 0x00;
	}
	edxOut = edx_130;
	return eax_120;
}

// 006DF4C0: Register Eq_3 fn006DF4C0(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Stack Eq_3 dwArg0C, Register out ptr32 edxOut)
// Called from:
//      fn006DF5A0
//      fn00708130
Eq_3 fn006DF4C0(Eq_3 dwArg04, Eq_3 dwArg08, Eq_3 dwArg0C, ptr32 & edxOut)
{
	Eq_3 eax_5 = g_tA6D67C;
	*((word32) eax_5 + 0x0C) = (word32) *((word32) eax_5 + 0x0C) + 1;
	Eq_3 eax_8 = g_tA1E8AC;
	Eq_3 ecx_9 = g_tA6D67C;
	g_tA1E8AC = eax_8 - 0x01;
	if (*((word32) ecx_9 + 0x0C) > eax_8 - 0x01)
	{
		ptr32 edx_19;
		if (fn00706DC0(edx, ebx, edi, es, ds, out edx_19) != 0x00)
		{
			edxOut = edx_19;
			return 0x00;
		}
	}
	ptr32 edx_109;
	Eq_3 eax_107;
	struct Eq_55786 * eax_37 = *((word32) dwArg04 + 4);
	struct Eq_55790 * esp_38 = fp - 0x0C;
	if (eax_37 == *((word32) dwArg08 + 4) && eax_37 != &g_tA1EB98)
	{
		if ((eax_37->b0054 & 0x20) != 0x00)
		{
			<anonymous> * eax_50 = eax_37->ptr0064;
			if (eax_50 != null)
			{
				struct Eq_55849 * esp_61;
				eax_50();
				esp_38 = (struct Eq_55790 *) ((const char *) &esp_61->t0008 + 4);
				if (eax_107 != 0x00A16480)
				{
l006DF58F:
					Eq_3 ecx_115 = g_tA6D67C;
					*((word32) ecx_115 + 0x0C) = (word32) *((word32) ecx_115 + 0x0C) - 1;
					edxOut = edx_109;
					return eax_107;
				}
				word32 v13_70 = (word32) *eax_107 - 1;
				*eax_107 = v13_70;
				if (v13_70 == 0x00)
				{
					struct Eq_55876 * edx_74 = *((word32) eax_107 + 4);
					esp_61->t0008 = eax_107;
					word32 esp_78;
					edx_74->ptr0018();
					esp_38 = esp_78 + 0x04;
				}
			}
		}
		<anonymous> * eax_89 = *((word32) *((word32) dwArg04 + 4) + 40);
		if (eax_89 != null)
		{
			struct Eq_55889 * esp_126 = esp_38 - 4;
			esp_126->t0000 = dwArg08;
			esp_126->tFFFFFFFC = dwArg04;
			Eq_54099 eax_131;
			eax_89();
			ptr32 edx_142;
			word32 * eax_140 = fn006DDFE0(eax_131, out edx_142);
			if (eax_140 != (word32 *) ~0x01)
			{
				Eq_3 eax_148 = fn006DE250(eax_140, dwArg0C);
				Eq_3 ecx_154 = g_tA6D67C;
				*((word32) ecx_154 + 0x0C) = (word32) *((word32) ecx_154 + 0x0C) - 1;
				edxOut = edx_142;
				return eax_148;
			}
			else
			{
				Eq_3 ecx_164 = g_tA6D67C;
				*((word32) ecx_164 + 0x0C) = (word32) *((word32) ecx_164 + 0x0C) - 1;
				edxOut = edx_142;
				return 0x00;
			}
		}
	}
	esp_38->tFFFFFFFC = dwArg0C;
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_3 stackArg4 = <invalid>;
	eax_107 = fn006DF460(dwArg08, dwArg04, stackArg4, out edx_109);
	goto l006DF58F;
}

// 006DF5A0: Register Eq_55932 fn006DF5A0(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Stack Eq_3 dwArg0C, Register out Eq_3 edxOut)
// Called from:
//      fn00704E40
//      fn0070B600
Eq_55932 fn006DF5A0(Eq_3 dwArg04, Eq_3 dwArg08, Eq_3 dwArg0C, union Eq_3 & edxOut)
{
	if (dwArg04 == dwArg08)
	{
		if (dwArg0C == 0x02)
		{
			edxOut = dwArg0C;
			return 0x01;
		}
		if (dwArg0C == 0x03)
		{
			edxOut = dwArg0C;
			return 0x00;
		}
	}
	Eq_3 edx_126;
	Eq_3 eax_30 = fn006DF4C0(dwArg04, dwArg08, dwArg0C, out edx_126);
	if (eax_30 != 0x00)
	{
		Eq_55932 eax_48;
		if (*((word32) eax_30 + 4) == &g_tA19118)
			eax_48.u1 = (uint32) (int8) (eax_30 == 0x00A191E4);
		else
		{
			word32 ecx_162;
			eax_48 = fn006DEA90(eax_30, out ecx_162, out edx_126);
		}
		word32 v13_63 = (word32) *eax_30 - 1;
		*eax_30 = v13_63;
		if (v13_63 == 0x00)
		{
			struct Eq_55954 * ecx_71 = *((word32) eax_30 + 4);
			ecx_71->ptr0018();
		}
		edxOut = edx_126;
		return eax_48;
	}
	else
	{
		edxOut = edx_126;
		return ~0x00;
	}
}

// 006DF760: Register Eq_3 fn006DF760(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Register out ptr32 edxOut, Register out Eq_540 ediOut)
// Called from:
//      fn0042DF20
//      fn006DF7C0
//      fn006DF870
//      fn006E1780
//      fn006E7D90
//      fn006E8060
//      fn006E8D90
//      fn006F8440
//      fn006F8C70
//      fn007038E0
//      fn00708210
//      fn00708C10
//      fn00718F10
//      fn00731A20
//      fn00731B10
Eq_3 fn006DF760(Eq_3 dwArg04, Eq_3 dwArg08, ptr32 & edxOut, union Eq_540 & ediOut)
{
	<anonymous> * eax_9 = *((word32) *((word32) dwArg04 + 4) + 32);
	if (eax_9 == null)
	{
		ptr32 edx_22;
		word32 ecx_137;
		Eq_3 eax_20 = fn006F1A70(out ecx_137, out edx_22);
		if (eax_20 != 0x00)
		{
			word32 ecx_138;
			ptr32 edx_102;
			Eq_3 eax_35 = fn006DE330(dwArg04, dwArg04, out ecx_138, out edx_102);
			word32 v12_41 = (word32) *eax_20 - 1;
			*eax_20 = v12_41;
			if (v12_41 == 0x00)
			{
				struct Eq_56026 * eax_46 = *((word32) eax_20 + 4);
				eax_46->ptr0018();
			}
			edxOut = edx_102;
			ediOut.u0 = <invalid>;
			return eax_35;
		}
		else
		{
			edxOut = edx_22;
			ediOut.u0 = <invalid>;
			return eax_20;
		}
	}
	else
	{
		Eq_3 eax_76;
		ptr32 edx_78;
		eax_9();
		edxOut = edx_78;
		ediOut.u0 = <invalid>;
		return eax_76;
	}
}

// 006DF7C0: Register word32 fn006DF7C0(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Register out ptr32 edxOut)
// Called from:
//      fn006E1DE0
//      fn006E8060
//      fn006F8C70
//      fn00703640
//      fn00704700
word32 fn006DF7C0(Eq_3 dwArg04, Eq_3 dwArg08, ptr32 & edxOut)
{
	word32 edi_84;
	ptr32 edx_14;
	Eq_3 eax_12 = fn006DF760(dwArg04, dwArg08, out edx_14, out edi_84);
	if (eax_12 == 0x00)
	{
		ptr32 edx_23;
		word32 ecx_85;
		fn006E1160(out ecx_85, out edx_23);
		edxOut = edx_23;
		return 0x00;
	}
	else
	{
		word32 v9_31 = (word32) *eax_12 - 1;
		*eax_12 = v9_31;
		if (v9_31 == 0x00)
		{
			struct Eq_56065 * edx_35 = *((word32) eax_12 + 4);
			edx_35->ptr0018();
		}
		edxOut = edx_14;
		return 0x01;
	}
}

// 006DF800: Register Eq_3 fn006DF800(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Stack Eq_3 dwArg0C, Register out ptr32 ecxOut, Register out ptr32 edxOut)
// Called from:
//      fn006E1DE0
//      fn006F7100
//      fn00731A20
Eq_3 fn006DF800(Eq_3 dwArg04, Eq_3 dwArg08, Eq_3 dwArg0C, ptr32 & ecxOut, ptr32 & edxOut)
{
	<anonymous> * eax_9 = *((word32) *((word32) dwArg04 + 4) + 36);
	if (eax_9 == null)
	{
		ptr32 ecx_21;
		ptr32 edx_22;
		Eq_3 eax_20 = fn006F1A70(out ecx_21, out edx_22);
		if (eax_20 != 0x00)
		{
			ptr32 ecx_110;
			ptr32 edx_113;
			Eq_3 eax_38 = fn006DE430(dwArg04, dwArg04, dwArg08, out ecx_110, out edx_113);
			word32 v12_44 = (word32) *eax_20 - 1;
			*eax_20 = v12_44;
			if (v12_44 == 0x00)
			{
				struct Eq_56119 * edx_49 = *((word32) eax_20 + 4);
				edx_49->ptr0018();
			}
			ecxOut = ecx_110;
			edxOut = edx_113;
			return eax_38;
		}
		else
		{
			ecxOut = ecx_21;
			edxOut = edx_22;
			return ~0x00;
		}
	}
	else
	{
		Eq_3 eax_85;
		ptr32 ecx_86;
		ptr32 edx_87;
		eax_9();
		ecxOut = ecx_86;
		edxOut = edx_87;
		return eax_85;
	}
}

// 006DF870: Register uint32 fn006DF870(Stack Eq_3 dwArg04)
// Called from:
//      fn00657140
//      fn007038E0
//      fn0074E190
uint32 fn006DF870(Eq_3 dwArg04)
{
	if (dwArg04 == 0x00)
		return 0x00;
	struct Eq_51591 * ecx_9 = *((word32) dwArg04 + 4);
	if (ecx_9 != &g_tA1EB98)
		return (uint32) (int8) (ecx_9->dw0040 != 0x00);
	word32 edx_102;
	word32 edi_103;
	Eq_3 eax_21 = fn006DF760(dwArg04, 0x008D0068, out edx_102, out edi_103);
	if (eax_21 != 0x00)
	{
		word32 v9_30 = (word32) *eax_21 - 1;
		*eax_21 = v9_30;
		if (v9_30 == 0x00)
		{
			struct Eq_56171 * ecx_34 = *((word32) eax_21 + 4);
			word32 edx_41;
			ecx_34->ptr0018();
		}
		return 0x01;
	}
	else
	{
		word32 ecx_104;
		word32 edx_105;
		fn006E1160(out ecx_104, out edx_105);
		return 0x00;
	}
}

// 006DFD20: Register Eq_3 fn006DFD20(Stack Eq_3 dwArg04, Register out Eq_3 ecxOut, Register out Eq_3 edxOut)
// Called from:
//      fn006DFF80
//      fn006E0B00
//      fn006E1BD0
//      fn006EA0A0
//      fn006F4F00
//      fn00703780
//      fn00703800
//      fn00703870
//      fn007038E0
//      fn00703AA0
//      fn00704BA0
//      fn00707680
//      fn00707A80
//      fn00707AF0
//      fn00707B30
//      fn00708DC0
//      fn0070B600
//      fn007264A0
//      fn00728AC0
//      fn0072AC20
//      fn007367D0
//      fn0073A5E0
//      fn0074E140
//      fn0074EB10
Eq_3 fn006DFD20(Eq_3 dwArg04, union Eq_3 & ecxOut, union Eq_3 & edxOut)
{
	if (dwArg04 < 0x00)
	{
		Eq_3 edx_170;
		ecxOut = fn006E1DC0(out edx_170);
		edxOut = edx_170;
		return 0x00;
	}
	Eq_3 esi_25;
	if (dwArg04 == 0x00)
	{
		Eq_3 eax_19 = g_tA6C4D0;
		if (eax_19 != 0x00)
		{
			*eax_19 = (word32) *eax_19 + 1;
			ecxOut = ecx;
			edxOut = edx;
			return eax_19;
		}
	}
	else if (dwArg04 >= 0x14)
		goto l006DFDDF;
	esi_25 = *((const char *) &g_tA6C4D0 + dwArg04 * 0x04);
	if (esi_25 != 0x00)
	{
		word32 eax_76 = *((word32) esi_25 + 0x0C);
		(&g_dwA6C520)[dwArg04 * 0x04] += ~0x00;
		*((const char *) &g_tA6C4D0 + dwArg04 * 0x04) = eax_76;
		*esi_25 = 0x01;
		goto l006DFD7C;
	}
l006DFDDF:
	if (dwArg04 * 0x04 >> 0x02 != dwArg04 || dwArg04 * 0x04 <= 0x0C)
	{
		Eq_3 ecx_52;
		Eq_3 edx_53;
		Eq_3 eax_51 = fn006E1210(out ecx_52, out edx_53);
		ecxOut = ecx_52;
		edxOut = edx_53;
		return eax_51;
	}
	Eq_3 ecx_63;
	Eq_3 edx_64;
	Eq_3 eax_62 = fn006FEF50(&g_tA16588, dwArg04, out ecx_63, out edx_64);
	esi_25 = eax_62;
	if (eax_62 == 0x00)
	{
		ecxOut = ecx_63;
		edxOut = edx_64;
		return eax_62;
	}
l006DFD7C:
	if (dwArg04 > 0x00)
	{
		word32 * edi_152 = (word32) esi_25 + 0x0C;
		Eq_3 ecx_155;
		for (ecx_155 = dwArg04; ecx_155 != 0x00; --ecx_155)
		{
			*edi_152 = 0x00;
			++edi_152;
		}
	}
	if (dwArg04 == 0x00)
	{
		++g_dwA6C520;
		g_tA6C4D0 = esi_25;
		*esi_25 = (word32) *esi_25 + 1;
	}
	Eq_3 edi_118 = esi_25 - 0x10;
	if (*((word32) esi_25 - 8) != ~0x01)
		fn006E86F0(0x008D0E04);
	*((word32) edi_118 + 8) = ~0x02;
	Eq_3 edx_134 = g_tA1D558;
	*edi_118 = edx_134;
	Eq_3 eax_137 = *((word32) g_tA1D558 + 4);
	*((word32) edi_118 + 4) = eax_137;
	*eax_137 = edi_118;
	Eq_3 ecx_140 = g_tA1D558;
	*((word32) ecx_140 + 4) = edi_118;
	ecxOut = ecx_140;
	edxOut = edx_134;
	return esi_25;
}

// 006DFE20: Register word32 fn006DFE20(Stack Eq_3 dwArg04, Register out Eq_3 ecxOut, Register out ptr32 edxOut)
// Called from:
//      fn006E0FD0
//      fn00707020
//      fn0070BCC0
//      fn0070C1A0
//      fn0070C700
//      fn00725010
//      fn00728BE0
//      fn00734BB0
//      fn00735890
word32 fn006DFE20(Eq_3 dwArg04, union Eq_3 & ecxOut, ptr32 & edxOut)
{
	Eq_3 eax_8 = *((word32) dwArg04 + 4);
	if (eax_8 == 0x00A16588 || fn006D5670(eax_8, 0x00A16588, out ecx, out edx) != 0x00)
	{
		word32 eax_28 = *((word32) dwArg04 + 8);
		ecxOut = ecx;
		edxOut = edx;
		return eax_28;
	}
	else
	{
		ptr32 edx_40;
		ecxOut = fn006E1DC0(out edx_40);
		edxOut = edx_40;
		return ~0x00;
	}
}

// 006DFE60: Register word32 fn006DFE60(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08)
// Called from:
//      fn00708DC0
//      fn0070BCC0
//      fn0070C1A0
//      fn0070C700
//      fn00725010
//      fn00734BB0
//      fn0073B870
word32 fn006DFE60(Eq_3 dwArg04, Eq_3 dwArg08)
{
	Eq_3 eax_8 = *((word32) dwArg04 + 4);
	if (eax_8 != 0x00A16588)
	{
		word32 ecx_119;
		word32 edx_120;
		if (fn006D5670(eax_8, 0x00A16588, out ecx_119, out edx_120) == 0x00)
		{
			word32 edx_121;
			fn006E1DC0(out edx_121);
			return 0x00;
		}
	}
	if (dwArg08 >= 0x00 && dwArg08 < *((word32) dwArg04 + 8))
		return *((word32) dwArg04 + (dwArg08 * 0x04 + 0x0C));
	word32 ecx_122;
	word32 edx_123;
	fn006E0F80(g_tA17CA4, 9248432, out ecx_122, out edx_123);
	return 0x00;
}

// 006DFF80: Register Eq_3 fn006DFF80(Stack Eq_3 dwArg04, Register out (ptr32 word32) ecxOut, Register out Eq_3 edxOut, Register out Eq_540 esiOut)
// Called from:
//      fn006DC1B0
//      fn006E1BD0
//      fn006E8D90
//      fn006FB760
//      fn00708590
//      fn00708DC0
//      fn00726260
//      fn00726340
//      fn007276E0
//      fn00729040
//      fn00731B10
//      fn0073A5E0
//      fn0073B870
Eq_3 fn006DFF80(Eq_3 dwArg04, word32 & ecxOut, union Eq_3 & edxOut, union Eq_540 & esiOut)
{
	Eq_3 edx_12;
	word32 * ecx_13;
	Eq_3 eax_11 = fn006DFD20(dwArg04, out ecx_13, out edx_12);
	if (eax_11 != 0x00)
	{
		Eq_3 edx_20 = 0x00;
		if (dwArg04 > 0x00)
		{
			word32 * esi_26 = fp + 0x04 + 0x04;
			do
			{
				ecx_13 = *esi_26;
				++*ecx_13;
				*((word32) eax_11 + (edx_20 * 0x04 + 0x0C)) = ecx_13;
				++esi_26;
				edx_20 = (word32) edx_20 + 1;
			} while (edx_20 < dwArg04);
		}
		ecxOut = ecx_13;
		edxOut = edx_20;
		esiOut.u0 = <invalid>;
		return <invalid>;
	}
	else
	{
		ecxOut = ecx_13;
		edxOut = edx_12;
		esiOut.u0 = <invalid>;
		return <invalid>;
	}
}

// 006E0B00: Register Eq_56458 fn006E0B00(Stack Eq_3 dwArg00, Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Register out Eq_3 ecxOut)
// Called from:
//      fn00704BA0
Eq_56458 fn006E0B00(Eq_3 dwArg00, Eq_3 dwArg04, Eq_3 dwArg08, union Eq_3 & ecxOut)
{
	Eq_3 dwLoc04_318 = ecx;
	ptr32 esp_11 = fp - 0x0C;
	Eq_3 esi_14 = *dwArg04;
	if (esi_14 != 0x00)
	{
		struct Eq_56481 * ecx_18 = *((word32) esi_14 + 4);
		if (ecx_18 == &g_tA16588)
		{
			Eq_3 ebp_21 = *((word32) esi_14 + 8);
			if (ebp_21 == 0x00 || *esi_14 == 0x01)
			{
				struct Eq_56493 * esp_273 = fp - 16;
				if (ebp_21 != dwArg08)
				{
					if (ebp_21 != 0x00)
					{
						struct Eq_56544 * edx_92 = *((word32) esi_14 - 0x0C);
						struct Eq_56548 * eax_93 = *((word32) esi_14 - 16);
						*((word32) esi_14 - 8) = ~0x01;
						edx_92->ptr0000 = eax_93;
						*((word32) *((word32) esi_14 - 16) + 4) = *((word32) esi_14 - 0x0C);
						*((word32) esi_14 - 16) = null;
						struct Eq_56572 * esp_123 = fp - 20;
						if (dwArg08 < ebp_21)
						{
							word32 * edi_108 = (word32) esi_14 + 0x0C + dwArg08 * 0x04;
							dwLoc04_318 = ebp_21 - dwArg08;
							do
							{
								word32 * eax_112 = *edi_108;
								if (eax_112 != null)
								{
									*eax_112 += ~0x00;
									struct Eq_56665 * eax_118 = *edi_108;
									if (eax_118->dw0000 == 0x00)
									{
										struct Eq_56674 * ecx_121 = eax_118->ptr0004;
										<anonymous> * edx_122 = ecx_121->ptr0018;
										esp_123->ptrFFFFFFFC = eax_118;
										word32 esp_130;
										word32 edx_133;
										edx_122();
										esp_123 = esp_130 + 0x04;
									}
								}
								*edi_108 = 0x00;
								word32 v18_142 = esp_123->dw0010 - 0x01;
								esp_123->dw0010 = v18_142;
								++edi_108;
							} while (v18_142 != 0x00);
						}
						struct Eq_56611 * esp_147 = esp_123 - 4;
						esp_147->t0000 = dwArg08;
						esp_147->tFFFFFFFC = esi_14;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_3 stackArg4 = <invalid>;
						word32 edx_440;
						Eq_3 eax_166 = fn006FEF90(stackArg4, dwArg04, out edx_440);
						if (eax_166 != 0x00)
						{
							*eax_166 = 0x01;
							if (dwArg08 > ebp_21)
								memset((word32) eax_166 + 0x0C + ebp_21 * 0x04, 0x00, (dwArg08 - ebp_21) * 0x04);
							*dwArg08 = eax_166;
							if (*((word32) eax_166 - 8) != ~0x01)
								fn006E86F0(0x008D0E04);
							*((word32) eax_166 - 8) = ~0x02;
							*((word32) eax_166 - 16) = g_tA1D558;
							Eq_3 eax_214 = *((word32) g_tA1D558 + 4);
							*((word32) eax_166 - 0x0C) = eax_214;
							*eax_214 = eax_166 - 0x10;
							*((word32) g_tA1D558 + 4) = eax_166 - 0x10;
							ecxOut = dwArg00;
							return 0x00;
						}
						else
						{
							*dwArg08 = eax_166;
							fn006FEFD0(esi_14);
							ecxOut = dwLoc04_318;
							return ~0x00;
						}
					}
					else
					{
						word32 v13_259 = (word32) *esi_14 - 1;
						*esi_14 = v13_259;
						if (v13_259 == 0x00)
						{
							word32 esp_267;
							word32 edx_270;
							ecx_18->ptr0018();
							esp_273 = esp_267 + 0x04;
						}
						esp_273->tFFFFFFFC = dwArg08;
						word32 edx_438;
						word32 ecx_437;
						Eq_3 eax_286 = fn006DFD20(dwArg00, out ecx_437, out edx_438);
						*dwArg04 = eax_286;
						ecxOut = ecx;
						return (eax_286 == 0x00) - 0x01;
					}
				}
				else
				{
					ecxOut = ecx;
					return 0x00;
				}
			}
		}
	}
	dwArg04->u0 = 0x00;
	if (esi_14 != 0x00)
	{
		word32 v12_33 = (word32) *esi_14 - 1;
		*esi_14 = v12_33;
		if (v12_33 == 0x00)
		{
			struct Eq_56481 * eax_37 = *((word32) esi_14 + 4);
			<anonymous> * ecx_38 = eax_37->ptr0018;
			word32 esp_44;
			word32 edx_47;
			ecx_38();
			esp_11 = esp_44 + 0x04;
		}
	}
	struct Eq_56505 * esp_53 = esp_11 - 4;
	esp_53->dw0000 = 0x02C9;
	esp_53->dwFFFFFFFC = 9248404;
	word32 edx_436;
	fn006E1DC0(out edx_436);
	ecxOut = ecx;
	return ~0x00;
}

// 006E0CA0: Register Eq_3 fn006E0CA0(Register Eq_3 esi, Register word32 edi, Register out ptr32 ediOut)
// Called from:
//      fn006E8910
Eq_3 fn006E0CA0(Eq_3 esi, word32 edi, ptr32 & ediOut)
{
	ptr32 esp_2 = fp;
	Eq_3 eax_5 = g_tA6C4D0;
	if (eax_5 != 0x00)
	{
		*eax_5 = (word32) *eax_5 - 1;
		Eq_3 eax_11 = g_tA6C4D0;
		if (*eax_11 == 0x00)
		{
			struct Eq_56802 * ecx_14 = *((word32) eax_11 + 4);
			word32 esp_18;
			word32 edx_21;
			ecx_14->ptr0018();
			dwLoc04 = eax_11;
			esp_2 = esp_18 + 0x04;
		}
	}
	struct Eq_56769 * esp_27 = esp_2 - 4;
	esp_27->t0000 = esi;
	esp_27->dwFFFFFFFC = edi;
	g_tA6C4D0.u0 = 0x00;
	union Eq_3 * esp_31 = esp_27 - 4;
	union Eq_3 * edi_36 = g_aA6C4D4;
	do
	{
		Eq_3 esi_39 = *edi_36;
		*edi_36 = (union Eq_3 *) 0x00;
		while (esi_39 != 0x00)
		{
			esi_39 = *((word32) esi_39 + 0x0C);
			union Eq_3 * esp_49 = esp_31 - 4;
			*esp_49 = (union Eq_3 *) esi_39;
			fn006FEFD0(*esp_49);
			esp_31 = esp_49;
		}
		esp_31 = fp - 8;
		edi_36 = (union Eq_3 *) ((const char *) edi_36 + 4);
	} while (edi_36 < &g_dwA6C520);
	ediOut = dwLoc08;
	return dwLoc04;
}

// 006E0E00: Register Eq_3 fn006E0E00(Stack Eq_3 dwArg0C, Register out Eq_3 ecxOut, Register out Eq_3 edxOut)
// Called from:
//      fn00657140
//      fn006DDFE0
//      fn006E1DE0
//      fn006E7CE0
//      fn006E8D90
//      fn006FBCC0
//      fn007040D0
//      fn00707020
//      fn00708590
//      fn007086B0
//      fn00708C10
//      fn00708DC0
//      fn00716A00
//      fn0073B3D0
//      fn0073B4E0
//      fn0073B870
Eq_3 fn006E0E00(Eq_3 dwArg0C, union Eq_3 & ecxOut, union Eq_3 & edxOut)
{
	Eq_3 eax_119 = dwArg0C;
	Eq_3 esi_14 = g_tA6D67C;
	struct Eq_56852 * esp_112 = fp - 0x0C;
	if (dwArg0C != 0x00)
	{
		struct Eq_51591 * ecx_19 = *((word32) dwArg0C + 4);
		if (ecx_19 != &g_tA25E40)
		{
			word32 v12_22 = (word32) *dwArg0C - 1;
			*dwArg0C = v12_22;
			if (v12_22 == 0x00)
			{
				word32 esp_29;
				ecx_19->ptr0018();
				esp_112 = esp_29 + 0x04;
			}
			eax_119.u0 = 0x00;
		}
	}
	Eq_3 ecx_120 = *((word32) esi_14 + 40);
	Eq_3 edi_50 = *((word32) esi_14 + 44);
	Eq_3 ebx_51 = *((word32) esi_14 + 48);
	*((word32) esi_14 + 40) = esp_112->t0010;
	Eq_3 edx_121 = esp_112->t0014;
	*((word32) esi_14 + 44) = edx_121;
	*((word32) esi_14 + 48) = eax_119;
	if (ecx_120 != 0x00)
	{
		word32 v14_58 = (word32) *ecx_120 - 1;
		*ecx_120 = v14_58;
		if (v14_58 == 0x00)
		{
			struct Eq_56925 * eax_62 = *((word32) ecx_120 + 4);
			esp_112->tFFFFFFFC = ecx_120;
			word32 esp_68;
			eax_62->ptr0018();
			esp_112 = esp_68 + 0x04;
		}
	}
	if (edi_50 != 0x00)
	{
		word32 v15_81 = (word32) *edi_50 - 1;
		*edi_50 = v15_81;
		if (v15_81 == 0x00)
		{
			struct Eq_56951 * edx_85 = *((word32) edi_50 + 4);
			<anonymous> * eax_86 = edx_85->ptr0018;
			esp_112->tFFFFFFFC = edi_50;
			word32 esp_93;
			eax_86();
			esp_112 = esp_93 + 0x04;
		}
	}
	if (ebx_51 != 0x00)
	{
		word32 v16_106 = (word32) *ebx_51 - 1;
		*ebx_51 = v16_106;
		if (v16_106 == 0x00)
		{
			struct Eq_56976 * ecx_110 = *((word32) ebx_51 + 4);
			<anonymous> * edx_111 = ecx_110->ptr0018;
			esp_112->tFFFFFFFC = ebx_51;
			edx_111();
		}
	}
	ecxOut = ecx_120;
	edxOut = edx_121;
	return eax_119;
}

// 006E0E90: Register Eq_3 fn006E0E90(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Register out Eq_3 ecxOut, Register out Eq_3 edxOut)
// Called from:
//      fn006D9ED0
//      fn006E0F80
//      fn006E11D0
//      fn006E1210
//      fn006E1260
//      fn006E1400
//      fn006E15D0
//      fn006E8430
//      fn006F2790
//      fn006F9120
//      fn006FB760
//      fn00728360
//      fn0073B830
//      fn0073C100
//      fn0073CAE0
//      fn0073DBD0
//      fn0073EB70
//      fn0073F9D0
//      fn0073FAF0
//      fn0073FC30
//      fn0074E280
Eq_3 fn006E0E90(Eq_3 dwArg04, Eq_3 dwArg08, union Eq_3 & ecxOut, union Eq_3 & edxOut)
{
	struct Eq_56988 * esp_10 = fp - 0x0C;
	if (dwArg04 != 0x00)
		*dwArg04 = (word32) *dwArg04 + 1;
	Eq_3 edx_105 = dwArg08;
	if (dwArg08 != 0x00)
		*dwArg08 = (word32) *dwArg08 + 1;
	Eq_3 eax_106 = g_tA6D67C;
	Eq_3 ecx_107 = *((word32) eax_106 + 40);
	Eq_3 esi_34 = *((word32) eax_106 + 44);
	Eq_3 ebx_35 = *((word32) eax_106 + 48);
	*((word32) eax_106 + 40) = dwArg04;
	*((word32) eax_106 + 44) = dwArg08;
	((word32) eax_106 + 48)->u0 = 0x00;
	if (ecx_107 != 0x00)
	{
		word32 v15_43 = (word32) *ecx_107 - 1;
		*ecx_107 = v15_43;
		if (v15_43 == 0x00)
		{
			struct Eq_57053 * eax_47 = *((word32) ecx_107 + 4);
			word32 esp_54;
			eax_47->ptr0018();
			esp_10 = esp_54 + 0x04;
		}
	}
	if (esi_34 != 0x00)
	{
		word32 v16_67 = (word32) *esi_34 - 1;
		*esi_34 = v16_67;
		if (v16_67 == 0x00)
		{
			struct Eq_57076 * edx_71 = *((word32) esi_34 + 4);
			<anonymous> * eax_72 = edx_71->ptr0018;
			esp_10->tFFFFFFFC = esi_34;
			word32 esp_79;
			eax_72();
			esp_10 = esp_79 + 0x04;
		}
	}
	if (ebx_35 != 0x00)
	{
		word32 v17_92 = (word32) *ebx_35 - 1;
		*ebx_35 = v17_92;
		if (v17_92 == 0x00)
		{
			struct Eq_57101 * ecx_96 = *((word32) ebx_35 + 4);
			<anonymous> * edx_97 = ecx_96->ptr0018;
			esp_10->tFFFFFFFC = ebx_35;
			edx_97();
		}
	}
	ecxOut = ecx_107;
	edxOut = edx_105;
	return eax_106;
}

// 006E0F10: Register Eq_3 fn006E0F10(Stack Eq_3 dwArg04, Register out Eq_3 edxOut)
// Called from:
//      fn006E1210
//      fn006E8430
//      fn00708DC0
Eq_3 fn006E0F10(Eq_3 dwArg04, union Eq_3 & edxOut)
{
	Eq_3 edx_120 = dwArg04;
	if (dwArg04 != 0x00)
		*dwArg04 = (word32) *dwArg04 + 1;
	Eq_3 eax_13 = g_tA6D67C;
	Eq_3 ecx_117 = *((word32) eax_13 + 40);
	Eq_3 esi_22 = *((word32) eax_13 + 44);
	Eq_3 edi_27 = *((word32) eax_13 + 48);
	*((word32) eax_13 + 40) = dwArg04;
	((word32) eax_13 + 44)->u0 = 0x00;
	((word32) eax_13 + 48)->u0 = 0x00;
	struct Eq_57144 * esp_23 = fp - 8;
	if (ecx_117 != 0x00)
	{
		word32 v13_33 = (word32) *ecx_117 - 1;
		*ecx_117 = v13_33;
		if (v13_33 == 0x00)
		{
			struct Eq_57171 * eax_37 = *((word32) ecx_117 + 4);
			word32 esp_42;
			eax_37->ptr0018();
			esp_23 = esp_42 + 0x04;
		}
	}
	if (esi_22 != 0x00)
	{
		word32 v14_55 = (word32) *esi_22 - 1;
		*esi_22 = v14_55;
		if (v14_55 == 0x00)
		{
			struct Eq_57194 * edx_59 = *((word32) esi_22 + 4);
			<anonymous> * eax_60 = edx_59->ptr0018;
			esp_23->tFFFFFFFC = esi_22;
			word32 esp_66;
			eax_60();
			esp_23 = esp_66 + 0x04;
		}
	}
	if (edi_27 != 0x00)
	{
		word32 v15_79 = (word32) *edi_27 - 1;
		*edi_27 = v15_79;
		if (v15_79 == 0x00)
		{
			struct Eq_57219 * ecx_83 = *((word32) edi_27 + 4);
			<anonymous> * edx_84 = ecx_83->ptr0018;
			esp_23->tFFFFFFFC = edi_27;
			edx_84();
		}
	}
	edxOut = edx_120;
	return ecx_117;
}

// 006E0F80: Register Eq_3 fn006E0F80(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Register out ptr32 ecxOut, Register out (ptr32 (arr Eq_3)) edxOut)
// Called from:
//      fn00656570
//      fn006DDEB0
//      fn006DEB90
//      fn006DEEA0
//      fn006DFE60
//      fn006E5590
//      fn006E5AD0
//      fn006E5C60
//      fn006E7660
//      fn006E98A0
//      fn006E99A0
//      fn006E9B00
//      fn006E9BD0
//      fn006E9FA0
//      fn006EA0A0
//      fn006EA420
//      fn006EA9D0
//      fn006ECAC0
//      fn006F2090
//      fn006F29C0
//      fn006F68F0
//      fn006F6EA0
//      fn006F7890
//      fn006F82C0
//      fn006F8AD0
//      fn006F8C70
//      fn006F8EC0
//      fn006F9090
//      fn006FF3E0
//      fn007012A0
//      fn00701650
//      fn00701880
//      fn00702910
//      fn00702970
//      fn007029D0
//      fn00702AF0
//      fn00703120
//      fn00703180
//      fn00703210
//      fn00703300
//      fn00703390
//      fn00703420
//      fn00703520
//      fn007035C0
//      fn00703690
//      fn00703710
//      fn00703800
//      fn00703870
//      fn007038E0
//      fn00703AF0
//      fn00703CB0
//      fn00703D00
//      fn00703F10
//      fn00704080
//      fn007040D0
//      fn00704220
//      fn00704300
//      fn00704400
//      fn00704BA0
//      fn00704DA0
//      fn00704E40
//      fn007051A0
//      fn007052C0
//      fn00705340
//      fn00706DC0
//      fn00707020
//      fn007072E0
//      fn00707680
//      fn00707D70
//      fn00708210
//      fn00708410
//      fn00708DC0
//      fn0070B600
//      fn0070BCC0
//      fn007108F0
//      fn007109D0
//      fn00710E90
//      fn007114E0
//      fn00711F50
//      fn007120F0
//      fn00717280
//      fn00717680
//      fn00718F10
//      fn00720070
//      fn00723540
//      fn00725150
//      fn00728310
//      fn0072B360
//      fn0072BBE0
//      fn0072BD40
//      fn0072E660
//      fn0072E790
//      fn0072E9C0
//      fn00731B10
//      fn00731D30
//      fn007367D0
//      fn0073C440
//      fn0073C4B0
//      fn0073D450
//      fn00742ED0
//      fn00742F20
//      fn00742FB0
//      fn007430A0
//      fn00743100
//      fn00743200
//      fn00743290
//      fn00743300
//      fn00743370
//      fn007434C0
//      fn00743560
//      fn007435D0
//      fn00743680
//      fn00743770
//      fn007437D0
//      fn00743880
//      fn00743900
//      fn00743980
//      fn00743A70
//      fn00743AD0
//      fn00743B70
//      fn00743BE0
//      fn00743C60
//      fn00743CC0
//      fn00743D20
//      fn00743D80
//      fn00743E30
//      fn00743EE0
//      fn00743F60
//      fn00743FC0
//      fn007440C0
//      fn00744110
//      fn00744200
//      fn00744270
//      fn00747580
//      fn00747960
//      fn00747FD0
//      fn007486D0
//      fn00748810
//      fn00748E50
//      fn00749820
//      fn0074E0B0
//      fn0074E190
//      fn0074E280
//      fn0074EB10
//      fn0074ED80
//      fn0074EE90
//      fn0074F9E0
//      fn007514B0
//      fn00752B30
//      fn00752CA0
//      fn00753600
//      fn00755780
//      fn007558B0
Eq_3 fn006E0F80(Eq_3 dwArg04, Eq_3 dwArg08, ptr32 & ecxOut, Eq_3 (& edxOut)
{
	word32 ecx_84;
	word32 edx_85;
	Eq_3 eax_12 = fn006ECAC0(dwArg08, out ecx_84, out edx_85);
	ptr32 ecx_24;
	Eq_3 (* edx_25)[];
	Eq_3 eax_23 = fn006E0E90(dwArg04, eax_12, out ecx_24, out edx_25);
	if (eax_12 != 0x00)
	{
		word32 v10_34 = (word32) *eax_12 - 1;
		*eax_12 = v10_34;
		if (v10_34 == 0x00)
		{
			struct Eq_57258 * edx_38 = *((word32) eax_12 + 4);
			edx_38->ptr0018();
		}
	}
	ecxOut = ecx_24;
	edxOut = edx_25;
	return eax_23;
}

// 006E0FC0: Register Eq_3 fn006E0FC0()
// Called from:
//      fn00657140
//      fn006D9ED0
//      fn006DC1B0
//      fn006DDFE0
//      fn006E5590
//      fn006E5C60
//      fn006E7D90
//      fn006E8060
//      fn006E8430
//      fn006E9BD0
//      fn006E9FA0
//      fn006F3930
//      fn006F8050
//      fn006FCC90
//      fn006FE400
//      fn006FEEB0
//      fn00701880
//      fn00702910
//      fn00702970
//      fn007029D0
//      fn00702AF0
//      fn00702C30
//      fn00703120
//      fn00703180
//      fn00703210
//      fn00703300
//      fn00703390
//      fn00703420
//      fn00703520
//      fn007035C0
//      fn00703690
//      fn00703710
//      fn00703800
//      fn00703870
//      fn007038E0
//      fn00703AF0
//      fn00703BF0
//      fn00703CB0
//      fn00703F10
//      fn00704040
//      fn00704080
//      fn007040D0
//      fn00704220
//      fn00704300
//      fn00704400
//      fn007044F0
//      fn00704BA0
//      fn00704DA0
//      fn00704E40
//      fn007051A0
//      fn00705340
//      fn007072E0
//      fn00707D70
//      fn00708DC0
//      fn0070B600
//      fn00718F10
//      fn00726930
//      fn0072E790
//      fn0072E9C0
//      fn00731D30
//      fn00735890
//      fn007367D0
//      fn007389B0
//      fn00740A90
//      fn0074F9E0
Eq_3 fn006E0FC0()
{
	return *((word32) g_tA6D67C + 40);
}

// 006E0FD0: Register uint32 fn006E0FD0(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Register out ptr32 ecxOut, Register out ptr32 edxOut)
// Called from:
//      fn006E0FD0
//      fn006E1110
//      fn006E1210
//      fn00702C30
//      fn00708130
uint32 fn006E0FD0(Eq_3 dwArg04, Eq_3 dwArg08, ptr32 & ecxOut, ptr32 & edxOut)
{
	Eq_3 ebp_144 = dwArg04;
	if (dwArg04 == 0x00 || dwArg08 == 0x00)
	{
		ecxOut = ecx;
		edxOut = edx;
		return 0x00;
	}
	Eq_3 eax_27 = *((word32) dwArg08 + 4);
	if (eax_27 != 0x00A16588)
	{
		word32 ecx_403;
		word32 edx_404;
		if (fn006D5670(eax_27, 0x00A16588, out ecx_403, out edx_404) == 0x00)
		{
			Eq_3 eax_120 = *((word32) dwArg04 + 4);
			if (eax_120 != 10611608)
			{
				word32 ecx_405;
				word32 edx_406;
				if (fn006D5670(eax_120, g_tA169F0, out ecx_405, out edx_406) == 0x00)
					goto l006E103D;
			}
			Eq_3 eax_141 = *((word32) dwArg04 + 4);
			if (eax_141 == 10611608)
				ebp_144 = *((word32) dwArg04 + 8);
			else
				ebp_144 = eax_141;
l006E103D:
			ptr32 edx_161;
			ptr32 ecx_160;
			Eq_3 eax_148 = *((word32) ebp_144 + 4);
			if (eax_148 == 10611048 || (eax_148 == 0x00A15380 || fn006D5670(eax_148, 0x00A15380, out ecx_160, out edx_161) != 0x00) && fn006D5670(ebp_144, g_tA169F0, out ecx_160, out edx_161) != 0x00)
			{
				Eq_3 eax_194 = *((word32) dwArg08 + 4);
				if (eax_194 == 10611048 || (eax_194 == 0x00A15380 || fn006D5670(eax_194, 0x00A15380, out ecx_160, out edx_161) != 0x00) && fn006D5670(dwArg08, g_tA169F0, out ecx_160, out edx_161) != 0x00)
				{
					ptr32 ecx_263;
					ptr32 edx_264;
					uint32 eax_262 = fn00704020(out ecx_263, out edx_264);
					ecxOut = ecx_263;
					edxOut = edx_264;
					return eax_262;
				}
			}
			ecxOut = ecx_160;
			edxOut = edx_161;
			return (uint32) (int8) (ebp_144 == dwArg08);
		}
	}
	ptr32 edx_355;
	ptr32 ecx_349;
	Eq_3 eax_60 = fn006DFE20(dwArg08, out ecx_349, out edx_355);
	Eq_3 esi_103 = 0x00;
	if (eax_60 > 0x00)
	{
		do
		{
			if (fn006E0FD0(dwArg04, dwArg04, out ecx_349, out edx_355) != 0x00)
			{
				ecxOut = ecx_349;
				edxOut = edx_355;
				return 0x01;
			}
			esi_103 = (word32) esi_103 + 1;
		} while (esi_103 < eax_60);
	}
	ecxOut = ecx_349;
	edxOut = edx_355;
	return 0x00;
}

