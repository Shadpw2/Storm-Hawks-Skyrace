// sho_text_0030.c
// Generated by decompiling sho.exe
// using Reko decompiler version 0.10.0.0.

#include "sho.h"

// 007012A0: Register word32 fn007012A0(Stack Eq_3 rArg04, Stack Eq_3 dwArg0C, Stack Eq_3 dwArg10, Register out Eq_84400 edxOut)
// Called from:
//      fn00735890
word32 fn007012A0(Eq_3 rArg04, Eq_3 dwArg0C, Eq_3 dwArg10, union Eq_84400 & edxOut)
{
	Eq_3 bArg04 = (byte) rArg04;
	byte bArg05 = SLICE(rArg04, byte, 8);
	byte bArg06 = SLICE(rArg04, byte, 16);
	byte bArg07 = SLICE(rArg04, byte, 24);
	byte bArg08 = SLICE(rArg04, byte, 32);
	byte bArg09 = SLICE(rArg04, byte, 40);
	byte bArg0A = SLICE(rArg04, byte, 48);
	byte bArg0B = SLICE(rArg04, byte, 56);
	word24 ebx_24_8_110 = SLICE(ebx, word24, 8);
	Eq_3 eax_5 = g_tA6CD1C;
	if (eax_5 == 0x00)
	{
		Eq_3 esi_106 = dwArg0C;
		int32 edi_108 = 0x01;
		if (dwArg10 != eax_5)
		{
			esi_106 = (word32) dwArg0C + 7;
			edi_108 = ~0x00;
		}
		word32 ebx_109;
		Eq_3 rLoc1_453 = rArg04;
		if (rArg04 < 0.0)
		{
			rLoc1_453 = -rArg04;
			ebx_109 = SEQ(ebx_24_8_110, 0x01);
		}
		else
			ebx_109 = SEQ(ebx_24_8_110, 0x00);
		int32 edx_189;
		word32 edx_116;
		Eq_84489 rRet0;
		MSVCR80.dll!frexp();
		byte bl_361 = (byte) ebx_109;
		word24 edx_24_8_625 = SLICE(edx_116, word24, 8);
		if (rRet0 <= 1.0 && rLoc1_453 < 0.0)
		{
			edx_189 = dwLoc0C - 0x01;
			if (dwLoc0C >= 0x0401)
				goto l0070146E;
			if (dwLoc0C < ~0x03FC)
			{
				ldexp(0.0, dwLoc0C + 1021);
				edx_189 = 0x00;
				goto l0070137B;
			}
			if (dwLoc0C != 0x01)
			{
l00701369:
				edx_189 += 0x03FF;
				goto l0070137B;
			}
		}
		else
		{
			if (PARITY_EVEN(rLoc1_453 - 0.0))
			{
				Eq_84400 edx_176;
				word32 ecx_724;
				fn006E0F80(g_tA18720, bArg04, out ecx_724, out edx_176);
				edxOut = edx_176;
				return ~0x00;
			}
			edx_189 = 0x00;
		}
		if (!PARITY_EVEN(0.0 - 0.0))
		{
l0070137B:
			real64 rLoc1_676 = rLoc1_453 *64 g_r8D6C30;
			uint16 wLoc0C_677 = __fstcw();
			__fldcw((word16) ((word32) wLoc0C_677 | 0x0C00));
			__fldcw(wLoc0C_677);
			Eq_84538 dwLoc08_682 = (word32) (int64) rLoc1_676;
			Eq_84538 ecx_274 = dwLoc08_682;
			uint16 wLoc0C_687 = __fstcw();
			real64 rLoc1_690 = (rLoc1_453 - 0.0) * g_r8D6C28 + g_r8AB850;
			__fldcw((word16) ((word32) wLoc0C_687 | 0x0C00));
			__fldcw(wLoc0C_687);
			uint32 dwLoc08_693 = (word32) (int64) rLoc1_690;
			uint32 dwLoc08_694 = dwLoc08_693;
			if ((dwLoc08_693 & 0xFF000000) == 0x00)
			{
l00701418:
				*esi_106 = (byte) (edx_189 >> 0x04) | bl_361 << 0x07;
				byte * esi_368 = (word32) esi_106 + edi_108;
				*esi_368 = (byte) (ecx_274 >> 0x18) | (byte) edx_189 << 0x04;
				byte * esi_377 = esi_368 + edi_108;
				*esi_377 = (byte) (ecx_274 >> 0x10);
				byte * esi_382 = esi_377 + edi_108;
				*esi_382 = (byte) (ecx_274 >> 0x08);
				byte * esi_389 = esi_382 + edi_108;
				*esi_389 = (byte) ecx_274;
				byte * esi_392 = esi_389 + edi_108;
				*esi_392 = (byte) (dwLoc08_694 >> 0x10);
				byte * esi_397 = esi_392 + edi_108;
				*esi_397 = (byte) (dwLoc08_694 >> 0x08);
				esi_397[edi_108] = (byte) dwLoc08_694;
				edxOut = dwLoc08_694 >> 0x08;
				return 0x00;
			}
			ecx_274 = (word32) dwLoc08_682.u0 + 1;
			dwLoc08_694 = 0x00;
			if (((word32) dwLoc08_682.u0 + 1 & 0xF0000000) == 0x00)
				goto l00701418;
			++edx_189;
			ecx_274.u0 = 0x00;
			if (edx_189 < 0x07FF)
				goto l00701418;
l0070146E:
			Eq_84400 edx_344;
			word32 ecx_725;
			fn006E0F80(g_tA18598, bArg04, out ecx_725, out edx_344);
			edxOut = edx_344;
			return ~0x00;
		}
		goto l00701369;
	}
	Eq_3 eax_22;
	int32 ecx_11 = 0x01;
	if (eax_5 == 0x02)
	{
		if (dwArg10 != 0x00)
		{
l007014BE:
			eax_22 = dwArg0C;
l007014C2:
			*eax_22 = bArg04;
			*((word32) eax_22 + ecx_11) = bArg05;
			byte eax_40[] = (word32) eax_22 + ecx_11;
			eax_40[ecx_11] = bArg06;
			byte eax_43[] = eax_40 + ecx_11;
			eax_43[ecx_11] = bArg07;
			byte eax_46[] = eax_43 + ecx_11;
			eax_46[ecx_11] = bArg08;
			byte eax_49[] = eax_46 + ecx_11;
			eax_49[ecx_11] = bArg09;
			byte * eax_53 = eax_49 + ecx_11 + ecx_11;
			*eax_53 = bArg0A;
			eax_53[ecx_11] = bArg0B;
			edxOut = SEQ(edx_24_8, bArg0B);
			return 0x00;
		}
	}
	else if (eax_5 != 0x01 || dwArg10 == 0x00)
		goto l007014BE;
	eax_22 = (word32) dwArg0C + 7;
	ecx_11 = ~0x00;
	goto l007014C2;
}

// 00701650: Register Eq_3 fn00701650(Register word24 edx_24_8, Register Eq_3 ebx, Register Eq_3 ebp, Register Eq_3 esi, Register Eq_3 edi, Register (ptr16 Eq_7) es, Register (ptr16 Eq_8) ds, Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, FpuStack out Eq_84521 rLoc1Out)
// Called from:
//      fn007367D0
Eq_3 fn00701650(word24 edx_24_8, Eq_3 ebx, Eq_3 ebp, Eq_3 esi, Eq_3 edi, struct Eq_7 * es, struct Eq_8 * ds, Eq_3 dwArg04, Eq_3 dwArg08, union Eq_84521 & rLoc1Out)
{
	Eq_3 dwLoc0C = (word32) qwLoc0C;
	ui32 eax_7 = g_tA14188 ^ fp - 0x14;
	Eq_3 ecx_9 = g_tA6CD1C;
	Eq_3 eax_12 = dwArg04;
	if (ecx_9 == 0x00)
	{
		int32 ecx_132 = 0x01;
		if (dwArg08 != 0x00)
		{
			eax_12 = (word32) dwArg04 + 7;
			ecx_132 = ~0x00;
		}
		Eq_3 edx_183;
		Eq_3 eax_180;
		ui32 edx_140 = (word32) *eax_12;
		uint32 esi_142 = (word32) *((word32) eax_12 + ecx_132);
		bcu8 dl_147 = (byte) edx_140;
		ui32 edi_159 = (edx_140 & 0x7F) << 0x04 | esi_142 >> 0x04;
		ui32 esi_161 = (esi_142 & 0x0F) << 0x18;
		byte * eax_162 = (word32) eax_12 + ecx_132 + ecx_132;
		if (edi_159 == 0x07FF)
		{
			word32 ecx_466;
			eax_180 = fn006E0F80(g_tA17E2C, 9268288, out ecx_466, out edx_183);
		}
		else
		{
			uint8 * eax_168 = eax_162 + ecx_132;
			byte * eax_171 = eax_168 + ecx_132;
			byte * eax_177 = eax_171 + ecx_132;
			eax_180 = eax_177 + ecx_132;
			word32 ecx_181 = (word32) *((word32) eax_180 + ecx_132);
			ui32 edx_179 = (word32) *eax_177;
			int32 ecx_187 = SEQ(SLICE(ecx_181, word16, 16), *eax_180, (byte) ecx_181) | edx_179 << 0x10;
			int32 esi_178 = esi_161 | (word32) (*eax_162) << 0x10 | SEQ(0x00, *eax_168, 0x00) | (word32) (*eax_171);
			edx_183 = edx_179 << 0x10;
			real64 rLoc1_376 = (real64) ecx_187;
			if (ecx_187 < 0x00)
				rLoc1_376 += g_r8ACE50;
			real64 rLoc1_379 = rLoc1_376 * g_r8D6C88;
			real64 rLoc2_381 = (real64) esi_178;
			if (esi_178 < 0x00)
				rLoc2_381 += g_r8ACE50;
			int32 edi_221;
			real64 rLoc1_386 = (rLoc1_379 + rLoc2_381) * g_r8D6C80;
			if (edi_159 == 0x00)
				edi_221 = ~0x03FD;
			else
			{
				rLoc1_386 += g_r8AD1C8;
				edi_221 = edi_159 - 0x03FF;
			}
			rLoc1 = ldexp(rLoc1_386, edi_221);
			if (dl_147 >> 0x07 != 0x00)
			{
				word32 ecx_468;
				fn00694B8E(eax_180, eax_7 ^ fp - 0x14, edx_179 << 0x10, ebx, ebp, esi, edi, es, ds, esi, out ecx_468);
				rLoc1Out = -rLoc1;
				return edx_179 << 0x10;
			}
		}
		word32 ecx_467;
		fn00694B8E(eax_180, eax_7 ^ fp - 20, edx_183, ebx, ebp, esi, edi, es, ds, esi, out ecx_467);
		rLoc1Out = rLoc1;
		return edx_183;
	}
	if (ecx_9 == 0x02)
	{
		if (dwArg08 != 0x00)
		{
l00701787:
			Eq_3 edx_98 = *dwArg04;
			Eq_3 eax_99 = *((word32) dwArg04 + 4);
			word32 ecx_464;
			fn00694B8E(eax_99, eax_7 ^ fp - 0x14, edx_98, ebx, ebp, esi, edi, es, ds, esi, out ecx_464);
			rLoc1Out = SEQ(eax_99, edx_98);
			return edx_98;
		}
	}
	else if (ecx_9 != 0x01 || dwArg08 == 0x00)
		goto l00701787;
	word32 esi_27 = 0x08;
	byte * ecx_28 = fp - 0x05;
	do
	{
		byte dl_31 = *eax_12;
		*ecx_28 = dl_31;
		--ecx_28;
		eax_12 = (word32) eax_12 + 1;
		--esi_27;
		Eq_3 edx_61 = SEQ(edx_24_8, dl_31);
	} while (esi_27 != 0x00);
	word32 ecx_465;
	fn00694B8E(dwLoc0C, eax_7 ^ fp - 0x14, edx_61, ebx, ebp, esi, edi, es, ds, esi, out ecx_465);
	rLoc1Out = qwLoc0C;
	return edx_61;
}

// 00701800: Register word32 fn00701800(Register out ptr32 ecxOut, Register out ptr32 edxOut)
// Called from:
//      fn00704220
//      fn00704300
//      fn00704400
word32 fn00701800(ptr32 & ecxOut, ptr32 & edxOut)
{
	ptr32 ecx_17;
	ptr32 edx_19;
	fn006E15D0(g_tA16B7C, dwArg04, out ecx_17, out edx_19);
	ecxOut = ecx_17;
	edxOut = edx_19;
	return 0x00;
}

// 00701880: Register word32 fn00701880(Stack Eq_3 dwArg04, Stack (ptr32 Eq_3) dwArg08, Stack (ptr32 int32) dwArg0C, Register out ptr32 edxOut)
// Called from:
//      fn00720070
word32 fn00701880(Eq_3 dwArg04, union Eq_3 * dwArg08, int32 * dwArg0C, ptr32 & edxOut)
{
	if (dwArg04 == 0x00 || (dwArg08 == null || dwArg0C == null))
	{
		if (fn006E0FC0() == 0x00)
		{
			word32 ecx_259;
			fn006E0F80(g_tA18720, 9268368, out ecx_259, out edx);
		}
		edxOut = edx;
		return ~0x00;
	}
	else
	{
		struct Eq_84935 * esi_64 = *((word32) *((word32) dwArg04 + 4) + 80);
		if (esi_64 != null && esi_64->ptr000C != null)
		{
			<anonymous> * eax_70 = esi_64->ptr0008;
			if (eax_70 != null)
			{
				ptr32 edx_128;
				struct Eq_84966 * esp_108;
				word32 eax_109;
				word32 ecx_110;
				word32 edx_111;
				eax_70();
				if (eax_109 != 0x01)
				{
					Eq_3 ecx_149 = g_tA16B7C;
					esp_108->dw0004 = 0x008D6CD8;
					esp_108->t0000 = ecx_149;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_3 stackArg4 = <invalid>;
					word32 ecx_258;
					fn006E0F80(stackArg4, dwArg04, out ecx_258, out edx_128);
				}
				else
				{
					<anonymous> * eax_117 = esi_64->ptr000C;
					esp_108->dw0004 = &esp_108->dw0004 + 6;
					esp_108->t0000.u0 = 0x00;
					esp_108->tFFFFFFFC = dwArg04;
					int32 eax_126;
					word32 ecx_127;
					eax_117();
					if (eax_126 >= 0x00)
					{
						*dwArg08 = (union Eq_3 *) dwArg04;
						*dwArg0C = eax_126;
						edxOut = edx_128;
						return 0x00;
					}
				}
				edxOut = edx_128;
				return ~0x00;
			}
		}
		ptr32 edx_89;
		word32 ecx_256;
		fn006E0F80(g_tA16B7C, 9268404, out ecx_256, out edx_89);
		edxOut = edx_89;
		return ~0x00;
	}
}

// 00701950: Register word32 fn00701950(Stack Eq_3 dwArg04)
// Called from:
//      fn00734BB0
//      fn00735890
word32 fn00701950(Eq_3 dwArg04)
{
	struct Eq_84935 * eax_7 = *((word32) *((word32) dwArg04 + 4) + 80);
	if (eax_7 == null || eax_7->dw0000 == 0x00)
		return 0x00;
	<anonymous> * eax_13 = eax_7->ptr0008;
	if (eax_13 == null)
		return 0x00;
	word32 eax_23;
	eax_13();
	if (eax_23 != 0x01)
		return 0x00;
	return eax_23;
}

// 00701B20: Register word32 fn00701B20(Stack Eq_3 dwArg04)
// Called from:
//      fn006DE1B0
word32 fn00701B20(Eq_3 dwArg04)
{
	if (dwArg04 == 0x00)
		return 0x00;
	struct Eq_85056 * eax_10 = *((word32) *((word32) dwArg04 + 4) + 48);
	if (eax_10 == null || eax_10->dw0048 == 0x00 && eax_10->dw0050 == 0x00)
		return 0x00;
	return 0x01;
}

// 00701B50: Register (ptr32 Eq_85076) fn00701B50(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Stack (ptr32 Eq_85079) dwArg0C)
// Called from:
//      fn007020D0
//      fn00702130
//      fn00702190
//      fn007021F0
//      fn00702250
//      fn007022B0
//      fn00702310
//      fn007023D0
//      fn00702450
//      fn007024B0
//      fn00702510
//      fn007025E0
//      fn007027D0
//      fn00704560
//      fn00704610
struct Eq_85076 * fn00701B50(Eq_3 dwArg04, Eq_3 dwArg08, struct Eq_85079 * dwArg0C)
{
	word24 ebx_24_8_93 = SLICE(ebx, word24, 8);
	Eq_3 ecx_6 = *((word32) dwArg04 + 4);
	struct Eq_85087 * eax_7 = *((word32) ecx_6 + 48);
	struct Eq_85091 * esp_106 = fp - 16;
	<anonymous> * edi_21 = null;
	<anonymous> * esi_125 = null;
	if (eax_7 != null && (*((word32) ecx_6 + 84) & 0x10) != 0x00)
		edi_21 = Mem20[eax_7 + dwArg0C:word32];
	word32 ebx_91 = SEQ(ebx_24_8_93, 0x10);
	if (*((word32) dwArg08 + 4) != ecx_6)
	{
		Eq_3 edx_39 = *((word32) dwArg08 + 4);
		struct Eq_85087 * eax_40 = *((word32) edx_39 + 48);
		ebx_91 = SEQ(ebx_24_8_93, 0x10);
		if (eax_40 != null)
		{
			ebx_91 = SEQ(ebx_24_8_93, 0x10);
			if ((*((word32) edx_39 + 84) & 0x10) != 0x00)
			{
				esi_125 = Mem20[eax_40 + dwArg0C:word32];
				if (esi_125 == edi_21)
					esi_125 = null;
			}
		}
	}
	struct Eq_85076 * eax_103;
	byte bl_218 = (byte) ebx_91;
	if (edi_21 != null)
	{
		if (esi_125 != null)
		{
			esp_106 = fp - 0x10;
			word32 ecx_581;
			word32 edx_582;
			if (fn006D5670(*((word32) dwArg08 + 4), ecx_6, out ecx_581, out edx_582) != 0x00)
			{
				struct Eq_85188 * esp_100;
				fn00000000();
				esp_106 = (struct Eq_85091 *) ((const char *) &esp_100->ptr0004 + 4);
				if (eax_103 != &g_dwA16480)
					return eax_103;
				word32 v15_109 = eax_103->dw0000 + ~0x00;
				eax_103->dw0000 = v15_109;
				if (v15_109 == 0x00)
				{
					struct Eq_85207 * ecx_113 = eax_103->ptr0004;
					<anonymous> * edx_114 = ecx_113->ptr0018;
					esp_100->ptr0004 = eax_103;
					word32 esp_117;
					edx_114();
					esp_106 = esp_117 + 0x04;
				}
				esi_125 = null;
			}
		}
		word32 eax_132 = esp_106->dw0018;
		word32 ecx_133 = esp_106->dw0014;
		struct Eq_85159 * esp_134 = esp_106 - 4;
		esp_134->dw0000 = eax_132;
		esp_134->dwFFFFFFFC = ecx_133;
		struct Eq_85168 * esp_147;
		fn00000000();
		esp_106 = (struct Eq_85091 *) ((const char *) &esp_147->ptr0004 + 4);
		if (eax_103 != &g_dwA16480)
			return eax_103;
		word32 v23_156 = eax_103->dw0000 + ~0x00;
		eax_103->dw0000 = v23_156;
		if (v23_156 == 0x00)
		{
			struct Eq_85207 * edx_160 = eax_103->ptr0004;
			esp_147->ptr0004 = eax_103;
			word32 esp_164;
			edx_160->ptr0018();
			esp_106 = esp_164 + 0x04;
		}
	}
	if (esi_125 != null)
	{
		word32 ecx_178 = esp_106->dw0018;
		word32 edx_179 = esp_106->dw0014;
		struct Eq_85238 * esp_180 = esp_106 - 4;
		esp_180->dw0000 = ecx_178;
		esp_180->dwFFFFFFFC = edx_179;
		struct Eq_85247 * esp_188;
		fn00000000();
		if (eax_103 != &g_dwA16480)
			return eax_103;
		word32 v16_197 = eax_103->dw0000 + ~0x00;
		eax_103->dw0000 = v16_197;
		if (v16_197 == 0x00)
		{
			struct Eq_85207 * ecx_201 = eax_103->ptr0004;
			<anonymous> * edx_202 = ecx_201->ptr0018;
			esp_188->ptr0004 = eax_103;
			edx_202();
		}
	}
	if ((*((word32) *((word32) dwArg04 + 4) + 84) & bl_218) == 0x00 || (*((word32) (*((word32) dwArg08 + 4)) + 84) & bl_218) == 0x00)
	{
		int32 eax_234 = fn006DEB20(fp + 0x04, fp + 0x08);
		struct Eq_85281 * esp_240 = fp - 0x10;
		if (eax_234 < 0x00)
			return null;
		if (eax_234 == 0x00)
		{
			struct Eq_85087 * ecx_247 = *((word32) *((word32) dwArg04 + 4) + 48);
			if (ecx_247 != null)
			{
				word32 ecx_253 = Mem233[ecx_247 + dwArg0C:word32];
				if (ecx_253 != null)
				{
					struct Eq_85332 * esp_338;
					struct Eq_85076 * eax_341;
					ecx_253();
					struct Eq_85334 * eax_345 = esp_338->ptr001C;
					eax_345->dw0000 += ~0x00;
					struct Eq_85334 * eax_348 = esp_338->ptr001C;
					struct Eq_85350 * esp_349 = (const char *) &esp_338->ptr0004 + 4;
					if (eax_348->dw0000 == 0x00)
					{
						struct Eq_85379 * ecx_352 = eax_348->ptr0004;
						<anonymous> * edx_353 = ecx_352->ptr0018;
						esp_338->ptr0004 = eax_348;
						word32 esp_356;
						edx_353();
						esp_349 = esp_356 + 0x04;
					}
					struct Eq_85358 * eax_366 = esp_349->ptr0018;
					eax_366->dw0000 += ~0x00;
					struct Eq_85358 * eax_369 = esp_349->ptr0018;
					if (eax_369->dw0000 == 0x00)
					{
						struct Eq_85393 * ecx_372 = eax_369->ptr0004;
						<anonymous> * edx_373 = ecx_372->ptr0018;
						esp_349->ptrFFFFFFFC = eax_369;
						edx_373();
					}
					return eax_341;
				}
			}
			*dwArg04 = (word32) *dwArg04 - 1;
			if (*dwArg04 == 0x00)
			{
				Eq_3 ecx_265 = *((word32) dwArg04 + 4);
				word32 esp_284;
				(*((word32) ecx_265 + 24))();
				esp_240 = esp_284 + 0x04;
			}
			struct Eq_85404 * eax_294 = esp_240->ptr0018;
			eax_294->dw0000 += ~0x00;
			struct Eq_85404 * eax_297 = esp_240->ptr0018;
			if (eax_297->dw0000 == 0x00)
			{
				struct Eq_85435 * ecx_300 = eax_297->ptr0004;
				<anonymous> * edx_301 = ecx_300->ptr0018;
				esp_240->ptrFFFFFFFC = eax_297;
				edx_301();
			}
		}
	}
	++g_dwA16480;
	eax_103 = (struct Eq_85076 *) &g_dwA16480;
	return eax_103;
}

// 00701D30: Register (ptr32 Eq_85470) fn00701D30(Stack Eq_3 dwArg04, Stack (ptr32 Eq_85472) dwArg08, Stack (ptr32 Eq_85473) dwArg0C, Stack Eq_85474 dwArg10)
// Called from:
//      fn00702570
//      fn007028C0
struct Eq_85470 * fn00701D30(Eq_3 dwArg04, struct Eq_85472 * dwArg08, struct Eq_85473 * dwArg0C, Eq_85474 dwArg10)
{
	Eq_3 ecx_7 = *((word32) dwArg04 + 4);
	Eq_3 edx_10 = dwArg08->t0004;
	struct Eq_85087 * eax_9 = *((word32) ecx_7 + 48);
	struct Eq_85087 * ebp_17 = *((word32) edx_10 + 48);
	struct Eq_85491 * esp_111 = fp - 0x20;
	struct Eq_85495 * edi_130 = null;
	struct Eq_85470 * esi_160 = null;
	struct Eq_85495 * dwLoc10_736 = null;
	if (eax_9 != null && (*((word32) ecx_7 + 84) & 0x10) != 0x00)
		dwLoc10_736 = Mem27[eax_9 + dwArg10:word32];
	word24 ebx_24_8_99 = SLICE(dwArg04, word24, 8);
	word32 ebx_100 = SEQ(ebx_24_8_99, 0x10);
	if (dwArg08->t0004 != *((word32) dwArg04 + 4))
	{
		ebx_100 = SEQ(ebx_24_8_99, 0x10);
		if (ebp_17 != null)
		{
			ebx_100 = SEQ(ebx_24_8_99, 0x10);
			if ((*((word32) edx_10 + 84) & 0x10) != 0x00)
			{
				edi_130 = Mem36[dwArg10 + ebp_17:word32];
				if (edi_130 == dwLoc10_736)
					edi_130 = null;
			}
		}
	}
	struct Eq_85470 * eax_106;
	byte bl_232 = (byte) ebx_100;
	if (dwLoc10_736 != null)
	{
		if (edi_130 != null)
		{
			esp_111 = fp - 0x20;
			word32 edx_994;
			word32 ecx_993;
			if (fn006D5670(edx_10, ecx_7, out ecx_993, out edx_994) != 0x00)
			{
				struct Eq_85587 * esp_105;
				fn00000000();
				esp_111 = (struct Eq_85491 *) ((const char *) &esp_105->ptr0008 + 4);
				if (eax_106 != &g_dwA16480)
					return eax_106;
				word32 v15_114 = eax_106->dw0000 + ~0x00;
				eax_106->dw0000 = v15_114;
				if (v15_114 == 0x00)
				{
					struct Eq_85606 * ecx_118 = eax_106->ptr0004;
					<anonymous> * edx_119 = ecx_118->ptr0018;
					esp_105->ptr0008 = eax_106;
					word32 esp_122;
					edx_119();
					esp_111 = esp_122 + 0x04;
				}
				edi_130 = null;
			}
		}
		struct Eq_85495 * eax_137 = esp_111->ptr0028;
		struct Eq_85495 * ecx_138 = esp_111->ptr0024;
		struct Eq_85566 * esp_139 = esp_111 - 4;
		esp_139->ptr0000 = dwArg0C;
		esp_139->ptrFFFFFFFC = eax_137;
		esp_139->ptrFFFFFFF8 = ecx_138;
		struct Eq_85578 * esp_154;
		struct Eq_85470 * eax_155;
		esp_139->ptr0014();
		esi_160 = eax_155;
		esp_111 = (struct Eq_85491 *) ((const char *) &esp_154->ptr0008 + 4);
		if (eax_155 != &g_dwA16480)
			return esi_160;
		word32 v19_164 = eax_155->dw0000 + ~0x00;
		eax_155->dw0000 = v19_164;
		if (v19_164 == 0x00)
		{
			struct Eq_85606 * edx_168 = eax_155->ptr0004;
			<anonymous> * eax_169 = edx_168->ptr0018;
			esp_154->ptr0008 = eax_155;
			word32 esp_172;
			eax_169();
			esp_111 = esp_172 + 0x04;
		}
	}
	if (edi_130 != null)
	{
		struct Eq_85495 * ecx_186 = esp_111->ptr0028;
		struct Eq_85495 * edx_187 = esp_111->ptr0024;
		struct Eq_85638 * esp_188 = esp_111 - 4;
		esp_188->ptr0000 = dwArg0C;
		esp_188->ptrFFFFFFFC = ecx_186;
		esp_188->ptrFFFFFFF8 = edx_187;
		struct Eq_85650 * esp_198;
		struct Eq_85470 * eax_199;
		fn00000000();
		esi_160 = eax_199;
		esp_111 = (struct Eq_85491 *) ((const char *) &esp_198->ptr0008 + 4);
		if (eax_199 != &g_dwA16480)
			return esi_160;
		word32 v16_208 = eax_199->dw0000 + ~0x00;
		eax_199->dw0000 = v16_208;
		if (v16_208 == 0x00)
		{
			struct Eq_85606 * eax_212 = eax_199->ptr0004;
			<anonymous> * ecx_213 = eax_212->ptr0018;
			esp_198->ptr0008 = eax_199;
			word32 esp_216;
			ecx_213();
			esp_111 = esp_216 + 0x04;
		}
	}
	struct Eq_85620 * ecx_226 = dwArg0C->ptr0004;
	ptr32 eax_227 = ecx_226->ptr0030;
	if (eax_227 != 0x00 && (ecx_226->b0054 & bl_232) != 0x00)
	{
		struct Eq_85495 * eax_238 = eax_227 + esp_111->dw0030;
		if (eax_238 != esp_111->ptr0010 && (eax_238 != edi_130 && eax_238 != null))
		{
			struct Eq_85495 * ecx_247 = esp_111->ptr0028;
			struct Eq_85495 * edx_248 = esp_111->ptr0024;
			struct Eq_85724 * esp_249 = esp_111 - 4;
			esp_249->ptr0000 = dwArg0C;
			esp_249->ptrFFFFFFFC = ecx_247;
			esp_249->ptrFFFFFFF8 = edx_248;
			struct Eq_85736 * esp_260;
			struct Eq_85470 * eax_261;
			eax_238();
			esi_160 = eax_261;
			esp_111 = (struct Eq_85491 *) ((const char *) &esp_260->ptr0008 + 4);
			if (eax_261 != &g_dwA16480)
				return esi_160;
			word32 v17_270 = eax_261->dw0000 + ~0x00;
			eax_261->dw0000 = v17_270;
			if (v17_270 == 0x00)
			{
				struct Eq_85606 * eax_274 = eax_261->ptr0004;
				<anonymous> * ecx_275 = eax_274->ptr0018;
				esp_260->ptr0008 = eax_261;
				word32 esp_278;
				ecx_275();
				esp_111 = esp_278 + 0x04;
			}
		}
	}
	struct Eq_85495 * ecx_294;
	struct Eq_85495 * eax_288 = esp_111->ptr0024;
	if ((eax_288->ptr0004->b0054 & bl_232) != 0x00)
	{
		ecx_294 = esp_111->ptr0028;
		if ((ecx_294->ptr0004->b0054 & bl_232) != 0x00)
		{
			if (dwArg0C == &g_dwA163B8)
				goto l0070206D;
			if ((dwArg0C->ptr0004->b0054 & bl_232) != 0x00)
			{
l00702065:
				if (dwArg0C != &g_dwA163B8)
				{
					struct Eq_85690 * ecx_623 = ecx_294->ptr0004;
					struct Eq_85690 * eax_625 = eax_288->ptr0004;
					struct Eq_85967 * esp_627 = esp_111 - 4;
					esp_627->dw0000 = dwArg0C->ptr0004->dw000C;
					word32 ecx_630 = eax_625->dw000C;
					esp_627->dwFFFFFFFC = ecx_623->dw000C;
					Eq_3 edx_633 = g_tA16B7C;
					esp_627->dwFFFFFFF8 = ecx_630;
					esp_627->dwFFFFFFF4 = 0x008D6D88;
					esp_627->tFFFFFFF0 = edx_633;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_3 stackArg4 = <invalid>;
					word32 ecx_1001;
					word32 edx_1002;
					fn006E15D0(stackArg4, dwArg04, out ecx_1001, out edx_1002);
					eax_106 = null;
					return eax_106;
				}
l0070206D:
				word32 ecx_679 = eax_288->ptr0004->dw000C;
				struct Eq_85814 * esp_681 = esp_111 - 4;
				esp_681->dw0000 = ecx_294->ptr0004->dw000C;
				Eq_3 edx_683 = g_tA16B7C;
				esp_681->dwFFFFFFFC = ecx_679;
				esp_681->dwFFFFFFF8 = 0x008D6DD0;
				esp_681->tFFFFFFF4 = edx_683;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_3 stackArg4 = <invalid>;
				word32 edx_998;
				word32 ecx_997;
				fn006E15D0(stackArg4, dwArg04, out ecx_997, out edx_998);
				return null;
			}
		}
	}
	struct Eq_85767 * esp_308 = esp_111 - 4;
	esp_308->ptr0000 = (struct Eq_85473 *) &esp_111->ptr0028;
	esp_308->ptrFFFFFFFC = &esp_308->ptr0028;
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_3 stackArg4 = <invalid>;
	int32 eax_324 = fn006DEB90(stackArg4, dwArg04);
	int32 edi_329 = eax_324;
	esp_111 = (struct Eq_85491 *) ((const char *) &esp_308->ptr0000 + 4);
	bool v45_727 = eax_324 >= 0x00;
	if (eax_324 != 0x00)
	{
l00702057:
		if (v45_727)
			return esi_160;
		eax_288 = esp_111->ptr0024;
		ecx_294 = esp_111->ptr0028;
		goto l00702065;
	}
	if (dwArg0C == &g_dwA163B8)
	{
		struct Eq_85860 * ecx_515 = esp_308->ptr0028;
		<anonymous> * eax_517[] = ecx_515->ptr0004->ptr0030;
		if (eax_517 != null)
		{
			<anonymous> * eax_522 = eax_517[esp_308->dw0034 / 4];
			if (eax_522 != null)
			{
				word32 * edx_530 = esp_308->ptr002C;
				esp_308->ptr0000 = dwArg0C;
				esp_308->ptrFFFFFFFC = edx_530;
				esp_308->ptrFFFFFFF8 = ecx_515;
				word32 esp_537;
				struct Eq_85470 * eax_538;
				eax_522();
				esp_111 = esp_537 + 0x0C;
				esi_160 = eax_538;
				goto l0070201D;
			}
		}
		edi_329 = ~0x00;
		goto l0070201D;
	}
	struct Eq_85860 * eax_336 = esp_308->ptr0028;
	esp_308->ptr0000 = (struct Eq_85473 *) &esp_308->ptr0020;
	esp_308->ptrFFFFFFFC = &esp_308->ptr001C;
	esp_308->ptr001C = eax_336;
	esp_308->ptr0020 = dwArg0C;
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_3 stackArg4 = <invalid>;
	int32 eax_346 = fn006DEB90(stackArg4, dwArg04);
	edi_329 = eax_346;
	esp_111 = (struct Eq_85491 *) ((const char *) &esp_308->ptr0000 + 4);
	if (eax_346 != 0x00)
		goto l0070201D;
	struct Eq_85473 * ecx_357 = esp_308->ptr0020;
	esp_308->ptr0014 = esp_308->ptr002C;
	esp_308->ptr0000 = (struct Eq_85473 *) &esp_308->ptr0018;
	esp_308->ptrFFFFFFFC = &esp_308->ptr0014;
	esp_308->ptr0018 = ecx_357;
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_3 stackArg4 = <invalid>;
	int32 eax_367 = fn006DEB90(stackArg4, dwArg04);
	edi_329 = eax_367;
	esp_111 = (struct Eq_85491 *) ((const char *) &esp_308->ptr0000 + 4);
	if (eax_367 != 0x00)
	{
l00701FE5:
		struct Eq_85495 * eax_467 = esp_111->ptr0018;
		eax_467->t0000 = (<anonymous>) (eax_467->t0000 + ~0x00);
		struct Eq_85495 * eax_470 = esp_111->ptr0018;
		if (eax_470->t0000 == 0x00)
		{
			struct Eq_85690 * ecx_473 = eax_470->ptr0004;
			<anonymous> * edx_474 = ecx_473->ptr0018;
			esp_111->ptrFFFFFFFC = eax_470;
			word32 esp_482;
			edx_474();
			esp_111 = esp_482 + 0x04;
		}
		struct Eq_85495 * eax_492 = esp_111->ptr001C;
		eax_492->t0000 = (<anonymous>) (eax_492->t0000 + ~0x00);
		struct Eq_85495 * eax_495 = esp_111->ptr001C;
		if (eax_495->t0000 == 0x00)
		{
			struct Eq_85690 * ecx_498 = eax_495->ptr0004;
			<anonymous> * edx_499 = ecx_498->ptr0018;
			esp_111->ptrFFFFFFFC = eax_495;
			word32 esp_507;
			edx_499();
			esp_111 = esp_507 + 0x04;
		}
l0070201D:
		struct Eq_85495 * eax_550 = esp_111->ptr0024;
		eax_550->t0000 = (<anonymous>) (eax_550->t0000 + ~0x00);
		struct Eq_85495 * eax_553 = esp_111->ptr0024;
		if (eax_553->t0000 == 0x00)
		{
			struct Eq_85690 * ecx_556 = eax_553->ptr0004;
			<anonymous> * edx_557 = ecx_556->ptr0018;
			esp_111->ptrFFFFFFFC = eax_553;
			word32 esp_569;
			edx_557();
			esp_111 = esp_569 + 0x04;
		}
		struct Eq_85495 * eax_579 = esp_111->ptr0028;
		eax_579->t0000 = (<anonymous>) (eax_579->t0000 + ~0x00);
		struct Eq_85495 * eax_582 = esp_111->ptr0028;
		if (eax_582->t0000 == 0x00)
		{
			struct Eq_85690 * ecx_585 = eax_582->ptr0004;
			<anonymous> * edx_586 = ecx_585->ptr0018;
			esp_111->ptrFFFFFFFC = eax_582;
			word32 esp_594;
			edx_586();
			esp_111 = esp_594 + 0x04;
		}
		v45_727 = edi_329 >= 0x00;
		goto l00702057;
	}
	struct Eq_85860 * ecx_377 = esp_308->ptr001C;
	<anonymous> * eax_379[] = ecx_377->ptr0004->ptr0030;
	if (eax_379 != null)
	{
		<anonymous> * eax_384 = eax_379[esp_308->dw0034 / 4];
		if (eax_384 != null)
		{
			esp_308->ptr0000 = esp_308->ptr0018;
			word32 * edx_395 = esp_308->ptr0014;
			esp_308->ptrFFFFFFFC = edx_395;
			esp_308->ptrFFFFFFF8 = ecx_377;
			word32 esp_400;
			struct Eq_85470 * eax_401;
			eax_384();
			esp_111 = esp_400 + 0x0C;
			esi_160 = eax_401;
l00701FAD:
			struct Eq_85495 * eax_413 = esp_111->ptr0010;
			eax_413->t0000 = (<anonymous>) (eax_413->t0000 + ~0x00);
			struct Eq_85495 * eax_416 = esp_111->ptr0010;
			if (eax_416->t0000 == 0x00)
			{
				struct Eq_85690 * ecx_419 = eax_416->ptr0004;
				<anonymous> * edx_420 = ecx_419->ptr0018;
				esp_111->ptrFFFFFFFC = eax_416;
				word32 esp_432;
				edx_420();
				esp_111 = esp_432 + 0x04;
			}
			struct Eq_85495 * eax_442 = esp_111->ptr0014;
			eax_442->t0000 = (<anonymous>) (eax_442->t0000 + ~0x00);
			struct Eq_85495 * eax_445 = esp_111->ptr0014;
			if (eax_445->t0000 == 0x00)
			{
				struct Eq_85690 * ecx_448 = eax_445->ptr0004;
				<anonymous> * edx_449 = ecx_448->ptr0018;
				esp_111->ptrFFFFFFFC = eax_445;
				word32 esp_457;
				edx_449();
				esp_111 = esp_457 + 0x04;
			}
			goto l00701FE5;
		}
	}
	edi_329 = ~0x00;
	goto l00701FAD;
}

// 007020D0: Register (ptr32 Eq_85079) fn007020D0(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08)
// Called from:
//      fn00708DC0
//      fn00726570
struct Eq_85079 * fn007020D0(Eq_3 dwArg04, Eq_3 dwArg08)
{
	struct Eq_85079 * eax_18 = fn00701B50(dwArg04, dwArg08, (struct Eq_85079 *) 0x40);
	ptr32 esp_25 = fp - 0x08;
	if (eax_18 == &g_dwA16480)
	{
		word32 v8_28 = eax_18->dw0000 + ~0x00;
		eax_18->dw0000 = v8_28;
		if (v8_28 == 0x00)
		{
			struct Eq_86365 * ecx_32 = eax_18->ptr0004;
			word32 esp_36;
			ecx_32->ptr0018();
			esp_25 = esp_36 + 0x04;
		}
		Eq_3 eax_50 = *((word32) *((word32) dwArg04 + 4) + 0x0C);
		struct Eq_86328 * esp_52 = esp_25 - 4;
		esp_52->t0000 = *((word32) *((word32) dwArg08 + 4) + 0x0C);
		Eq_3 ecx_54 = g_tA16B7C;
		esp_52->tFFFFFFFC = eax_50;
		esp_52->dwFFFFFFF8 = 9268756;
		esp_52->dwFFFFFFF4 = 0x008D6D48;
		esp_52->tFFFFFFF0 = ecx_54;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_3 stackArg4 = <invalid>;
		word32 edx_113;
		word32 ecx_112;
		fn006E15D0(stackArg4, dwArg04, out ecx_112, out edx_113);
		eax_18 = null;
	}
	return eax_18;
}

// 00702130: Register (ptr32 Eq_85079) fn00702130(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08)
// Called from:
//      fn00708DC0
//      fn00726570
struct Eq_85079 * fn00702130(Eq_3 dwArg04, Eq_3 dwArg08)
{
	struct Eq_85079 * eax_18 = fn00701B50(dwArg04, dwArg08, (struct Eq_85079 *) 0x3C);
	ptr32 esp_25 = fp - 0x08;
	if (eax_18 == &g_dwA16480)
	{
		word32 v8_28 = eax_18->dw0000 + ~0x00;
		eax_18->dw0000 = v8_28;
		if (v8_28 == 0x00)
		{
			struct Eq_86365 * ecx_32 = eax_18->ptr0004;
			word32 esp_36;
			ecx_32->ptr0018();
			esp_25 = esp_36 + 0x04;
		}
		Eq_3 eax_50 = *((word32) *((word32) dwArg04 + 4) + 0x0C);
		struct Eq_86406 * esp_52 = esp_25 - 4;
		esp_52->t0000 = *((word32) *((word32) dwArg08 + 4) + 0x0C);
		Eq_3 ecx_54 = g_tA16B7C;
		esp_52->tFFFFFFFC = eax_50;
		esp_52->dwFFFFFFF8 = 0x008D6E18;
		esp_52->dwFFFFFFF4 = 0x008D6D48;
		esp_52->tFFFFFFF0 = ecx_54;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_3 stackArg4 = <invalid>;
		word32 edx_113;
		word32 ecx_112;
		fn006E15D0(stackArg4, dwArg04, out ecx_112, out edx_113);
		eax_18 = null;
	}
	return eax_18;
}

// 00702190: Register (ptr32 Eq_85079) fn00702190(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08)
// Called from:
//      fn00708DC0
//      fn00726570
struct Eq_85079 * fn00702190(Eq_3 dwArg04, Eq_3 dwArg08)
{
	struct Eq_85079 * eax_18 = fn00701B50(dwArg04, dwArg08, (struct Eq_85079 *) 0x38);
	ptr32 esp_25 = fp - 0x08;
	if (eax_18 == &g_dwA16480)
	{
		word32 v8_28 = eax_18->dw0000 + ~0x00;
		eax_18->dw0000 = v8_28;
		if (v8_28 == 0x00)
		{
			struct Eq_86365 * ecx_32 = eax_18->ptr0004;
			word32 esp_36;
			ecx_32->ptr0018();
			esp_25 = esp_36 + 0x04;
		}
		Eq_3 eax_50 = *((word32) *((word32) dwArg04 + 4) + 0x0C);
		struct Eq_86484 * esp_52 = esp_25 - 4;
		esp_52->t0000 = *((word32) *((word32) dwArg08 + 4) + 0x0C);
		Eq_3 ecx_54 = g_tA16B7C;
		esp_52->tFFFFFFFC = eax_50;
		esp_52->dwFFFFFFF8 = 9268764;
		esp_52->dwFFFFFFF4 = 0x008D6D48;
		esp_52->tFFFFFFF0 = ecx_54;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_3 stackArg4 = <invalid>;
		word32 edx_113;
		word32 ecx_112;
		fn006E15D0(stackArg4, dwArg04, out ecx_112, out edx_113);
		eax_18 = null;
	}
	return eax_18;
}

// 007021F0: Register (ptr32 Eq_85079) fn007021F0(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08)
// Called from:
//      fn00708DC0
//      fn00726570
struct Eq_85079 * fn007021F0(Eq_3 dwArg04, Eq_3 dwArg08)
{
	struct Eq_85079 * eax_18 = fn00701B50(dwArg04, dwArg08, (struct Eq_85079 *) 0x30);
	ptr32 esp_25 = fp - 0x08;
	if (eax_18 == &g_dwA16480)
	{
		word32 v8_28 = eax_18->dw0000 + ~0x00;
		eax_18->dw0000 = v8_28;
		if (v8_28 == 0x00)
		{
			struct Eq_86365 * ecx_32 = eax_18->ptr0004;
			word32 esp_36;
			ecx_32->ptr0018();
			esp_25 = esp_36 + 0x04;
		}
		Eq_3 eax_50 = *((word32) *((word32) dwArg04 + 4) + 0x0C);
		struct Eq_86562 * esp_52 = esp_25 - 4;
		esp_52->t0000 = *((word32) *((word32) dwArg08 + 4) + 0x0C);
		Eq_3 ecx_54 = g_tA16B7C;
		esp_52->tFFFFFFFC = eax_50;
		esp_52->dwFFFFFFF8 = 9268768;
		esp_52->dwFFFFFFF4 = 0x008D6D48;
		esp_52->tFFFFFFF0 = ecx_54;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_3 stackArg4 = <invalid>;
		word32 edx_113;
		word32 ecx_112;
		fn006E15D0(stackArg4, dwArg04, out ecx_112, out edx_113);
		eax_18 = null;
	}
	return eax_18;
}

// 00702250: Register (ptr32 Eq_85079) fn00702250(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08)
// Called from:
//      fn00708DC0
//      fn00726570
struct Eq_85079 * fn00702250(Eq_3 dwArg04, Eq_3 dwArg08)
{
	struct Eq_85079 * eax_18 = fn00701B50(dwArg04, dwArg08, (struct Eq_85079 *) 0x34);
	ptr32 esp_25 = fp - 0x08;
	if (eax_18 == &g_dwA16480)
	{
		word32 v8_28 = eax_18->dw0000 + ~0x00;
		eax_18->dw0000 = v8_28;
		if (v8_28 == 0x00)
		{
			struct Eq_86365 * ecx_32 = eax_18->ptr0004;
			word32 esp_36;
			ecx_32->ptr0018();
			esp_25 = esp_36 + 0x04;
		}
		Eq_3 eax_50 = *((word32) *((word32) dwArg04 + 4) + 0x0C);
		struct Eq_86640 * esp_52 = esp_25 - 4;
		esp_52->t0000 = *((word32) *((word32) dwArg08 + 4) + 0x0C);
		Eq_3 ecx_54 = g_tA16B7C;
		esp_52->tFFFFFFFC = eax_50;
		esp_52->dwFFFFFFF8 = 9268772;
		esp_52->dwFFFFFFF4 = 0x008D6D48;
		esp_52->tFFFFFFF0 = ecx_54;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_3 stackArg4 = <invalid>;
		word32 edx_113;
		word32 ecx_112;
		fn006E15D0(stackArg4, dwArg04, out ecx_112, out edx_113);
		eax_18 = null;
	}
	return eax_18;
}

// 007022B0: Register (ptr32 Eq_85079) fn007022B0(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08)
// Called from:
//      fn00708DC0
//      fn00726570
struct Eq_85079 * fn007022B0(Eq_3 dwArg04, Eq_3 dwArg08)
{
	struct Eq_85079 * eax_18 = fn00701B50(dwArg04, dwArg08, (struct Eq_85079 *) 0x04);
	ptr32 esp_25 = fp - 0x08;
	if (eax_18 == &g_dwA16480)
	{
		word32 v8_28 = eax_18->dw0000 + ~0x00;
		eax_18->dw0000 = v8_28;
		if (v8_28 == 0x00)
		{
			struct Eq_86365 * ecx_32 = eax_18->ptr0004;
			word32 esp_36;
			ecx_32->ptr0018();
			esp_25 = esp_36 + 0x04;
		}
		Eq_3 eax_50 = *((word32) *((word32) dwArg04 + 4) + 0x0C);
		struct Eq_86718 * esp_52 = esp_25 - 4;
		esp_52->t0000 = *((word32) *((word32) dwArg08 + 4) + 0x0C);
		Eq_3 ecx_54 = g_tA16B7C;
		esp_52->tFFFFFFFC = eax_50;
		esp_52->dwFFFFFFF8 = 9259944;
		esp_52->dwFFFFFFF4 = 0x008D6D48;
		esp_52->tFFFFFFF0 = ecx_54;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_3 stackArg4 = <invalid>;
		word32 edx_113;
		word32 ecx_112;
		fn006E15D0(stackArg4, dwArg04, out ecx_112, out edx_113);
		eax_18 = null;
	}
	return eax_18;
}

// 00702310: Register (ptr32 Eq_85079) fn00702310(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08)
// Called from:
//      fn00708DC0
struct Eq_85079 * fn00702310(Eq_3 dwArg04, Eq_3 dwArg08)
{
	struct Eq_85079 * eax_18 = fn00701B50(dwArg04, dwArg08, (struct Eq_85079 *) 0x0C);
	ptr32 esp_25 = fp - 0x08;
	if (eax_18 == &g_dwA16480)
	{
		word32 v8_28 = eax_18->dw0000 + ~0x00;
		eax_18->dw0000 = v8_28;
		if (v8_28 == 0x00)
		{
			struct Eq_86365 * ecx_32 = eax_18->ptr0004;
			word32 esp_36;
			ecx_32->ptr0018();
			esp_25 = esp_36 + 0x04;
		}
		Eq_3 eax_50 = *((word32) *((word32) dwArg04 + 4) + 0x0C);
		struct Eq_86796 * esp_52 = esp_25 - 4;
		esp_52->t0000 = *((word32) *((word32) dwArg08 + 4) + 0x0C);
		Eq_3 ecx_54 = g_tA16B7C;
		esp_52->tFFFFFFFC = eax_50;
		esp_52->dwFFFFFFF8 = 0x008A6A50;
		esp_52->dwFFFFFFF4 = 0x008D6D48;
		esp_52->tFFFFFFF0 = ecx_54;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_3 stackArg4 = <invalid>;
		word32 edx_113;
		word32 ecx_112;
		fn006E15D0(stackArg4, dwArg04, out ecx_112, out edx_113);
		eax_18 = null;
	}
	return eax_18;
}

// 007023D0: Register (ptr32 Eq_85079) fn007023D0(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08)
// Called from:
//      fn00708DC0
//      fn00726570
struct Eq_85079 * fn007023D0(Eq_3 dwArg04, Eq_3 dwArg08)
{
	struct Eq_85079 * eax_137 = fn00701B50(dwArg04, dwArg08, null);
	ptr32 esp_28 = fp - 0x0C;
	if (eax_137 != &g_dwA16480)
		return eax_137;
	struct Eq_86856 * edi_32 = *((word32) *((word32) dwArg04 + 4) + 52);
	word32 v10_33 = eax_137->dw0000 + ~0x00;
	eax_137->dw0000 = v10_33;
	if (v10_33 == 0x00)
	{
		struct Eq_86365 * edx_37 = eax_137->ptr0004;
		word32 esp_41;
		edx_37->ptr0018();
		esp_28 = esp_41 + 0x04;
	}
	if (edi_32 != null)
	{
		<anonymous> * eax_54 = edi_32->ptr0004;
		if (eax_54 != null)
		{
			struct Eq_86936 * esp_101 = esp_28 - 4;
			esp_101->t0000 = dwArg08;
			esp_101->tFFFFFFFC = dwArg04;
			struct Eq_85079 * eax_106;
			eax_54();
			return eax_106;
		}
	}
	Eq_3 ecx_66 = *((word32) *((word32) dwArg04 + 4) + 0x0C);
	struct Eq_86893 * esp_69 = esp_28 - 4;
	esp_69->t0000 = *((word32) *((word32) dwArg08 + 4) + 0x0C);
	Eq_3 edx_71 = g_tA16B7C;
	esp_69->tFFFFFFFC = ecx_66;
	esp_69->dwFFFFFFF8 = 9268788;
	esp_69->dwFFFFFFF4 = 0x008D6D48;
	esp_69->tFFFFFFF0 = edx_71;
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_3 stackArg4 = <invalid>;
	word32 ecx_177;
	word32 edx_178;
	fn006E15D0(stackArg4, dwArg04, out ecx_177, out edx_178);
	eax_137 = null;
	return eax_137;
}

// 00702450: Register (ptr32 Eq_85079) fn00702450(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08)
// Called from:
//      fn00708DC0
//      fn00726570
struct Eq_85079 * fn00702450(Eq_3 dwArg04, Eq_3 dwArg08)
{
	struct Eq_85079 * eax_18 = fn00701B50(dwArg04, dwArg08, (struct Eq_85079 *) 0x88);
	ptr32 esp_25 = fp - 0x08;
	if (eax_18 == &g_dwA16480)
	{
		word32 v8_28 = eax_18->dw0000 + ~0x00;
		eax_18->dw0000 = v8_28;
		if (v8_28 == 0x00)
		{
			struct Eq_86365 * ecx_32 = eax_18->ptr0004;
			word32 esp_36;
			ecx_32->ptr0018();
			esp_25 = esp_36 + 0x04;
		}
		Eq_3 eax_50 = *((word32) *((word32) dwArg04 + 4) + 0x0C);
		struct Eq_86977 * esp_52 = esp_25 - 4;
		esp_52->t0000 = *((word32) *((word32) dwArg08 + 4) + 0x0C);
		Eq_3 ecx_54 = g_tA16B7C;
		esp_52->tFFFFFFFC = eax_50;
		esp_52->dwFFFFFFF8 = 9268792;
		esp_52->dwFFFFFFF4 = 0x008D6D48;
		esp_52->tFFFFFFF0 = ecx_54;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_3 stackArg4 = <invalid>;
		word32 edx_113;
		word32 ecx_112;
		fn006E15D0(stackArg4, dwArg04, out ecx_112, out edx_113);
		eax_18 = null;
	}
	return eax_18;
}

// 007024B0: Register (ptr32 Eq_85079) fn007024B0(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08)
// Called from:
//      fn00708DC0
//      fn00726570
struct Eq_85079 * fn007024B0(Eq_3 dwArg04, Eq_3 dwArg08)
{
	struct Eq_85079 * eax_18 = fn00701B50(dwArg04, dwArg08, (struct Eq_85079 *) 0x8C);
	ptr32 esp_25 = fp - 0x08;
	if (eax_18 == &g_dwA16480)
	{
		word32 v8_28 = eax_18->dw0000 + ~0x00;
		eax_18->dw0000 = v8_28;
		if (v8_28 == 0x00)
		{
			struct Eq_86365 * ecx_32 = eax_18->ptr0004;
			word32 esp_36;
			ecx_32->ptr0018();
			esp_25 = esp_36 + 0x04;
		}
		Eq_3 eax_50 = *((word32) *((word32) dwArg04 + 4) + 0x0C);
		struct Eq_87055 * esp_52 = esp_25 - 4;
		esp_52->t0000 = *((word32) *((word32) dwArg08 + 4) + 0x0C);
		Eq_3 ecx_54 = g_tA16B7C;
		esp_52->tFFFFFFFC = eax_50;
		esp_52->dwFFFFFFF8 = 0x008A6A50;
		esp_52->dwFFFFFFF4 = 0x008D6D48;
		esp_52->tFFFFFFF0 = ecx_54;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_3 stackArg4 = <invalid>;
		word32 edx_113;
		word32 ecx_112;
		fn006E15D0(stackArg4, dwArg04, out ecx_112, out edx_113);
		eax_18 = null;
	}
	return eax_18;
}

// 00702510: Register (ptr32 Eq_85079) fn00702510(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08)
// Called from:
//      fn00708DC0
//      fn00726570
struct Eq_85079 * fn00702510(Eq_3 dwArg04, Eq_3 dwArg08)
{
	struct Eq_85079 * eax_18 = fn00701B50(dwArg04, dwArg08, (struct Eq_85079 *) 0x10);
	ptr32 esp_25 = fp - 0x08;
	if (eax_18 == &g_dwA16480)
	{
		word32 v8_28 = eax_18->dw0000 + ~0x00;
		eax_18->dw0000 = v8_28;
		if (v8_28 == 0x00)
		{
			struct Eq_86365 * ecx_32 = eax_18->ptr0004;
			word32 esp_36;
			ecx_32->ptr0018();
			esp_25 = esp_36 + 0x04;
		}
		Eq_3 eax_50 = *((word32) *((word32) dwArg04 + 4) + 0x0C);
		struct Eq_87133 * esp_52 = esp_25 - 4;
		esp_52->t0000 = *((word32) *((word32) dwArg08 + 4) + 0x0C);
		Eq_3 ecx_54 = g_tA16B7C;
		esp_52->tFFFFFFFC = eax_50;
		esp_52->dwFFFFFFF8 = 9260940;
		esp_52->dwFFFFFFF4 = 0x008D6D48;
		esp_52->tFFFFFFF0 = ecx_54;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_3 stackArg4 = <invalid>;
		word32 edx_113;
		word32 ecx_112;
		fn006E15D0(stackArg4, dwArg04, out ecx_112, out edx_113);
		eax_18 = null;
	}
	return eax_18;
}

// 00702570: Register word32 fn00702570()
// Called from:
//      fn00708DC0
//      fn00726570
word32 fn00702570()
{
	return fn00701D30(dwArg04, dwArg08, dwArg0C, 0x18);
}

// 007025E0: void fn007025E0(Register Eq_3 esi, Register Eq_3 edi, Stack Eq_3 dwArg04, Stack (ptr32 Eq_85079) dwArg08)
// Called from:
//      fn00702670
//      fn007026A0
//      fn007026D0
//      fn007026F0
//      fn00702710
//      fn00702730
//      fn00702750
//      fn00702770
//      fn007027A0
//      fn007028A0
void fn007025E0(Eq_3 esi, Eq_3 edi, Eq_3 dwArg04, struct Eq_85079 * dwArg08)
{
	Eq_3 ecx_6 = *((word32) esi + 4);
	struct Eq_85087 * eax_7 = *((word32) ecx_6 + 48);
	if (eax_7 != null && (*((word32) ecx_6 + 84) & 0x08) != 0x00)
	{
		word32 eax_15 = Mem0[eax_7 + dwArg04:word32];
		if (eax_15 != null)
		{
			struct Eq_87221 * eax_26;
			eax_15();
			if (eax_26 != &g_dwA16480)
				return;
			word32 v11_33 = eax_26->dw0000 + ~0x00;
			eax_26->dw0000 = v11_33;
			if (v11_33 == 0x00)
			{
				struct Eq_87235 * edx_37 = eax_26->ptr0004;
				edx_37->ptr0018();
			}
		}
	}
	struct Eq_85079 * eax_60 = fn00701B50(esi, edi, dwArg08);
	ptr32 esp_67 = fp;
	if (eax_60 == &g_dwA16480)
	{
		word32 v13_70 = eax_60->dw0000 + ~0x00;
		eax_60->dw0000 = v13_70;
		if (v13_70 == 0x00)
		{
			struct Eq_86365 * edx_74 = eax_60->ptr0004;
			word32 esp_79;
			edx_74->ptr0018();
			esp_67 = esp_79 + 0x04;
		}
		Eq_3 ecx_93 = *((word32) *((word32) esi + 4) + 0x0C);
		Eq_3 eax_94 = g_tA16B7C;
		struct Eq_87263 * esp_96 = esp_67 - 4;
		esp_96->t0000 = *((word32) *((word32) edi + 4) + 0x0C);
		word32 edx_98 = esp_96->dw0010;
		esp_96->tFFFFFFFC = ecx_93;
		esp_96->dwFFFFFFF8 = edx_98;
		esp_96->dwFFFFFFF4 = 0x008D6D48;
		esp_96->tFFFFFFF0 = eax_94;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_3 stackArg4 = <invalid>;
		word32 ecx_156;
		word32 edx_157;
		fn006E15D0(stackArg4, dwArg04, out ecx_156, out edx_157);
	}
}

// 00702670: Register Eq_3 fn00702670()
// Called from:
//      fn00708DC0
Eq_3 fn00702670()
{
	fn007025E0(dwArg04, dwArg08, 0x84, (struct Eq_85079 *) 0x40);
	return <invalid>;
}

// 007026A0: Register Eq_3 fn007026A0()
// Called from:
//      fn00708DC0
Eq_3 fn007026A0()
{
	fn007025E0(dwArg04, dwArg08, 0x80, (struct Eq_85079 *) 0x3C);
	return <invalid>;
}

// 007026D0: Register Eq_3 fn007026D0()
// Called from:
//      fn00708DC0
Eq_3 fn007026D0()
{
	fn007025E0(dwArg04, dwArg08, 0x7C, (struct Eq_85079 *) 0x38);
	return <invalid>;
}

// 007026F0: Register Eq_3 fn007026F0()
// Called from:
//      fn00708DC0
Eq_3 fn007026F0()
{
	fn007025E0(dwArg04, dwArg08, 116, (struct Eq_85079 *) 0x30);
	return <invalid>;
}

// 00702710: Register Eq_3 fn00702710()
// Called from:
//      fn00708DC0
Eq_3 fn00702710()
{
	fn007025E0(dwArg04, dwArg08, 0x78, (struct Eq_85079 *) 0x34);
	return <invalid>;
}

// 00702730: Register Eq_3 fn00702730()
// Called from:
//      fn00708DC0
Eq_3 fn00702730()
{
	fn007025E0(dwArg04, dwArg08, 0x60, (struct Eq_85079 *) 0x04);
	return <invalid>;
}

// 00702750: Register Eq_3 fn00702750()
// Called from:
//      fn00708DC0
Eq_3 fn00702750()
{
	fn007025E0(dwArg04, dwArg08, 0x68, (struct Eq_85079 *) 0x0C);
	return <invalid>;
}

// 00702770: Register Eq_3 fn00702770()
// Called from:
//      fn00708DC0
Eq_3 fn00702770()
{
	fn007025E0(dwArg04, dwArg08, 0x90, (struct Eq_85079 *) 0x88);
	return <invalid>;
}

// 007027A0: Register Eq_3 fn007027A0()
// Called from:
//      fn00708DC0
Eq_3 fn007027A0()
{
	fn007025E0(dwArg04, dwArg08, 0x94, (struct Eq_85079 *) 0x8C);
	return <invalid>;
}

// 007027D0: Register (ptr32 Eq_85079) fn007027D0(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08)
// Called from:
//      fn00708DC0
struct Eq_85079 * fn007027D0(Eq_3 dwArg04, Eq_3 dwArg08)
{
	struct Eq_85079 * eax_149;
	Eq_3 eax_12 = *((word32) dwArg04 + 4);
	struct Eq_85087 * ecx_13 = *((word32) eax_12 + 48);
	ptr32 esp_16 = fp - 0x0C;
	if (ecx_13 != null && (*((word32) eax_12 + 84) & 0x08) != 0x00)
	{
		<anonymous> * ecx_23 = ecx_13->ptr005C;
		if (ecx_23 != null)
		{
			struct Eq_87433 * esp_31;
			ecx_23();
			esp_16 = (const char *) &esp_31->ptr0004 + 4;
			if (eax_149 != &g_dwA16480)
				return eax_149;
			word32 v12_40 = eax_149->dw0000 + ~0x00;
			eax_149->dw0000 = v12_40;
			if (v12_40 == 0x00)
			{
				struct Eq_86365 * ecx_44 = eax_149->ptr0004;
				<anonymous> * edx_45 = ecx_44->ptr0018;
				esp_31->ptr0004 = eax_149;
				word32 esp_48;
				edx_45();
				esp_16 = esp_48 + 0x04;
			}
		}
	}
	struct Eq_87391 * esp_57 = esp_16 - 4;
	esp_57->ptr0000 = null;
	esp_57->tFFFFFFFC = dwArg08;
	esp_57->tFFFFFFF8 = dwArg04;
	eax_149 = fn00701B50(esp_57->tFFFFFFF8, esp_57->tFFFFFFFC, esp_57->ptr0000);
	ptr32 esp_125 = (const char *) &esp_57->ptr0000 + 4;
	if (eax_149 != &g_dwA16480)
		return eax_149;
	struct Eq_86856 * edi_76 = *((word32) *((word32) dwArg04 + 4) + 52);
	word32 v14_77 = eax_149->dw0000 + ~0x00;
	eax_149->dw0000 = v14_77;
	if (v14_77 == 0x00)
	{
		struct Eq_86365 * edx_81 = eax_149->ptr0004;
		esp_57->ptr0000 = eax_149;
		word32 esp_86;
		edx_81->ptr0018();
		esp_125 = esp_86 + 0x04;
	}
	if (edi_76 != null)
	{
		<anonymous> * eax_104;
		if ((*((word32) *((word32) dwArg04 + 4) + 84) & 0x08) != 0x00)
		{
			eax_104 = edi_76->ptr0020;
			if (eax_104 != null)
			{
l0070285A:
				struct Eq_87561 * esp_161 = esp_125 - 4;
				esp_161->t0000 = dwArg08;
				esp_161->tFFFFFFFC = dwArg04;
				struct Eq_85079 * eax_171;
				eax_104();
				return eax_171;
			}
		}
		eax_104 = edi_76->ptr0004;
		if (eax_104 != null)
			goto l0070285A;
	}
	Eq_3 edx_123 = *((word32) *((word32) dwArg04 + 4) + 0x0C);
	struct Eq_87503 * esp_127 = esp_125 - 4;
	esp_127->t0000 = *((word32) *((word32) dwArg08 + 4) + 0x0C);
	Eq_3 eax_129 = g_tA16B7C;
	esp_127->tFFFFFFFC = edx_123;
	esp_127->dwFFFFFFF8 = 9268828;
	esp_127->dwFFFFFFF4 = 0x008D6D48;
	esp_127->tFFFFFFF0 = eax_129;
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_3 stackArg4 = <invalid>;
	word32 edx_261;
	word32 ecx_260;
	fn006E15D0(stackArg4, dwArg04, out ecx_260, out edx_261);
	eax_149 = null;
	return eax_149;
}

// 007028A0: Register Eq_3 fn007028A0()
// Called from:
//      fn00708DC0
Eq_3 fn007028A0()
{
	fn007025E0(dwArg04, dwArg08, 0x6C, (struct Eq_85079 *) 0x10);
	return <invalid>;
}

// 007028C0: Register word32 fn007028C0(Stack Eq_3 dwArg04)
// Called from:
//      fn00708DC0
word32 fn007028C0(Eq_3 dwArg04)
{
	Eq_3 eax_6 = *((word32) dwArg04 + 4);
	if ((*((word32) eax_6 + 84) & 0x08) == 0x00)
		return fn00701D30(dwArg04, dwArg08, dwArg0C, 0x18);
	struct Eq_85087 * eax_10 = *((word32) eax_6 + 48);
	if (eax_10 == null || eax_10->dw0070 == 0x00)
		return fn00701D30(dwArg04, dwArg08, dwArg0C, 0x18);
	return fn00701D30(dwArg04, dwArg08, dwArg0C, 0x70);
}

// 00702910: Register word32 fn00702910(Stack Eq_3 dwArg04)
// Called from:
//      fn00708DC0
//      fn00726760
word32 fn00702910(Eq_3 dwArg04)
{
	if (dwArg04 != 0x00)
	{
		struct Eq_85087 * eax_10 = *((word32) *((word32) dwArg04 + 4) + 48);
		if (eax_10 != null)
		{
			<anonymous> * eax_14 = eax_10->ptr001C;
			if (eax_14 != null)
			{
				word32 eax_41;
				word32 ecx_42;
				eax_14();
				return eax_41;
			}
		}
		word32 ecx_107;
		word32 edx_108;
		fn006E15D0(g_tA16B7C, 9268836, out ecx_107, out edx_108);
		return 0x00;
	}
	else
	{
		if (fn006E0FC0() != 0x00)
			return 0x00;
		word32 ecx_105;
		word32 edx_106;
		fn006E0F80(g_tA18720, 9268368, out ecx_105, out edx_106);
		return 0x00;
	}
}

// 00702970: Register word32 fn00702970(Stack Eq_3 dwArg04)
// Called from:
//      fn00708DC0
word32 fn00702970(Eq_3 dwArg04)
{
	if (dwArg04 != 0x00)
	{
		struct Eq_85087 * eax_10 = *((word32) *((word32) dwArg04 + 4) + 48);
		if (eax_10 != null)
		{
			<anonymous> * eax_14 = eax_10->ptr0020;
			if (eax_14 != null)
			{
				word32 eax_41;
				word32 ecx_42;
				eax_14();
				return eax_41;
			}
		}
		word32 ecx_107;
		word32 edx_108;
		fn006E15D0(g_tA16B7C, 9268876, out ecx_107, out edx_108);
		return 0x00;
	}
	else
	{
		if (fn006E0FC0() != 0x00)
			return 0x00;
		word32 ecx_105;
		word32 edx_106;
		fn006E0F80(g_tA18720, 9268368, out ecx_105, out edx_106);
		return 0x00;
	}
}

// 007029D0: Register word32 fn007029D0(Stack Eq_3 dwArg04)
// Called from:
//      fn00708DC0
//      fn00726760
word32 fn007029D0(Eq_3 dwArg04)
{
	if (dwArg04 != 0x00)
	{
		struct Eq_85087 * eax_10 = *((word32) *((word32) dwArg04 + 4) + 48);
		if (eax_10 != null)
		{
			<anonymous> * eax_14 = eax_10->ptr002C;
			if (eax_14 != null)
			{
				word32 eax_41;
				word32 ecx_42;
				eax_14();
				return eax_41;
			}
		}
		word32 ecx_107;
		word32 edx_108;
		fn006E15D0(g_tA16B7C, 9268916, out ecx_107, out edx_108);
		return 0x00;
	}
	else
	{
		if (fn006E0FC0() != 0x00)
			return 0x00;
		word32 ecx_105;
		word32 edx_106;
		fn006E0F80(g_tA18720, 9268368, out ecx_105, out edx_106);
		return 0x00;
	}
}

// 00702AF0: Register Eq_3 fn00702AF0(Stack Eq_3 dwArg04, Register out ptr32 ecxOut, Register out ptr32 edxOut)
// Called from:
//      fn00702C30
Eq_3 fn00702AF0(Eq_3 dwArg04, ptr32 & ecxOut, ptr32 & edxOut)
{
	Eq_3 edi_104 = 0x00;
	if (dwArg04 == 0x00)
	{
		if (fn006E0FC0() == 0x00)
			fn006E0F80(g_tA18720, 9268368, out ecx, out edx);
		ecxOut = ecx;
		edxOut = edx;
		return 0x00;
	}
	Eq_3 eax_15 = *((word32) dwArg04 + 4);
	if (eax_15 != 10610664 && fn006D5670(eax_15, 10610664, out ecx, out edx) == 0x00)
	{
		Eq_3 eax_33 = *((word32) dwArg04 + 4);
		if (eax_33 != 0x00A1F400 && fn006D5670(eax_33, 0x00A1F400, out ecx, out edx) == 0x00)
		{
			ptr32 edx_101;
			ptr32 ecx_100;
			Eq_3 ecx_62 = *((word32) dwArg04 + 4);
			struct Eq_85087 * eax_63 = *((word32) ecx_62 + 48);
			if (eax_63 != null && (*((word32) ecx_62 + 84) & 0x00020000) != 0x00)
			{
				<anonymous> * eax_70 = eax_63->ptr0098;
				if (eax_70 != null)
				{
					struct Eq_87833 * esp_98;
					Eq_3 eax_99;
					eax_70();
					edi_104 = eax_99;
					if (eax_99 != 0x00)
					{
						Eq_3 eax_109 = *((word32) eax_99 + 4);
						if (eax_109 != 10610664)
						{
							esp_98->t0000.u0 = 10610664;
							esp_98->tFFFFFFFC = eax_109;
							if (fn006D5670(esp_98->tFFFFFFFC, esp_98->t0000, out ecx_100, out edx_101) == 0x00)
							{
								Eq_3 eax_127 = *((word32) eax_99 + 4);
								if (eax_127 != 0x00A1F400)
								{
									esp_98->t0000.u0 = 0x00A1F400;
									esp_98->tFFFFFFFC = eax_127;
									if (fn006D5670(esp_98->tFFFFFFFC, esp_98->t0000, out ecx_100, out edx_101) == 0x00)
									{
										Eq_3 eax_155 = g_tA16B7C;
										esp_98->t0000 = *((word32) *((word32) eax_99 + 4) + 0x0C);
										esp_98->tFFFFFFFC.u0 = 9269080;
										esp_98->tFFFFFFF8 = eax_155;
										// Failed to bind call argument.
										// Please report this issue at https://github.com/uxmal/reko
										Eq_3 stackArg4 = <invalid>;
										ptr32 ecx_164;
										ptr32 edx_165;
										fn006E15D0(stackArg4, dwArg04, out ecx_164, out edx_165);
										word32 v12_169 = (word32) *eax_99 - 1;
										*eax_99 = v12_169;
										if (v12_169 == 0x00)
										{
											Eq_3 ecx_173 = *((word32) eax_99 + 4);
											<anonymous> * edx_174 = *((word32) ecx_173 + 24);
											esp_98->t0000 = eax_99;
											edx_174();
										}
										ecxOut = ecx_164;
										edxOut = edx_165;
										return 0x00;
									}
								}
							}
						}
					}
l00702C1A:
					ecxOut = ecx_100;
					edxOut = edx_101;
					return edi_104;
				}
			}
			fn006E15D0(g_tA16B7C, 9269028, out ecx_100, out edx_101);
			goto l00702C1A;
		}
	}
	*dwArg04 = (word32) *dwArg04 + 1;
	ecxOut = ecx;
	edxOut = edx;
	return dwArg04;
}

// 00702C30: Register Eq_3 fn00702C30(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Register out ptr32 ecxOut, Register out Eq_87940 edxOut)
// Called from:
//      fn00704220
//      fn00704300
//      fn00704400
//      fn007044F0
//      fn00707D70
Eq_3 fn00702C30(Eq_3 dwArg04, Eq_3 dwArg08, ptr32 & ecxOut, union Eq_87940 & edxOut)
{
	ptr32 ecx_15;
	Eq_87940 edx_16;
	Eq_3 eax_14 = fn00702AF0(dwArg04, out ecx_15, out edx_16);
	if (eax_14 != 0x00)
	{
		ptr32 ecx_119;
		Eq_87940 edx_100;
		Eq_3 eax_30 = fn007052C0(eax_14, out ecx_119, out edx_100);
		Eq_3 edi_102 = eax_30;
		if (eax_30 == ~0x00)
		{
			Eq_3 eax_39 = fn006E0FC0();
			if (eax_39 != 0x00 && fn006E0FD0(eax_39, dwArg04, out ecx_119, out edx_100) != 0x00)
			{
				word32 ecx_206;
				word32 edx_207;
				fn006E1160(out ecx_206, out edx_207);
				if (dwArg08 == 0x00)
				{
					uint32 edx_99 = (uint32) (int8) (fn00710C20(eax_14, out ecx_119) < 0x00);
					edx_100 = edx_99 + 0x7FFFFFFF;
					edi_102 = edx_99 + 0x7FFFFFFF;
				}
				else
					fn006E15D0(dwArg08, dwArg04, out ecx_119, out edx_100);
			}
		}
		word32 v15_105 = (word32) *eax_14 - 1;
		*eax_14 = v15_105;
		if (v15_105 == 0x00)
		{
			Eq_3 eax_109 = *((word32) eax_14 + 4);
			(*((word32) eax_109 + 24))();
		}
		ecxOut = ecx_119;
		edxOut = edx_100;
		return edi_102;
	}
	else
	{
		ecxOut = ecx_15;
		edxOut = edx_16;
		return ~0x00;
	}
}

// 00703120: Register word32 fn00703120(Stack Eq_3 dwArg04, Register out Eq_3 edxOut)
// Called from:
//      fn006E5710
word32 fn00703120(Eq_3 dwArg04, union Eq_3 & edxOut)
{
	Eq_3 edx_31 = dwArg04;
	if (dwArg04 == 0x00)
	{
		if (fn006E0FC0() == 0x00)
		{
			Eq_3 edx_59;
			word32 ecx_107;
			fn006E0F80(g_tA18720, 9268368, out ecx_107, out edx_59);
			edxOut = edx_59;
			return ~0x00;
		}
	}
	else
	{
		struct Eq_86856 * eax_10 = *((word32) *((word32) dwArg04 + 4) + 52);
		if (eax_10 != null)
		{
			<anonymous> * eax_14 = eax_10->ptr0000;
			if (eax_14 != null)
			{
				Eq_3 edx_40;
				word32 eax_41;
				word32 ecx_42;
				eax_14();
				edxOut = edx_40;
				return eax_41;
			}
		}
		word32 ecx_108;
		fn006E15D0(g_tA16B7C, 0x008D70D4, out ecx_108, out edx_31);
	}
	edxOut = edx_31;
	return ~0x00;
}

// 00703180: Register word32 fn00703180(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Register out ptr32 ecxOut, Register out ptr32 edxOut)
// Called from:
//      fn006E5710
//      fn006F8C70
//      fn00704220
//      fn00708210
word32 fn00703180(Eq_3 dwArg04, Eq_3 dwArg08, ptr32 & ecxOut, ptr32 & edxOut)
{
	if (dwArg04 != 0x00)
	{
		struct Eq_86856 * esi_15 = *((word32) *((word32) dwArg04 + 4) + 52);
		if (esi_15 == null || esi_15->ptr000C == null)
		{
			ptr32 edx_37;
			ptr32 ecx_38;
			fn006E15D0(g_tA16B7C, 9269500, out ecx_38, out edx_37);
			ecxOut = ecx_38;
			edxOut = edx_37;
			return 0x00;
		}
		else
		{
			if (dwArg08 < 0x00)
			{
				<anonymous> * eax_56 = esi_15->ptr0000;
				if (eax_56 != null)
				{
					int32 eax_63;
					ptr32 edx_64;
					ptr32 ecx_65;
					eax_56();
					if (eax_63 < 0x00)
					{
						ecxOut = ecx_65;
						edxOut = edx_64;
						return 0x00;
					}
				}
			}
			word32 eax_86;
			ptr32 edx_87;
			ptr32 ecx_88;
			esi_15->ptr000C();
			ecxOut = ecx_88;
			edxOut = edx_87;
			return eax_86;
		}
	}
	else
	{
		if (fn006E0FC0() == 0x00)
			fn006E0F80(g_tA18720, 9268368, out ecx, out edx);
		ecxOut = ecx;
		edxOut = edx;
		return 0x00;
	}
}

// 00703210: Register word32 fn00703210(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Stack Eq_3 dwArg0C)
// Called from:
//      fn00707E00
word32 fn00703210(Eq_3 dwArg04, Eq_3 dwArg08, Eq_3 dwArg0C)
{
	if (dwArg04 != 0x00)
	{
		Eq_3 eax_11 = *((word32) dwArg04 + 4);
		struct Eq_86856 * esi_15 = *((word32) eax_11 + 52);
		if (esi_15 == null || esi_15->ptr0010 == null)
		{
			struct Eq_88157 * edi_26 = *((word32) eax_11 + 56);
			if (edi_26 == null || edi_26->ptr0004 == null)
			{
				word32 edx_373;
				word32 ecx_372;
				fn006E15D0(g_tA16B7C, 9269532, out ecx_372, out edx_373);
				return 0x00;
			}
			else
			{
				struct Eq_88206 * eax_66 = fn0072F230(dwArg08, dwArg0C);
				if (eax_66 == null)
					return 0x00;
				struct Eq_88215 * esp_92;
				word32 eax_93;
				word32 edx_94;
				word32 ecx_95;
				edi_26->ptr0004();
				word32 v15_99 = eax_66->dw0000 + ~0x00;
				eax_66->dw0000 = v15_99;
				if (v15_99 == 0x00)
				{
					struct Eq_88233 * edx_104 = eax_66->ptr0004;
					<anonymous> * eax_105 = edx_104->ptr0018;
					esp_92->ptr0004 = eax_66;
					word32 ecx_111;
					eax_105();
				}
				return eax_93;
			}
		}
		else
		{
			if (dwArg08 < 0x00 || dwArg0C < 0x00)
			{
				<anonymous> * eax_139 = esi_15->ptr0000;
				if (eax_139 != null)
				{
					int32 eax_151;
					word32 edx_152;
					word32 ecx_153;
					eax_139();
					if (eax_151 < 0x00)
						return 0x00;
				}
			}
			word32 eax_193;
			word32 edx_194;
			word32 ecx_195;
			esi_15->ptr0010();
			return eax_193;
		}
	}
	else
	{
		if (fn006E0FC0() == 0x00)
		{
			word32 edx_371;
			word32 ecx_370;
			fn006E0F80(g_tA18720, 9268368, out ecx_370, out edx_371);
		}
		return 0x00;
	}
}

// 00703300: Register word32 fn00703300(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Stack Eq_3 dwArg0C, Register out ptr32 ecxOut)
// Called from:
//      fn00704300
word32 fn00703300(Eq_3 dwArg04, Eq_3 dwArg08, Eq_3 dwArg0C, ptr32 & ecxOut)
{
	if (dwArg04 != 0x00)
	{
		struct Eq_86856 * esi_15 = *((word32) *((word32) dwArg04 + 4) + 52);
		if (esi_15 == null || esi_15->ptr0014 == null)
		{
			ptr32 ecx_37;
			word32 edx_205;
			fn006E15D0(g_tA16B7C, 9269564, out ecx_37, out edx_205);
			ecxOut = ecx_37;
			return ~0x00;
		}
		else
		{
			if (dwArg08 < 0x00)
			{
				<anonymous> * eax_56 = esi_15->ptr0000;
				if (eax_56 != null)
				{
					int32 eax_63;
					ptr32 ecx_64;
					word32 edx_65;
					eax_56();
					if (eax_63 < 0x00)
					{
						ecxOut = ecx_64;
						return ~0x00;
					}
				}
			}
			word32 eax_89;
			ptr32 ecx_90;
			word32 edx_91;
			esi_15->ptr0014();
			ecxOut = ecx_90;
			return eax_89;
		}
	}
	else
	{
		if (fn006E0FC0() == 0x00)
		{
			word32 edx_204;
			fn006E0F80(g_tA18720, 9268368, out ecx, out edx_204);
		}
		ecxOut = ecx;
		return ~0x00;
	}
}

// 00703390: Register word32 fn00703390(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Register out ptr32 ecxOut, Register out ptr32 edxOut)
// Called from:
//      fn00704400
//      fn00727290
//      fn0072C160
//      fn00748030
word32 fn00703390(Eq_3 dwArg04, Eq_3 dwArg08, ptr32 & ecxOut, ptr32 & edxOut)
{
	if (dwArg04 != 0x00)
	{
		struct Eq_86856 * esi_15 = *((word32) *((word32) dwArg04 + 4) + 52);
		if (esi_15 == null || esi_15->ptr0014 == null)
		{
			ptr32 edx_37;
			ptr32 ecx_38;
			fn006E15D0(g_tA16B7C, 9269616, out ecx_38, out edx_37);
			ecxOut = ecx_38;
			edxOut = edx_37;
			return ~0x00;
		}
		else
		{
			if (dwArg08 < 0x00)
			{
				<anonymous> * eax_56 = esi_15->ptr0000;
				if (eax_56 != null)
				{
					int32 eax_63;
					ptr32 edx_64;
					ptr32 ecx_65;
					eax_56();
					if (eax_63 < 0x00)
					{
						ecxOut = ecx_65;
						edxOut = edx_64;
						return ~0x00;
					}
				}
			}
			word32 eax_88;
			ptr32 edx_89;
			ptr32 ecx_90;
			esi_15->ptr0014();
			ecxOut = ecx_90;
			edxOut = edx_89;
			return eax_88;
		}
	}
	else
	{
		if (fn006E0FC0() == 0x00)
			fn006E0F80(g_tA18720, 9268368, out ecx, out edx);
		ecxOut = ecx;
		edxOut = edx;
		return ~0x00;
	}
}

// 00703420: Register word32 fn00703420(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Stack Eq_3 dwArg0C, Stack Eq_3 dwArg10)
// Called from:
//      fn00707F70
word32 fn00703420(Eq_3 dwArg04, Eq_3 dwArg08, Eq_3 dwArg0C, Eq_3 dwArg10)
{
	if (dwArg04 != 0x00)
	{
		Eq_3 eax_11 = *((word32) dwArg04 + 4);
		struct Eq_86856 * esi_15 = *((word32) eax_11 + 52);
		if (esi_15 == null || esi_15->ptr0018 == null)
		{
			struct Eq_88157 * edi_26 = *((word32) eax_11 + 56);
			if (edi_26 == null || edi_26->ptr0008 == null)
			{
				word32 edx_388;
				word32 ecx_387;
				fn006E15D0(g_tA16B7C, 9269664, out ecx_387, out edx_388);
				return ~0x00;
			}
			else
			{
				struct Eq_88206 * eax_66 = fn0072F230(dwArg08, dwArg0C);
				if (eax_66 == null)
					return ~0x00;
				struct Eq_88462 * esp_96;
				word32 eax_97;
				word32 ecx_98;
				edi_26->ptr0008();
				word32 v15_103 = eax_66->dw0000 + ~0x00;
				eax_66->dw0000 = v15_103;
				if (v15_103 == 0x00)
				{
					struct Eq_88233 * ecx_108 = eax_66->ptr0004;
					<anonymous> * edx_109 = ecx_108->ptr0018;
					esp_96->ptr0008 = eax_66;
					word32 edx_115;
					edx_109();
				}
				return eax_97;
			}
		}
		else
		{
			if (dwArg08 < 0x00 || dwArg0C < 0x00)
			{
				<anonymous> * eax_143 = esi_15->ptr0000;
				if (eax_143 != null)
				{
					int32 eax_155;
					word32 ecx_156;
					word32 edx_157;
					eax_143();
					if (eax_155 < 0x00)
						return ~0x00;
				}
			}
			word32 eax_200;
			word32 edx_202;
			esi_15->ptr0018();
			return eax_200;
		}
	}
	else
	{
		if (fn006E0FC0() == 0x00)
		{
			word32 edx_386;
			word32 ecx_385;
			fn006E0F80(g_tA18720, 9268368, out ecx_385, out edx_386);
		}
		return ~0x00;
	}
}

// 00703520: Register word32 fn00703520(Stack Eq_3 dwArg04, Stack int32 dwArg08, Stack int32 dwArg0C)
// Called from:
//      fn00707F70
word32 fn00703520(Eq_3 dwArg04, int32 dwArg08, int32 dwArg0C)
{
	if (dwArg04 != 0x00)
	{
		struct Eq_86856 * esi_15 = *((word32) *((word32) dwArg04 + 4) + 52);
		if (esi_15 == null || esi_15->ptr0018 == null)
		{
			word32 edx_263;
			word32 ecx_262;
			fn006E15D0(g_tA16B7C, 9269716, out ecx_262, out edx_263);
			return ~0x00;
		}
		else
		{
			if (dwArg08 < 0x00 || dwArg0C < 0x00)
			{
				<anonymous> * eax_65 = esi_15->ptr0000;
				if (eax_65 != null)
				{
					int32 eax_77;
					word32 edx_78;
					word32 ecx_79;
					eax_65();
					if (eax_77 < 0x00)
						return ~0x00;
				}
			}
			word32 eax_121;
			word32 edx_122;
			word32 ecx_123;
			esi_15->ptr0018();
			return eax_121;
		}
	}
	else
	{
		if (fn006E0FC0() == 0x00)
		{
			word32 edx_261;
			word32 ecx_260;
			fn006E0F80(g_tA18720, 9268368, out ecx_260, out edx_261);
		}
		return ~0x00;
	}
}

// 007035C0: Register Eq_3 fn007035C0(Stack Eq_3 dwArg04)
// Called from:
//      fn00704DA0
//      fn00728BE0
Eq_3 fn007035C0(Eq_3 dwArg04)
{
	if (dwArg04 != 0x00)
	{
		word32 edx_177;
		Eq_3 eax_17 = fn006F2650(0x00, out edx_177);
		if (eax_17 == 0x00)
			return 0x00;
		struct Eq_88590 * eax_32 = fn006F3930(eax_17, dwArg04);
		if (eax_32 != null)
		{
			word32 v13_41 = eax_32->dw0000 + ~0x00;
			eax_32->dw0000 = v13_41;
			if (v13_41 == 0x00)
			{
				struct Eq_88626 * ecx_45 = eax_32->ptr0004;
				word32 edx_52;
				ecx_45->ptr0018();
			}
			return eax_17;
		}
		else
		{
			word32 v10_65 = (word32) *eax_17 - 1;
			*eax_17 = v10_65;
			if (v10_65 == 0x00)
			{
				Eq_3 ecx_69 = *((word32) eax_17 + 4);
				word32 edx_76;
				(*((word32) ecx_69 + 24))();
			}
			return 0x00;
		}
	}
	else
	{
		if (fn006E0FC0() == 0x00)
		{
			word32 edx_179;
			word32 ecx_178;
			fn006E0F80(g_tA18720, 9268368, out ecx_178, out edx_179);
		}
		return 0x00;
	}
}

// 00703640: Register word32 fn00703640(Stack Eq_3 dwArg04)
// Called from:
//      fn0070BCC0
word32 fn00703640(Eq_3 dwArg04)
{
	if (dwArg04 == 0x00)
		return 0x00;
	Eq_3 eax_9 = *((word32) dwArg04 + 4);
	if (eax_9 != 10611608)
	{
		struct Eq_88157 * ecx_12 = *((word32) eax_9 + 56);
		if (ecx_12 != null && ecx_12->ptr0004 != null)
		{
			struct Eq_86856 * eax_18 = *((word32) eax_9 + 52);
			if (eax_18 == null || eax_18->ptr0010 == null)
				return 0x01;
		}
		return 0x00;
	}
	else
	{
		word32 edx_74;
		return fn006DF7C0(dwArg04, 0x008D0B00, out edx_74);
	}
}

// 00703690: Register word32 fn00703690(Stack Eq_3 dwArg04, Register out Eq_3 edxOut)
// Called from:
//      fn00704080
//      fn007040D0
word32 fn00703690(Eq_3 dwArg04, union Eq_3 & edxOut)
{
	Eq_3 edx_31 = dwArg04;
	if (dwArg04 == 0x00)
	{
		if (fn006E0FC0() == 0x00)
		{
			Eq_3 edx_59;
			word32 ecx_107;
			fn006E0F80(g_tA18720, 9268368, out ecx_107, out edx_59);
			edxOut = edx_59;
			return ~0x00;
		}
	}
	else
	{
		struct Eq_88157 * eax_10 = *((word32) *((word32) dwArg04 + 4) + 56);
		if (eax_10 != null)
		{
			<anonymous> * eax_14 = eax_10->ptr0000;
			if (eax_14 != null)
			{
				Eq_3 edx_40;
				word32 eax_41;
				word32 ecx_42;
				eax_14();
				edxOut = edx_40;
				return eax_41;
			}
		}
		word32 ecx_108;
		fn006E15D0(g_tA16B7C, 0x008D70D4, out ecx_108, out edx_31);
	}
	edxOut = edx_31;
	return ~0x00;
}

// 007036F0: Register Eq_3 fn007036F0(Register out ptr32 ecxOut, Register out Eq_540 edxOut)
// Called from:
//      fn00657140
//      fn007533F0
//      fn00753C30
Eq_3 fn007036F0(ptr32 & ecxOut, union Eq_540 & edxOut)
{
	ptr32 ecx_15;
	word32 edx_33;
	word32 esi_34;
	word32 edi_35;
	Eq_3 eax_14 = fn00707680(dwArg04, dwArg08, 0x00, out ecx_15, out edx_33, out esi_34, out edi_35);
	ecxOut = ecx_15;
	edxOut.u0 = <invalid>;
	return eax_14;
}

// 00703710: Register word32 fn00703710(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Stack Eq_3 dwArg0C, Register out ptr32 ecxOut, Register out ptr32 edxOut)
// Called from:
//      fn006DC1B0
//      fn00703780
//      fn00703AF0
//      fn00707680
//      fn00707B30
//      fn00707BD0
word32 fn00703710(Eq_3 dwArg04, Eq_3 dwArg08, Eq_3 dwArg0C, ptr32 & ecxOut, ptr32 & edxOut)
{
	<anonymous> * eax_7 = *((word32) *((word32) dwArg04 + 4) + 64);
	if (eax_7 == null)
	{
		ptr32 edx_20;
		ptr32 ecx_21;
		fn006E15D0(g_tA16B7C, 9269764, out ecx_21, out edx_20);
		ecxOut = ecx_21;
		edxOut = edx_20;
		return 0x00;
	}
	else
	{
		struct Eq_88755 * esp_40;
		word32 eax_43;
		ptr32 ecx_42;
		ptr32 edx_41;
		eax_7();
		if (eax_43 == 0x00 && fn006E0FC0() == 0x00)
		{
			Eq_3 edx_55 = g_tA18720;
			esp_40->dw0008 = 9269796;
			esp_40->t0004 = edx_55;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg4 = <invalid>;
			fn006E0F80(stackArg4, dwArg04, out ecx_42, out edx_41);
		}
		ecxOut = ecx_42;
		edxOut = edx_41;
		return eax_43;
	}
}

// 00703780: Register Eq_3 fn00703780(Register Eq_3 eax, Stack Eq_3 dwArg04, Register out ptr32 ecxOut, Register out ptr32 edxOut)
// Called from:
//      fn00703800
//      fn00703870
//      fn007038E0
Eq_3 fn00703780(Eq_3 eax, Eq_3 dwArg04, ptr32 & ecxOut, ptr32 & edxOut)
{
	Eq_3 esi_43 = eax;
	if (eax == 0x00)
	{
l007037C2:
		ecxOut = ecx;
		edxOut = edx;
		return 0x00;
	}
	else
	{
		Eq_3 eax_12 = *((word32) eax + 4);
		if (eax_12 != 0x00A16588)
		{
			word32 edx_174;
			word32 ecx_173;
			if (fn006D5670(eax_12, 0x00A16588, out ecx_173, out edx_174) == 0x00)
			{
				Eq_3 eax_33 = fn006DFD20(0x01, out ecx, out edx);
				if (eax_33 == 0x00)
				{
					word32 v9_92 = (word32) *eax - 1;
					*eax = v9_92;
					if (v9_92 == 0x00)
					{
						Eq_3 eax_96 = *((word32) eax + 4);
						(*((word32) eax_96 + 24))();
					}
					goto l007037C2;
				}
				*((word32) eax_33 + 0x0C) = eax;
				esi_43 = eax_33;
			}
		}
		ptr32 ecx_127;
		ptr32 edx_133;
		Eq_3 eax_61 = fn00703710(dwArg04, esi_43, 0x00, out ecx_127, out edx_133);
		word32 v13_67 = (word32) *esi_43 - 1;
		*esi_43 = v13_67;
		if (v13_67 == 0x00)
		{
			Eq_3 eax_72 = *((word32) esi_43 + 4);
			(*((word32) eax_72 + 24))();
		}
		ecxOut = ecx_127;
		edxOut = edx_133;
		return eax_61;
	}
}

// 00703800: Register Eq_3 fn00703800(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Register out ptr32 ecxOut, Register out Eq_540 edxOut)
// Called from:
//      fn006E1970
//      fn006E19F0
Eq_3 fn00703800(Eq_3 dwArg04, Eq_3 dwArg08, ptr32 & ecxOut, union Eq_540 & edxOut)
{
	if (dwArg04 != 0x00)
	{
		if (dwArg08 == 0x00 || *dwArg08 == 0x00)
		{
			word32 ecx_136;
			word32 edx_137;
			fn006DFD20(0x00, out ecx_136, out edx_137);
			ptr32 ecx_33;
			word32 edx_139;
			Eq_3 eax_32 = fn00703780(eax, dwArg04, out ecx_33, out edx_139);
			ecxOut = ecx_33;
			edxOut.u0 = <invalid>;
			return eax_32;
		}
		else
		{
			fn006EA240();
			ptr32 ecx_56;
			word32 edx_140;
			Eq_3 eax_55 = fn00703780(eax, dwArg04, out ecx_56, out edx_140);
			ecxOut = ecx_56;
			edxOut.u0 = <invalid>;
			return eax_55;
		}
	}
	else
	{
		if (fn006E0FC0() == 0x00)
		{
			word32 edx_135;
			fn006E0F80(g_tA18720, 9268368, out ecx, out edx_135);
		}
		ecxOut = ecx;
		edxOut.u0 = <invalid>;
		return 0x00;
	}
}

// 00703870: Register Eq_3 fn00703870(Stack Eq_3 dwArg04, Stack (ptr32 byte) dwArg08, Register out ptr32 ecxOut, Register out Eq_540 edxOut)
// Called from:
//      fn006E3D10
//      fn006E3E50
Eq_3 fn00703870(Eq_3 dwArg04, byte * dwArg08, ptr32 & ecxOut, union Eq_540 & edxOut)
{
	if (dwArg04 != 0x00)
	{
		if (dwArg08 == null || *dwArg08 == 0x00)
		{
			word32 ecx_136;
			word32 edx_137;
			fn006DFD20(0x00, out ecx_136, out edx_137);
			ptr32 ecx_33;
			word32 edx_139;
			Eq_3 eax_32 = fn00703780(eax, dwArg04, out ecx_33, out edx_139);
			ecxOut = ecx_33;
			edxOut.u0 = <invalid>;
			return eax_32;
		}
		else
		{
			fn006EA260();
			ptr32 ecx_56;
			word32 edx_140;
			Eq_3 eax_55 = fn00703780(eax, dwArg04, out ecx_56, out edx_140);
			ecxOut = ecx_56;
			edxOut.u0 = <invalid>;
			return eax_55;
		}
	}
	else
	{
		if (fn006E0FC0() == 0x00)
		{
			word32 edx_135;
			fn006E0F80(g_tA18720, 9268368, out ecx, out edx_135);
		}
		ecxOut = ecx;
		edxOut.u0 = <invalid>;
		return 0x00;
	}
}

// 007038E0: Register Eq_3 fn007038E0(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Stack Eq_3 dwArg0C, Register out ptr32 ecxOut, Register out Eq_75900 edxOut)
// Called from:
//      fn006F7890
//      fn006F82C0
//      fn006FCC90
//      fn006FE400
//      fn007040D0
//      fn00708210
Eq_3 fn007038E0(Eq_3 dwArg04, Eq_3 dwArg08, Eq_3 dwArg0C, ptr32 & ecxOut, union Eq_75900 & edxOut)
{
	Eq_3 ebx_131 = 0x00;
	if (dwArg04 == 0x00 || dwArg08 == 0x00)
	{
		if (fn006E0FC0() == 0x00)
			fn006E0F80(g_tA18720, 9268368, out ecx, out edx);
		ecxOut = ecx;
		edxOut = edx;
		return 0x00;
	}
	else
	{
		word32 edx_312;
		word32 edi_313;
		Eq_3 eax_59 = fn006DF760(dwArg04, dwArg08, out edx_312, out edi_313);
		if (eax_59 != 0x00)
		{
			Eq_75900 edx_126;
			ptr32 ecx_125;
			if (fn006DF870(eax_59) == 0x00)
				fn006E15D0(g_tA16B7C, dwArg04, out ecx_125, out edx_126);
			else
			{
				if (dwArg0C != 0x00 && *dwArg0C != 0x00)
					fn006EA240();
				else
				{
					word32 ecx_314;
					word32 edx_315;
					fn006DFD20(0x00, out ecx_314, out edx_315);
				}
				ebx_131 = fn00703780(eax, eax_59, out ecx_125, out edx_126);
			}
			word32 v13_151 = (word32) *eax_59 - 1;
			*eax_59 = v13_151;
			if (v13_151 == 0x00)
			{
				Eq_3 edx_155 = *((word32) eax_59 + 4);
				(*((word32) edx_155 + 24))();
			}
			ecxOut = ecx_125;
			edxOut = edx_126;
			return ebx_131;
		}
		else
		{
			ptr32 ecx_188;
			Eq_75900 edx_189;
			fn006E0F80(g_tA178F0, dwArg04, out ecx_188, out edx_189);
			ecxOut = ecx_188;
			edxOut = edx_189;
			return 0x00;
		}
	}
}

// 00703AA0: Register Eq_3 fn00703AA0(Register Eq_3 eax, Register out (ptr32 word32) ecxOut, Register out (ptr32 word32) edxOut)
// Called from:
//      fn00703AF0
Eq_3 fn00703AA0(Eq_3 eax, word32 & ecxOut, word32 & edxOut)
{
	Eq_3 edi_10 = 0x00;
	if (*eax != 0x00)
	{
		eax_17 = eax;
		do
		{
			Eq_3 eax_17;
			eax_17 = (word32) eax_17 + 4;
			edi_10 = (word32) edi_10 + 1;
		} while (*eax_17 != 0x00);
	}
	word32 * ecx_39;
	word32 * edx_38;
	Eq_3 eax_37 = fn006DFD20(edi_10, out ecx_39, out edx_38);
	if (eax_37 != 0x00 && edi_10 > 0x00)
	{
		edx_38 = eax - 0x04 + 0x04;
		word32 * esi_49 = (word32) eax_37 + 0x0C;
		do
		{
			ecx_39 = *edx_38;
			*esi_49 = ecx_39;
			++*ecx_39;
			++edx_38;
			++esi_49;
			--edi_10;
		} while (edi_10 != 0x00);
	}
	ecxOut = ecx_39;
	edxOut = edx_38;
	return eax_37;
}

// 00703AF0: Register Eq_3 fn00703AF0(Stack Eq_3 dwArg04, Register out ptr32 ecxOut, Register out ptr32 edxOut)
// Called from:
//      fn006F6AF0
//      fn006F9120
//      fn006FE160
//      fn00708C10
//      fn00708DC0
//      fn00717CB0
//      fn00719F20
Eq_3 fn00703AF0(Eq_3 dwArg04, ptr32 & ecxOut, ptr32 & edxOut)
{
	if (dwArg04 != 0x00)
	{
		ptr32 ecx_13;
		ptr32 edx_14;
		Eq_3 eax_12 = fn00703AA0(fp + 0x08, out ecx_13, out edx_14);
		if (eax_12 != 0x00)
		{
			ptr32 ecx_33;
			ptr32 edx_103;
			Eq_3 eax_32 = fn00703710(dwArg04, dwArg04, 0x00, out ecx_33, out edx_103);
			word32 v11_38 = (word32) *eax_12 - 1;
			*eax_12 = v11_38;
			if (v11_38 == 0x00)
			{
				Eq_3 edx_43 = *((word32) eax_12 + 4);
				(*((word32) edx_43 + 24))();
			}
			ecxOut = ecx_33;
			edxOut = edx_103;
			return eax_32;
		}
		else
		{
			ecxOut = ecx_13;
			edxOut = edx_14;
			return eax_12;
		}
	}
	else
	{
		if (fn006E0FC0() == 0x00)
			fn006E0F80(g_tA18720, 9268368, out ecx, out edx);
		ecxOut = ecx;
		edxOut = edx;
		return 0x00;
	}
}

// 00703B60: Register Eq_3 fn00703B60(Stack Eq_3 dwArg04, Register out ptr32 ecxOut)
// Called from:
//      fn00703BF0
//      fn00703CB0
//      fn00703F10
Eq_3 fn00703B60(Eq_3 dwArg04, ptr32 & ecxOut)
{
	Eq_3 eax_12 = g_tA6CD34;
	if (eax_12 == 0x00)
	{
		ptr32 ecx_13;
		word32 edx_177;
		eax_12 = fn006ECAC0(0x008D0D60, out ecx_13, out edx_177);
		g_tA6CD34 = eax_12;
		if (eax_12 == 0x00)
		{
			ecxOut = ecx_13;
			return eax_12;
		}
	}
	word32 edx_176;
	ptr32 ecx_126;
	Eq_3 eax_35 = fn006DE330(dwArg04, eax_12, out ecx_126, out edx_176);
	if (eax_35 != 0x00)
	{
		Eq_3 eax_45 = *((word32) eax_35 + 4);
		if (eax_45 != 0x00A16588)
		{
			word32 edx_180;
			if (fn006D5670(eax_45, 0x00A16588, out ecx_126, out edx_180) == 0x00)
			{
				word32 v10_69 = (word32) *eax_35 - 1;
				*eax_35 = v10_69;
				if (v10_69 == 0x00)
				{
					Eq_3 edx_73 = *((word32) eax_35 + 4);
					(*((word32) edx_73 + 24))();
				}
				ecxOut = ecx_126;
				return 0x00;
			}
		}
		ecxOut = ecx_126;
		return eax_35;
	}
	else
	{
		word32 edx_178;
		ptr32 ecx_106;
		if (fn006E1110(out ecx_106, out edx_178) != 0x00)
		{
			word32 edx_179;
			fn006E1160(out ecx_106, out edx_179);
		}
		ecxOut = ecx_106;
		return 0x00;
	}
}

// 00703BF0: Register Eq_3 fn00703BF0(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Register out (ptr32 word32) ecxOut)
// Called from:
//      fn00703BF0
//      fn00703D00
//      fn00703F10
Eq_3 fn00703BF0(Eq_3 dwArg04, Eq_3 dwArg08, word32 & ecxOut)
{
	Eq_3 esi_122 = 0x00;
	if (dwArg04 == dwArg08)
	{
l00703C01:
		ecxOut = ecx;
		return 0x01;
	}
	Eq_3 eax_18 = *((word32) dwArg08 + 4);
	if (eax_18 != 0x00A16588)
	{
		word32 ecx_294;
		word32 edx_295;
		if (fn006D5670(eax_18, 0x00A16588, out ecx_294, out edx_295) == 0x00)
		{
l00703C40:
			word32 * ecx_108;
			struct Eq_89270 * eax_76 = fn00703B60(dwArg04, out ecx_108);
			if (eax_76 != null)
			{
				int32 ebx_86 = eax_76->dw0008;
				int32 edi_102 = 0x00;
				if (ebx_86 > 0x00)
				{
					word32 * esi_117 = &eax_76->dw0008 + 1;
					while (fn00703BF0(*esi_117, dwArg04, out ecx_108) == 0x00)
					{
						++edi_102;
						++esi_117;
						if (edi_102 >= ebx_86)
							break;
					}
					esi_122 = dwArg04;
				}
				word32 v15_126 = eax_76->dw0000 + ~0x00;
				eax_76->dw0000 = v15_126;
				if (v15_126 == 0x00)
				{
					struct Eq_89331 * edx_130 = eax_76->ptr0004;
					edx_130->ptr0018();
				}
				ecxOut = ecx_108;
				return esi_122;
			}
			else
			{
				Eq_3 eax_171 = 0x00 - (fn006E0FC0() == 0x00);
				ecxOut = ecx_108;
				return eax_171;
			}
		}
	}
	Eq_3 edx_38 = *((word32) dwArg08 + 8);
	Eq_3 eax_39 = 0x00;
	if (edx_38 > 0x00)
	{
		ecx = (word32) dwArg08 + 0x0C;
		do
		{
			if (dwArg04 == *ecx)
				goto l00703C01;
			eax_39 = (word32) eax_39 + 1;
			++ecx;
		} while (eax_39 < edx_38);
	}
	goto l00703C40;
}

// 00703CB0: Register Eq_3 fn00703CB0(Register out ptr32 ecxOut)
// Called from:
//      fn00703D00
//      fn00703F10
Eq_3 fn00703CB0(ptr32 & ecxOut)
{
	ptr32 ecx_27;
	struct Eq_89270 * eax_8 = fn00703B60(eax, out ecx_27);
	if (eax_8 != null)
	{
		word32 v10_17 = eax_8->dw0000 + ~0x00;
		eax_8->dw0000 = v10_17;
		if (v10_17 == 0x00)
		{
			struct Eq_89331 * ecx_21 = eax_8->ptr0004;
			ecx_21->ptr0018();
		}
		ecxOut = ecx_27;
		return ~0x00;
	}
	else
	{
		if (fn006E0FC0() == 0x00)
		{
			word32 edx_92;
			fn006E0F80(g_tA16B7C, dwArg04, out ecx_27, out edx_92);
		}
		ecxOut = ecx_27;
		return 0x00;
	}
}

// 00703D00: Register Eq_3 fn00703D00(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Stack word32 dwArg0C)
// Called from:
//      fn00703D00
//      fn00704700
Eq_3 fn00703D00(Eq_3 dwArg04, Eq_3 dwArg08, word32 dwArg0C)
{
	Eq_3 ebx_10 = 0x00;
	if (g_tA6CD38 == 0x00)
	{
		word32 edx_648;
		word32 ecx_647;
		Eq_3 eax_17 = fn006ECAC0(0x008B299C, out ecx_647, out edx_648);
		g_tA6CD38 = eax_17;
		if (eax_17 == 0x00)
			return ~0x00;
	}
	Eq_3 eax_37 = *((word32) dwArg08 + 4);
	if (eax_37 == 10611048 && *((word32) dwArg04 + 4) == 10611608)
	{
		word32 ecx_649;
		return fn0070C700(*((word32) dwArg04 + 8), dwArg08, out ecx_649);
	}
	if (eax_37 != 0x00A15380)
	{
		word32 ecx_650;
		word32 edx_651;
		if (fn006D5670(eax_37, 0x00A15380, out ecx_650, out edx_651) == 0x00)
		{
			Eq_3 eax_209 = *((word32) dwArg08 + 4);
			if (eax_209 != 0x00A16588)
			{
				word32 edx_653;
				word32 ecx_652;
				if (fn006D5670(eax_209, 0x00A16588, out ecx_652, out edx_653) == 0x00)
				{
					word32 ecx_654;
					if (fn00703CB0(out ecx_654) == 0x00)
						return ~0x00;
					word32 edx_656;
					word32 ecx_655;
					Eq_3 eax_339 = fn006DE330(dwArg04, g_tA6CD38, out ecx_655, out edx_656);
					if (eax_339 != 0x00)
					{
						word32 ecx_657;
						Eq_3 eax_354 = fn00703BF0(eax_339, dwArg08, out ecx_657);
						word32 v16_359 = (word32) *eax_339 - 1;
						*eax_339 = v16_359;
						ebx_10 = eax_354;
						if (v16_359 != 0x00)
							return ebx_10;
						Eq_3 ecx_378 = *((word32) eax_339 + 4);
						word32 edx_385;
						(*((word32) ecx_378 + 24))();
						return eax_354;
					}
					else
					{
						word32 edx_659;
						word32 ecx_658;
						fn006E1160(out ecx_658, out edx_659);
						return 0x00;
					}
				}
			}
			if (dwArg0C != 0x00)
			{
				Eq_3 ebp_234 = *((word32) dwArg08 + 8);
				Eq_3 edi_235 = 0x00;
				if (ebp_234 <= 0x00)
					return ebx_10;
				word32 * esi_240 = (word32) dwArg08 + 0x0C;
				do
				{
					Eq_3 eax_260 = fn00703D00(dwArg04, *esi_240, dwArg0C + ~0x00);
					ebx_10 = eax_260;
					if (eax_260 != 0x00)
						return ebx_10;
					edi_235 = (word32) edi_235 + 1;
					++esi_240;
				} while (edi_235 < ebp_234);
				return eax_260;
			}
			else
			{
				word32 ecx_665;
				word32 edx_666;
				fn006E0F80(g_tA175E0, 9269884, out ecx_665, out edx_666);
				return ~0x00;
			}
		}
	}
	Eq_3 eax_69 = *((word32) dwArg04 + 4);
	if (eax_69 == dwArg08)
		return 0x01;
	word32 ecx_660;
	word32 edx_661;
	if (fn006D5670(eax_69, dwArg08, out ecx_660, out edx_661) != 0x00)
		return 0x01;
	ebx_10.u0 = 0x00;
	word32 edx_662;
	word32 ecx_118;
	Eq_3 eax_119 = fn006DE330(dwArg04, g_tA6CD38, out ecx_118, out edx_662);
	if (eax_119 == 0x00)
	{
		word32 ecx_663;
		word32 edx_664;
		fn006E1160(out ecx_663, out edx_664);
		return 0x00;
	}
	if (eax_119 != *((word32) dwArg04 + 4))
	{
		Eq_3 eax_130 = *((word32) eax_119 + 4);
		if (eax_130 == 0x00A15380)
		{
l00703ECA:
			word32 edx_667;
			ebx_10 = fn006D5670(eax_119, dwArg08, out ecx_118, out edx_667);
			goto l00703ED6;
		}
		word32 edx_668;
		if (fn006D5670(eax_130, 0x00A15380, out ecx_118, out edx_668) != 0x00)
			goto l00703ECA;
	}
l00703ED6:
	word32 v15_167 = (word32) *eax_119 - 1;
	*eax_119 = v15_167;
	if (v15_167 == 0x00)
	{
		Eq_3 edx_171 = *((word32) eax_119 + 4);
		(*((word32) edx_171 + 24))();
	}
	return ebx_10;
}

// 00703F10: Register Eq_3 fn00703F10(Register Eq_3 ebx, Register word32 ebp, Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Register out ptr32 ecxOut)
// Called from:
//      fn00703F10
//      fn00704020
Eq_3 fn00703F10(Eq_3 ebx, word32 ebp, Eq_3 dwArg04, Eq_3 dwArg08, ptr32 & ecxOut)
{
	Eq_3 eax_112;
	if (*((word32) dwArg04 + 4) == 10611048 && *((word32) dwArg08 + 4) == 10611048)
	{
		eax_112 = (uint32) (int8) (dwArg04 == dwArg08);
		if (eax_112 == 0x00)
		{
			ptr32 ecx_238;
			Eq_3 eax_237 = fn0070C700(dwArg04, dwArg08, out ecx_238);
			ecxOut = ecx_238;
			return eax_237;
		}
		goto l00704017;
	}
	struct Eq_89270 * eax_24 = fn00703B60(dwArg04, out ecx);
	struct Eq_89629 * esp_29 = fp - 0x08;
	if (eax_24 != null)
	{
		word32 v11_33 = eax_24->dw0000 + ~0x00;
		eax_24->dw0000 = v11_33;
		if (v11_33 == 0x00)
		{
			struct Eq_89331 * ecx_37 = eax_24->ptr0004;
			word32 esp_41;
			word32 edx_44;
			ecx_37->ptr0018();
			esp_29 = esp_41 + 0x04;
		}
		Eq_3 eax_51 = *((word32) dwArg08 + 4);
		if (eax_51 != 0x00A16588)
		{
			struct Eq_89706 * esp_55 = esp_29 - 4;
			esp_55->t0000.u0 = 0x00A16588;
			esp_55->tFFFFFFFC = eax_51;
			word32 edx_367;
			if (fn006D5670(esp_55->tFFFFFFFC, esp_55->t0000, out ecx, out edx_367) == 0x00)
			{
				esp_55->t0000.u0 = 9269992;
				if (fn00703CB0(out ecx) != 0x00)
				{
					esp_55->t0000 = dwArg08;
					esp_55->tFFFFFFFC = dwArg04;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_3 stackArg4 = <invalid>;
					ptr32 ecx_180;
					Eq_3 eax_179 = fn00703BF0(stackArg4, dwArg04, out ecx_180);
					ecxOut = ecx_180;
					return eax_179;
				}
l00703F6E:
				ecxOut = ecx;
				return ~0x00;
			}
		}
		word32 eax_72 = esp_29->dw0014;
		struct Eq_89694 * esp_75 = esp_29 - 4;
		esp_75->t0000 = ebx;
		Eq_3 ebx_82 = *((word32) dwArg08 + 8);
		if (eax_72 == 0x00)
		{
			Eq_3 eax_136 = g_tA175E0;
			esp_75->dwFFFFFFFC = 9269884;
			esp_75->tFFFFFFF8 = eax_136;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg4 = <invalid>;
			ptr32 ecx_147;
			word32 edx_370;
			fn006E0F80(stackArg4, dwArg04, out ecx_147, out edx_370);
			ecxOut = ecx_147;
			return ~0x00;
		}
		esp_75->dwFFFFFFFC = ebp;
		Eq_3 edi_108 = 0x00;
		if (ebx_82 > 0x00)
		{
			word32 * esi_122 = (word32) dwArg08 + 0x0C;
			do
			{
				struct Eq_89784 * esp_99 = esp_29 - 8;
				word32 ecx_98 = *esi_122;
				word32 edx_100 = esp_99->dw0014;
				esp_99->dwFFFFFFFC = eax_72 - 0x01;
				esp_99->dwFFFFFFF8 = ecx_98;
				esp_99->dwFFFFFFF4 = edx_100;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_3 stackArg4 = <invalid>;
				eax_112 = fn00703F10(ebx_82, eax_72 - 0x01, stackArg4, dwArg04, out ecx);
				if (eax_112 != 0x00)
					goto l00704015;
				edi_108 = (word32) edi_108 + 1;
				++esi_122;
			} while (edi_108 < ebx_82);
		}
		eax_112.u0 = 0x00;
l00704015:
l00704017:
		ecxOut = ecx;
		return eax_112;
	}
	else
	{
		if (fn006E0FC0() == 0x00)
		{
			word32 edx_366;
			fn006E0F80(g_tA16B7C, dwArg04, out ecx, out edx_366);
		}
		goto l00703F6E;
	}
}

// 00704020: Register Eq_3 fn00704020(Register out ptr32 ecxOut, Register out Eq_540 edxOut)
// Called from:
//      fn006E0FD0
//      fn006E1BD0
Eq_3 fn00704020(ptr32 & ecxOut, union Eq_540 & edxOut)
{
	fn00706DA0();
	ptr32 ecx_15;
	Eq_3 eax_16 = fn00703F10(ebx, ebp, dwArg04, dwArg08, out ecx_15);
	ecxOut = ecx_15;
	edxOut.u0 = <invalid>;
	return eax_16;
}

// 00704040: Register word32 fn00704040(Stack Eq_3 dwArg04, Register out ptr32 ecxOut, Register out ptr32 edxOut)
// Called from:
//      fn006FCC90
//      fn00704BA0
//      fn007072E0
//      fn00735890
//      fn007389B0
word32 fn00704040(Eq_3 dwArg04, ptr32 & ecxOut, ptr32 & edxOut)
{
	Eq_3 ecx_6 = *((word32) dwArg04 + 4);
	union Eq_3 * esp_13;
	word32 eax_14;
	ptr32 ecx_15;
	ptr32 edx_16;
	(*((word32) ecx_6 + 112))();
	if (eax_14 == 0x00)
	{
		if (fn006E0FC0() != 0x00)
		{
			*esp_13 = (union Eq_3 *) g_tA16D00;
			if (fn006E1110(out ecx_15, out edx_16) != 0x00)
				fn006E1160(out ecx_15, out edx_16);
		}
	}
	ecxOut = ecx_15;
	edxOut = edx_16;
	return eax_14;
}

// 00704080: Register Eq_3 fn00704080(Stack Eq_3 dwArg04, Register out (ptr32 charconst ) edxOut)
// Called from:
//      fn00726570
//      fn00735890
//      fn00753C30
Eq_3 fn00704080(Eq_3 dwArg04, const char & edxOut)
{
	if (dwArg04 != 0x00)
	{
		struct Eq_86856 * eax_10 = *((word32) *((word32) dwArg04 + 4) + 52);
		if (eax_10 != null)
		{
			<anonymous> * eax_14 = eax_10->ptr0000;
			if (eax_14 != null)
			{
				Eq_3 eax_31;
				const char * edx_32;
				eax_14();
				edxOut = edx_32;
				return eax_31;
			}
		}
		const char * edx_25;
		Eq_3 eax_24 = fn00703690(dwArg04, out edx_25);
		edxOut = edx_25;
		return eax_24;
	}
	else
	{
		if (fn006E0FC0() == 0x00)
		{
			word32 ecx_93;
			fn006E0F80(g_tA18720, 9268368, out ecx_93, out edx);
		}
		edxOut = edx;
		return ~0x00;
	}
}

// 007040D0: Register Eq_3 fn007040D0(Register Eq_3 edi, Stack Eq_3 dwArg04)
// Called from:
//      fn006F3930
//      fn00704BA0
Eq_3 fn007040D0(Eq_3 edi, Eq_3 dwArg04)
{
	Eq_3 eax_150;
	ptr32 esp_41 = fp - 0x0C;
	if (dwArg04 == 0x00)
	{
		if (fn006E0FC0() == 0x00)
		{
			word32 ecx_371;
			word32 edx_372;
			fn006E0F80(g_tA18720, 9268368, out ecx_371, out edx_372);
			esp_41 = fp - 0x0C;
		}
		goto l00704121;
	}
	ptr32 esp_26;
	struct Eq_86856 * eax_13 = *((word32) *((word32) dwArg04 + 4) + 52);
	if (eax_13 != null)
	{
		<anonymous> * eax_17 = eax_13->ptr0000;
		if (eax_17 != null)
		{
			eax_17();
l00704115:
			esp_41 = esp_26 + 0x04;
			if (eax_150 != ~0x00)
				return eax_150;
l00704121:
			union Eq_3 * esp_66 = esp_41 - 4;
			*esp_66 = (union Eq_3 *) g_tA16B7C;
			word32 ecx_369;
			word32 edx_370;
			if (fn006E1110(out ecx_369, out edx_370) == 0x00)
			{
				*esp_66 = (union Eq_3 *) g_tA178F0;
				word32 ecx_378;
				word32 edx_379;
				if (fn006E1110(out ecx_378, out edx_379) == 0x00)
					goto l00704214;
			}
			struct Eq_89967 * esp_97 = esp_41 - 4;
			esp_97->t0000 = esp_41 + 0x10;
			esp_97->tFFFFFFFC = &esp_97->t0008;
			esp_97->tFFFFFFF8 = &esp_97->t000C;
			fn006E1130(esp_97->tFFFFFFF8, esp_97->tFFFFFFFC, esp_97->t0000);
			esp_97->dwFFFFFFF4 = 0x00;
			esp_97->dwFFFFFFF0 = 0x008D1E78;
			esp_97->tFFFFFFEC = dwArg04;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg4 = <invalid>;
			Eq_3 stackArg12 = <invalid>;
			word32 ecx_376;
			word32 edx_377;
			Eq_3 eax_121 = fn007038E0(stackArg4, dwArg04, stackArg12, out ecx_376, out edx_377);
			if (eax_121 != 0x00)
			{
				esp_97->t0000 = edi;
				esp_97->tFFFFFFFC = eax_121;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_3 stackArg4 = <invalid>;
				word32 ecx_383;
				word32 edx_384;
				word32 esi_385;
				word32 edi_386;
				Eq_3 eax_171 = fn007051A0(edi, stackArg4, out ecx_383, out edx_384, out esi_385, out edi_386);
				word32 v12_177 = (word32) *eax_121 - 1;
				*eax_121 = v12_177;
				struct Eq_89967 * esp_176 = esp_97;
				if (v12_177 == 0x00)
				{
					Eq_3 ecx_182 = *((word32) eax_121 + 4);
					<anonymous> * edx_183 = *((word32) ecx_182 + 24);
					esp_97->tFFFFFFFC = eax_121;
					word32 esp_186;
					edx_183();
					esp_176 = esp_186 + 0x04;
				}
				Eq_3 eax_196 = esp_176->t000C;
				if (eax_196 != 0x00)
				{
					*eax_196 = (word32) *eax_196 - 1;
					Eq_3 eax_202 = esp_176->t000C;
					if (*eax_202 == 0x00)
					{
						Eq_3 ecx_205 = *((word32) eax_202 + 4);
						<anonymous> * edx_206 = *((word32) ecx_205 + 24);
						esp_176->tFFFFFFFC = eax_202;
						word32 esp_212;
						edx_206();
						esp_176 = esp_212 + 0x04;
					}
				}
				Eq_3 eax_222 = esp_176->t0008;
				if (eax_222 != 0x00)
				{
					*eax_222 = (word32) *eax_222 - 1;
					Eq_3 eax_228 = esp_176->t0008;
					if (*eax_228 == 0x00)
					{
						Eq_3 ecx_231 = *((word32) eax_228 + 4);
						<anonymous> * edx_232 = *((word32) ecx_231 + 24);
						esp_176->tFFFFFFFC = eax_228;
						word32 esp_238;
						edx_232();
						esp_176 = esp_238 + 0x04;
					}
				}
				Eq_3 eax_248 = esp_176->t0014;
				if (eax_248 != 0x00)
				{
					*eax_248 = (word32) *eax_248 - 1;
					Eq_3 eax_254 = esp_176->t0014;
					if (*eax_254 == 0x00)
					{
						Eq_3 ecx_257 = *((word32) eax_254 + 4);
						<anonymous> * edx_258 = *((word32) ecx_257 + 24);
						esp_176->tFFFFFFFC = eax_254;
						edx_258();
					}
				}
				return eax_171;
			}
			Eq_3 ecx_132 = esp_97->t0008;
			Eq_3 edx_133 = esp_97->t000C;
			esp_97->t0000 = esp_97->t0014;
			esp_97->tFFFFFFFC = ecx_132;
			esp_97->tFFFFFFF8 = edx_133;
			word32 edx_381;
			word32 ecx_380;
			fn006E0E00(esp_97->t0000, out ecx_380, out edx_381);
l00704214:
			eax_150.u0 = ~0x00;
			return eax_150;
		}
	}
	word32 edx_373;
	eax_150 = fn00703690(dwArg04, out edx_373);
	esp_26 = fp - 0x10;
	goto l00704115;
}

// 00704220: Register Eq_3 fn00704220(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Register out Eq_79220 ecxOut, Register out ptr32 edxOut)
// Called from:
//      fn006F9120
//      fn006FCC90
//      fn00707E00
//      fn00708DC0
//      fn00726570
//      fn0073B310
Eq_3 fn00704220(Eq_3 dwArg04, Eq_3 dwArg08, union Eq_79220 & ecxOut, ptr32 & edxOut)
{
	if (dwArg04 == 0x00 || dwArg08 == 0x00)
	{
		if (fn006E0FC0() == 0x00)
			fn006E0F80(g_tA18720, 9268368, out ecx, out edx);
		ecxOut = ecx;
		edxOut = edx;
		return 0x00;
	}
	Eq_3 esi_46 = *((word32) dwArg04 + 4);
	struct Eq_88157 * ecx_47 = *((word32) esi_46 + 56);
	if (ecx_47 != null)
	{
		<anonymous> * ecx_51 = ecx_47->ptr0004;
		if (ecx_51 != null)
		{
			Eq_3 eax_182;
			Eq_79220 ecx_183;
			ptr32 edx_184;
			ecx_51();
			ecxOut = ecx_183;
			edxOut = edx_184;
			return eax_182;
		}
	}
	ptr32 edx_103;
	Eq_79220 ecx_102;
	struct Eq_86856 * edi_61 = *((word32) esi_46 + 52);
	if (edi_61 != null)
	{
		Eq_3 edx_66 = *((word32) dwArg08 + 4);
		struct Eq_85087 * ecx_67 = *((word32) edx_66 + 48);
		if (ecx_67 != null && ((*((word32) edx_66 + 84) & 0x00020000) != 0x00 && ecx_67->ptr0098 != null))
		{
			if (fn00702C30(dwArg08, g_tA17CA4, out ecx_102, out edx_103) != ~0x00 || fn006E0FC0() == 0x00)
			{
				Eq_79220 ecx_165;
				ptr32 edx_166;
				Eq_3 eax_164 = fn00703180(dwArg04, dwArg04, out ecx_165, out edx_166);
				ecxOut = ecx_165;
				edxOut = edx_166;
				return eax_164;
			}
l007042D5:
			ecxOut = ecx_102;
			edxOut = edx_103;
			return 0x00;
		}
		if (edi_61->ptr000C != null)
		{
			Eq_79220 ecx_112;
			ptr32 edx_113;
			Eq_3 eax_111 = fn00701800(out ecx_112, out edx_113);
			ecxOut = ecx_112;
			edxOut = edx_113;
			return eax_111;
		}
	}
	fn006E15D0(g_tA16B7C, 0x008D7344, out ecx_102, out edx_103);
	goto l007042D5;
}

// 00704300: Register word32 fn00704300(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Stack Eq_3 dwArg0C, Register out Eq_90326 ecxOut)
// Called from:
//      fn00707F70
//      fn00708210
//      fn00708DC0
//      fn0073B2B0
word32 fn00704300(Eq_3 dwArg04, Eq_3 dwArg08, Eq_3 dwArg0C, union Eq_90326 & ecxOut)
{
	if (dwArg04 == 0x00 || (dwArg08 == 0x00 || dwArg0C == 0x00))
	{
		if (fn006E0FC0() == 0x00)
		{
			word32 edx_339;
			fn006E0F80(g_tA18720, 9268368, out ecx, out edx_339);
		}
		ecxOut = ecx;
		return ~0x00;
	}
	Eq_3 esi_57 = *((word32) dwArg04 + 4);
	struct Eq_88157 * ecx_58 = *((word32) esi_57 + 56);
	if (ecx_58 != null)
	{
		<anonymous> * ecx_62 = ecx_58->ptr0008;
		if (ecx_62 != null)
		{
			word32 eax_210;
			Eq_90326 ecx_211;
			word32 edx_212;
			ecx_62();
			ecxOut = ecx_211;
			return eax_210;
		}
	}
	struct Eq_86856 * edi_72 = *((word32) esi_57 + 52);
	if (edi_72 != null)
	{
		Eq_90326 ecx_136;
		Eq_3 edx_77 = *((word32) dwArg08 + 4);
		struct Eq_85087 * ecx_78 = *((word32) edx_77 + 48);
		if (ecx_78 != null && ((*((word32) edx_77 + 84) & 0x00020000) != 0x00 && ecx_78->ptr0098 != null))
		{
			word32 edx_341;
			if (fn00702C30(dwArg08, g_tA17CA4, out ecx_136, out edx_341) != ~0x00 || fn006E0FC0() == 0x00)
			{
				Eq_90326 ecx_189;
				word32 eax_188 = fn00703300(dwArg04, dwArg04, dwArg08, out ecx_189);
				ecxOut = ecx_189;
				return eax_188;
			}
			goto l007043AB;
		}
		if (edi_72->ptr0014 != null)
		{
			word32 edx_342;
			fn00701800(out ecx_136, out edx_342);
l007043AB:
			ecxOut = ecx_136;
			return ~0x00;
		}
	}
	Eq_90326 ecx_116;
	word32 edx_340;
	fn006E15D0(g_tA16B7C, 9269564, out ecx_116, out edx_340);
	ecxOut = ecx_116;
	return ~0x00;
}

// 00704400: Register int32 fn00704400(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Register out Eq_90438 ecxOut)
// Called from:
//      fn00707F70
//      fn00708DC0
//      fn0073B2B0
int32 fn00704400(Eq_3 dwArg04, Eq_3 dwArg08, union Eq_90438 & ecxOut)
{
	if (dwArg04 == 0x00 || dwArg08 == 0x00)
	{
		if (fn006E0FC0() == 0x00)
		{
			word32 edx_299;
			fn006E0F80(g_tA18720, 9268368, out ecx, out edx_299);
		}
		ecxOut = ecx;
		return ~0x00;
	}
	Eq_3 esi_47 = *((word32) dwArg04 + 4);
	struct Eq_88157 * ecx_48 = *((word32) esi_47 + 56);
	if (ecx_48 != null)
	{
		<anonymous> * ecx_52 = ecx_48->ptr0008;
		if (ecx_52 != null)
		{
			int32 eax_188;
			Eq_90438 ecx_189;
			word32 edx_190;
			ecx_52();
			ecxOut = ecx_189;
			return eax_188;
		}
	}
	struct Eq_86856 * edi_62 = *((word32) esi_47 + 52);
	if (edi_62 != null)
	{
		Eq_90438 ecx_121;
		Eq_3 edx_67 = *((word32) dwArg08 + 4);
		struct Eq_85087 * ecx_68 = *((word32) edx_67 + 48);
		if (ecx_68 != null && ((*((word32) edx_67 + 84) & 0x00020000) != 0x00 && ecx_68->ptr0098 != null))
		{
			word32 edx_301;
			if (fn00702C30(dwArg08, g_tA17CA4, out ecx_121, out edx_301) != ~0x00 || fn006E0FC0() == 0x00)
			{
				Eq_90438 ecx_169;
				word32 edx_302;
				int32 eax_168 = fn00703390(dwArg04, dwArg04, out ecx_169, out edx_302);
				ecxOut = ecx_169;
				return eax_168;
			}
			goto l0070449C;
		}
		if (edi_62->ptr0014 != null)
		{
			word32 edx_303;
			fn00701800(out ecx_121, out edx_303);
l0070449C:
			ecxOut = ecx_121;
			return ~0x00;
		}
	}
	Eq_90438 ecx_103;
	word32 edx_300;
	fn006E15D0(g_tA16B7C, 0x008D7398, out ecx_103, out edx_300);
	ecxOut = ecx_103;
	return ~0x00;
}

// 007044F0: Register word32 fn007044F0(Register Eq_3 edx, Stack Eq_3 dwArg04, Stack Eq_3 dwArg08)
// Called from:
//      fn00704560
//      fn00704610
word32 fn007044F0(Eq_3 edx, Eq_3 dwArg04, Eq_3 dwArg08)
{
	Eq_3 ecx_6 = *((word32) edx + 4);
	struct Eq_85087 * eax_7 = *((word32) ecx_6 + 48);
	if (eax_7 == null || ((*((word32) ecx_6 + 84) & 0x00020000) == 0x00 || eax_7->ptr0098 == null))
	{
		word32 edx_126;
		word32 ecx_125;
		fn006E15D0(g_tA16B7C, 0x008D73C8, out ecx_125, out edx_126);
		return 0x00;
	}
	else
	{
		word32 edx_48;
		word32 ecx_127;
		Eq_3 eax_49 = fn00702C30(edx, g_tA18598, out ecx_127, out edx_48);
		if (eax_49 == ~0x00 && fn006E0FC0() != 0x00)
			return 0x00;
		word32 eax_73;
		dwArg04();
		return eax_73;
	}
}

// 00704560: Register (ptr32 Eq_85079) fn00704560(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08)
// Called from:
//      fn00708DC0
//      fn00726570
struct Eq_85079 * fn00704560(Eq_3 dwArg04, Eq_3 dwArg08)
{
	struct Eq_85079 * eax_111 = fn00701B50(dwArg04, dwArg08, (struct Eq_85079 *) 0x08);
	ptr32 esp_31 = fp - 0x10;
	if (eax_111 != &g_dwA16480)
		return eax_111;
	struct Eq_86856 * ebx_36 = *((word32) *((word32) dwArg04 + 4) + 52);
	struct Eq_86856 * ebp_37 = *((word32) *((word32) dwArg08 + 4) + 52);
	word32 v12_38 = eax_111->dw0000 + ~0x00;
	eax_111->dw0000 = v12_38;
	if (v12_38 == 0x00)
	{
		struct Eq_86365 * ecx_42 = eax_111->ptr0004;
		word32 esp_46;
		ecx_42->ptr0018();
		esp_31 = esp_46 + 0x04;
	}
	if (ebx_36 != null)
	{
		word32 ebx_59 = ebx_36->dw0008;
		if (ebx_59 != 0x00)
		{
			struct Eq_90658 * esp_145 = esp_31 - 4;
			esp_145->t0000 = dwArg04;
			esp_145->dwFFFFFFFC = ebx_59;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg4 = <invalid>;
			return fn007044F0(dwArg08, stackArg4, dwArg04);
		}
	}
	if (ebp_37 != null)
	{
		word32 eax_69 = ebp_37->dw0008;
		if (eax_69 != 0x00)
		{
			struct Eq_90721 * esp_124 = esp_31 - 4;
			esp_124->t0000 = dwArg08;
			esp_124->dwFFFFFFFC = eax_69;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg4 = <invalid>;
			return fn007044F0(dwArg04, stackArg4, dwArg04);
		}
	}
	Eq_3 eax_83 = *((word32) *((word32) dwArg04 + 4) + 0x0C);
	struct Eq_90678 * esp_87 = esp_31 - 4;
	esp_87->t0000 = *((word32) *((word32) dwArg08 + 4) + 0x0C);
	Eq_3 ecx_89 = g_tA16B7C;
	esp_87->tFFFFFFFC = eax_83;
	esp_87->dwFFFFFFF8 = 0x008A7F90;
	esp_87->dwFFFFFFF4 = 0x008D6D48;
	esp_87->tFFFFFFF0 = ecx_89;
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_3 stackArg4 = <invalid>;
	word32 ecx_242;
	word32 edx_243;
	fn006E15D0(stackArg4, dwArg04, out ecx_242, out edx_243);
	eax_111 = null;
	return eax_111;
}

// 00704610: Register (ptr32 Eq_85079) fn00704610(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08)
// Called from:
//      fn00708DC0
struct Eq_85079 * fn00704610(Eq_3 dwArg04, Eq_3 dwArg08)
{
	struct Eq_85079 * eax_185;
	Eq_3 eax_15 = *((word32) dwArg04 + 4);
	struct Eq_85087 * ecx_16 = *((word32) eax_15 + 48);
	ptr32 esp_19 = fp - 16;
	if (ecx_16 != null && (*((word32) eax_15 + 84) & 0x08) != 0x00)
	{
		<anonymous> * ecx_26 = ecx_16->ptr0064;
		if (ecx_26 != null)
		{
			struct Eq_90793 * esp_34;
			ecx_26();
			esp_19 = (const char *) &esp_34->ptr0004 + 4;
			if (eax_185 != &g_dwA16480)
				return eax_185;
			word32 v13_43 = eax_185->dw0000 + ~0x00;
			eax_185->dw0000 = v13_43;
			if (v13_43 == 0x00)
			{
				struct Eq_86365 * ecx_47 = eax_185->ptr0004;
				<anonymous> * edx_48 = ecx_47->ptr0018;
				esp_34->ptr0004 = eax_185;
				word32 esp_51;
				edx_48();
				esp_19 = esp_51 + 0x04;
			}
		}
	}
	struct Eq_90751 * esp_60 = esp_19 - 4;
	esp_60->ptr0000 = (struct Eq_85079 *) 0x08;
	esp_60->tFFFFFFFC = dwArg08;
	esp_60->tFFFFFFF8 = dwArg04;
	eax_185 = fn00701B50(esp_60->tFFFFFFF8, esp_60->tFFFFFFFC, esp_60->ptr0000);
	ptr32 esp_112 = (const char *) &esp_60->ptr0000 + 4;
	if (eax_185 != &g_dwA16480)
		return eax_185;
	struct Eq_86856 * edi_80 = *((word32) *((word32) dwArg04 + 4) + 52);
	struct Eq_86856 * ebx_81 = *((word32) *((word32) dwArg08 + 4) + 52);
	word32 v15_82 = eax_185->dw0000 + ~0x00;
	eax_185->dw0000 = v15_82;
	if (v15_82 == 0x00)
	{
		struct Eq_86365 * ecx_86 = eax_185->ptr0004;
		<anonymous> * edx_87 = ecx_86->ptr0018;
		esp_60->ptr0000 = eax_185;
		word32 esp_91;
		edx_87();
		esp_112 = esp_91 + 0x04;
	}
	if (edi_80 != null)
	{
		word32 eax_141;
		if ((*((word32) *((word32) dwArg04 + 4) + 84) & 0x08) != 0x00)
		{
			eax_141 = edi_80->dw0024;
			if (eax_141 != 0x00)
			{
l007046A5:
				struct Eq_90887 * esp_199 = esp_112 - 4;
				esp_199->t0000 = dwArg04;
				esp_199->dwFFFFFFFC = eax_141;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_3 stackArg4 = <invalid>;
				return fn007044F0(dwArg08, stackArg4, dwArg04);
			}
		}
		eax_141 = edi_80->dw0008;
		if (eax_141 != 0x00)
			goto l007046A5;
	}
	else if (ebx_81 != null)
	{
		word32 ebx_108 = ebx_81->dw0008;
		if (ebx_108 != 0x00)
		{
			struct Eq_90949 * esp_113 = esp_112 - 4;
			esp_113->t0000 = dwArg08;
			esp_113->dwFFFFFFFC = ebx_108;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg4 = <invalid>;
			return fn007044F0(dwArg04, stackArg4, dwArg04);
		}
	}
	Eq_3 ecx_159 = *((word32) *((word32) dwArg04 + 4) + 0x0C);
	struct Eq_90906 * esp_162 = esp_112 - 4;
	esp_162->t0000 = *((word32) *((word32) dwArg08 + 4) + 0x0C);
	Eq_3 edx_164 = g_tA16B7C;
	esp_162->tFFFFFFFC = ecx_159;
	esp_162->dwFFFFFFF8 = 9270268;
	esp_162->dwFFFFFFF4 = 0x008D6D48;
	esp_162->tFFFFFFF0 = edx_164;
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_3 stackArg4 = <invalid>;
	word32 edx_318;
	word32 ecx_317;
	fn006E15D0(stackArg4, dwArg04, out ecx_317, out edx_318);
	eax_185 = null;
	return eax_185;
}

// 00704700: Register word32 fn00704700(Stack Eq_3 dwArg04, Register out Eq_540 edxOut)
// Called from:
//      fn006E5710
//      fn00704B00
//      fn00725DA0
word32 fn00704700(Eq_3 dwArg04, union Eq_540 & edxOut)
{
	if (dwArg04 == 0x00 || *((word32) dwArg04 + 4) != 10611608)
	{
		if (fn00703D00(dwArg04, 0x00A1D1B8, fn00706DA0()) == 0x00 && dwArg04 != 0x00)
		{
			struct Eq_86856 * eax_35 = *((word32) *((word32) dwArg04 + 4) + 52);
			if (eax_35 != null && eax_35->ptr000C != null)
			{
				edxOut.u0 = <invalid>;
				return 0x01;
			}
		}
		edxOut.u0 = <invalid>;
		return 0x00;
	}
	else
	{
		word32 edx_97;
		word32 eax_56 = fn006DF7C0(dwArg04, 0x008D0B00, out edx_97);
		edxOut.u0 = <invalid>;
		return eax_56;
	}
}

// 00704B00: Register (ptr32 Eq_91000) fn00704B00(Stack Eq_3 dwArg04, Register out ptr32 ecxOut, Register out ptr32 edxOut)
// Called from:
//      fn006F3930
//      fn006FCC90
//      fn00704BA0
//      fn00704DA0
//      fn00704E40
//      fn007072E0
//      fn00708DC0
//      fn00735890
//      fn007389B0
struct Eq_91000 * fn00704B00(Eq_3 dwArg04, ptr32 & ecxOut, ptr32 & edxOut)
{
	Eq_3 eax_8 = *((word32) dwArg04 + 4);
	if ((*((word32) eax_8 + 84) & 0x80) != 0x00)
	{
		<anonymous> * eax_12 = *((word32) eax_8 + 0x006C);
		if (eax_12 != null)
		{
			struct Eq_91024 * esp_18;
			struct Eq_91000 * eax_19;
			ptr32 ecx_142;
			ptr32 edx_145;
			eax_12();
			struct Eq_91000 * esi_24 = eax_19;
			if (eax_19 != null)
			{
				struct Eq_91051 * eax_29 = eax_19->ptr0004;
				if ((eax_29->b0054 & 0x80) == 0x00 || eax_29->dw0070 == 0x00)
				{
					Eq_3 ecx_38 = g_tA16B7C;
					esp_18->ptr0000 = eax_29->ptr000C;
					esp_18->dwFFFFFFFC = 0x008D744C;
					esp_18->tFFFFFFF8 = ecx_38;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_3 stackArg4 = <invalid>;
					fn006E15D0(stackArg4, dwArg04, out ecx_142, out edx_145);
					word32 v11_55 = eax_19->dw0000 + ~0x00;
					eax_19->dw0000 = v11_55;
					if (v11_55 == 0x00)
					{
						struct Eq_91051 * edx_59 = eax_19->ptr0004;
						<anonymous> * eax_60 = edx_59->ptr0018;
						esp_18->ptr0000 = eax_19;
						eax_60();
					}
					esi_24 = null;
				}
			}
			ecxOut = ecx_142;
			edxOut = edx_145;
			return esi_24;
		}
	}
	word32 edx_191;
	if (fn00704700(dwArg04, out edx_191) == 0x00)
	{
		ptr32 ecx_108;
		ptr32 edx_109;
		fn006E15D0(g_tA16B7C, dwArg04, out ecx_108, out edx_109);
		ecxOut = ecx_108;
		edxOut = edx_109;
		return null;
	}
	else
	{
		ptr32 ecx_122;
		ptr32 edx_123;
		struct Eq_91000 * eax_121 = fn00725DA0(dwArg04, out ecx_122, out edx_123);
		ecxOut = ecx_122;
		edxOut = edx_123;
		return eax_121;
	}
}

// 00704BA0: Register Eq_3 fn00704BA0(Stack Eq_3 dwArg04)
// Called from:
//      fn00707BD0
Eq_3 fn00704BA0(Eq_3 dwArg04)
{
	if (dwArg04 == 0x00)
	{
		if (fn006E0FC0() == 0x00)
		{
			word32 ecx_674;
			word32 edx_675;
			fn006E0F80(g_tA18720, 9268368, out ecx_674, out edx_675);
		}
		return 0x00;
	}
	Eq_3 eax_14 = *((word32) dwArg04 + 4);
	if (eax_14 == 0x00A16588)
	{
		*dwArg04 = (word32) *dwArg04 + 1;
		return dwArg04;
	}
	if (eax_14 == 0x00A1BAF0)
		return fn006F4F00(dwArg04);
	word32 edx_677;
	word32 ecx_676;
	if (fn006D5670(eax_14, 0x00A1BAF0, out ecx_676, out edx_677) != 0x00)
		return fn006F4F00(dwArg04);
	word32 edx_679;
	word32 ecx_678;
	Eq_3 eax_59 = fn00704B00(dwArg04, out ecx_678, out edx_679);
	Eq_3 ebx_240 = eax_59;
	if (eax_59 == 0x00)
		return eax_59;
	Eq_3 eax_76 = fn007040D0(edi, dwArg04);
	Eq_3 edi_122 = eax_76;
	if (eax_76 < 0x00)
	{
		if (fn006E0FC0() != 0x00)
		{
			word32 ecx_684;
			word32 edx_685;
			if (fn006E1110(out ecx_684, out edx_685) == 0x00)
			{
				word32 ecx_686;
				word32 edx_687;
				if (fn006E1110(out ecx_686, out edx_687) == 0x00)
				{
					word32 v15_407 = (word32) *eax_59 - 1;
					*eax_59 = v15_407;
					if (v15_407 == 0x00)
					{
						Eq_3 eax_411 = *((word32) eax_59 + 4);
						<anonymous> * ecx_412 = *((word32) eax_411 + 24);
						word32 edx_418;
						ecx_412();
					}
					return 0x00;
				}
			}
		}
		word32 edx_683;
		word32 ecx_682;
		fn006E1160(out ecx_682, out edx_683);
		edi_122.u0 = 0x0A;
	}
	word32 edx_681;
	word32 ecx_680;
	Eq_3 eax_142 = fn006DFD20(edi_122, out ecx_680, out edx_681);
	struct Eq_91181 * esp_146 = fp - 0x14;
	if (eax_142 != 0x00)
	{
		word32 ecx_688;
		word32 edx_689;
		Eq_3 eax_158 = fn00704040(eax_59, out ecx_688, out edx_689);
		Eq_3 ebp_153 = 0x00;
		Eq_3 esi_162 = eax_158;
		if (eax_158 != 0x00)
		{
			ptr32 ebx_167 = 0x0C;
			do
			{
				if (ebp_153 >= edi_122)
				{
					word32 esp_199;
					int32 edi_173 = (word64) edi_122.u0 + 0x0A;
					edi_122 = edi_173 + (edi_173 >> 0x02);
					if (edi_122 < edi_122)
					{
						word32 ecx_692;
						word32 edx_693;
						fn006E1210(out ecx_692, out edx_693);
						word32 v19_191 = (word32) *esi_162 - 1;
						*esi_162 = v19_191;
						esp_146 = fp - 0x14;
						if (v19_191 == 0x00)
						{
							Eq_3 eax_195 = *((word32) esi_162 + 4);
							<anonymous> * ecx_196 = *((word32) eax_195 + 24);
							word32 edx_202;
							ecx_196();
l00704D4A:
							esp_146 = esp_199 + 0x04;
						}
l00704D4D:
						ebx_240 = esp_146->t0018;
						goto l00704D51;
					}
					else
					{
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_3 stackArg0 = <invalid>;
						esp_146 = fp - 0x14;
						word32 ecx_211;
						if (fn006E0B00(stackArg0, fp - 0x04, dwArg04, out ecx_211) == 0x00)
							goto l00704CC9;
						word32 v18_220 = (word32) *esi_162 - 1;
						*esi_162 = v18_220;
						if (v18_220 != 0x00)
							goto l00704D4D;
						Eq_3 edx_224 = *((word32) esi_162 + 4);
						(*((word32) edx_224 + 24))();
						goto l00704D4A;
					}
				}
l00704CC9:
				*((word32) eax_142 + ebx_167) = esi_162;
				word32 ecx_690;
				word32 edx_691;
				Eq_3 eax_258 = fn00704040(dwArg04, out ecx_690, out edx_691);
				ebp_153 = (word32) ebp_153 + 1;
				ebx_167 += 0x04;
				esi_162 = eax_258;
			} while (eax_258 != 0x00);
			ebx_240 = dwArg04;
		}
		esp_146 = fp - 0x14;
		if (fn006E0FC0() == 0x00)
		{
			if (ebp_153 >= edi_122)
			{
l00704D0C:
				word32 v21_373 = (word32) *ebx_240 - 1;
				*ebx_240 = v21_373;
				if (v21_373 == 0x00)
				{
					Eq_3 ecx_377 = *((word32) ebx_240 + 4);
					word32 edx_389;
					(*((word32) ecx_377 + 24))();
				}
				return eax_142;
			}
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg0 = <invalid>;
			esp_146 = fp - 0x14;
			word32 ecx_696;
			if (fn006E0B00(stackArg0, fp - 0x04, dwArg04, out ecx_696) == 0x00)
				goto l00704D0C;
		}
l00704D51:
		Eq_3 eax_299 = esp_146->t0010;
		if (eax_299 != 0x00)
		{
			*eax_299 = (word32) *eax_299 - 1;
			Eq_3 eax_305 = esp_146->t0010;
			if (*eax_305 == 0x00)
			{
				Eq_3 ecx_308 = *((word32) eax_305 + 4);
				<anonymous> * edx_309 = *((word32) ecx_308 + 24);
				esp_146->tFFFFFFFC = eax_305;
				word32 esp_325;
				word32 edx_328;
				edx_309();
				esp_146 = esp_325 + 0x04;
			}
		}
	}
	word32 v17_335 = (word32) *ebx_240 - 1;
	*ebx_240 = v17_335;
	if (v17_335 == 0x00)
	{
		Eq_3 eax_339 = *((word32) ebx_240 + 4);
		<anonymous> * ecx_340 = *((word32) eax_339 + 24);
		esp_146->tFFFFFFFC = ebx_240;
		word32 edx_351;
		ecx_340();
	}
	return 0x00;
}

// 00704DA0: Register Eq_3 fn00704DA0(Stack Eq_3 dwArg04)
// Called from:
//      fn006F31C0
//      fn006F3930
Eq_3 fn00704DA0(Eq_3 dwArg04)
{
	if (dwArg04 != 0x00)
	{
		Eq_3 ecx_9 = *((word32) dwArg04 + 4);
		if (ecx_9 == 0x00A1BAF0 || ecx_9 == 0x00A16588)
		{
			*dwArg04 = (word32) *dwArg04 + 1;
			return dwArg04;
		}
		else
		{
			word32 ecx_207;
			word32 edx_208;
			Eq_3 eax_25 = fn00704B00(dwArg04, out ecx_207, out edx_208);
			if (eax_25 != 0x00)
			{
				Eq_3 eax_41 = fn007035C0(eax_25);
				word32 v13_47 = (word32) *eax_25 - 1;
				*eax_25 = v13_47;
				if (v13_47 == 0x00)
				{
					Eq_3 ecx_52 = *((word32) eax_25 + 4);
					word32 edx_59;
					(*((word32) ecx_52 + 24))();
				}
				return eax_41;
			}
			else
			{
				word32 ecx_209;
				word32 edx_210;
				if (fn006E1110(out ecx_209, out edx_210) != 0x00)
				{
					word32 ecx_211;
					word32 edx_212;
					fn006E0F80(g_tA16B7C, dwArg04, out ecx_211, out edx_212);
				}
				return 0x00;
			}
		}
	}
	else
	{
		if (fn006E0FC0() == 0x00)
		{
			word32 edx_206;
			word32 ecx_205;
			fn006E0F80(g_tA18720, 9268368, out ecx_205, out edx_206);
		}
		return 0x00;
	}
}

// 00704E40: Register word32 fn00704E40(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08)
// Called from:
//      fn00704FE0
word32 fn00704E40(Eq_3 dwArg04, Eq_3 dwArg08)
{
	word32 ebx_11 = 0x00;
	if (dwArg04 == 0x00 || dwArg08 == 0x00)
	{
		if (fn006E0FC0() == 0x00)
		{
			word32 edx_438;
			word32 ecx_437;
			fn006E0F80(g_tA18720, 9268368, out ecx_437, out edx_438);
		}
		return ~0x00;
	}
	word32 ecx_433;
	word32 edx_434;
	Eq_3 eax_54 = fn00704B00(dwArg04, out ecx_433, out edx_434);
	if (eax_54 == 0x00)
	{
		word32 edx_436;
		word32 ecx_435;
		fn006E15D0(g_tA16B7C, dwArg04, out ecx_435, out edx_436);
		return ~0x00;
	}
	struct Eq_91536 * esp_117 = fp - 16;
	while (true)
	{
		ptr32 esp_124;
		Eq_3 eax_69 = *((word32) eax_54 + 4);
		<anonymous> * ecx_70 = *((word32) eax_69 + 112);
		esp_117->tFFFFFFFC = eax_54;
		struct Eq_91564 * esp_78;
		Eq_3 eax_79;
		word32 ecx_80;
		word32 edx_81;
		ecx_70();
		if (eax_79 == 0x00)
			break;
		word32 edx_126 = esp_78->dw001C;
		esp_78->t0000.u0 = 0x02;
		esp_78->tFFFFFFFC = eax_79;
		esp_78->dwFFFFFFF8 = edx_126;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_3 stackArg4 = <invalid>;
		word32 edx_440;
		int32 eax_134 = fn006DF5A0(stackArg4, dwArg04, dwArg08, out edx_440);
		word32 v14_140 = (word32) *eax_79 - 1;
		*eax_79 = v14_140;
		esp_117 = (struct Eq_91536 *) ((const char *) &esp_78->t0000 + 4);
		if (v14_140 == 0x00)
		{
			Eq_3 eax_145 = *((word32) eax_79 + 4);
			<anonymous> * ecx_146 = *((word32) eax_145 + 24);
			esp_78->t0000 = eax_79;
			word32 esp_149;
			word32 ecx_151;
			word32 edx_152;
			ecx_146();
			esp_117 = esp_149 + 0x04;
		}
		if (eax_134 < 0x00)
			goto l00704F7A;
		if (eax_134 > 0x00)
		{
			word32 eax_163 = esp_117->dw001C;
			if (eax_163 == 0x01)
			{
				if (ebx_11 == 0x7FFFFFFF)
				{
					Eq_3 edx_170 = g_tA18598;
					struct Eq_91709 * esp_171 = esp_117 - 4;
					esp_171->dw0000 = 0x008D747C;
					esp_171->tFFFFFFFC = edx_170;
					esp_124 = esp_171 - 4;
					goto l00704F72;
				}
				else
				{
					++ebx_11;
					continue;
				}
			}
			if (eax_163 == 0x02)
			{
				if (esp_117->dw0014 == 0x00)
					goto l00704F7D;
				Eq_3 ecx_182 = g_tA18598;
				struct Eq_91765 * esp_183 = esp_117 - 4;
				esp_183->dw0000 = 9270428;
				esp_183->tFFFFFFFC = ecx_182;
				esp_124 = esp_183 - 4;
				goto l00704F72;
			}
			if (eax_163 == 0x03)
			{
				ebx_11 = 0x01;
				goto l00704F7D;
			}
		}
		if (esp_117->dw001C == 0x02)
		{
			if (ebx_11 == 0x7FFFFFFF)
				esp_117->dw0014 = 0x01;
			++ebx_11;
		}
	}
	if (fn006E0FC0() != 0x00)
	{
		esp_78->t0000 = g_tA16D00;
		word32 edx_442;
		word32 ecx_441;
		if (fn006E1110(out ecx_441, out edx_442) != 0x00)
		{
			word32 ecx_443;
			word32 edx_444;
			fn006E1160(out ecx_443, out edx_444);
		}
	}
	esp_117 = (struct Eq_91536 *) ((const char *) &esp_78->t0000 + 4);
	if (fn006E0FC0() == 0x00)
	{
		if (esp_78->dw0020 != 0x02)
		{
l00704F7D:
			word32 v16_222 = (word32) *eax_54 - 1;
			*eax_54 = v16_222;
			struct Eq_91700 * esp_228 = (const char *) &esp_117->tFFFFFFFC + 8;
			if (v16_222 == 0x00)
			{
				Eq_3 eax_230 = *((word32) eax_54 + 4);
				<anonymous> * ecx_231 = *((word32) eax_230 + 24);
				esp_228->tFFFFFFFC = eax_54;
				word32 ecx_241;
				word32 edx_242;
				ecx_231();
			}
			return ebx_11;
		}
		Eq_3 eax_121 = g_tA17E2C;
		esp_78->t0000.u0 = 9270460;
		esp_78->tFFFFFFFC = eax_121;
		esp_124 = esp_78 - 4;
l00704F72:
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_3 stackArg4 = <invalid>;
		word32 edx_447;
		word32 ecx_446;
		fn006E0F80(stackArg4, dwArg04, out ecx_446, out edx_447);
		esp_117 = esp_124 + 0x08;
	}
l00704F7A:
	ebx_11 = ~0x00;
	goto l00704F7D;
}

// 00704FE0: Register word32 fn00704FE0(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08)
// Called from:
//      fn00708130
word32 fn00704FE0(Eq_3 dwArg04, Eq_3 dwArg08)
{
	Eq_3 eax_6 = *((word32) dwArg04 + 4);
	if ((*((word32) eax_6 + 84) & 0x02) == 0x00)
		return fn00704E40(dwArg04, dwArg08);
	struct Eq_86856 * eax_10 = *((word32) eax_6 + 52);
	if (eax_10 == null)
		return fn00704E40(dwArg04, dwArg08);
	<anonymous> * eax_14 = eax_10->ptr001C;
	if (eax_14 == null)
		return fn00704E40(dwArg04, dwArg08);
	word32 eax_39;
	eax_14();
	return eax_39;
}

// 00705040: Register word32 fn00705040()
// Called from:
//      fn006E9BD0
word32 fn00705040()
{
	return 0x7FFFFFFF;
}

// 00705050: Register Eq_3 fn00705050(Register out (ptr32 Eq_91810) ecxOut, Register out (ptr32 Eq_91810) edxOut)
// Called from:
//      fn007050A0
Eq_3 fn00705050(struct Eq_91810 & ecxOut, struct Eq_91810 & edxOut)
{
	Eq_3 eax_6 = malloc(988);
	if (eax_6 != 0x00)
	{
		*eax_6 = g_tA6D158;
		g_tA6D158 = eax_6;
		struct Eq_91810 * ecx_19 = (word32) eax_6 + 976 + 0x04;
		if ((word32) eax_6 + 976 > (word32) eax_6 + 4)
		{
			do
			{
				edx = ecx_19 - 0x0C;
				ecx_19->dw0000 = edx;
				ecx_19 = edx;
			} while (edx > (word32) eax_6 + 4);
		}
		ecx_19->dw0004 = 0x00;
		ecxOut = ecx_19;
		edxOut = edx;
		return (word32) eax_6 + 976;
	}
	else
	{
		struct Eq_91810 * ecx_40;
		struct Eq_91810 * edx_41;
		Eq_3 eax_39 = fn006E1210(out ecx_40, out edx_41);
		ecxOut = ecx_40;
		edxOut = edx_41;
		return eax_39;
	}
}

// 007050A0: Register (ptr32 Eq_59236) fn007050A0(Stack Eq_3 dwArg04, Register out (ptr32 word32) ecxOut, Register out (ptr32 Eq_59236) edxOut)
// Called from:
//      fn006E1DE0
//      fn006E9BD0
//      fn00705120
//      fn00708DC0
//      fn00711280
//      fn00726260
//      fn00726340
//      fn007276E0
//      fn0072A940
//      fn0072AC20
//      fn00731A20
//      fn007367D0
//      fn0073D140
//      fn00747610
//      fn00747890
//      fn00747A80
//      fn00748190
struct Eq_59236 * fn007050A0(Eq_3 dwArg04, word32 & ecxOut, struct Eq_59236 & edxOut)
{
	if (dwArg04 > 0x0100)
	{
		struct Eq_59236 * eax_11 = g_ptrA6D15C;
		if (eax_11 == null)
		{
			struct Eq_59236 * edx_17;
			word32 * ecx_18;
			eax_11 = fn00705050(out ecx_18, out edx_17);
			g_ptrA6D15C = eax_11;
			if (eax_11 == null)
			{
				ecxOut = ecx_18;
				edxOut = edx_17;
				return eax_11;
			}
		}
		struct Eq_59236 * edx_28 = eax_11->dw0004;
		eax_11->dw0008 = (word32) dwArg04;
		g_ptrA6D15C = edx_28;
		word32 * ecx_29 = &eax_11->dw0004;
		*ecx_29 = 10610664;
		eax_11->dw0000 = 0x01;
		ecxOut = ecx_29;
		edxOut = edx_28;
		return eax_11;
	}
	else
	{
		struct Eq_59236 * eax_40 = *((const char *) g_aA6CD54 + dwArg04 * 0x04);
		++eax_40->dw0000;
		ecxOut = ecx;
		edxOut = edx;
		return eax_40;
	}
}

// 00705120: Register Eq_3 fn00705120(Stack Eq_3 dwArg04, Register out ptr32 ecxOut, Register out Eq_540 edxOut)
// Called from:
//      fn006E3770
//      fn006E38B0
//      fn0072F230
//      fn00735890
Eq_3 fn00705120(Eq_3 dwArg04, ptr32 & ecxOut, union Eq_540 & edxOut)
{
	if (dwArg04 > 0x80000001)
	{
		ptr32 ecx_23;
		word32 edx_65;
		Eq_3 eax_22 = fn00710CB0(fp + 0x04, 0x04, 0x01, 0x01, out ecx_23, out edx_65);
		ecxOut = ecx_23;
		edxOut.u0 = <invalid>;
		return eax_22;
	}
	else
	{
		ptr32 ecx_31;
		word32 edx_64;
		Eq_3 eax_30 = fn007050A0(dwArg04, out ecx_31, out edx_64);
		ecxOut = ecx_31;
		edxOut.u0 = <invalid>;
		return eax_30;
	}
}

// 007051A0: Register Eq_3 fn007051A0(Register Eq_3 edi, Stack Eq_3 dwArg04, Register out ptr32 ecxOut, Register out ptr32 edxOut, Register out Eq_540 esiOut, Register out Eq_3 ediOut)
// Called from:
//      fn00656570
//      fn006DC1B0
//      fn006E5C60
//      fn006E7D90
//      fn006E8D90
//      fn007040D0
//      fn007052C0
//      fn00708DC0
//      fn007108F0
//      fn007114E0
//      fn007276E0
//      fn0072FBB0
//      fn00731A20
//      fn00735890
//      fn0073B870
//      fn00748140
Eq_3 fn007051A0(Eq_3 edi, Eq_3 dwArg04, ptr32 & ecxOut, ptr32 & edxOut, union Eq_540 & esiOut, union Eq_3 & ediOut)
{
	ptr32 edx_112;
	ptr32 ecx_113;
	if (dwArg04 != 0x00)
	{
		Eq_3 eax_11 = *((word32) dwArg04 + 4);
		if (eax_11 == 10610664 || fn006D5670(eax_11, 10610664, out ecx, out edx) != 0x00)
		{
			Eq_3 eax_232 = *((word32) dwArg04 + 8);
			ecxOut = ecx;
			edxOut = edx;
			esiOut.u0 = <invalid>;
			ediOut = edi;
			return eax_232;
		}
		struct Eq_85087 * eax_30 = *((word32) *((word32) dwArg04 + 4) + 48);
		if (eax_30 != null)
		{
			<anonymous> * eax_34 = eax_30->ptr0048;
			if (eax_34 != null)
			{
				struct Eq_91984 * esp_57;
				Eq_3 eax_58;
				eax_34();
				if (eax_58 != 0x00)
				{
					Eq_3 edi_102;
					Eq_3 eax_76 = *((word32) eax_58 + 4);
					esp_57->t0000 = edi;
					if (eax_76 != 10610664)
					{
						esp_57->tFFFFFFFC.u0 = 10610664;
						esp_57->tFFFFFFF8 = eax_76;
						if (fn006D5670(esp_57->tFFFFFFF8, esp_57->tFFFFFFFC, out ecx_113, out edx_112) == 0x00)
						{
							Eq_3 eax_118 = *((word32) eax_58 + 4);
							if (eax_118 != 0x00A1F400)
							{
								esp_57->tFFFFFFFC.u0 = 0x00A1F400;
								esp_57->tFFFFFFF8 = eax_118;
								struct Eq_91984 * esp_132 = esp_57;
								word32 edx_340;
								word32 ecx_339;
								if (fn006D5670(esp_57->tFFFFFFF8, esp_57->tFFFFFFFC, out ecx_339, out edx_340) == 0x00)
								{
									word32 v11_190 = (word32) *eax_58 - 1;
									*eax_58 = v11_190;
									if (v11_190 == 0x00)
									{
										Eq_3 ecx_194 = *((word32) eax_58 + 4);
										<anonymous> * edx_195 = *((word32) ecx_194 + 24);
										esp_57->tFFFFFFFC = eax_58;
										word32 esp_198;
										word32 edx_200;
										edx_195();
										esp_132 = esp_198 + 0x04;
									}
									Eq_3 eax_207 = g_tA16B7C;
									struct Eq_92098 * esp_209 = esp_132 - 4;
									esp_209->dw0000 = 0x008D7528;
									esp_209->tFFFFFFFC = eax_207;
									// Failed to bind call argument.
									// Please report this issue at https://github.com/uxmal/reko
									Eq_3 stackArg4 = <invalid>;
									ptr32 edx_218;
									ptr32 ecx_219;
									fn006E0F80(stackArg4, dwArg04, out ecx_219, out edx_218);
									ecxOut = ecx_219;
									edxOut = edx_218;
									esiOut.u0 = <invalid>;
									ediOut = dwArg04;
									return ~0x00;
								}
							}
							esp_57->tFFFFFFFC = eax_58;
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							Eq_3 stackArg4 = <invalid>;
							Eq_3 eax_143 = fn007108F0(stackArg4, out ecx_113, out edx_112);
							word32 v13_149 = (word32) *eax_58 - 1;
							*eax_58 = v13_149;
							edi_102 = eax_143;
							if (v13_149 == 0x00)
							{
								Eq_3 ecx_154 = *((word32) eax_58 + 4);
								<anonymous> * edx_155 = *((word32) ecx_154 + 24);
								esp_57->tFFFFFFFC = eax_58;
								edx_155();
							}
							if (eax_143 == ~0x00)
							{
								Eq_3 eax_169 = fn006E0FC0();
								if (eax_169 != 0x00)
								{
									ecxOut = ecx_113;
									edxOut = edx_112;
									esiOut.u0 = <invalid>;
									ediOut = dwArg04;
									return eax_169 | eax_143;
								}
							}
l007052A1:
							ecxOut = ecx_113;
							edxOut = edx_112;
							esiOut.u0 = <invalid>;
							ediOut = dwArg04;
							return edi_102;
						}
					}
					word32 v14_99 = (word32) *eax_58 - 1;
					*eax_58 = v14_99;
					edi_102 = *((word32) eax_58 + 8);
					if (v14_99 == 0x00)
					{
						Eq_3 eax_104 = *((word32) eax_58 + 4);
						<anonymous> * ecx_105 = *((word32) eax_104 + 24);
						esp_57->tFFFFFFFC = eax_58;
						ecx_105();
					}
					goto l007052A1;
				}
l007052BA:
				ecxOut = ecx_113;
				edxOut = edx_112;
				esiOut.u0 = <invalid>;
				ediOut = edi;
				return ~0x00;
			}
		}
	}
	fn006E0F80(g_tA16B7C, 0x008D7510, out ecx_113, out edx_112);
	goto l007052BA;
}

// 007052C0: Register Eq_3 fn007052C0(Stack Eq_3 dwArg04, Register out ptr32 ecxOut, Register out ptr32 edxOut)
// Called from:
//      fn00702C30
//      fn00708DC0
Eq_3 fn007052C0(Eq_3 dwArg04, ptr32 & ecxOut, ptr32 & edxOut)
{
	if (dwArg04 != 0x00)
	{
		Eq_3 eax_11 = *((word32) dwArg04 + 4);
		if (eax_11 == 10610664 || fn006D5670(eax_11, 10610664, out ecx, out edx) != 0x00)
		{
			Eq_3 eax_31 = *((word32) dwArg04 + 8);
			ecxOut = ecx;
			edxOut = edx;
			return eax_31;
		}
		else
		{
			Eq_3 eax_35 = *((word32) dwArg04 + 4);
			if (eax_35 != 0x00A1F400)
			{
				word32 ecx_153;
				word32 edx_154;
				if (fn006D5670(eax_35, 0x00A1F400, out ecx_153, out edx_154) == 0x00)
				{
					ptr32 ecx_73;
					ptr32 edx_74;
					word32 esi_156;
					word32 edi_157;
					Eq_3 eax_71 = fn007051A0(edi, dwArg04, out ecx_73, out edx_74, out esi_156, out edi_157);
					ecxOut = ecx_73;
					edxOut = edx_74;
					return eax_71;
				}
			}
			ptr32 ecx_61;
			ptr32 edx_62;
			Eq_3 eax_59 = fn007109D0(dwArg04, out ecx_61, out edx_62);
			ecxOut = ecx_61;
			edxOut = edx_62;
			return eax_59;
		}
	}
	else
	{
		ptr32 ecx_88;
		ptr32 edx_89;
		fn006E0F80(g_tA16B7C, 0x008D7510, out ecx_88, out edx_89);
		ecxOut = ecx_88;
		edxOut = edx_89;
		return ~0x00;
	}
}

// 00705340: Register Eq_3 fn00705340(Register Eq_3 edi, Stack Eq_3 dwArg04)
// Called from:
//      fn006E5C60
//      fn00710B80
Eq_3 fn00705340(Eq_3 edi, Eq_3 dwArg04)
{
	if (dwArg04 != 0x00)
	{
		Eq_3 eax_11 = *((word32) dwArg04 + 4);
		if (eax_11 == 10610664)
			return *((word32) dwArg04 + 8);
		word32 edx_377;
		word32 ecx_376;
		if (fn006D5670(eax_11, 10610664, out ecx_376, out edx_377) != 0x00)
			return *((word32) dwArg04 + 8);
		Eq_3 eax_29 = *((word32) dwArg04 + 4);
		if (eax_29 == 0x00A1F400)
			return fn00710B80(dwArg04);
		word32 ecx_378;
		word32 edx_379;
		if (fn006D5670(eax_29, 0x00A1F400, out ecx_378, out edx_379) != 0x00)
			return fn00710B80(dwArg04);
		struct Eq_85087 * eax_48 = *((word32) *((word32) dwArg04 + 4) + 48);
		if (eax_48 != null)
		{
			<anonymous> * eax_52 = eax_48->ptr0048;
			if (eax_52 != null)
			{
				struct Eq_92293 * esp_75;
				Eq_3 eax_76;
				word32 edx_77;
				word32 ecx_78;
				eax_52();
				if (eax_76 == 0x00)
					return ~0x00;
				Eq_3 edi_120;
				Eq_3 eax_94 = *((word32) eax_76 + 4);
				esp_75->t0000 = edi;
				if (eax_94 != 10610664)
				{
					esp_75->tFFFFFFFC.u0 = 10610664;
					esp_75->tFFFFFFF8 = eax_94;
					word32 edx_381;
					word32 ecx_380;
					if (fn006D5670(esp_75->tFFFFFFF8, esp_75->tFFFFFFFC, out ecx_380, out edx_381) == 0x00)
					{
						Eq_3 eax_136 = *((word32) eax_76 + 4);
						if (eax_136 != 0x00A1F400)
						{
							esp_75->tFFFFFFFC.u0 = 0x00A1F400;
							esp_75->tFFFFFFF8 = eax_136;
							struct Eq_92293 * esp_150 = esp_75;
							word32 edx_384;
							word32 ecx_383;
							if (fn006D5670(esp_75->tFFFFFFF8, esp_75->tFFFFFFFC, out ecx_383, out edx_384) == 0x00)
							{
								word32 v11_206 = (word32) *eax_76 - 1;
								*eax_76 = v11_206;
								if (v11_206 == 0x00)
								{
									Eq_3 ecx_210 = *((word32) eax_76 + 4);
									<anonymous> * edx_211 = *((word32) ecx_210 + 24);
									esp_75->tFFFFFFFC = eax_76;
									word32 esp_214;
									word32 edx_216;
									edx_211();
									esp_150 = esp_214 + 0x04;
								}
								Eq_3 eax_223 = g_tA16B7C;
								struct Eq_92405 * esp_225 = esp_150 - 4;
								esp_225->dw0000 = 0x008D7528;
								esp_225->tFFFFFFFC = eax_223;
								// Failed to bind call argument.
								// Please report this issue at https://github.com/uxmal/reko
								Eq_3 stackArg4 = <invalid>;
								word32 ecx_386;
								word32 edx_387;
								fn006E0F80(stackArg4, dwArg04, out ecx_386, out edx_387);
								return ~0x00;
							}
						}
						esp_75->tFFFFFFFC = eax_76;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_3 stackArg4 = <invalid>;
						Eq_3 eax_161 = fn00710B80(stackArg4);
						word32 v13_167 = (word32) *eax_76 - 1;
						*eax_76 = v13_167;
						edi_120 = eax_161;
						if (v13_167 == 0x00)
						{
							Eq_3 ecx_172 = *((word32) eax_76 + 4);
							<anonymous> * edx_173 = *((word32) ecx_172 + 24);
							esp_75->tFFFFFFFC = eax_76;
							word32 edx_178;
							edx_173();
						}
						if (fn006E0FC0() == 0x00)
							return edi_120;
						return ~0x00;
					}
				}
				word32 v14_117 = (word32) *eax_76 - 1;
				*eax_76 = v14_117;
				edi_120 = *((word32) eax_76 + 8);
				if (v14_117 == 0x00)
				{
					Eq_3 eax_122 = *((word32) eax_76 + 4);
					<anonymous> * ecx_123 = *((word32) eax_122 + 24);
					esp_75->tFFFFFFFC = eax_76;
					word32 edx_130;
					word32 ecx_131;
					ecx_123();
				}
				return edi_120;
			}
		}
	}
	word32 edx_375;
	word32 ecx_374;
	fn006E0F80(g_tA16B7C, 0x008D7510, out ecx_374, out edx_375);
	return ~0x00;
}

// 00706900: void fn00706900()
// Called from:
//      fn006E8910
void fn00706900()
{
	struct Eq_92468 * esp_15 = fp - 0x1C;
	word32 * esi_18 = g_aA6CD40;
	int32 edi_19;
	for (edi_19 = 0x0105; edi_19 >= 0x00; --edi_19)
	{
		struct Eq_92476 * eax_22 = *esi_18;
		if (eax_22 != null)
		{
			eax_22->dw0000 += ~0x00;
			struct Eq_92476 * eax_28 = *esi_18;
			if (eax_28->dw0000 == 0x00)
			{
				struct Eq_92504 * ecx_31 = eax_28->ptr0004;
				<anonymous> * edx_32 = ecx_31->ptr0018;
				esp_15->ptrFFFFFFFC = eax_28;
				word32 esp_39;
				edx_32();
				esp_15 = esp_39 + 0x04;
			}
		}
		*esi_18 = null;
		++esi_18;
	}
	Eq_3 edx_213 = g_tA6D158;
	esp_15->dw0014 = 0x00;
	esp_15->dw0018 = 0x00;
	esp_15->dw0010 = 0x00;
	g_tA6D158.u0 = 0x00;
	g_ptrA6D15C = null;
	if (edx_213 != 0x00)
	{
		do
		{
			++esp_15->dw0014;
			struct Eq_59236 * eax_127 = (word32) edx_213 + 4;
			word32 ebp_104 = 0x00;
			struct Eq_59236 * ecx_74 = eax_127;
			word32 esi_100;
			for (esi_100 = 0x29; esi_100 != 0x00; --esi_100)
			{
				if (ecx_74->dw0004 == 10610664 && ecx_74->dw0000 != 0x00)
					++ebp_104;
				if (ecx_74->dw0010 == 10610664 && ecx_74->dw000C != 0x00)
					++ebp_104;
				++ecx_74;
			}
			Eq_3 ebx_111 = *edx_213;
			if (ebp_104 != 0x00)
			{
				*edx_213 = g_tA6D158;
				g_tA6D158 = edx_213;
				word32 edi_125;
				for (edi_125 = 0x29; edi_125 != 0x00; --edi_125)
				{
					if (eax_127->dw0004 == 10610664)
					{
						word32 edx_131 = eax_127->dw0000;
						if (edx_131 == 0x00)
							goto l007069EE;
						int32 ecx_140 = eax_127->dw0008;
						if (ecx_140 >= ~0x04 && (ecx_140 < 0x0101 && *((const char *) g_aA6CD54 + ecx_140 * 0x04) == 0x00))
						{
							eax_127->dw0000 = edx_131 + 0x01;
							*((const char *) g_aA6CD54 + ecx_140 * 0x04) = (struct Eq_59236 **) eax_127;
						}
					}
					else
					{
l007069EE:
						eax_127->dw0004 = g_ptrA6D15C;
						g_ptrA6D15C = eax_127;
					}
					if (eax_127->dw0010 == 10610664)
					{
						word32 esi_157 = eax_127->dw000C;
						word32 * edx_160 = &eax_127->dw000C;
						if (esi_157 == 0x00)
							goto l00706A33;
						int32 ecx_168 = eax_127->dw0014;
						if (ecx_168 >= ~0x04 && (ecx_168 < 0x0101 && *((const char *) g_aA6CD54 + ecx_168 * 0x04) == 0x00))
						{
							*edx_160 = esi_157 + 0x01;
							*((const char *) g_aA6CD54 + ecx_168 * 0x04) = edx_160;
						}
					}
					else
					{
l00706A33:
						eax_127->dw0010 = g_ptrA6D15C;
						g_ptrA6D15C = (struct Eq_59236 *) &eax_127->dw000C;
					}
					++eax_127;
				}
			}
			else
			{
				struct Eq_92655 * esp_116 = esp_15 - 4;
				esp_116->t0000 = edx_213;
				free(esp_116->t0000);
				++esp_116->dw001C;
			}
			esp_15->dw0010 += ebp_104;
			edx_213 = ebx_111;
		} while (ebx_111 != 0x00);
	}
	if (g_tA74AF0 != 0x00)
	{
		struct Eq_92578 * esp_308;
		esp_15->ptrFFFFFFFC = &g_t8D7718;
		struct Eq_92583 * esp_241;
		word32 eax_242;
		word32 ecx_243;
		_iob_func();
		esp_241->tFFFFFFFC = eax_242 + 0x40;
		fprintf(esp_241->tFFFFFFFC, esp_241->t0000, 0x00);
		word32 esi_252 = esp_241->dw0014;
		if (esi_252 == 0x00)
		{
			esp_241->t0000.u0 = 0x008A6DE8;
			struct Eq_92620 * esp_312;
			word32 eax_313;
			word32 ecx_314;
			_iob_func();
			esp_312->tFFFFFFFC = eax_313 + 0x40;
			fprintf(esp_312->tFFFFFFFC, esp_312->t0000, 0x00);
			esp_308 = (struct Eq_92578 *) ((const char *) &esp_312->t0000 + 4);
		}
		else
		{
			Eq_3 edx_257 = esp_241->t0018;
			Eq_3 ecx_259 = 9070991;
			if (edx_257 != 0x01)
				ecx_259.u0 = 9118380;
			word32 eax_264 = 9070991;
			if (esi_252 != 0x01)
				eax_264 = 9118380;
			esp_241->t0000 = ecx_259;
			esp_241->tFFFFFFFC = edx_257;
			word32 edx_277 = edx_257 - esp_241->dw001C;
			esp_241->dwFFFFFFF8 = edx_277;
			esp_241->dwFFFFFFF4 = eax_264;
			esp_241->dwFFFFFFF0 = esi_252;
			esp_241->dwFFFFFFEC = 9271020;
			struct Eq_92911 * esp_297;
			word32 eax_298;
			word32 ecx_299;
			_iob_func();
			esp_297->tFFFFFFFC = eax_298 + 0x40;
			fprintf(esp_297->tFFFFFFFC, esp_297->t0000, 0x00);
			esp_308 = (struct Eq_92578 *) ((const char *) &esp_297->t0000 + 24);
		}
		if (g_tA74AF0 > 0x01)
		{
			Eq_3 eax_327 = g_tA6D158;
			esp_308->t0018 = eax_327;
			if (eax_327 != 0x00)
			{
				do
				{
					struct Eq_92733 * esi_336 = (word32) esp_308->t0018 + 4;
					word32 ebp_338;
					for (ebp_338 = 0x52; ebp_338 != 0x00; --ebp_338)
					{
						if (esi_336->dw0004 == 10610664)
						{
							word32 eax_343 = esi_336->dw0000;
							if (eax_343 != 0x00)
							{
								word32 ecx_347 = esi_336->dw0008;
								struct Eq_92757 * esp_349 = esp_308 - 4;
								esp_349->dw0000 = ecx_347;
								esp_349->dwFFFFFFFC = eax_343;
								esp_349->ptrFFFFFFF8 = esi_336;
								esp_349->dwFFFFFFF4 = 9270980;
								struct Eq_92773 * esp_361;
								word32 eax_362;
								_iob_func();
								esp_361->tFFFFFFFC = eax_362 + 0x40;
								fprintf(esp_361->tFFFFFFFC, esp_361->t0000, 0x00);
								esp_308 = (struct Eq_92578 *) ((const char *) &esp_361->t0000 + 16);
							}
						}
						++esi_336;
					}
					Eq_3 eax_382 = *esp_308->t0018;
					esp_308->t0018 = eax_382;
				} while (eax_382 != 0x00);
			}
		}
	}
}

// 00706BE0: Register word32 fn00706BE0()
// Called from:
//      fn006F5C60
//      fn007556D0
//      fn007558B0
word32 fn00706BE0()
{
	word32 ecx_10;
	if (fn007158B0(0x00, out ecx_10) == 0x00)
		fn006E86F0(9271172);
	Eq_3 eax_26 = g_tA6D260;
	if (eax_26 != 0x00)
		fn0074F570(eax_26);
	return ecx_10;
}

// 00706C20: void fn00706C20(Stack Eq_3 dwArg04)
// Called from:
//      fn006F5C60
//      fn007556D0
//      fn007558B0
void fn00706C20(Eq_3 dwArg04)
{
	if (dwArg04 == 0x00)
		fn006E86F0(0x008D77A4);
	if (g_tA6D260 != 0x00)
	{
		word32 edi_34 = *_errno();
		word32 ecx_84;
		fn0074F540(g_tA6D260, 0x01, out ecx_84);
		*_errno() = edi_34;
	}
	word32 ecx_83;
	fn007158B0(dwArg04, out ecx_83);
}

// 00706CF0: Register word32 fn00706CF0()
// Called from:
//      fn00708DC0
word32 fn00706CF0()
{
	if ((g_dwA6D264 == 0x00 || fn0074F680() == g_dwA6D264) && g_dwA6D278 == 0x00)
	{
		g_dwA6D278 = 0x01;
		g_dwA6D270 = 0x00;
		ui32 eax_19 = g_dwA6D268;
		while (eax_19 != g_dwA6D26C)
		{
			ui32 eax_27 = eax_19 + 0x01;
			<anonymous> * ecx_25 = g_aA6D160[eax_19];
			word32 edx_26 = g_aA6D164[eax_19];
			ui32 eax_28 = eax_27 & 0x8000001F;
			if ((eax_27 & 0x8000001F) < 0x00)
				eax_28 = ((eax_27 & 0x8000001F) - 0x01 | ~0x1F) + 0x01;
			g_dwA6D268 = eax_28;
			int32 eax_48;
			word32 ecx_49;
			word32 edx_50;
			ecx_25();
			if (eax_48 < 0x00)
			{
				g_dwA6D278 = 0x00;
				g_dwA6D270 = 0x01;
				return ~0x00;
			}
			eax_19 = g_dwA6D268;
		}
		g_dwA6D278 = 0x00;
	}
	return 0x00;
}

// 00706DA0: Register Eq_3 fn00706DA0()
// Called from:
//      fn00704020
//      fn00704700
Eq_3 fn00706DA0()
{
	return g_tA1E8A8;
}

// 00706DC0: Register word32 fn00706DC0(Register Eq_3 edx, Register Eq_3 ebx, Register Eq_3 edi, Register (ptr16 Eq_7) es, Register (ptr16 Eq_8) ds, Register out Eq_3 edxOut)
// Called from:
//      fn006DF4C0
//      fn00708DC0
word32 fn00706DC0(Eq_3 edx, Eq_3 ebx, Eq_3 edi, struct Eq_7 * es, struct Eq_8 * ds, union Eq_3 & edxOut)
{
	Eq_3 esi_7 = g_tA6D67C;
	if (fn006E8800(edx, ebx, esi_7, edi, es, ds) == 0x00)
	{
		Eq_3 eax_28 = *((word32) esi_7 + 0x0C);
		Eq_3 ecx_29 = g_tA1E8A8;
		if (eax_28 <= ecx_29)
		{
			g_tA1E8AC = ecx_29;
			edxOut = edx;
			return 0x00;
		}
		else
		{
			*((word32) esi_7 + 0x0C) = (word32) eax_28 - 1;
			Eq_3 edx_52;
			word32 ecx_119;
			fn006E15D0(g_tA175E0, 0x008D77C8, out ecx_119, out edx_52);
			edxOut = edx_52;
			return ~0x00;
		}
	}
	else
	{
		*((word32) esi_7 + 0x0C) = (word32) *((word32) esi_7 + 0x0C) - 1;
		Eq_3 edx_72;
		word32 ecx_118;
		fn006E0F80(g_tA188A8, 9271276, out ecx_118, out edx_72);
		edxOut = edx_72;
		return ~0x00;
	}
}

// 00706E30: void fn00706E30(Register (ptr32 Eq_93111) eax, Register (ptr32 Eq_93112) edi, Stack Eq_3 dwArg04, Stack Eq_3 dwArg08)
// Called from:
//      fn00708DC0
void fn00706E30(struct Eq_93111 * eax, struct Eq_93112 * edi, Eq_3 dwArg04, Eq_3 dwArg08)
{
	struct Eq_93115 * edx_6 = eax->ptr0008;
	struct Eq_93119 * esp_132 = fp - 0x0C;
	if (edx_6->ptr002C == null)
	{
		if (eax->ptr0034 == null)
		{
			++g_dwA163B8;
			eax->ptr0034 = (struct Eq_93112 *) &g_dwA163B8;
		}
		struct Eq_93112 * ecx_27 = eax->ptr0034;
		++ecx_27->dw0000;
		Eq_3 ecx_30 = eax->t0038;
		if (ecx_30 != 0x00)
			*ecx_30 = (word32) *ecx_30 + 1;
		Eq_3 ecx_39 = eax->t003C;
		if (ecx_39 != 0x00)
			*ecx_39 = (word32) *ecx_39 + 1;
		edx_6->ptr002C = eax->ptr0034;
		edx_6->t0030 = eax->t0038;
		edx_6->t0034 = eax->t003C;
	}
	struct Eq_93112 * ecx_59 = eax->ptr0034;
	Eq_3 esi_60 = eax->t0038;
	Eq_3 ebx_61 = eax->t003C;
	++edi->dw0000;
	if (dwArg04 != 0x00)
		*dwArg04 = (word32) *dwArg04 + 1;
	if (dwArg08 != 0x00)
		*dwArg08 = (word32) *dwArg08 + 1;
	eax->ptr0034 = edi;
	eax->t0038 = dwArg04;
	eax->t003C = dwArg08;
	if (ecx_59 != null)
	{
		word32 v20_107 = ecx_59->dw0000 + ~0x00;
		ecx_59->dw0000 = v20_107;
		if (v20_107 == 0x00)
		{
			struct Eq_93239 * edx_111 = ecx_59->ptr0004;
			<anonymous> * eax_112 = edx_111->ptr0018;
			word32 esp_126;
			eax_112();
			esp_132 = esp_126 + 0x04;
		}
	}
	if (esi_60 != 0x00)
	{
		Eq_3 v22_139 = (word32) *esi_60 - 1;
		*esi_60 = v22_139;
		if (v22_139 == 0x00)
		{
			Eq_3 ecx_143 = *((word32) esi_60 + 4);
			<anonymous> * edx_144 = *((word32) ecx_143 + 24);
			esp_132->tFFFFFFFC = esi_60;
			word32 esp_153;
			edx_144();
			esp_132 = esp_153 + 0x04;
		}
	}
	if (ebx_61 != 0x00)
	{
		Eq_3 v23_166 = (word32) *ebx_61 - 1;
		*ebx_61 = v23_166;
		if (v23_166 == 0x00)
		{
			Eq_3 eax_170 = *((word32) ebx_61 + 4);
			<anonymous> * ecx_171 = *((word32) eax_170 + 24);
			esp_132->tFFFFFFFC = ebx_61;
			word32 esp_179;
			ecx_171();
			esp_132 = esp_179 + 0x04;
		}
	}
	struct Eq_93303 * esp_188 = esp_132 - 4;
	esp_188->ptr0000 = edi;
	esp_188->dwFFFFFFFC = 9262252;
	word32 edi_267;
	fn00715E50(dwArg04, out edi_267);
	esp_188->tFFFFFFF8 = dwArg04;
	esp_188->dwFFFFFFF4 = 9262240;
	word32 edi_268;
	fn00715E50(dwArg04, out edi_268);
	esp_188->dw0014 = 9262224;
	word32 edi_269;
	fn00715E50(dwArg08, out edi_269);
}

// 00706F10: void fn00706F10(Register (ptr32 Eq_93361) eax)
// Called from:
//      fn00708DC0
void fn00706F10(struct Eq_93361 * eax)
{
	struct Eq_93362 * esi_14 = eax->ptr0008;
	struct Eq_93366 * ecx_15 = esi_14->ptr002C;
	struct Eq_93366 * edx_6 = eax->ptr0034;
	struct Eq_93374 * ebx_10 = eax->ptr003C;
	struct Eq_93374 * edi_19 = eax->ptr0038;
	++ecx_15->dw0000;
	struct Eq_93390 * esp_100 = fp - 0x0C;
	struct Eq_93374 * ecx_22 = esi_14->ptr0030;
	if (ecx_22 != null)
		++ecx_22->dw0000;
	struct Eq_93374 * ecx_31 = esi_14->ptr0034;
	if (ecx_31 != null)
		++ecx_31->dw0000;
	eax->ptr0034 = esi_14->ptr002C;
	eax->ptr0038 = esi_14->ptr0030;
	eax->ptr003C = esi_14->ptr0034;
	if (edx_6 != null)
	{
		word32 v16_53 = edx_6->dw0000 + ~0x00;
		edx_6->dw0000 = v16_53;
		if (v16_53 == 0x00)
		{
			struct Eq_93455 * eax_57 = edx_6->ptr0004;
			word32 esp_69;
			eax_57->ptr0018();
			esp_100 = esp_69 + 0x04;
		}
	}
	if (edi_19 != null)
	{
		word32 v17_82 = edi_19->dw0000 + ~0x00;
		edi_19->dw0000 = v17_82;
		if (v17_82 == 0x00)
		{
			struct Eq_93478 * edx_86 = edi_19->ptr0004;
			<anonymous> * eax_87 = edx_86->ptr0018;
			esp_100->ptrFFFFFFFC = edi_19;
			word32 esp_94;
			eax_87();
			esp_100 = esp_94 + 0x04;
		}
	}
	if (ebx_10 != null)
	{
		word32 v18_107 = ebx_10->dw0000 + ~0x00;
		ebx_10->dw0000 = v18_107;
		if (v18_107 == 0x00)
		{
			struct Eq_93478 * ecx_111 = ebx_10->ptr0004;
			<anonymous> * edx_112 = ecx_111->ptr0018;
			esp_100->ptrFFFFFFFC = ebx_10;
			word32 esp_121;
			edx_112();
			esp_100 = esp_121 + 0x04;
		}
	}
	struct Eq_93492 * esp_133 = esp_100 - 4;
	esp_133->ptr0000 = esi_14->ptr002C;
	esp_133->dwFFFFFFFC = 9262252;
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_3 stackArg8 = <invalid>;
	word32 edi_313;
	fn00715E50(stackArg8, out edi_313);
	esp_133->ptrFFFFFFF8 = esi_14->ptr0030;
	esp_133->dwFFFFFFF4 = 9262240;
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_3 stackArg8 = <invalid>;
	word32 edi_315;
	fn00715E50(stackArg8, out edi_315);
	esp_133->ptrFFFFFFF0 = esi_14->ptr0034;
	esp_133->dwFFFFFFEC = 9262224;
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_3 stackArg8 = <invalid>;
	word32 edi_317;
	fn00715E50(stackArg8, out edi_317);
	struct Eq_93366 * eax_168 = esi_14->ptr002C;
	struct Eq_93374 * edi_169 = esi_14->ptr0030;
	struct Eq_93374 * ebx_170 = esi_14->ptr0034;
	esi_14->ptr002C = null;
	esi_14->ptr0030 = null;
	esi_14->ptr0034 = null;
	word32 v19_175 = eax_168->dw0000 + ~0x00;
	eax_168->dw0000 = v19_175;
	struct Eq_93573 * esp_171 = (const char *) &esp_133->ptr0000 + 4;
	if (v19_175 == 0x00)
	{
		struct Eq_93455 * ecx_179 = eax_168->ptr0004;
		<anonymous> * edx_180 = ecx_179->ptr0018;
		esp_133->ptr0000 = eax_168;
		word32 esp_183;
		edx_180();
		esp_171 = esp_183 + 0x04;
	}
	if (edi_169 != null)
	{
		word32 v20_196 = edi_169->dw0000 + ~0x00;
		edi_169->dw0000 = v20_196;
		if (v20_196 == 0x00)
		{
			struct Eq_93478 * eax_200 = edi_169->ptr0004;
			<anonymous> * ecx_201 = eax_200->ptr0018;
			esp_171->ptrFFFFFFFC = edi_169;
			word32 esp_208;
			ecx_201();
			esp_171 = esp_208 + 0x04;
		}
	}
	if (ebx_170 != null)
	{
		word32 v21_221 = ebx_170->dw0000 + ~0x00;
		ebx_170->dw0000 = v21_221;
		if (v21_221 == 0x00)
		{
			struct Eq_93478 * edx_225 = ebx_170->ptr0004;
			<anonymous> * eax_226 = edx_225->ptr0018;
			esp_171->ptrFFFFFFFC = ebx_170;
			eax_226();
		}
	}
}

// 00707020: Register uint32 fn00707020(Stack Eq_3 dwArg04, Stack Eq_3 dwArg0C)
// Called from:
//      fn00708DC0
uint32 fn00707020(Eq_3 dwArg04, Eq_3 dwArg0C)
{
	struct Eq_93671 * esp_130 = fp;
	Eq_3 eax_39 = dwArg0C;
	if (dwArg04 == 0x00)
	{
		Eq_3 eax_8 = g_tA6D67C;
		Eq_3 ecx_13 = *((word32) eax_8 + 52);
		if (ecx_13 == 0x00)
			ecx_13.u0 = 0x00A163B8;
		Eq_3 eax_22 = *((word32) eax_8 + 60);
		dwArg04 = ecx_13;
		struct Eq_93693 * edx_20 = *((word32) eax_8 + 56);
		dwArg0C = eax_22;
		if (ecx_13 != 0x00)
			*ecx_13.u0 = (word32) *ecx_13.u0 + 1;
		if (edx_20 != null)
			++edx_20->dw0000;
		eax_39 = eax_22;
		if (eax_22 != 0x00)
		{
			*eax_22 = (word32) *eax_22 + 1;
			eax_39 = eax_22;
		}
	}
	struct Eq_93676 * esp_275;
	ptr32 esp_265;
	if (eax_39 == 0x00A163B8)
	{
		*eax_39 = (word32) *eax_39 - 1;
		if (*dwArg0C == 0x00)
		{
			Eq_3 ecx_70 = *((word32) dwArg0C + 4);
			word32 esp_78;
			(*((word32) ecx_70 + 24))();
			esp_130 = esp_78 + 0x04;
		}
		esp_130[3] = (struct Eq_93671) 0x00;
	}
	else if (eax_39 != 0x00 && *((word32) eax_39 + 4) != 10640960)
	{
		esp_265 = fp - 8;
		goto l007071F2;
	}
	if (esp_130[2] == 0x00)
	{
		++g_dwA163B8;
		esp_130[2] = (struct Eq_93671) 0x00A163B8;
	}
l007070B4:
	struct Eq_93787 * eax_98 = esp_130[1];
	if (eax_98->t0004 != 0x00A16588)
	{
		Eq_3 ecx_101 = eax_98->t0004;
		struct Eq_93867 * esp_102 = esp_130 - 4;
		esp_102->t0000.u0 = 0x00A16588;
		esp_102->tFFFFFFFC = ecx_101;
		word32 ecx_556;
		word32 edx_557;
		if (fn006D5670(esp_102->tFFFFFFFC, esp_102->t0000, out ecx_556, out edx_557) == 0x00)
		{
l00707125:
			Eq_3 ecx_135 = esp_130[1];
			Eq_3 eax_136 = *((word32) ecx_135 + 4);
			if (eax_136 == 0x00A1B450)
			{
				Eq_3 eax_295 = g_tA18A34;
				struct Eq_93979 * esp_296 = esp_130 - 4;
				esp_296->dw0000 = 0x01;
				esp_296->dwFFFFFFFC = 0x008D7878;
				esp_296->tFFFFFFF8 = eax_295;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_3 stackArg4 = <invalid>;
				Eq_3 stackArg12 = <invalid>;
				esp_275 = (struct Eq_93676 *) (&esp_296->dw0000 + 1);
				word32 edx_560;
				if (fn006E1970(stackArg4, dwArg04, stackArg12, out edx_560) == 0x00)
					goto l007072B8;
				goto l007071FA;
			}
			if (eax_136 != 10611048)
			{
				if (eax_136 != 0x00A15380)
				{
					struct Eq_94076 * esp_144 = esp_130 - 4;
					esp_144->t0000.u0 = 0x00A15380;
					esp_144->tFFFFFFFC = eax_136;
					word32 ecx_569;
					word32 edx_570;
					if (fn006D5670(esp_144->tFFFFFFFC, esp_144->t0000, out ecx_569, out edx_570) == 0x00)
					{
l00707197:
						struct Eq_94100 * eax_202 = esp_130[1];
						if (eax_202->t0004 != 10611608)
						{
							Eq_3 edx_206 = eax_202->t0004;
							struct Eq_94123 * esp_207 = esp_130 - 4;
							esp_207->t0000 = g_tA169F0;
							esp_207->tFFFFFFFC = edx_206;
							word32 ecx_571;
							word32 edx_572;
							if (fn006D5670(esp_207->tFFFFFFFC, esp_207->t0000, out ecx_571, out edx_572) == 0x00)
							{
								Eq_3 eax_280 = g_tA16B7C;
								esp_207->t0000 = esp_207->ptr0008->ptr0004->t000C;
								esp_207->tFFFFFFFC.u0 = 0x008D7830;
								esp_207->tFFFFFFF8 = eax_280;
								// Failed to bind call argument.
								// Please report this issue at https://github.com/uxmal/reko
								Eq_3 stackArg4 = <invalid>;
								word32 ecx_574;
								word32 edx_575;
								fn006E15D0(stackArg4, dwArg04, out ecx_574, out edx_575);
								esp_275 = (struct Eq_93676 *) ((const char *) &esp_207->t0000 + 4);
l007071FA:
								struct Eq_93750 * eax_315 = esp_275->ptr0008;
								if (eax_315 != null)
								{
									eax_315->dw0000 += ~0x00;
									struct Eq_93750 * eax_321 = esp_275->ptr0008;
									if (eax_321->dw0000 == 0x00)
									{
										struct Eq_93774 * edx_324 = eax_321->ptr0004;
										esp_275->ptrFFFFFFFC = eax_321;
										word32 esp_329;
										edx_324->ptr0018();
										esp_275 = esp_329 + 0x04;
									}
								}
								struct Eq_93750 * eax_339 = esp_275->ptr0004;
								if (eax_339 != null)
								{
									eax_339->dw0000 += ~0x00;
									struct Eq_93750 * eax_345 = esp_275->ptr0004;
									if (eax_345->dw0000 == 0x00)
									{
										struct Eq_93774 * ecx_348 = eax_345->ptr0004;
										<anonymous> * edx_349 = ecx_348->ptr0018;
										esp_275->ptrFFFFFFFC = eax_345;
										word32 esp_353;
										edx_349();
										esp_275 = esp_353 + 0x04;
									}
								}
								struct Eq_93750 * eax_363 = esp_275->ptr000C;
								if (eax_363 != null)
								{
									eax_363->dw0000 += ~0x00;
									struct Eq_93750 * eax_369 = esp_275->ptr000C;
									if (eax_369->dw0000 == 0x00)
									{
										struct Eq_93774 * ecx_372 = eax_369->ptr0004;
										<anonymous> * edx_373 = ecx_372->ptr0018;
										esp_275->ptrFFFFFFFC = eax_369;
										edx_373();
									}
								}
								return 0x02;
							}
						}
						struct Eq_93671 * esp_222 = esp_130;
						word32 * eax_224 = esp_130[2];
						if (eax_224 != &g_dwA163B8)
						{
							Eq_3 ecx_262 = g_tA16B7C;
							struct Eq_94199 * esp_263 = esp_130 - 4;
							esp_263->dw0000 = 9271292;
							esp_263->tFFFFFFFC = ecx_262;
							esp_265 = esp_263 - 4;
l007071F2:
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							Eq_3 stackArg4 = <invalid>;
							word32 ecx_551;
							word32 edx_552;
							fn006E0F80(stackArg4, dwArg04, out ecx_551, out edx_552);
							esp_275 = esp_265 + 0x08;
							goto l007071FA;
						}
						*eax_224 += ~0x00;
						struct Eq_94187 * eax_229 = esp_130[2];
						if (eax_229->dw0000 == 0x00)
						{
							struct Eq_94223 * ecx_232 = eax_229->ptr0004;
							<anonymous> * edx_233 = ecx_232->ptr0018;
							esp_130->dwFFFFFFFC = eax_229;
							word32 esp_238;
							edx_233();
							esp_222 = esp_238 + 0x04;
						}
						struct Eq_94211 * eax_248 = esp_222[1];
						esp_222[2] = (struct Eq_93671) eax_248;
						if (eax_248->ptr0004 == &g_tA1EB98)
						{
							word32 * eax_257 = eax_248->ptr0008;
							esp_222[1] = (struct Eq_93671) eax_257;
							++*eax_257;
						}
						else
						{
							word32 * eax_252 = eax_248->ptr0004;
							esp_222[1] = (struct Eq_93671) eax_252;
							++*eax_252;
						}
l007072B8:
						word32 edx_562;
						word32 ecx_561;
						fn006E0E00(dwArg0C, out ecx_561, out edx_562);
						uint32 eax_410 = (uint32) (int8) (dwArg0C != 0x00);
						return eax_410 + 0x02 + eax_410;
					}
					ecx_135 = esp_144->t0008;
				}
				struct Eq_94051 * esp_163 = esp_130 - 4;
				esp_163->t0000 = g_tA169F0;
				esp_163->tFFFFFFFC = ecx_135;
				word32 ecx_567;
				word32 edx_568;
				if (fn006D5670(esp_163->tFFFFFFFC, esp_163->t0000, out ecx_567, out edx_568) == 0x00)
					goto l00707197;
			}
			struct Eq_94022 * esp_181 = esp_130 - 4;
			esp_181->ptr0000 = (word32 *) (esp_130 + 3);
			esp_181->ptrFFFFFFFC = (const char *) &esp_181->ptr0000 + 0x0C;
			esp_181->ptrFFFFFFF8 = (const char *) &esp_181->ptr0000 + 8;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg4 = <invalid>;
			word32 ebp_564;
			word32 esi_565;
			word32 edi_566;
			fn006E1BD0(stackArg4, dwArg04, out ebp_564, out esi_565, out edi_566);
			goto l007072B8;
		}
	}
	struct Eq_93843 * esp_120 = esp_130 - 4;
	esp_120->ptr0000 = (struct Eq_93848 *) esp_130[1];
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_3 stackArg4 = <invalid>;
	esp_130 = (struct Eq_93671 *) ((const char *) &esp_120->ptr0000 + 4);
	word32 ecx_554;
	word32 edx_555;
	if (fn006DFE20(stackArg4, out ecx_554, out edx_555) > 0x00)
	{
		struct Eq_93848 * eax_412 = esp_120->ptr0008;
		struct Eq_93848 * ecx_413 = eax_412->ptr000C;
		esp_120->ptr0008 = ecx_413;
		++ecx_413->dw0000;
		word32 v15_417 = eax_412->dw0000 + ~0x00;
		eax_412->dw0000 = v15_417;
		if (v15_417 == 0x00)
		{
			struct Eq_93931 * ecx_421 = eax_412->ptr0004;
			<anonymous> * edx_422 = ecx_421->ptr0018;
			esp_120->ptr0000 = eax_412;
			word32 esp_425;
			edx_422();
			esp_130 = esp_425 + 0x04;
		}
		goto l007070B4;
	}
	goto l00707125;
}

// 007072E0: Register Eq_3 fn007072E0(Register Eq_94296 ecx, Register Eq_3 ebx)
// Called from:
//      fn00708DC0
Eq_3 fn007072E0(Eq_94296 ecx, Eq_3 ebx)
{
	Eq_94296 edi_158 = ecx;
	Eq_3 esi_155 = 0x00;
	word32 edx_356;
	word32 ecx_355;
	Eq_3 eax_22 = fn00704B00(eax, out ecx_355, out edx_356);
	if (eax_22 == 0x00)
		return 0x00;
	struct Eq_94311 * esp_110;
	if (ebx > 0x00)
	{
		edi_158 = ecx;
		do
		{
			word32 ecx_358;
			word32 edx_359;
			Eq_3 eax_47 = fn00704040(eax_22, out ecx_358, out edx_359);
			esp_110 = fp - 0x0C;
			if (eax_47 == 0x00)
			{
				if (fn006E0FC0() == 0x00)
				{
					word32 edx_365;
					word32 ecx_364;
					fn006E15D0(g_tA17E2C, 0x008D78EC, out ecx_364, out edx_365);
					esp_110 = fp - 0x0C;
				}
				goto l0070739E;
			}
			edi_158 -= 0x04;
			*edi_158 = eax_47;
			esi_155 = (word32) esi_155 + 1;
		} while (esi_155 < ebx);
	}
	word32 ecx_106;
	word32 edx_357;
	Eq_3 eax_105 = fn00704040(eax_22, out ecx_106, out edx_357);
	esp_110 = fp - 0x0C;
	if (eax_105 == 0x00)
	{
		if (fn006E0FC0() == 0x00)
		{
			Eq_3 v14_234 = (word32) *eax_22 - 1;
			*eax_22 = v14_234;
			if (v14_234 == 0x00)
			{
				Eq_3 edx_238 = *((word32) eax_22 + 4);
				Eq_3 eax_239 = *((word32) edx_238 + 24);
				eax_239();
			}
			return 0x01;
		}
	}
	else
	{
		Eq_3 v16_114 = (word32) *eax_105 - 1;
		*eax_105 = v16_114;
		if (v16_114 == 0x00)
		{
			Eq_3 ecx_118 = *((word32) eax_105 + 4);
			word32 esp_122;
			(*((word32) ecx_118 + 24))();
			esp_110 = esp_122 + 0x04;
		}
		Eq_3 eax_131 = g_tA17E2C;
		struct Eq_94389 * esp_133 = esp_110 - 4;
		esp_133->dw0000 = 0x008D78D0;
		esp_133->tFFFFFFFC = eax_131;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_3 stackArg4 = <invalid>;
		Eq_3 stackArg8 = <invalid>;
		word32 ecx_362;
		word32 edx_363;
		fn006E0F80(stackArg4, stackArg8, out ecx_362, out edx_363);
		esp_110 = (struct Eq_94311 *) (&esp_133->dw0000 + 1);
	}
l0070739E:
	for (; esi_155 > 0x00; --esi_155)
	{
		word32 * eax_160 = *edi_158;
		*eax_160 += ~0x00;
		Eq_3 eax_163 = *edi_158;
		if (*eax_163 == 0x00)
		{
			Eq_3 ecx_166 = *((word32) eax_163 + 4);
			Eq_3 edx_167 = *((word32) ecx_166 + 24);
			esp_110->tFFFFFFFC = eax_163;
			word32 esp_175;
			edx_167();
			esp_110 = esp_175 + 0x04;
		}
		edi_158 = (word32) edi_158 + 4;
	}
	Eq_3 v18_195 = (word32) *eax_22 - 1;
	*eax_22 = v18_195;
	if (v18_195 == 0x00)
	{
		Eq_3 eax_199 = *((word32) eax_22 + 4);
		Eq_3 ecx_200 = *((word32) eax_199 + 24);
		esp_110->tFFFFFFFC = eax_22;
		ecx_200();
	}
	return 0x00;
}

// 007073E0: Register Eq_3 fn007073E0(Register Eq_3 eax, Register Eq_3 ecx, Register word32 edx, Stack Eq_3 dwArg04, Stack Eq_3 dwArg08)
// Called from:
//      fn00707430
//      fn00708590
//      fn00708880
//      fn00708DC0
Eq_3 fn007073E0(Eq_3 eax, Eq_3 ecx, word32 edx, Eq_3 dwArg04, Eq_3 dwArg08)
{
	struct Eq_93693 * esi_8 = *((word32) eax + 56);
	if (esi_8->dw0010 != 0x00)
		return 0x00;
	esi_8->dw0010 = 0x01;
	esi_8->dw0014 = 0x00;
	Eq_3 eax_25;
	dwArg04();
	if (esi_8->dw001C != 0x00 || esi_8->dw0018 != 0x00)
	{
		esi_8->dw0010 += ~0x00;
		esi_8->dw0014 = 0x01;
		return eax_25;
	}
	else
	{
		esi_8->dw0010 += ~0x00;
		esi_8->dw0014 = 0x00;
		return eax_25;
	}
}

// 00707430: Register Eq_3 fn00707430(Register (ptr32 Eq_3) ebx, Register Eq_3 esi, Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Stack (ptr32 Eq_3) dwArg0C, Stack (ptr32 Eq_3) dwArg10, Register out Eq_540 edxOut)
// Called from:
//      fn00708DC0
Eq_3 fn00707430(union Eq_3 * ebx, Eq_3 esi, Eq_3 dwArg04, Eq_3 dwArg08, union Eq_3 * dwArg0C, union Eq_3 * dwArg10, union Eq_540 & edxOut)
{
	Eq_3 eax_6 = *((word32) esi + 60);
	Eq_3 edi_15 = 0x00;
	if (eax_6 >= *ebx && eax_6 < *dwArg0C)
	{
		if (eax_6 <= *dwArg10)
		{
			Eq_3 eax_102 = fn007073E0(esi, 0x00A163B8, 0x02, dwArg04, dwArg08);
			*dwArg10 = (union Eq_3 *) *((word32) esi + 60);
			edxOut.u0 = <invalid>;
			return eax_102;
		}
	}
	else
	{
		Eq_3 eax_34 = fn007355A0(*((word32) esi + 16), eax_6, fp - 0x08);
		if (eax_34 >= 0x00)
		{
			*((word32) esi + 64) = eax_34;
			edi_15 = fn007073E0(esi, 0x00A163B8, 0x02, dwArg04, dwArg08);
		}
		*ebx = (union Eq_3 *) dwLoc08;
		*dwArg0C = (union Eq_3 *) dwLoc04;
	}
	*dwArg10 = (union Eq_3 *) *((word32) esi + 60);
	edxOut.u0 = <invalid>;
	return edi_15;
}

// 007075C0: Register word32 fn007075C0()
// Called from:
//      fn0072EC10
word32 fn007075C0()
{
	Eq_3 eax_5 = g_tA6D67C;
	word32 eax_9;
	g_ptrA6D680();
	return eax_9;
}

// 007075D0: Register (ptr32 Eq_94634) fn007075D0()
// Called from:
//      fn007367D0
struct Eq_94634 * fn007075D0()
{
	Eq_3 eax_5 = g_tA6D67C;
	struct Eq_94634 * eax_9;
	g_ptrA6D680();
	if (eax_9 != null)
		return (uint32) (int8) (eax_9->dw0014 != ((eax_9->ptr0038)->ptr0004)->dw0010);
	return eax_9;
}

// 00707600: Register uint32 fn00707600(Stack Eq_3 dwArg04)
// Called from:
//      fn0070BCC0
uint32 fn00707600(Eq_3 dwArg04)
{
	Eq_3 eax_5 = g_tA6D67C;
	struct Eq_94663 * eax_12;
	g_ptrA6D680();
	Eq_3 ecx_18 = *dwArg04;
	uint32 eax_37 = (uint32) (int8) (ecx_18 != 0x00);
	if (eax_12 != null)
	{
		ui32 edx_29 = eax_12->ptr0010->dw0014;
		if ((edx_29 & 0xE000) != 0x00)
		{
			*dwArg04 = ecx_18 | edx_29 & 0xE000;
			eax_37 = 0x01;
		}
	}
	return eax_37;
}

// 00707640: Register Eq_3 fn00707640(Register out ptr32 ebxOut, Register out ptr32 ediOut)
// Called from:
//      fn006E8060
//      fn006E8730
//      fn006E8D90
Eq_3 fn00707640(ptr32 & ebxOut, ptr32 & ediOut)
{
	word32 ecx_98;
	word32 edx_99;
	Eq_3 eax_9 = fn00715DD0(out ecx_98, out edx_99);
	if (eax_9 != 0x00)
	{
		Eq_3 esi_30;
		if (fn00731A20(eax_9, 0x00, out ebx, out esi_30, out edi) != 0x00)
		{
			ptr32 edi_44;
			word32 edx_100;
			word32 esi_101;
			Eq_3 eax_47 = fn00731D30(0x008A6DE8, esi_30, out edx_100, out esi_101, out edi_44);
			ebxOut = ebx;
			ediOut = edi_44;
			return eax_47;
		}
	}
	ebxOut = ebx;
	ediOut = edi;
	return 0x00;
}

// 00707680: Register Eq_3 fn00707680(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Stack Eq_3 dwArg0C, Register out ptr32 ecxOut, Register out ptr32 edxOut, Register out Eq_540 esiOut, Register out Eq_540 ediOut)
// Called from:
//      fn006E1BD0
//      fn006E8730
//      fn006E8D90
//      fn007036F0
//      fn00708DC0
//      fn0072EC10
//      fn00731B10
//      fn0074EB10
//      fn0074ED80
//      fn0074EE90
Eq_3 fn00707680(Eq_3 dwArg04, Eq_3 dwArg08, Eq_3 dwArg0C, ptr32 & ecxOut, ptr32 & edxOut, union Eq_540 & esiOut, union Eq_540 & ediOut)
{
	Eq_3 esi_101 = dwArg08;
	if (dwArg08 == 0x00)
	{
		ptr32 ecx_55;
		ptr32 edx_56;
		Eq_3 eax_54 = fn006DFD20(dwArg08, out ecx_55, out edx_56);
		esi_101 = eax_54;
		if (eax_54 == 0x00)
		{
			ecxOut = ecx_55;
			edxOut = edx_56;
			esiOut.u0 = <invalid>;
			ediOut.u0 = <invalid>;
			return eax_54;
		}
	}
	else
	{
		Eq_3 eax_11 = *((word32) dwArg08 + 4);
		if (eax_11 != 0x00A16588)
		{
			word32 ecx_265;
			word32 edx_266;
			if (fn006D5670(eax_11, 0x00A16588, out ecx_265, out edx_266) == 0x00)
			{
				ptr32 ecx_41;
				ptr32 edx_42;
				fn006E0F80(g_tA16B7C, 0x008D7934, out ecx_41, out edx_42);
				ecxOut = ecx_41;
				edxOut = edx_42;
				esiOut.u0 = <invalid>;
				ediOut.u0 = <invalid>;
				return 0x00;
			}
		}
		*dwArg08 = (word32) *dwArg08 + 1;
	}
	if (dwArg0C != 0x00)
	{
		Eq_3 eax_75 = *((word32) dwArg0C + 4);
		if (eax_75 != 0x00A1D1B8)
		{
			word32 ecx_267;
			word32 edx_268;
			if (fn006D5670(eax_75, 0x00A1D1B8, out ecx_267, out edx_268) == 0x00)
			{
				ptr32 ecx_147;
				ptr32 edx_148;
				fn006E0F80(g_tA16B7C, 0x008D7910, out ecx_147, out edx_148);
				Eq_3 v12_152 = (word32) *esi_101 - 1;
				*esi_101 = v12_152;
				if (v12_152 == 0x00)
				{
					Eq_3 edx_156 = *((word32) esi_101 + 4);
					(*((word32) edx_156 + 24))();
				}
				ecxOut = ecx_147;
				edxOut = edx_148;
				esiOut.u0 = <invalid>;
				ediOut.u0 = <invalid>;
				return 0x00;
			}
		}
	}
	ptr32 ecx_110;
	ptr32 edx_111;
	Eq_3 eax_109 = fn00703710(dwArg04, esi_101, dwArg08, out ecx_110, out edx_111);
	Eq_3 v14_115 = (word32) *esi_101 - 1;
	*esi_101 = v14_115;
	if (v14_115 == 0x00)
	{
		Eq_3 edx_120 = *((word32) esi_101 + 4);
		(*((word32) edx_120 + 24))();
	}
	ecxOut = ecx_110;
	edxOut = edx_111;
	esiOut.u0 = <invalid>;
	ediOut.u0 = <invalid>;
	return eax_109;
}

// 00707750: Register Eq_3 fn00707750(Stack Eq_3 dwArg04)
// Called from:
//      fn00707950
//      fn00707BD0
Eq_3 fn00707750(Eq_3 dwArg04)
{
	Eq_3 eax_11 = dwArg04;
	if (*((word32) dwArg04 + 4) == 10612000)
	{
		do
			eax_11 = *((word32) eax_11 + 8);
		while (*((word32) eax_11 + 4) == 10612000);
	}
	Eq_3 ecx_19 = *((word32) eax_11 + 4);
	if (ecx_19 != 0x00A249B8)
	{
		if (ecx_19 == 10602136)
			return **((word32) eax_11 + 8);
		if (ecx_19 != 10611048)
		{
			if (ecx_19 != 10611608)
				return *((word32) ecx_19 + 0x0C);
			Eq_3 ecx_30 = *((word32) *((word32) eax_11 + 8) + 16);
			word32 ecx_109;
			word32 edx_110;
			word32 esi_111;
			return fn006ECC50(ecx_30, out ecx_109, out edx_110, out esi_111);
		}
		else
		{
			Eq_3 edx_44 = *((word32) eax_11 + 16);
			word32 ecx_106;
			word32 edx_107;
			word32 esi_108;
			return fn006ECC50(edx_44, out ecx_106, out edx_107, out esi_108);
		}
	}
	else
	{
		Eq_3 eax_54 = *((word32) eax_11 + 28);
		word32 ecx_103;
		word32 edx_104;
		word32 esi_105;
		return fn006ECC50(eax_54, out ecx_103, out edx_104, out esi_105);
	}
}

// 007077C0: Register word32 fn007077C0(Stack Eq_3 dwArg04)
// Called from:
//      fn00707950
//      fn00707BD0
word32 fn007077C0(Eq_3 dwArg04)
{
	Eq_3 eax_6 = *((word32) dwArg04 + 4);
	if (eax_6 == 10612000 || (eax_6 == 0x00A249B8 || eax_6 == 10602136))
		return 9234492;
	if (eax_6 == 10611048)
		return 0x008D7968;
	word32 eax_16 = 9271644;
	if (eax_6 != 10611608)
		eax_16 = 9271636;
	return eax_16;
}

// 00707810: void fn00707810(Stack Eq_3 bArg04)
// Called from:
//      fn00708880
void fn00707810(Eq_3 bArg04)
{
	Eq_3 edx_7 = g_tA16B7C;
	if ((bArg04 & 0x04) == 0x00)
	{
		word32 ecx_69;
		word32 edx_70;
		fn006E15D0(edx_7, 0x008D7978, out ecx_69, out edx_70);
	}
	else
	{
		word32 ecx_71;
		word32 edx_72;
		fn006E15D0(edx_7, 9271720, out ecx_71, out edx_72);
	}
}

// 00707850: Register Eq_3 fn00707850(Register Eq_3 eax, Register Eq_3 ecx, Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Stack Eq_3 dwArg0C)
// Called from:
//      fn00708880
Eq_3 fn00707850(Eq_3 eax, Eq_3 ecx, Eq_3 dwArg04, Eq_3 dwArg08, Eq_3 dwArg0C)
{
	Eq_3 edx_6 = *((word32) ecx + 8);
	Eq_3 esi_16 = *((word32) ecx + 0x0C);
	if (*((word32) ecx + 16) != 0x00 || (*((word32) edx_6 + 8) != eax || (dwArg0C != 0x00 || *((word32) edx_6 + 20) != 0x43)))
	{
		word32 edx_285;
		return fn0070B600(edx_6, esi_16, 0x00, dwArg08, dwArg0C, out edx_285);
	}
	else
	{
		Eq_3 ebx_94 = g_tA6D67C;
		word32 edx_286;
		Eq_3 eax_106 = fn0073AFB0(ebx_94, edx_6, esi_16, out edx_286);
		if (eax_106 == 0x00)
			return eax_106;
		word32 * eax_118 = *dwArg04 - eax * 0x04;
		Eq_3 ecx_119 = 0x00;
		if (eax > 0x00)
		{
			do
			{
				word32 * edx_125 = *eax_118;
				++*edx_125;
				*((word32) eax_106 + (ecx_119 * 0x04 + 312)) = *eax_118;
				ecx_119 = (word32) ecx_119 + 1;
				++eax_118;
			} while (ecx_119 < eax);
		}
		word32 edx_289;
		Eq_3 eax_156 = fn00708DC0(es, ds, eax_106, dwArg04, out edx_289);
		*((word32) ebx_94 + 0x0C) = (word32) *((word32) ebx_94 + 0x0C) + 1;
		Eq_3 v17_162 = (word32) *eax_106 - 1;
		*eax_106 = v17_162;
		if (v17_162 == 0x00)
		{
			Eq_3 eax_167 = *((word32) eax_106 + 4);
			Eq_3 ecx_168 = *((word32) eax_167 + 24);
			ecx_168();
		}
		*((word32) ebx_94 + 0x0C) = (word32) *((word32) ebx_94 + 0x0C) - 1;
		return eax_156;
	}
}

// 00707950: Register Eq_3 fn00707950(Register Eq_3 eax, Register (ptr32 word32) ebx, Stack Eq_3 dwArg04, Register out Eq_540 ecxOut)
// Called from:
//      fn00707B30
//      fn00707BD0
Eq_3 fn00707950(Eq_3 eax, word32 * ebx, Eq_3 dwArg04, union Eq_540 & ecxOut)
{
	Eq_3 ebp_30;
	if (eax == 0x00)
	{
		word32 ecx_448;
		word32 edx_449;
		ebp_30 = fn006FDCC0(out ecx_448, out edx_449);
	}
	else
	{
		word32 edx_447;
		Eq_3 eax_22 = fn006FDE60(eax, out edx_447);
		Eq_3 v11_27 = (word32) *eax - 1;
		*eax = v11_27;
		ebp_30 = eax_22;
		if (v11_27 == 0x00)
		{
			Eq_3 eax_32 = *((word32) eax + 4);
			Eq_3 ecx_33 = *((word32) eax_32 + 24);
			ecx_33();
		}
	}
	if (ebp_30 != 0x00)
	{
		struct Eq_95146 * esp_225 = fp - 16;
		if (dwArg04 >= 0x01)
		{
			do
			{
				*ebx += ~0x03;
				struct Eq_95155 * eax_69 = *ebx;
				Eq_3 edi_70 = eax_69->t0000;
				*ebx = &eax_69->tFFFFFFFC;
				Eq_3 esi_74 = eax_69->tFFFFFFFC;
				struct Eq_95177 * esp_76 = esp_225 - 4;
				esp_76->t0000 = esi_74;
				esp_76->tFFFFFFFC = ebp_30;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_3 stackArg4 = <invalid>;
				word32 edx_452;
				word32 ecx_451;
				if (fn006FBCC0(stackArg4, dwArg04 - 0x01, out ecx_451, out edx_452) != 0x00)
				{
					esp_76->t0000 = esi_74;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_3 stackArg4 = <invalid>;
					word32 ecx_454;
					word32 esi_456;
					word32 edx_455;
					Eq_3 eax_97 = fn006ECC50(stackArg4, out ecx_454, out edx_455, out esi_456);
					Eq_3 ecx_101 = esp_76->t001C;
					esp_76->t0000 = eax_97;
					esp_76->tFFFFFFFC = ecx_101;
					esp_76->tFFFFFFFC = fn007077C0(esp_76->tFFFFFFFC);
					esp_76->tFFFFFFF8 = ecx_101;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_3 stackArg4 = <invalid>;
					esp_76->tFFFFFFF8 = fn00707750(stackArg4);
					Eq_3 eax_129 = g_tA16B7C;
					esp_76->dwFFFFFFF4 = 0x008D79D0;
					esp_76->tFFFFFFF0 = eax_129;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_3 stackArg4 = <invalid>;
					word32 edx_459;
					word32 ecx_135;
					Eq_3 eax_136 = fn006E15D0(stackArg4, dwArg04 - 0x01, out ecx_135, out edx_459);
					Eq_3 v19_141 = (word32) *esi_74 - 1;
					*esi_74 = v19_141;
					struct Eq_95267 * esp_140 = (const char *) &esp_76->t0000 + 4;
					if (v19_141 == 0x00)
					{
						Eq_3 ecx_145 = *((word32) esi_74 + 4);
						Eq_3 edx_146 = *((word32) ecx_145 + 24);
						esp_76->t0000 = esi_74;
						word32 esp_149;
						edx_146();
						esp_140 = esp_149 + 0x04;
					}
					Eq_3 v21_159 = (word32) *edi_70 - 1;
					*edi_70 = v21_159;
					if (v21_159 == 0x00)
					{
						Eq_3 eax_163 = *((word32) edi_70 + 4);
						Eq_3 ecx_164 = *((word32) eax_163 + 24);
						esp_140->tFFFFFFFC = edi_70;
						word32 esp_171;
						ecx_164();
						esp_140 = esp_171 + 0x04;
					}
					Eq_3 v23_181 = (word32) *ebp_30 - 1;
					*ebp_30 = v23_181;
					if (v23_181 == 0x00)
					{
						Eq_3 edx_185 = *((word32) ebp_30 + 4);
						Eq_3 eax_186 = *((word32) edx_185 + 24);
						esp_140->tFFFFFFFC = ebp_30;
						eax_186();
						ecxOut.u0 = <invalid>;
						return 0x00;
					}
					goto l00707A74;
				}
				esp_76->t0000 = edi_70;
				esp_76->tFFFFFFFC = esi_74;
				esp_76->tFFFFFFF8 = ebp_30;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_3 stackArg4 = <invalid>;
				Eq_3 stackArg12 = <invalid>;
				word32 ecx_220;
				word32 edi_464;
				word32 edx_462;
				word32 ebx_463;
				Eq_3 eax_221 = fn006FBD90(stackArg4, dwArg04 - 0x01, stackArg12, out ecx_220, out edx_462, out ebx_463, out edi_464);
				Eq_3 v17_226 = (word32) *esi_74 - 1;
				*esi_74 = v17_226;
				esp_76->t0010 = eax_221;
				esp_225 = (struct Eq_95146 *) ((const char *) &esp_76->t0000 + 4);
				if (v17_226 == 0x00)
				{
					Eq_3 edx_231 = *((word32) esi_74 + 4);
					Eq_3 eax_232 = *((word32) edx_231 + 24);
					esp_76->t0000 = esi_74;
					word32 esp_235;
					eax_232();
					esp_225 = esp_235 + 0x04;
				}
				Eq_3 v20_245 = (word32) *edi_70 - 1;
				*edi_70 = v20_245;
				if (v20_245 == 0x00)
				{
					Eq_3 ecx_249 = *((word32) edi_70 + 4);
					Eq_3 edx_250 = *((word32) ecx_249 + 24);
					esp_225->dwFFFFFFFC = (word32) edi_70;
					word32 esp_258;
					edx_250();
					esp_225 = esp_258 + 0x04;
				}
				if (esp_225[3] != 0x00)
				{
					Eq_3 v24_271 = (word32) *ebp_30 - 1;
					*ebp_30 = v24_271;
					if (v24_271 == 0x00)
					{
						Eq_3 ecx_275 = *((word32) ebp_30 + 4);
						Eq_3 edx_276 = *((word32) ecx_275 + 24);
						esp_225->dwFFFFFFFC = (word32) ebp_30;
						edx_276();
					}
l00707A74:
					ecxOut.u0 = <invalid>;
					return 0x00;
				}
				int32 v22_304 = esp_225[5] - 0x01;
				esp_225[5] = (struct Eq_95146) v22_304;
			} while (v22_304 >= 0x00);
		}
		ecxOut.u0 = <invalid>;
		return ebp_30;
	}
	else
	{
		ecxOut.u0 = <invalid>;
		return 0x00;
	}
}

// 00707A80: Register Eq_3 fn00707A80(Register Eq_3 eax, Register (ptr32 word32) edi, Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Register out (ptr32 word32) ecxOut)
// Called from:
//      fn00707BD0
Eq_3 fn00707A80(Eq_3 eax, word32 * edi, Eq_3 dwArg04, Eq_3 dwArg08, word32 & ecxOut)
{
	Eq_3 ebp_44 = dwArg04;
	word32 edx_145;
	word32 * ecx_106;
	word32 eax_17 = fn006DFD20(eax + dwArg04, out ecx_106, out edx_145);
	if (eax_17 != 0x00)
	{
		if (dwArg04 > 0x00)
		{
			word32 * ebx_32 = (word32) eax_17 + 0x0C + eax * 0x04;
			word32 * edx_33 = (word32) dwArg08 + 0x0C;
			do
			{
				ecx_106 = *edx_33;
				++*ecx_106;
				*ebx_32 = ecx_106;
				++edx_33;
				++ebx_32;
				--ebp_44;
			} while (ebp_44 != 0x00);
		}
		int32 esi_53 = eax - 0x01;
		if (eax >= 0x01)
		{
			ecx_106 = (word32) eax_17 + 0x0C + (eax - 0x01) * 0x04;
			do
			{
				*edi += ~0x03;
				*ecx_106 = *edi + 0x00;
				--esi_53;
				ecx_106 -= 0x04;
			} while (esi_53 >= 0x00);
		}
		ecxOut = ecx_106;
		return <invalid>;
	}
	else
	{
		ecxOut = ecx_106;
		return <invalid>;
	}
}

// 00707AF0: Register Eq_3 fn00707AF0(Register Eq_3 eax, Register Eq_3 esi)
// Called from:
//      fn00708880
Eq_3 fn00707AF0(Eq_3 eax, Eq_3 esi)
{
	word32 edx_82;
	word32 ecx_81;
	Eq_3 eax_12 = fn006DFD20(eax, out ecx_81, out edx_82);
	if (eax_12 == 0x00)
		return;
	int32 edi_21 = eax - 0x01;
	if (eax >= 0x01)
	{
		word32 * ecx_24 = (word32) eax_12 + 0x0C + (eax - 0x01) * 0x04;
		do
		{
			*esi = (word32) *esi - 4;
			*ecx_24 = (word32) **esi;
			--edi_21;
			ecx_24 -= 0x04;
		} while (edi_21 >= 0x00);
	}
	return;
}

// 00707B30: Register Eq_3 fn00707B30(Register Eq_3 eax, Register (ptr32 word32) ecx, Stack Eq_3 dwArg04, Stack Eq_3 dwArg08)
// Called from:
//      fn00708880
Eq_3 fn00707B30(Eq_3 eax, word32 * ecx, Eq_3 dwArg04, Eq_3 dwArg08)
{
	Eq_3 edi_13 = 0x00;
	Eq_3 ebp_114 = 0x00;
	if (eax > 0x00)
	{
		word32 ecx_232;
		Eq_3 eax_29 = fn00707950(0x00, ecx, eax, out ecx_232);
		edi_13 = eax_29;
		if (eax_29 == 0x00)
			return ebp_114;
	}
	word32 ecx_230;
	word32 edx_231;
	Eq_3 eax_55 = fn006DFD20(dwArg08, out ecx_230, out edx_231);
	ptr32 esp_110 = fp - 0x10;
	if (eax_55 != 0x00)
	{
		int32 eax_66 = (word32) dwArg08 - 1;
		if (dwArg08 >= ~0x00)
		{
			word32 * ecx_69 = (word32) eax_55 + 0x0C + ((word32) dwArg08 - 1) * 0x04;
			do
			{
				*ecx += ~0x03;
				*ecx_69 = *ecx + 0x00;
				--eax_66;
				ecx_69 -= 0x04;
			} while (eax_66 >= 0x00);
		}
		word32 edx_234;
		word32 ecx_233;
		Eq_3 eax_105 = fn00703710(dwArg04, dwArg04, edi_13, out ecx_233, out edx_234);
		Eq_3 v17_111 = (word32) *eax_55 - 1;
		*eax_55 = v17_111;
		esp_110 = fp - 0x10;
		ebp_114 = eax_105;
		if (v17_111 == 0x00)
		{
			Eq_3 ecx_116 = *((word32) eax_55 + 4);
			word32 esp_120;
			(*((word32) ecx_116 + 24))();
			esp_110 = esp_120 + 0x04;
		}
	}
	struct Eq_95610 * esp_134 = esp_110 + 4;
	if (edi_13 != 0x00)
	{
		Eq_3 v18_136 = (word32) *edi_13 - 1;
		*edi_13 = v18_136;
		if (v18_136 == 0x00)
		{
			Eq_3 eax_140 = *((word32) edi_13 + 4);
			Eq_3 ecx_141 = *((word32) eax_140 + 24);
			esp_134->tFFFFFFFC = edi_13;
			ecx_141();
		}
	}
	return ebp_114;
}

// 00707BD0: Register (ptr32 word32) fn00707BD0(Register (ptr32 word32) eax, Stack Eq_3 dwArg04, Stack Eq_3 bArg08)
// Called from:
//      fn00708DC0
word32 * fn00707BD0(word32 * eax, Eq_3 dwArg04, Eq_3 bArg08)
{
	word32 ecx_148;
	struct Eq_95706 * esp_154;
	Eq_3 ebp_113 = 0x00;
	Eq_3 edi_117 = 0x00;
	Eq_3 esi_153 = 0x00;
	if ((bArg08 & 0x02) != 0x00)
	{
		*eax += ~0x03;
		esi_153 = *eax + 0x00;
		if (esi_153 == 0x00)
		{
l00707C0F:
			fn007077C0(dwArg04);
			fn00707750(dwArg04);
			word32 edx_502;
			fn006E15D0(g_tA16B7C, dwArg04, out ecx_148, out edx_502);
			esp_154 = fp - 0x14;
			goto l00707D30;
		}
		Eq_3 eax_34 = *((word32) esi_153 + 4);
		if (eax_34 != 0x00A1D1B8)
		{
			word32 ecx_503;
			word32 edx_504;
			if (fn006D5670(eax_34, 0x00A1D1B8, out ecx_503, out edx_504) == 0x00)
				goto l00707C0F;
		}
	}
	struct Eq_95717 * esp_110 = fp - 20;
	if ((bArg08 & 0x01) != 0x00)
	{
		*eax += ~0x03;
		ebp_113 = *eax + 0x00;
		Eq_3 eax_62 = *((word32) ebp_113 + 4);
		if (eax_62 != 0x00A16588)
		{
			esp_110 = fp - 0x14;
			word32 ecx_505;
			word32 edx_506;
			if (fn006D5670(eax_62, 0x00A16588, out ecx_505, out edx_506) == 0x00)
			{
				Eq_3 eax_87 = fn00704BA0(ebp_113);
				esp_110 = fp - 0x14;
				if (eax_87 == 0x00)
				{
					esp_154 = fp - 0x14;
					word32 edx_507;
					if (fn006E1110(out ecx_148, out edx_507) != 0x00)
					{
						fn007077C0(dwArg04);
						fn00707750(dwArg04);
						word32 edx_508;
						fn006E15D0(g_tA16B7C, 0x008D7A0C, out ecx_148, out edx_508);
						esp_154 = fp - 0x14;
					}
					goto l00707D30;
				}
				Eq_3 v17_96 = (word32) *ebp_113 - 1;
				*ebp_113 = v17_96;
				if (v17_96 == 0x00)
				{
					Eq_3 eax_100 = *((word32) ebp_113 + 4);
					Eq_3 ecx_101 = *((word32) eax_100 + 24);
					word32 esp_104;
					ecx_101();
					esp_110 = esp_104 + 0x04;
				}
				ebp_113 = eax_87;
			}
		}
		edi_117 = *((word32) ebp_113 + 8);
	}
	int32 eax_122 = esp_110->dw0024;
	if (eax_122 > 0x00)
	{
		struct Eq_95937 * esp_126 = esp_110 - 4;
		esp_126->dw0000 = esp_110->dw0018;
		esp_126->dwFFFFFFFC = eax_122;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_3 stackArg4 = <invalid>;
		Eq_3 eax_149 = fn00707950(esi_153, eax, stackArg4, out ecx_148);
		esi_153 = eax_149;
		esp_154 = (struct Eq_95706 *) (&esp_126->dw0000 + 1);
		if (eax_149 == 0x00)
		{
l00707D45:
			if (ebp_113 != 0x00)
			{
				Eq_3 v18_339 = (word32) *ebp_113 - 1;
				*ebp_113 = v18_339;
				if (v18_339 == 0x00)
				{
					Eq_3 edx_343 = *((word32) ebp_113 + 4);
					Eq_3 eax_344 = *((word32) edx_343 + 24);
					esp_154->tFFFFFFFC = ebp_113;
					eax_344();
				}
			}
			return null;
		}
	}
	Eq_3 eax_160 = esp_110->t0020;
	struct Eq_95918 * esp_161 = esp_110 - 4;
	esp_161->t0000 = ebp_113;
	esp_161->tFFFFFFFC = edi_117;
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_3 stackArg4 = <invalid>;
	Eq_3 eax_174 = fn00707A80(eax_160, eax, stackArg4, dwArg04, out ecx_148);
	esp_154 = (struct Eq_95706 *) ((const char *) &esp_161->t0000 + 4);
	if (eax_174 != 0x00)
	{
		word32 eax_183 = esp_161->dw001C;
		esp_161->t0000 = esi_153;
		esp_161->tFFFFFFFC = eax_174;
		esp_161->dwFFFFFFF8 = eax_183;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_3 stackArg4 = <invalid>;
		word32 edx_512;
		Eq_3 eax_192 = fn00703710(stackArg4, dwArg04, bArg08, out ecx_148, out edx_512);
		Eq_3 v19_197 = (word32) *eax_174 - 1;
		*eax_174 = v19_197;
		esp_161->t0014 = eax_192;
		esp_154 = (struct Eq_95706 *) ((const char *) &esp_161->t0000 + 4);
		if (v19_197 == 0x00)
		{
			Eq_3 ecx_202 = *((word32) eax_174 + 4);
			Eq_3 edx_203 = *((word32) ecx_202 + 24);
			esp_161->t0000 = eax_174;
			word32 esp_206;
			edx_203();
			esp_154 = esp_206 + 0x04;
		}
	}
l00707D30:
	if (esi_153 != 0x00)
	{
		Eq_3 v16_313 = (word32) *esi_153 - 1;
		*esi_153 = v16_313;
		if (v16_313 == 0x00)
		{
			Eq_3 eax_317 = *((word32) esi_153 + 4);
			Eq_3 ecx_318 = *((word32) eax_317 + 24);
			esp_154->tFFFFFFFC = esi_153;
			word32 esp_326;
			ecx_318();
			esp_154 = esp_326 + 0x04;
		}
	}
	goto l00707D45;
}

// 00707D70: Register word32 fn00707D70(Stack Eq_3 dwArg04, Stack (ptr32 Eq_3) dwArg08)
// Called from:
//      fn00707E00
//      fn00707F70
word32 fn00707D70(Eq_3 dwArg04, union Eq_3 * dwArg08)
{
	if (dwArg04 == 0x00)
		return 0x01;
	Eq_3 esi_31;
	Eq_3 eax_11 = *((word32) dwArg04 + 4);
	if (eax_11 != 10610664)
	{
		word32 ecx_166;
		word32 edx_167;
		if (fn006D5670(eax_11, 10610664, out ecx_166, out edx_167) == 0x00)
		{
			Eq_3 ecx_32 = *((word32) dwArg04 + 4);
			struct Eq_96037 * eax_33 = *((word32) ecx_32 + 48);
			if (eax_33 == null || ((*((word32) ecx_32 + 84) & 0x00020000) == 0x00 || eax_33->dw0098 == 0x00))
			{
				word32 edx_169;
				word32 ecx_168;
				fn006E0F80(g_tA16B7C, 9271912, out ecx_168, out edx_169);
				return 0x00;
			}
			word32 edx_171;
			word32 ecx_170;
			Eq_3 eax_68 = fn00702C30(dwArg04, 0x00, out ecx_170, out edx_171);
			esi_31 = eax_68;
			if (eax_68 == ~0x00 && fn006E0FC0() != 0x00)
				return 0x00;
l00707DEA:
			*dwArg08 = (union Eq_3 *) esi_31;
			return 0x01;
		}
	}
	esi_31 = *((word32) dwArg04 + 8);
	goto l00707DEA;
}

// 00707E00: Register Eq_3 fn00707E00(Register Eq_3 eax, Register Eq_3 ecx, Stack Eq_3 dwArg04)
// Called from:
//      fn00708DC0
Eq_3 fn00707E00(Eq_3 eax, Eq_3 ecx, Eq_3 dwArg04)
{
	Eq_3 eax_20 = *((word32) *((word32) dwArg04 + 4) + 52);
	if (eax_20 == 0x00 || *((word32) eax_20 + 16) == 0x00)
	{
l00707F2C:
		Eq_3 eax_146 = fn0072F1E0(ecx, eax, 0x00);
		if (eax_146 == 0x00)
			return 0x00;
		word32 ecx_160;
		word32 edx_373;
		Eq_3 eax_161 = fn00704220(dwArg04, dwArg04, out ecx_160, out edx_373);
		Eq_3 v13_166 = (word32) *eax_146 - 1;
		*eax_146 = v13_166;
		if (v13_166 == 0x00)
		{
			Eq_3 edx_171 = *((word32) eax_146 + 4);
			Eq_3 eax_172 = *((word32) edx_171 + 24);
			eax_172();
		}
		return eax_161;
	}
	else
	{
		if (ecx != 0x00)
		{
			Eq_3 eax_30 = *((word32) ecx + 4);
			if (eax_30 != 10610664)
			{
				word32 ecx_365;
				word32 edx_366;
				if (fn006D5670(eax_30, 10610664, out ecx_365, out edx_366) == 0x00)
				{
					Eq_3 eax_48 = *((word32) ecx + 4);
					if (eax_48 != 0x00A1F400)
					{
						word32 ecx_367;
						word32 edx_368;
						if (fn006D5670(eax_48, 0x00A1F400, out ecx_367, out edx_368) == 0x00)
						{
							Eq_3 eax_66 = *((word32) ecx + 4);
							struct Eq_96037 * ecx_67 = *((word32) eax_66 + 48);
							if (ecx_67 == null || ((*((word32) eax_66 + 84) & 0x00020000) == 0x00 || ecx_67->dw0098 == 0x00))
								goto l00707F2C;
						}
					}
				}
			}
		}
		if (eax != 0x00)
		{
			Eq_3 eax_81 = *((word32) eax + 4);
			if (eax_81 == 10610664)
				goto l00707EE0;
			word32 ecx_369;
			word32 edx_370;
			if (fn006D5670(eax_81, 10610664, out ecx_369, out edx_370) == 0x00)
			{
				Eq_3 eax_100 = *((word32) eax + 4);
				if (eax_100 == 0x00A1F400)
					goto l00707EE0;
				word32 ecx_371;
				word32 edx_372;
				if (fn006D5670(eax_100, 0x00A1F400, out ecx_371, out edx_372) == 0x00)
				{
					Eq_3 eax_118 = *((word32) eax + 4);
					struct Eq_96037 * ecx_119 = *((word32) eax_118 + 48);
					if (ecx_119 != null && ((*((word32) eax_118 + 84) & 0x00020000) != 0x00 && ecx_119->dw0098 != 0x00))
						goto l00707EE0;
					goto l00707F2C;
				}
			}
		}
l00707EE0:
		if (fn00707D70(ecx, fp - 0x04) == 0x00 || fn00707D70(eax, (union Eq_3 *) 0x7FFFFFFF) == 0x00)
			return 0x00;
		return fn00703210(dwArg04, 0x7FFFFFFF, 0x7FFFFFFF);
	}
}

// 00707F70: Register Eq_3 fn00707F70(Register Eq_3 eax, Register Eq_3 ecx, Register Eq_3 ebx, Stack Eq_3 dwArg04)
// Called from:
//      fn00708DC0
Eq_3 fn00707F70(Eq_3 eax, Eq_3 ecx, Eq_3 ebx, Eq_3 dwArg04)
{
	Eq_3 eax_15 = *((word32) *((word32) ebx + 4) + 52);
	if (eax_15 == 0x00 || *((word32) eax_15 + 24) == 0x00)
	{
l007080CC:
		Eq_3 eax_141 = fn0072F1E0(ecx, eax, 0x00);
		if (eax_141 == 0x00)
			return ~0x00;
		Eq_3 eax_160;
		if (dwArg04 != 0x00)
		{
			word32 ecx_419;
			eax_160 = fn00704300(ebx, eax_141, dwArg04, out ecx_419);
		}
		else
		{
			word32 ecx_418;
			eax_160 = fn00704400(ebx, eax_141, out ecx_418);
		}
		Eq_3 v13_183 = (word32) *eax_141 - 1;
		*eax_141 = v13_183;
		if (v13_183 == 0x00)
		{
			Eq_3 ecx_189 = *((word32) eax_141 + 4);
			(*((word32) ecx_189 + 24))();
		}
		return eax_160;
	}
	else
	{
		if (ecx != 0x00)
		{
			Eq_3 eax_26 = *((word32) ecx + 4);
			if (eax_26 != 10610664)
			{
				word32 ecx_410;
				word32 edx_411;
				if (fn006D5670(eax_26, 10610664, out ecx_410, out edx_411) == 0x00)
				{
					Eq_3 eax_44 = *((word32) ecx + 4);
					if (eax_44 != 0x00A1F400)
					{
						word32 ecx_412;
						word32 edx_413;
						if (fn006D5670(eax_44, 0x00A1F400, out ecx_412, out edx_413) == 0x00)
						{
							Eq_3 eax_62 = *((word32) ecx + 4);
							struct Eq_96037 * ecx_63 = *((word32) eax_62 + 48);
							if (ecx_63 == null || ((*((word32) eax_62 + 84) & 0x00020000) == 0x00 || ecx_63->dw0098 == 0x00))
								goto l007080CC;
						}
					}
				}
			}
		}
		if (eax != 0x00)
		{
			Eq_3 eax_77 = *((word32) eax + 4);
			if (eax_77 == 10610664)
				goto l00708055;
			word32 edx_415;
			word32 ecx_414;
			if (fn006D5670(eax_77, 10610664, out ecx_414, out edx_415) == 0x00)
			{
				Eq_3 eax_96 = *((word32) eax + 4);
				if (eax_96 == 0x00A1F400)
					goto l00708055;
				word32 ecx_416;
				word32 edx_417;
				if (fn006D5670(eax_96, 0x00A1F400, out ecx_416, out edx_417) == 0x00)
				{
					Eq_3 eax_114 = *((word32) eax + 4);
					struct Eq_96037 * ecx_115 = *((word32) eax_114 + 48);
					if (ecx_115 != null && ((*((word32) eax_114 + 84) & 0x00020000) != 0x00 && ecx_115->dw0098 != 0x00))
						goto l00708055;
					goto l007080CC;
				}
			}
		}
l00708055:
		if (fn00707D70(ecx, fp - 0x04) == 0x00 || fn00707D70(eax, fp - 0x08) == 0x00)
			return ~0x00;
		if (dwArg04 != 0x00)
			return fn00703420(ebx, 0x00, 0x7FFFFFFF, dwArg04);
		return fn00703520(ebx, 0x00, 0x7FFFFFFF);
	}
}

// 00708130: Register Eq_3 fn00708130(Register Eq_3 eax, Register Eq_3 ecx, Register Eq_3 esi)
// Called from:
//      fn00708DC0
Eq_3 fn00708130(Eq_3 eax, Eq_3 ecx, Eq_3 esi)
{
	if (esi > 0x0A)
	{
		word32 edx_161;
		return fn006DF4C0(ecx, eax, esi, out edx_161);
	}
	else
	{
		bool v20_105;
		uint32 eax_30;
		switch (esi)
		{
		case 0x06:
			int32 eax_81 = fn00704FE0(eax, ecx);
			v20_105 = eax_81 != 0x00;
			if (eax_81 < 0x00)
				return 0x00;
			goto l0070818B;
		case 0x07:
			int32 eax_56 = fn00704FE0(eax, ecx);
			if (eax_56 < 0x00)
				return 0x00;
			eax_30 = (uint32) (int8) (eax_56 == 0x00);
			break;
		case 0x08:
			eax_30 = (uint32) (int8) (ecx == eax);
			break;
		case 0x09:
			eax_30 = (uint32) (int8) (ecx != eax);
			break;
		case 0x0A:
			word32 ecx_162;
			word32 edx_163;
			eax_30 = fn006E0FD0(ecx, eax, out ecx_162, out edx_163);
			break;
		}
		v20_105 = eax_30 != 0x00;
l0070818B:
		Eq_3 eax_89 = 0x00A191E4;
		if (!v20_105)
			eax_89.u0 = 0x00A191D8;
		*eax_89 = (word32) *eax_89 + 1;
		return eax_89;
	}
}

// 007081C0: Register Eq_3 fn007081C0()
// Called from:
//      fn00708DC0
Eq_3 fn007081C0()
{
	word32 ecx_109;
	word32 edx_110;
	Eq_3 eax_14 = fn006DE330(eax, edi, out ecx_109, out edx_110);
	if (eax_14 == 0x00)
	{
		word32 ecx_111;
		word32 edx_112;
		if (fn006E1110(out ecx_111, out edx_112) != 0x00)
		{
			word32 ecx_113;
			word32 edx_114;
			word32 esi_115;
			fn006ECC50(edi, out ecx_113, out edx_114, out esi_115);
			word32 ecx_116;
			word32 edx_117;
			fn006E15D0(g_tA16F8C, 0x008D7AAC, out ecx_116, out edx_117);
		}
	}
	return eax_14;
}

// 00708210: Register Eq_3 fn00708210(Register Eq_3 ebp, Stack Eq_3 dwArg08)
// Called from:
//      fn00708DC0
Eq_3 fn00708210(Eq_3 ebp, Eq_3 dwArg08)
{
	word32 edi_589;
	word32 edx_588;
	Eq_3 eax_21 = fn006DF760(dwArg08, 0x008D5F08, out edx_588, out edi_589);
	Eq_3 edi_15 = dwArg08;
	Eq_3 ebx_115 = eax_21;
	struct Eq_96557 * esp_101 = fp - 0x14;
	if (eax_21 == 0x00)
	{
		word32 ecx_594;
		word32 edx_595;
		if (fn006E1110(out ecx_594, out edx_595) == 0x00)
			return ~0x00;
		word32 ecx_596;
		word32 edx_597;
		fn006E1160(out ecx_596, out edx_597);
		word32 edx_598;
		word32 edi_599;
		Eq_3 eax_57 = fn006DF760(dwArg08, 9093500, out edx_598, out edi_599);
		if (eax_57 == 0x00)
		{
			word32 ecx_602;
			word32 edx_603;
			if (fn006E1110(out ecx_602, out edx_603) != 0x00)
			{
				word32 ecx_604;
				word32 edx_605;
				fn006E0F80(g_tA16F8C, 9272008, out ecx_604, out edx_605);
			}
			return ~0x00;
		}
		word32 edx_601;
		word32 ecx_600;
		Eq_3 eax_74 = fn007038E0(eax_57, 0x008B0A10, dwArg08, out ecx_600, out edx_601);
		Eq_3 v17_80 = (word32) *eax_57 - 1;
		*eax_57 = v17_80;
		esp_101 = fp - 0x14;
		ebx_115 = eax_74;
		if (v17_80 == 0x00)
		{
			Eq_3 eax_85 = *((word32) eax_57 + 4);
			word32 esp_89;
			(*((word32) eax_85 + 24))();
			esp_101 = esp_89 + 0x04;
		}
		if (eax_74 == 0x00)
			return ~0x00;
		esp_101->dw000C = 0x01;
	}
	struct Eq_96563 * esp_163;
	struct Eq_96563 * esp_104 = esp_101 - 4;
	esp_104->t0000 = ebp;
	esp_104->dwFFFFFFFC = 0x00;
	esp_104->tFFFFFFF8 = ebx_115;
	esp_104[5] = (struct Eq_96563) 0x00;
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_3 stackArg4 = <invalid>;
	Eq_3 stackArg8 = <invalid>;
	word32 ecx_592;
	word32 edx_593;
	Eq_3 eax_125 = fn00703180(stackArg4, stackArg8, out ecx_592, out edx_593);
	Eq_3 ebp_109 = 0x00;
	Eq_3 esi_130 = eax_125;
	struct Eq_96563 * esp_131 = esp_104;
	if (eax_125 != 0x00)
	{
		do
		{
			if (esp_131[4] != 0x00)
			{
				Eq_3 eax_140 = *((word32) esi_130 + 4);
				if (eax_140 != 0x00A1B450)
				{
					struct Eq_96713 * esp_143 = esp_131 - 4;
					esp_143->t0000.u0 = 0x00A1B450;
					esp_143->tFFFFFFFC = eax_140;
					word32 edx_613;
					word32 ecx_612;
					if (fn006D5670(esp_143->tFFFFFFFC, esp_143->t0000, out ecx_612, out edx_613) != 0x00)
						goto l00708303;
					goto l0070831C;
				}
l00708303:
				esp_163 = esp_131;
				if (*((word32) esi_130 + 20) != 0x5F)
					goto l0070831C;
				Eq_3 v14_282 = (word32) *esi_130 - 1;
				*esi_130 = v14_282;
				if (v14_282 == 0x00)
				{
					Eq_3 edx_286 = *((word32) esi_130 + 4);
					Eq_3 eax_287 = *((word32) edx_286 + 24);
					esp_131->dwFFFFFFFC = (word32) esi_130;
					word32 esp_290;
					eax_287();
					esp_163 = esp_290 + 0x04;
				}
			}
			else
			{
l0070831C:
				struct Eq_96682 * esp_164 = esp_131 - 4;
				esp_164->t0000 = esi_130;
				esp_164->tFFFFFFFC = edi_15;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_3 stackArg4 = <invalid>;
				Eq_3 stackArg8 = <invalid>;
				word32 ecx_610;
				word32 edx_611;
				Eq_3 eax_182 = fn006DE330(stackArg4, stackArg8, out ecx_610, out edx_611);
				if (eax_182 == 0x00)
					ebp_109.u0 = ~0x00;
				else
				{
					Eq_3 eax_202;
					struct Eq_96824 * eax_192 = esp_164->ptr0020;
					esp_164->t0000 = eax_182;
					esp_164->tFFFFFFFC = esi_130;
					esp_164->ptrFFFFFFF8 = eax_192;
					if (eax_192->dw0004 == 0x00A1D1B8)
					{
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_3 stackArg4 = <invalid>;
						Eq_3 stackArg8 = <invalid>;
						word32 edi_628;
						word32 ebx_627;
						word32 edx_626;
						word32 ecx_625;
						eax_202 = fn006FBD90(stackArg4, stackArg8, dwArg08, out ecx_625, out edx_626, out ebx_627, out edi_628);
					}
					else
					{
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_3 stackArg4 = <invalid>;
						Eq_3 stackArg8 = <invalid>;
						word32 ecx_622;
						eax_202 = fn00704300(stackArg4, stackArg8, dwArg08, out ecx_622);
					}
					ebp_109 = eax_202;
				}
				Eq_3 v16_225 = (word32) *esi_130 - 1;
				*esi_130 = v16_225;
				esp_163 = esp_131;
				if (v16_225 == 0x00)
				{
					Eq_3 ecx_229 = *((word32) esi_130 + 4);
					Eq_3 edx_230 = *((word32) ecx_229 + 24);
					esp_131->dwFFFFFFFC = (word32) esi_130;
					word32 esp_241;
					edx_230();
					esp_163 = esp_241 + 0x04;
				}
				if (eax_182 != 0x00)
				{
					Eq_3 v18_254 = (word32) *eax_182 - 1;
					*eax_182 = v18_254;
					if (v18_254 == 0x00)
					{
						Eq_3 eax_258 = *((word32) eax_182 + 4);
						Eq_3 ecx_259 = *((word32) eax_258 + 24);
						esp_163->dwFFFFFFFC = (word32) eax_182;
						word32 esp_267;
						ecx_259();
						esp_163 = esp_267 + 0x04;
					}
				}
				if (ebp_109 != 0x00)
					goto l007083BC;
				edi_15 = esp_163[8];
			}
			word32 eax_300 = esp_163[5];
			struct Eq_96752 * esp_303 = esp_163 - 4;
			esp_303->dw0000 = eax_300 + 0x01;
			esp_303->tFFFFFFFC = ebx_115;
			esp_303->dw0018 = eax_300 + 0x01;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg4 = <invalid>;
			Eq_3 stackArg8 = <invalid>;
			word32 edx_617;
			word32 ecx_616;
			Eq_3 eax_317 = fn00703180(stackArg4, stackArg8, out ecx_616, out edx_617);
			esi_130 = eax_317;
			esp_131 = (struct Eq_96563 *) (&esp_303->dw0000 + 1);
		} while (eax_317 != 0x00);
	}
	union Eq_3 * esp_330 = esp_131 - 4;
	*esp_330 = (union Eq_3 *) g_tA17CA4;
	esp_163 = (struct Eq_96563 *) ((const char *) esp_330 + 4);
	word32 ecx_606;
	word32 edx_607;
	if (fn006E1110(out ecx_606, out edx_607) == 0x00)
		ebp_109.u0 = ~0x00;
	else
	{
		word32 ecx_618;
		word32 edx_619;
		fn006E1160(out ecx_618, out edx_619);
	}
l007083BC:
	Eq_3 v15_359 = (word32) *ebx_115 - 1;
	*ebx_115 = v15_359;
	if (v15_359 == 0x00)
	{
		Eq_3 eax_363 = *((word32) ebx_115 + 4);
		Eq_3 ecx_364 = *((word32) eax_363 + 24);
		esp_163->dwFFFFFFFC = (word32) ebx_115;
		ecx_364();
	}
	return ebp_109;
}

// 007083E0: void fn007083E0(Register Eq_3 eax)
// Called from:
//      fn00708DC0
void fn007083E0(Eq_3 eax)
{
	if (eax != 0x00)
	{
		word32 ecx_61;
		word32 edx_62;
		word32 esi_63;
		if (fn006ECC50(eax, out ecx_61, out edx_62, out esi_63) != 0x00)
		{
			word32 ecx_64;
			word32 edx_65;
			fn006E15D0(dwArg04, dwArg08, out ecx_64, out edx_65);
		}
	}
}

// 00708410: Register Eq_3 fn00708410(Register (ptr32 Eq_96956) ecx, Register (ptr32 Eq_96957) edx, Stack Eq_3 dwArg04, Stack Eq_3 dwArg08)
// Called from:
//      fn00708DC0
Eq_3 fn00708410(struct Eq_96956 * ecx, struct Eq_96957 * edx, Eq_3 dwArg04, Eq_3 dwArg08)
{
	Eq_3 ebp_16 = *((word32) dwArg04 + 8);
	struct Eq_96964 * esp_12 = fp - 0x0C;
	Eq_3 esi_135 = dwArg04;
	if (Mem6[dwArg08 + 0x08:word32] + ebp_16 < 0x00)
	{
		word32 edx_339;
		word32 ecx_338;
		fn006E0F80(g_tA18598, 0x008D48B0, out ecx_338, out edx_339);
		return 0x00;
	}
	if (*dwArg04 != 0x02)
	{
l0070851F:
		if (*esi_135 != 0x01 || *((word32) esi_135 + 16) != 0x00)
		{
			struct Eq_97103 * esp_153 = esp_12 - 4;
			esp_153->dw0000 = esp_12->dw0014;
			esp_153->ptrFFFFFFFC = &esp_153->dw0000 + 5;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg4 = <invalid>;
			fn006EC440(stackArg4, dwArg04);
			return dwArg04;
		}
		else
		{
			Eq_3 esi_190 = esp_12->t0008;
			struct Eq_97129 * esp_192 = esp_12 - 4;
			Mem193[esp_192 + 0x00:word32] = esi_190 + ebp_16;
			esp_192->ptrFFFFFFFC = &esp_192->dw0000 + 5;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg4 = <invalid>;
			word32 ecx_343;
			word32 edx_344;
			if (fn006EC4F0(stackArg4, dwArg04, out ecx_343, out edx_344) != 0x00)
				return 0x00;
			memcpy((word32) ebp_16 + ((word32) dwArg04 + 20), (word32) dwArg08 + 20, esi_190);
			return dwArg04;
		}
	}
	word32 eax_23 = (word32) ecx->b0000;
	struct Eq_96999 * esp_107 = fp - 20;
	if (eax_23 != 0x5A)
	{
		if (eax_23 != 0x7D)
		{
			if (eax_23 != 0x89)
				goto l0070851D;
			Eq_3 edx_118 = edx->a0138[((word32) ecx->b0002 << 0x08) + (edx->ptr0010)->dw000C + (word32) ecx->b0001];
			if (*((word32) edx_118 + 8) == dwArg04)
			{
				word32 ecx_340;
				fn00750420(edx_118, 0x00, out ecx_340);
				esp_107 = fp - 0x14;
				goto l00708519;
			}
l0070851D:
			esp_12 = (struct Eq_96964 *) ((const char *) esp_107 + 8);
			goto l0070851F;
		}
		ui32 eax_85 = ((word32) ecx->b0002 << 0x08) + (word32) ecx->b0001;
		Eq_3 ecx_86 = edx->a0138[eax_85];
		if (ecx_86 != dwArg04)
			goto l0070851D;
		edx->a0138[eax_85].u0 = 0x00;
		if (ecx_86 == 0x00)
			goto l0070851D;
		Eq_3 v15_93 = (word32) *ecx_86 - 1;
		*ecx_86 = v15_93;
		if (v15_93 == 0x00)
		{
			Eq_3 edx_97 = *((word32) ecx_86 + 4);
			word32 esp_101;
			(*((word32) edx_97 + 24))();
			esp_107 = esp_101 + 0x04;
		}
	}
	else
	{
		Eq_3 edi_36 = edx->t001C;
		Eq_3 ebx_42 = edx->ptr0010->ptr0020->a000C[((word32) ecx->b0002 << 0x08) + (word32) ecx->b0001];
		if (*((word32) edi_36 + 4) != 0x00A1D1B8)
			goto l0070851D;
		esi_135 = dwArg04;
		esp_107 = fp - 0x14;
		word32 ecx_345;
		word32 edx_346;
		if (fn006FBCC0(edi_36, ebx_42, out ecx_345, out edx_346) != dwArg04)
			goto l0070851D;
		esp_107 = fp - 0x14;
		if (fn006FBE60(edi_36, dwArg04) != 0x00)
		{
			word32 ecx_347;
			word32 edx_348;
			fn006E1160(out ecx_347, out edx_348);
		}
	}
l00708519:
	esi_135 = esp_107->t0018;
	goto l0070851D;
}

// 00708590: void fn00708590(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Stack Eq_3 dwArg0C)
// Called from:
//      fn00708DC0
void fn00708590(Eq_3 dwArg04, Eq_3 dwArg08, Eq_3 dwArg0C)
{
	fn006E1130(fp - 0x08, fp - 0x0C, fp - 0x04);
	if (dwLoc0C == 0x00)
	{
		++g_dwA163B8;
		dwLoc0C = 0x00A163B8;
	}
	word32 ecx_324;
	word32 edx_325;
	word32 esi_326;
	Eq_3 eax_51 = fn006DFF80(0x03, out ecx_324, out edx_325, out esi_326);
	if (eax_51 != 0x00)
	{
		Eq_3 eax_74 = fn007073E0(dwArg0C, eax_51, 0x01, dwArg04, dwArg08);
		Eq_3 v13_82 = (word32) *eax_51 - 1;
		*eax_51 = v13_82;
		if (v13_82 == 0x00)
		{
			Eq_3 edx_87 = *((word32) eax_51 + 4);
			(*((word32) edx_87 + 24))();
		}
		struct Eq_97264 * esp_106 = fp - 16;
		if (eax_74 != 0x00)
		{
			if (dwLoc08 != null)
			{
				dwLoc08->dw0000 += ~0x00;
				if (dwLoc08->dw0000 == 0x00)
				{
					struct Eq_97304 * ecx_116 = dwLoc08->ptr0004;
					word32 esp_122;
					ecx_116->ptr0018();
					esp_106 = esp_122 + 0x04;
				}
			}
			struct Eq_97285 * eax_132 = esp_106->ptr0004;
			if (eax_132 != null)
			{
				eax_132->dw0000 += ~0x00;
				struct Eq_97285 * eax_138 = esp_106->ptr0004;
				if (eax_138->dw0000 == 0x00)
				{
					struct Eq_97337 * ecx_141 = eax_138->ptr0004;
					<anonymous> * edx_142 = ecx_141->ptr0018;
					esp_106->ptrFFFFFFFC = eax_138;
					word32 esp_148;
					edx_142();
					esp_106 = esp_148 + 0x04;
				}
			}
			struct Eq_97285 * eax_158 = esp_106->ptr000C;
			if (eax_158 != null)
			{
				eax_158->dw0000 += ~0x00;
				struct Eq_97285 * eax_164 = esp_106->ptr000C;
				if (eax_164->dw0000 == 0x00)
				{
					struct Eq_97337 * ecx_167 = eax_164->ptr0004;
					<anonymous> * edx_168 = ecx_167->ptr0018;
					esp_106->ptrFFFFFFFC = eax_164;
					edx_168();
				}
			}
		}
		else
		{
			word32 edx_330;
			word32 ecx_329;
			fn006E0E00(dwLoc04, out ecx_329, out edx_330);
		}
	}
	else
	{
		word32 edx_328;
		word32 ecx_327;
		fn006E0E00(dwLoc04, out ecx_327, out edx_328);
	}
}

// 007086B0: Register word32 fn007086B0(Register Eq_3 edi, Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Stack Eq_3 dwArg0C, Stack Eq_3 dwArg10)
// Called from:
//      fn00708880
//      fn00708DC0
word32 fn007086B0(Eq_3 edi, Eq_3 dwArg04, Eq_3 dwArg08, Eq_3 dwArg0C, Eq_3 dwArg10)
{
	fn006E1130(fp - 0x0C, fp - 0x08, fp - 0x04);
	struct Eq_93693 * esi_26 = *((word32) edi + 56);
	if (esi_26->dw0010 == 0x00)
	{
		word32 ecx_54;
		esi_26->dw0010 = 0x01;
		esi_26->dw0014 = 0x00;
		struct Eq_97420 * esp_43;
		word32 eax_44;
		dwArg04();
		struct Eq_97422 * esp_122 = (const char *) &esp_43->ptr000C + 4;
		if (esi_26->dw001C == 0x00 && esi_26->dw0018 == 0x00)
			ecx_54 = 0x00;
		else
			ecx_54 = 0x01;
		esi_26->dw0010 += ~0x00;
		esi_26->dw0014 = ecx_54;
		if (eax_44 != 0x00)
		{
			struct Eq_97450 * eax_73 = esp_43->ptr0014;
			if (eax_73 != null)
			{
				eax_73->dw0000 += ~0x00;
				struct Eq_97450 * eax_79 = esp_43->ptr0014;
				if (eax_79->dw0000 == 0x00)
				{
					struct Eq_97479 * ecx_82 = eax_79->ptr0004;
					<anonymous> * edx_83 = ecx_82->ptr0018;
					esp_43->ptr000C = eax_79;
					word32 esp_90;
					edx_83();
					esp_122 = esp_90 + 0x04;
				}
			}
			struct Eq_97456 * eax_100 = esp_122->ptr0008;
			if (eax_100 != null)
			{
				eax_100->dw0000 += ~0x00;
				struct Eq_97456 * eax_106 = esp_122->ptr0008;
				if (eax_106->dw0000 == 0x00)
				{
					struct Eq_97516 * ecx_109 = eax_106->ptr0004;
					<anonymous> * edx_110 = ecx_109->ptr0018;
					esp_122->ptrFFFFFFFC = eax_106;
					word32 esp_116;
					edx_110();
					esp_122 = esp_116 + 0x04;
				}
			}
			struct Eq_97456 * eax_126 = esp_122->ptr000C;
			if (eax_126 != null)
			{
				eax_126->dw0000 += ~0x00;
				struct Eq_97456 * eax_132 = esp_122->ptr000C;
				if (eax_132->dw0000 == 0x00)
				{
					struct Eq_97516 * ecx_135 = eax_132->ptr0004;
					<anonymous> * edx_136 = ecx_135->ptr0018;
					esp_122->ptrFFFFFFFC = eax_132;
					edx_136();
				}
			}
			return ~0x00;
		}
	}
	word32 edx_264;
	word32 ecx_263;
	fn006E0E00(dwLoc04, out ecx_263, out edx_264);
	return 0x00;
}

// 00708800: Register Eq_3 fn00708800()
// Called from:
//      fn006F6490
Eq_3 fn00708800()
{
	Eq_3 eax_5 = g_tA6D67C;
	struct Eq_97563 * eax_9;
	g_ptrA6D680();
	if (eax_9 != null)
		return eax_9->t0014;
	return *((word32) *((word32) g_tA6D67C + 4) + 16);
}

// 00708860: Register (ptr32 Eq_97579) fn00708860()
// Called from:
//      fn006F9120
struct Eq_97579 * fn00708860()
{
	Eq_3 eax_5 = g_tA6D67C;
	struct Eq_97579 * eax_9;
	g_ptrA6D680();
	if (eax_9 != null)
		return eax_9->ptr0018;
	return eax_9;
}

// 00708880: Register Eq_3 fn00708880(Register Eq_3 eax, Stack Eq_3 dwArg04)
// Called from:
//      fn00708DC0
Eq_3 fn00708880(Eq_3 eax, Eq_3 dwArg04)
{
	byte ah_16 = SLICE(eax, byte, 8);
	struct Eq_97595 * esp_150;
	word32 esp_335;
	Eq_3 eax_115;
	Eq_3 ecx_149;
	Eq_3 ebp_17 = (word32) ah_16;
	Eq_3 ecx_129 = (eax & 0xFF) + ebp_17 * 0x02;
	union Eq_3 * edx_23 = *dwArg04 - (ecx_129 * 0x04 + 0x04);
	Eq_3 edi_27 = *edx_23;
	Eq_3 esi_147 = eax & 0xFF;
	struct Eq_97595 * esp_24 = fp - 0x1C;
	Eq_3 eax_28 = *((word32) edi_27 + 4);
	if (eax_28 == 10602136 && ebp_17 == 0x00)
	{
		Eq_3 ecx_153 = *((word32) edi_27 + 8);
		Eq_3 eax_154 = *((word32) ecx_153 + 8);
		byte al_155 = (byte) eax_154;
		Eq_3 ebx_158 = g_tA6D67C;
		if ((al_155 & 0x0C) != 0x00)
		{
			Eq_3 ebp_343 = *((word32) ecx_153 + 4);
			Eq_3 ecx_344 = *((word32) edi_27 + 0x0C);
			if ((al_155 & 0x04) != 0x00 && (eax & 0xFF) == 0x00)
			{
				if (*((word32) ebx_158 + 20) != (eax & 0xFF))
				{
					eax_154 = *((word32) ebx_158 + 24);
					if (eax_154 != 0x00)
					{
						Eq_3 eax_586 = fn007073E0(*((word32) ebx_158 + 8), edi_27, 0x04, eax_154, *((word32) ebx_158 + 32));
						esp_150 = fp - 0x1C;
						if (eax_586 == 0x00)
						{
							struct Eq_97722 * esp_602;
							Eq_3 eax_603;
							ebp_343();
							esi_147 = eax_603;
							Eq_3 eax_609 = *((word32) ebx_158 + 24);
							esp_150 = (struct Eq_97595 *) ((const char *) &esp_602->t0004 + 4);
							if (eax_609 != 0x00)
							{
								if (eax_603 == 0x00)
								{
									Eq_3 ecx_655 = *((word32) ebx_158 + 32);
									esp_602->t0004 = edi_27;
									Eq_3 edi_658 = *((word32) ebx_158 + 8);
									esp_602->t0000.u0 = 0x05;
									esp_602->tFFFFFFFC = ecx_655;
									esp_602->tFFFFFFF8 = eax_609;
									fn007086B0(edi_658, esp_602->tFFFFFFF8, esp_602->tFFFFFFFC, esp_602->t0000, esp_602->t0004);
									esp_150 = (struct Eq_97595 *) ((const char *) &esp_602->t0004 + 4);
								}
								else
								{
									esp_602->t0004 = *((word32) ebx_158 + 32);
									esp_602->t0000 = eax_609;
									esp_150 = (struct Eq_97595 *) ((const char *) &esp_602->t0004 + 4);
									if (fn007073E0(*((word32) ebx_158 + 8), edi_27, 0x06, esp_602->t0000, esp_602->t0004) != 0x00)
									{
										Eq_3 v23_636 = (word32) *eax_603 - 1;
										*eax_603 = v23_636;
										if (v23_636 == 0x00)
										{
											Eq_3 eax_640 = *((word32) eax_603 + 4);
											Eq_3 ecx_641 = *((word32) eax_640 + 24);
											esp_602->t0004 = eax_603;
											word32 esp_644;
											ecx_641();
											esp_150 = esp_644 + 0x04;
										}
										esi_147.u0 = 0x00;
									}
								}
							}
						}
						goto l00708BCD;
					}
				}
				word32 esp_569;
				Eq_3 eax_570;
				ebp_343();
				esp_150 = esp_569 + 0x08;
				esi_147 = eax_570;
				goto l00708BCD;
			}
			if ((al_155 & 0x08) == 0x00 || (eax & 0xFF) != 0x01)
			{
				fn00707810(eax_154);
				esp_150 = fp - 0x1C;
				esi_147.u0 = 0x00;
				goto l00708BCD;
			}
			Eq_3 eax_388 = *dwArg04;
			*dwArg04 = (word32) eax_388 - 4;
			Eq_3 eax_389 = (word32) eax_388 - 4;
			word32 esi_392 = *((word32) eax_388 - 4);
			if (*((word32) ebx_158 + 20) != 0x00)
			{
				eax_389 = *((word32) ebx_158 + 24);
				if (eax_389 != 0x00)
				{
					Eq_3 eax_429 = fn007073E0(*((word32) ebx_158 + 8), edi_27, 0x04, eax_389, *((word32) ebx_158 + 32));
					esp_150 = fp - 0x1C;
					if (eax_429 != 0x00)
						esi_147.u0 = 0x00;
					else
					{
						struct Eq_98164 * esp_445;
						Eq_3 eax_446;
						ebp_343();
						esi_147 = eax_446;
						Eq_3 eax_452 = *((word32) ebx_158 + 24);
						esp_150 = (struct Eq_97595 *) ((const char *) &esp_445->t0004 + 4);
						if (eax_452 != 0x00)
						{
							if (eax_446 == 0x00)
							{
								Eq_3 ecx_498 = *((word32) ebx_158 + 32);
								esp_445->t0004 = edi_27;
								Eq_3 edi_501 = *((word32) ebx_158 + 8);
								esp_445->t0000.u0 = 0x05;
								esp_445->tFFFFFFFC = ecx_498;
								esp_445->tFFFFFFF8 = eax_452;
								fn007086B0(edi_501, esp_445->tFFFFFFF8, esp_445->tFFFFFFFC, esp_445->t0000, esp_445->t0004);
								esp_150 = (struct Eq_97595 *) ((const char *) &esp_445->t0004 + 4);
							}
							else
							{
								esp_445->t0004 = *((word32) ebx_158 + 32);
								esp_445->t0000 = eax_452;
								esp_150 = (struct Eq_97595 *) ((const char *) &esp_445->t0004 + 4);
								if (fn007073E0(*((word32) ebx_158 + 8), edi_27, 0x06, esp_445->t0000, esp_445->t0004) != 0x00)
								{
									Eq_3 v28_479 = (word32) *eax_446 - 1;
									*eax_446 = v28_479;
									if (v28_479 == 0x00)
									{
										Eq_3 eax_483 = *((word32) eax_446 + 4);
										Eq_3 ecx_484 = *((word32) eax_483 + 24);
										esp_445->t0004 = eax_446;
										word32 esp_487;
										ecx_484();
										esp_150 = esp_487 + 0x04;
									}
									esi_147.u0 = 0x00;
								}
							}
						}
					}
l00708A58:
					Eq_3 eax_524 = esp_150->t0018;
					Eq_3 v27_525 = (word32) *eax_524 - 1;
					*eax_524 = v27_525;
					if (v27_525 != 0x00)
						goto l00708BCD;
					Eq_3 edx_529 = *((word32) eax_524 + 4);
					esp_150->tFFFFFFFC = eax_524;
					Eq_3 eax_532 = *((word32) edx_529 + 24);
					eax_532();
l00708BCA:
					esp_150 = esp_335 + 0x04;
					goto l00708BCD;
				}
			}
			word32 esp_412;
			Eq_3 eax_413;
			ebp_343();
			esp_150 = esp_412 + 0x08;
			esi_147 = eax_413;
			goto l00708A58;
		}
		Eq_3 eax_163 = fn00707AF0(eax & 0xFF, dwArg04);
		if (*((word32) ebx_158 + 20) != 0x00)
		{
			Eq_3 eax_171 = *((word32) ebx_158 + 24);
			if (eax_171 != 0x00)
			{
				eax_115 = fn007073E0(*((word32) ebx_158 + 8), edi_27, 0x04, eax_171, *((word32) ebx_158 + 32));
				esp_150 = fp - 0x1C;
				if (eax_115 != 0x00)
					esi_147.u0 = 0x00;
				else
				{
					Eq_3 eax_223 = fn006F9540(edi_27, dwArg04, 0x00);
					esi_147 = eax_223;
					eax_115 = *((word32) ebx_158 + 24);
					esp_150 = fp - 0x1C;
					if (eax_115 != 0x00)
					{
						if (eax_223 == 0x00)
						{
							eax_115 = fn007086B0(*((word32) ebx_158 + 8), eax_115, *((word32) ebx_158 + 32), 0x05, edi_27);
							esp_150 = fp - 0x1C;
						}
						else
						{
							eax_115 = fn007073E0(*((word32) ebx_158 + 8), edi_27, 0x06, eax_115, *((word32) ebx_158 + 32));
							esp_150 = fp - 0x1C;
							if (eax_115 != 0x00)
							{
								Eq_3 v22_256 = (word32) *eax_223 - 1;
								*eax_223 = v22_256;
								if (v22_256 == 0x00)
								{
									Eq_3 edx_260 = *((word32) eax_223 + 4);
									Eq_3 eax_261 = *((word32) edx_260 + 24);
									word32 esp_264;
									eax_261();
									esp_150 = esp_264 + 0x04;
								}
								esi_147.u0 = 0x00;
							}
						}
					}
				}
l00708B30:
				if (eax_163 == 0x00)
					goto l00708BCD;
				Eq_3 v20_304 = (word32) *eax_163 - 1;
				*eax_163 = v20_304;
				if (v20_304 == 0x00)
				{
					ecx_149 = *((word32) eax_163 + 4);
					esp_150->tFFFFFFFC = eax_163;
					goto l00708BC5;
				}
l00708BCD:
				struct Eq_95155 * ebx_679 = esp_150->ptr0014;
				word32 * edi_680 = esp_150->ptr0020;
				if (*edi_680 > ebx_679)
				{
					struct Eq_97595 * esp_683 = esp_150;
					do
					{
						*edi_680 += ~0x03;
						Eq_3 eax_689 = *edi_680 + 0x00;
						Eq_3 v26_690 = (word32) *eax_689 - 1;
						*eax_689 = v26_690;
						if (v26_690 == 0x00)
						{
							Eq_3 ecx_694 = *((word32) eax_689 + 4);
							Eq_3 edx_695 = *((word32) ecx_694 + 24);
							esp_683->tFFFFFFFC = eax_689;
							word32 esp_703;
							edx_695();
							esp_683 = esp_703 + 0x04;
						}
					} while (*edi_680 > ebx_679);
				}
				return esi_147;
			}
		}
		eax_115 = fn006F9540(edi_27, dwArg04, 0x00);
		esp_150 = fp - 0x1C;
		esi_147 = eax_115;
		goto l00708B30;
	}
	if (eax_28 == 10612000)
	{
		Eq_3 ebx_41 = *((word32) edi_27 + 0x0C);
		if (ebx_41 != 0x00)
		{
			*ebx_41 = (word32) *ebx_41 + 1;
			edi_27 = *((word32) edi_27 + 8);
			*edi_27 = (word32) *edi_27 + 1;
			Eq_3 eax_56 = *edx_23;
			*eax_56 = (word32) *eax_56 - 1;
			Eq_3 eax_59 = *edx_23;
			if (*eax_59 == 0x00)
			{
				Eq_3 ecx_62 = *((word32) eax_59 + 4);
				struct Eq_97863 * esp_70;
				(*((word32) ecx_62 + 24))();
				edx_23 = esp_70->ptr0018;
				ecx_129 = esp_70->t001C;
				esp_24 = (struct Eq_97595 *) ((const char *) esp_70 + 4);
			}
			*edx_23 = (union Eq_3 *) ebx_41;
			esi_147 = (eax & 0xFF) + 0x01;
			ecx_129 = (word32) ecx_129 + 1;
l00708B8C:
			if (*((word32) edi_27 + 4) == 0x00A249B8)
			{
				word32 * eax_122 = esp_24->ptr0020;
				struct Eq_97934 * esp_123 = esp_24 - 4;
				esp_123->t0000 = ebp_17;
				esp_123->tFFFFFFFC = esi_147;
				esp_123->ptrFFFFFFF8 = eax_122;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_3 stackArg4 = <invalid>;
				Eq_3 stackArg12 = <invalid>;
				eax_115 = fn00707850(ecx_129, edi_27, stackArg4, dwArg04, stackArg12);
			}
			else
			{
				word32 * ecx_97 = esp_24->ptr0020;
				struct Eq_97917 * esp_98 = esp_24 - 4;
				esp_98->t0000 = esi_147;
				esp_98->tFFFFFFFC = edi_27;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_3 stackArg4 = <invalid>;
				eax_115 = fn00707B30(ebp_17, ecx_97, stackArg4, dwArg04);
			}
			Eq_3 v21_143 = (word32) *edi_27 - 1;
			*edi_27 = v21_143;
			esp_150 = esp_24;
			esi_147 = eax_115;
			if (v21_143 == 0x00)
			{
				ecx_149 = *((word32) edi_27 + 4);
				esp_24->tFFFFFFFC = edi_27;
l00708BC5:
				(*((word32) ecx_149 + 24))();
				goto l00708BCA;
			}
			goto l00708BCD;
		}
	}
	*edi_27 = (word32) *edi_27 + 1;
	goto l00708B8C;
}

// 00708C10: Register Eq_3 fn00708C10(Register (ptr32 Eq_98294) ebx, Stack Eq_3 dwArg04)
// Called from:
//      fn00708DC0
Eq_3 fn00708C10(struct Eq_98294 * ebx, Eq_3 dwArg04)
{
	Eq_3 esi_147;
	struct Eq_98297 * esp_148;
	Eq_3 eax_9 = *((word32) dwArg04 + 4);
	if (eax_9 != 0x00A1D1B8)
	{
		word32 ecx_466;
		word32 edx_467;
		if (fn006D5670(eax_9, 0x00A1D1B8, out ecx_466, out edx_467) == 0x00)
		{
l00708C4E:
			Eq_3 eax_57 = ebx->t0004;
			if (eax_57 != 0x00A16588)
			{
				word32 ecx_468;
				word32 edx_469;
				if (fn006D5670(eax_57, 0x00A16588, out ecx_468, out edx_469) == 0x00)
				{
l00708C91:
					Eq_3 eax_81 = g_tA6D67C;
					struct Eq_98361 * esp_99;
					struct Eq_98362 * eax_100;
					g_ptrA6D680();
					if (eax_100 != null)
					{
						Eq_3 esi_109 = eax_100->t0018;
						if (esi_109 == 0x00)
							goto l00708CDB;
						Eq_3 eax_113 = *((word32) esi_109 + 4);
						if (eax_113 == 0x00A1D1B8)
						{
l00708CC7:
							esp_99->t0000.u0 = 9272108;
							esp_99->tFFFFFFFC = esi_109;
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							Eq_3 stackArg4 = <invalid>;
							word32 edx_479;
							word32 esi_480;
							word32 edi_481;
							word32 ecx_478;
							Eq_3 eax_142 = fn006FD8B0(stackArg4, dwArg04, out ecx_478, out edx_479, out esi_480, out edi_481);
							esi_147 = eax_142;
							esp_148 = (struct Eq_98297 *) ((const char *) &esp_99->t0000 + 4);
							if (eax_142 != 0x00)
								goto l00708CE0;
							goto l00708CDB;
						}
						esp_99->t0000.u0 = 0x00A1D1B8;
						esp_99->tFFFFFFFC = eax_113;
						word32 edx_483;
						word32 ecx_482;
						if (fn006D5670(esp_99->tFFFFFFFC, esp_99->t0000, out ecx_482, out edx_483) != 0x00)
							goto l00708CC7;
					}
l00708CDB:
					esp_148 = (struct Eq_98297 *) ((const char *) &esp_99->t0000 + 4);
					esi_147.u0 = 10611048;
					goto l00708CE0;
				}
			}
			if (ebx->dw0008 > 0x00)
			{
				Eq_3 edi_153 = ebx->t000C;
				word32 edx_470;
				word32 edi_471;
				Eq_3 eax_159 = fn006DF760(edi_153, dwArg04, out edx_470, out edi_471);
				esi_147 = eax_159;
				esp_148 = fp - 0x14;
				if (eax_159 != 0x00)
				{
l00708CE3:
					word32 eax_187 = esp_148->dw001C;
					struct Eq_98386 * esp_188 = esp_148 - 4;
					esp_188->t0000.u0 = 0x00;
					esp_188->tFFFFFFFC = dwArg04;
					esp_188->ptrFFFFFFF8 = ebx;
					esp_188->dwFFFFFFF4 = eax_187;
					esp_188->tFFFFFFF0 = esi_147;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_3 stackArg4 = <invalid>;
					word32 ecx_473;
					word32 edx_474;
					Eq_3 eax_212 = fn00703AF0(stackArg4, out ecx_473, out edx_474);
					Eq_3 v13_218 = (word32) *esi_147 - 1;
					*esi_147 = v13_218;
					ptr32 esp_217 = (const char *) &esp_188->t0000 + 4;
					if (v13_218 == 0x00)
					{
						Eq_3 ecx_223 = *((word32) esi_147 + 4);
						Eq_3 edx_224 = *((word32) ecx_223 + 24);
						esp_188->t0000 = esi_147;
						word32 esp_227;
						edx_224();
						esp_217 = esp_227 + 0x04;
					}
					if (eax_212 != 0x00)
						return eax_212;
					struct Eq_98511 * esp_242 = esp_217 - 4;
					esp_242->t0000 = g_tA16B7C;
					word32 edx_485;
					word32 ecx_484;
					if (fn006E1110(out ecx_484, out edx_485) == 0x00)
						return eax_212;
					struct Eq_98527 * esp_290;
					esp_242->t0000 = (const char *) &esp_242->t0000 + 16;
					esp_242->tFFFFFFFC = &esp_242->t001C;
					esp_242->tFFFFFFF8 = (const char *) &esp_242->t0000 + 20;
					fn006E1130(esp_242->tFFFFFFF8, esp_242->tFFFFFFFC, esp_242->t0000);
					Eq_3 eax_274 = esp_242->t001C;
					if (*((word32) eax_274 + 4) != 0x00A1B450)
					{
						Eq_3 ecx_278 = *((word32) eax_274 + 4);
						esp_242->t0000.u0 = 0x00A1B450;
						esp_242->tFFFFFFFC = ecx_278;
						esp_290 = (struct Eq_98527 *) ((const char *) &esp_242->t0000 + 4);
						word32 ecx_486;
						word32 edx_487;
						if (fn006D5670(esp_242->tFFFFFFFC, esp_242->t0000, out ecx_486, out edx_487) == 0x00)
						{
l00708D9A:
							struct Eq_53824 * edx_343 = esp_290->ptr0018;
							word32 eax_344 = esp_290->dw0010;
							struct Eq_98614 * esp_345 = esp_290 - 4;
							esp_345->t0000 = esp_290->t000C;
							esp_345->ptrFFFFFFFC = edx_343;
							esp_345->dwFFFFFFF8 = eax_344;
							word32 ecx_488;
							word32 edx_489;
							fn006E0E00(esp_345->t0000, out ecx_488, out edx_489);
							return eax_212;
						}
						eax_274 = esp_242->t001C;
					}
					esp_242->t0000 = (word32) eax_274 + 20;
					esp_242->tFFFFFFFC.u0 = 9272060;
					struct Eq_53824 * eax_309 = fn006F2070();
					esp_290 = (struct Eq_98527 *) ((const char *) &esp_242->t0000 + 4);
					if (eax_309 != null)
					{
						Eq_3 eax_319 = esp_242->t001C;
						*eax_319 = (word32) *eax_319 - 1;
						Eq_3 eax_322 = esp_242->t001C;
						if (*eax_322 == 0x00)
						{
							Eq_3 edx_325 = *((word32) eax_322 + 4);
							esp_242->t0000 = eax_322;
							word32 esp_329;
							(*((word32) edx_325 + 24))();
							esp_290 = esp_329 + 0x04;
						}
						esp_290->ptr0018 = eax_309;
					}
					goto l00708D9A;
				}
				word32 ecx_475;
				word32 edx_476;
				fn006E1160(out ecx_475, out edx_476);
				esi_147 = *((word32) edi_153 + 4);
l00708CE0:
				*esi_147 = (word32) *esi_147 + 1;
				goto l00708CE3;
			}
			goto l00708C91;
		}
	}
	word32 ecx_462;
	word32 edx_463;
	word32 edi_465;
	word32 esi_464;
	Eq_3 eax_43 = fn006FD8B0(dwArg04, 9272108, out ecx_462, out edx_463, out esi_464, out edi_465);
	esi_147 = eax_43;
	esp_148 = fp - 0x14;
	if (eax_43 != 0x00)
		goto l00708CE0;
	goto l00708C4E;
}

// 00708DC0: Register Eq_3 fn00708DC0(Register (ptr16 Eq_7) es, Register (ptr16 Eq_8) ds, Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Register out Eq_3 edxOut)
// Called from:
//      fn00707850
//      fn0070B600
Eq_3 fn00708DC0(struct Eq_7 * es, struct Eq_8 * ds, Eq_3 dwArg04, Eq_3 dwArg08, union Eq_3 & edxOut)
{
	Eq_3 esi_11 = g_tA6D67C;
	if (dwArg04 == 0x00)
	{
l00708DF1:
		edxOut = edx;
		return <invalid>;
	}
	*((word32) esi_11 + 0x0C) = (word32) *((word32) esi_11 + 0x0C) + 1;
	Eq_3 eax_29 = g_tA1E8AC;
	Eq_3 ecx_30 = g_tA6D67C;
	g_tA1E8AC = eax_29 - 0x01;
	if (*((word32) ecx_30 + 0x0C) > eax_29 - 0x01 && fn00706DC0(edx, 0x00, dwArg04, es, ds, out edx) != 0x00)
		goto l00708DF1;
	*((word32) esi_11 + 8) = dwArg04;
	if (*((word32) esi_11 + 20) != 0x00)
	{
		Eq_3 eax_54 = *((word32) esi_11 + 28);
		if (eax_54 != 0x00 && fn007086B0(dwArg04, eax_54, *((word32) esi_11 + 36), 0x00, 0x00A163B8) != 0x00)
		{
l0070B382:
			Eq_3 eax_3462 = g_tA6D67C;
			*((word32) eax_3462 + 0x0C) = (word32) *((word32) eax_3462 + 0x0C) - 1;
			*((word32) esi_11 + 8) = *((word32) dwArg04 + 0x0C);
			edxOut = dwArg04;
			return <invalid>;
		}
		Eq_3 eax_83 = *((word32) esi_11 + 24);
		if (eax_83 != 0x00 && fn007086B0(dwArg04, eax_83, *((word32) esi_11 + 32), 0x00, 0x00A163B8) != 0x00)
			goto l0070B382;
	}
	Eq_3 esi_1003;
	word32 ebx_1517;
	Eq_3 edi_1088;
	Eq_3 ebp_1059 = *((word32) dwArg04 + 36);
	((word32) dwArg04 + 36)->u0 = 0x00;
	struct Eq_98733 * esp_1012 = fp - 0x6C;
	esi_1003 = esi_11;
	if (dwArg08 != 0x00)
	{
		esi_1003 = esi_11;
l00708EE0:
		edi_1088 = esp_1012->dw0014;
l00708EE4:
		ebx_1517 = esp_1012->dw001C;
		if (ebx_1517 != 0x01)
		{
			if (ebx_1517 != 0x02 && ebx_1517 != 0x04)
				goto l0070B044;
			goto l0070B019;
		}
		if (esp_1012[8] != 0x00 || edi_1088 == 0x00)
		{
			esp_1012->dw001C = 0x02;
			ebx_1517 = esp_1012->dw001C;
			esp_1012->dw0014 = 0x00A163B8;
			esp_1012[8] = (struct Eq_98733) 0x00;
			goto l0070B019;
		}
	}
l00708F23:
	int32 v17_582 = g_dwA1E8B4 + ~0x00;
	g_dwA1E8B4 = v17_582;
	if (v17_582 < 0x00 && *esp_1012->ptr0020 != 122)
	{
		Eq_3 edi_592 = esp_1012->dw0028;
		g_dwA1E8B4 = g_dwA1E8B0;
		word32 ecx_594 = g_dwA6D270;
		*((word32) edi_592 + 0x0044) = (word32) *((word32) edi_592 + 0x0044) + 1;
		if (ecx_594 != 0x00)
		{
			if (fn00706CF0() < 0x00)
			{
				esp_1012->dw001C = 0x02;
				ebx_1517 = esp_1012->dw001C;
				goto l0070B019;
			}
			if (g_dwA6D270 != 0x00)
				g_dwA1E8B4 = 0x00;
		}
		if (g_tA6D260 != 0x00)
		{
			union Eq_3 * esp_619 = esp_1012 - 4;
			*esp_619 = (union Eq_3 *) 0x00;
			word32 ecx_10914;
			if (fn007158B0(*esp_619, out ecx_10914) != edi_592)
			{
				*esp_619 = (union Eq_3 *) 9272744;
				fn006E86F0(*esp_619);
			}
			struct Eq_99138 * esp_639 = esp_1012 - 4;
			esp_639->t0000 = g_tA6D260;
			fn0074F570(esp_639->t0000);
			Eq_3 ecx_646 = g_tA6D260;
			esp_639->dwFFFFFFFC = 0x01;
			esp_639->tFFFFFFF8 = ecx_646;
			word32 ecx_10915;
			fn0074F540(esp_639->tFFFFFFF8, esp_639->dwFFFFFFFC, out ecx_10915);
			esp_639->tFFFFFFF4 = edi_592;
			word32 ecx_10916;
			if (fn007158B0(esp_639->tFFFFFFF4, out ecx_10916) != 0x00)
			{
				esp_639->t0000.u0 = 9272720;
				fn006E86F0(esp_639->t0000);
			}
			esi_1003 = *((word32) edi_592 + 76);
			if (esi_1003 != 0x00)
			{
				struct Eq_101665 * esp_6564 = esp_1012 - 4;
				esp_6564->t0000 = esi_1003;
				esp_6564->t0018 = esi_1003;
				((word32) edi_592 + 76)->u0 = 0x00;
				word32 edx_10988;
				fn006E0F10(esp_6564->t0000, out edx_10988);
				word32 v22_6576 = (word32) *esi_1003 - 1;
				*esi_1003 = v22_6576;
				esp_1012 = (struct Eq_98733 *) ((const char *) &esp_6564->t0000 + 4);
				if (v22_6576 == 0x00)
				{
					struct Eq_101705 * edx_6580 = *((word32) esi_1003 + 4);
					<anonymous> * eax_6581 = edx_6580->ptr0018;
					esp_6564->t0000 = esi_1003;
					word32 esp_6658;
					word32 ecx_6660;
					eax_6581();
					esp_1012 = esp_6658 + 0x04;
				}
				esp_1012->dw001C = 0x02;
				ebx_1517 = esp_1012->dw001C;
l0070B019:
				if (fn006E0FC0() == 0x00)
				{
					Eq_3 ecx_186 = g_tA18720;
					struct Eq_98819 * esp_187 = esp_1012 - 4;
					esp_187->dw0000 = 9272124;
					esp_187->tFFFFFFFC = ecx_186;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_3 stackArg4 = <invalid>;
					word32 edx_10911;
					word32 ecx_10910;
					fn006E0F80(stackArg4, dwArg04, out ecx_10910, out edx_10911);
					esp_187->dw0020 = 0x02;
					ebx_1517 = esp_187->dw0020;
					esp_1012 = (struct Eq_98733 *) (&esp_187->dw0000 + 1);
l0070B049:
					word32 esi_208 = esp_1012->dw0070;
					struct Eq_98849 * esp_209 = esp_1012 - 4;
					esp_209->dw0000 = esi_208;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_3 stackArg4 = <invalid>;
					fn0072F7F0(stackArg4);
					struct Eq_98860 * ecx_229 = esp_209->ptr002C;
					word32 eax_230 = ecx_229->dw001C;
					esp_1012 = (struct Eq_98733 *) (&esp_209->dw0000 + 1);
					if (eax_230 != 0x00)
					{
						word32 edx_235 = ecx_229->dw0024;
						esp_209->dw0000 = esi_208;
						esp_209->dwFFFFFFFC = edx_235;
						esp_209->dwFFFFFFF8 = eax_230;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_3 stackArg4 = <invalid>;
						fn00708590(stackArg4, dwArg04, dwArg08);
						esp_1012 = (struct Eq_98733 *) (&esp_209->dw0000 + 1);
					}
					goto l0070B08D;
				}
l0070B044:
				if (ebx_1517 == 0x02)
					goto l0070B049;
				if (ebx_1517 == 0x04)
				{
					esp_1012->dw001C = 0x02;
l0070B089:
					ebx_1517 = esp_1012->dw001C;
l0070B08D:
					Eq_3 edi_252 = esp_1012->dw0070;
					do
					{
						if (*((word32) edi_252 + 0x0044) <= 0x00)
						{
							while ((ebp_1059 - *((word32) edi_252 + 32) & ~0x03) != 0x00)
							{
								struct Eq_107423 * eax_265 = *((word32) ebp_1059 - 4);
								ebp_1059 -= 0x04;
								if (eax_265 != null)
								{
									word32 v135_270 = eax_265->dw0000 + ~0x00;
									eax_265->dw0000 = v135_270;
									if (v135_270 == 0x00)
									{
										struct Eq_107450 * ecx_274 = eax_265->ptr0004;
										<anonymous> * edx_275 = ecx_274->ptr0018;
										esp_1012->dwFFFFFFFC = eax_265;
										word32 esp_283;
										word32 edx_286;
										edx_275();
										esp_1012 = esp_283 + 0x04;
									}
								}
							}
							if (ebx_1517 != 0x08)
								esp_1012->ptr002C = (struct Eq_179984 *) null;
							goto l0070B27A;
						}
						struct Eq_98907 * esp_308 = esp_1012 - 4;
						esp_308->t0000 = edi_252;
						Eq_3 eax_310 = fn0073B280(esp_308->t0000);
						esi_1003 = eax_310;
						esp_1012 = (struct Eq_98733 *) ((const char *) &esp_308->t0000 + 4);
						if (*eax_310 == 0x78 && ebx_1517 == 0x20)
						{
							Eq_3 edx_322 = *((word32) eax_310 + 4);
							int32 eax_323 = *eax_310;
							esp_308->t0000 = *((word32) eax_310 + 8);
							esp_308->tFFFFFFFC = edx_322;
							esp_308->dwFFFFFFF8 = eax_323;
							esp_308->tFFFFFFF4 = edi_252;
							fn0073B240(esp_308->tFFFFFFF4, esp_308->dwFFFFFFF8, esp_308->tFFFFFFFC, esp_308->t0000);
							Eq_3 ecx_339 = esp_308->t0030;
							word32 eax_341 = (word32) *((word32) ecx_339 + 8) + esp_308->dw003C;
							word32 v134_343 = (word32) *ecx_339 - 1;
							*ecx_339 = v134_343;
							esp_308->dw0020 = 0x01;
							esp_308->dw0024 = eax_341;
							esp_1012 = (struct Eq_98733 *) ((const char *) &esp_308->t0000 + 4);
							if (v134_343 == 0x00)
							{
								Eq_3 edx_349 = *((word32) ecx_339 + 4);
								<anonymous> * eax_350 = *((word32) edx_349 + 24);
								esp_308->t0000 = ecx_339;
								word32 esp_354;
								word32 ecx_356;
								eax_350();
								esp_1012 = esp_354 + 0x04;
							}
							goto l00708F23;
						}
						while (ebp_1059 - *((word32) edi_252 + 32) >> 0x02 > *((word32) eax_310 + 8))
						{
							struct Eq_99033 * eax_376 = *((word32) ebp_1059 - 4);
							ebp_1059 -= 0x04;
							if (eax_376 != null)
							{
								word32 v16_381 = eax_376->dw0000 + ~0x00;
								eax_376->dw0000 = v16_381;
								if (v16_381 == 0x00)
								{
									struct Eq_99044 * ecx_385 = eax_376->ptr0004;
									<anonymous> * edx_386 = ecx_385->ptr0018;
									esp_1012->dwFFFFFFFC = eax_376;
									word32 esp_394;
									word32 edx_397;
									edx_386();
									esp_1012 = esp_394 + 0x04;
								}
							}
						}
						byte bl_427 = (byte) ebx_1517;
						int32 eax_413 = *eax_310;
						if (eax_413 == 0x78 && ebx_1517 == 0x10)
							goto l0070B206;
						if (eax_413 == 122)
						{
							if (ebx_1517 == 0x02)
								break;
							if ((bl_427 & 0x28) != 0x00)
							{
								*ebp_1059 = esp_1012->ptr002C;
								ebp_1059 += 0x04;
							}
							word32 * esp_443 = esp_1012 - 4;
							*esp_443 = ebx_1517;
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							Eq_3 stackArg4 = <invalid>;
							word32 ecx_11001;
							word32 edx_11002;
							*ebp_1059 = fn007050A0(stackArg4, out ecx_11001, out edx_11002);
							esp_1012 = (struct Eq_98733 *) (esp_443 + 1);
							goto l0070B203;
						}
					} while (eax_413 != 121 || ebx_1517 != 0x02);
					struct Eq_98733 * esp_473 = esp_1012 - 4;
					esp_473->t0000 = esp_1012 + 24;
					esp_473->dwFFFFFFFC = &esp_473->ptr0040;
					esp_473->tFFFFFFF8 = &esp_473->ptr0050;
					fn006E1130(esp_473->tFFFFFFF8, esp_473->dwFFFFFFFC, esp_473->t0000);
					esp_1012 = (struct Eq_98733 *) ((const char *) &esp_473->t0000 + 4);
					if (esp_473->ptr0040 == null)
					{
						++g_dwA163B8;
						esp_473->ptr0040 = (struct Eq_101786 *) &g_dwA163B8;
					}
					if (*eax_310 == 121)
					{
						esp_473->t0000 = &esp_473->dw004C;
						esp_473->dwFFFFFFFC = &esp_473->ptr0040;
						esp_473->tFFFFFFF8 = &esp_473->ptr0050;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_3 stackArg4 = <invalid>;
						word32 ebp_10994;
						word32 esi_10995;
						word32 edi_10996;
						fn006E1BD0(stackArg4, dwArg04, out ebp_10994, out esi_10995, out edi_10996);
						struct Eq_101786 * edx_525 = esp_473->ptr0040;
						struct Eq_93112 * edi_526 = esp_473->ptr0050;
						struct Eq_93111 * eax_527 = esp_473->ptr002C;
						esp_473->dwFFFFFFF4 = esp_473->dw004C;
						esp_473->ptrFFFFFFF0 = edx_525;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_3 stackArg4 = <invalid>;
						fn00706E30(eax_527, edi_526, stackArg4, dwArg04);
						esp_1012 = esp_473;
					}
					word32 eax_543 = esp_1012[24];
					if (eax_543 == 0x00)
					{
						++g_dwA163B8;
						*ebp_1059 = 0x00A163B8;
					}
					else
						*ebp_1059 = eax_543;
					Eq_3 ecx_556 = esp_1012->dw004C;
					word32 ebp_558 = ebp_1059 + 0x04;
					*ebp_558 = esp_1012[20];
					Mem562[ebp_558 + 0x04:word32] = ecx_556;
					ebp_1059 = ebp_558 + 0x04;
l0070B203:
					ebp_1059 += 0x04;
l0070B206:
					esi_1003 = (word32) *((word32) eax_310 + 4) + esp_1012->dw0038;
					esp_1012->dw001C = 0x01;
l00708F1F:
					esp_1012->ptr0020 = (byte *) esi_1003;
					goto l00708F23;
				}
				if (ebx_1517 != 0x01)
					goto l0070B089;
				goto l00708F23;
			}
		}
	}
	edi_1088 = esp_1012->dw0014;
l00709030:
	Eq_3 edx_2591 = esp_11188->dw0070;
	struct Eq_99211 * eax_691 = esp_11188->dw0028;
	*((word32) edx_2591 + 60) = esp_11188->ptr0020 - esp_11188->dw0038;
	if (eax_691->t001C == 0x00 || eax_691->dw0010 != 0x00)
	{
l007090A4:
		struct Eq_99192 * eax_741 = esp_11188->ptr0020;
		int32 ecx_742 = (word32) eax_741->b0000;
		esp_11188->ptr0020 = &eax_741->b0001;
		Eq_3 ebx_2263 = 0x00;
		if (ecx_742 >= 0x5A)
		{
			ui32 ebx_748 = (word32) eax_741->b0002;
			edx_2591 = (word32) eax_741->b0001;
			esp_11188->ptr0020 = (byte *) (&eax_741->b0002 + 1);
			ebx_2263 = (word32) edx_2591 + (ebx_748 << 0x08);
		}
l007090D0:
		byte bh_777 = SLICE(ebx_2263, byte, 8);
		esp_1012 = esp_11188;
		byte cl_5290 = (byte) ecx_742;
		struct Eq_99313 * eax_757 = ecx_742 - 0x01;
		if (eax_757 > (struct Eq_99313 *) 0x8E)
		{
l0070AFC3:
			struct Eq_99339 * eax_6436 = esp_11188->dw0070;
			word32 edx_6437 = eax_6436->dw0010;
			struct Eq_99347 * esp_6438 = esp_11188 - 4;
			esp_6438->dw0000 = ecx_742;
			esp_6438->tFFFFFFFC = eax_6436->t003C;
			esp_6438->dwFFFFFFF8 = edx_6437;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg4 = <invalid>;
			Eq_3 eax_6452 = fn00735550(stackArg4, dwArg04);
			esp_6438->tFFFFFFFC = eax_6452;
			esp_6438->dwFFFFFFF8 = 0x008D7B70;
			struct Eq_99376 * esp_6463;
			word32 eax_6464;
			_iob_func();
			esp_6463->tFFFFFFFC = eax_6464 + 0x40;
			fprintf(esp_6463->tFFFFFFFC, esp_6463->t0000, 0x00);
			Eq_3 eax_6474 = g_tA18720;
			esp_6463->dwFFFFFFF8 = 0x008D7B60;
			esp_6463->tFFFFFFF4 = eax_6474;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg4 = <invalid>;
			word32 ecx_6481;
			word32 edx_6482;
			fn006E0F80(stackArg4, dwArg04, out ecx_6481, out edx_6482);
			esp_6463->dw0028 = 0x02;
			ebx_1517 = esp_6463->dw0028;
			esp_1012 = (struct Eq_98733 *) ((const char *) &esp_6463->t0000 + 0x0C);
			goto l0070B019;
		}
		struct Eq_99420 * eax_4865;
		word32 esp_1335;
		struct Eq_99422 * eax_6175;
		Eq_3 eax_6285;
		union Eq_3 * esp_6295;
		Eq_3 ebx_3903;
		Eq_3 eax_3913;
		Eq_3 eax_3945;
		Eq_3 ebx_3935;
		struct Eq_99429 * esp_5175;
		struct Eq_99430 * ebx_3920;
		Eq_3 eax_3930;
		word32 esp_5026;
		Eq_3 eax_2933;
		struct Eq_99434 * ecx_2954;
		struct Eq_99435 * edx_5353;
		struct Eq_99436 * ebx_2779;
		Eq_3 eax_2791;
		Eq_3 ebx_3987;
		Eq_3 ebx_3985;
		Eq_3 ebx_1685;
		struct Eq_99441 * esp_1782;
		Eq_3 eax_4033 = (word32) eax_757->b70B530;
		esp_11188 = esp_1012;
		switch (eax_4033)
		{
		case 0x00:
			goto l00709397;
		case 0x01:
			Eq_3 eax_6513 = *((word32) ebp_1059 - 8);
			word32 ecx_6514 = *((word32) ebp_1059 - 4);
			esp_11188->dw0010 = (word32) eax_6513;
			*((word32) ebp_1059 - 4) = eax_6513;
			*((word32) ebp_1059 - 8) = ecx_6514;
			break;
		case 0x02:
			Eq_3 eax_6505 = *((word32) ebp_1059 - 8);
			edi_1088 = *((word32) ebp_1059 - 0x0C);
			word32 ecx_6507 = *((word32) ebp_1059 - 4);
			esp_11188->dw0010 = (word32) eax_6505;
			esp_11188->dw0014 = (word32) edi_1088;
			*((word32) ebp_1059 - 4) = eax_6505;
			*((word32) ebp_1059 - 8) = edi_1088;
			*((word32) ebp_1059 - 0x0C) = ecx_6507;
			break;
		case 0x03:
			word32 * eax_6499 = *((word32) ebp_1059 - 4);
			++*eax_6499;
			*ebp_1059 = eax_6499;
			ebp_1059 = (word32) ebp_1059 + 4;
			break;
		case 0x04:
			Eq_3 eax_6489 = *((word32) ebp_1059 - 0x0C);
			edi_1088 = *((word32) ebp_1059 - 16);
			word32 ecx_6491 = *((word32) ebp_1059 - 4);
			word32 edx_6492 = *((word32) ebp_1059 - 8);
			esp_11188->dw0010 = (word32) eax_6489;
			esp_11188->dw0014 = (word32) edi_1088;
			*((word32) ebp_1059 - 4) = edx_6492;
			*((word32) ebp_1059 - 8) = eax_6489;
			*((word32) ebp_1059 - 0x0C) = edi_1088;
			*((word32) ebp_1059 - 16) = ecx_6491;
			break;
		case 0x05:
		case 0x06:
		case 0x07:
		case 0x0D:
		case 0x0F:
		case 0x10:
		case 33:
		case 0x22:
		case 0x23:
		case 0x24:
		case 0x25:
		case 0x26:
		case 0x2B:
		case 44:
		case 0x2D:
		case 0x2E:
		case 0x2F:
		case 0x30:
		case 0x35:
		case 0x44:
		case 0x5D:
		case 0x6C:
		case 113:
		case 114:
		case 116:
		case 117:
		case 122:
		case 0x7E:
		case 0x7F:
		case 0x80:
		case 0x89:
		case 0x8A:
			goto l0070AFC3;
		case 0x08:
			break;
		case 0x09:
			esi_1003 = *((word32) ebp_1059 - 4);
			union Eq_3 * esp_6378 = esp_11188 - 4;
			*esp_6378 = (union Eq_3 *) esi_1003;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg4 = <invalid>;
			eax_6285 = fn00702970(stackArg4);
			esp_6295 = esp_6378;
			goto l007094C9;
		case 0x0A:
			esi_1003 = *((word32) ebp_1059 - 4);
			struct Eq_99582 * esp_6344 = esp_11188 - 4;
			esp_6344->t0000 = esi_1003;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg4 = <invalid>;
			Eq_3 eax_6347 = fn00702910(stackArg4);
			word32 v129_6353 = (word32) *esi_1003 - 1;
			*esi_1003 = v129_6353;
			esp_6344->t0018 = eax_6347;
			esp_1012 = (struct Eq_98733 *) ((const char *) &esp_6344->t0000 + 4);
			edi_1088 = eax_6347;
			if (v129_6353 == 0x00)
			{
				struct Eq_107337 * edx_6359 = *((word32) esi_1003 + 4);
				<anonymous> * eax_6360 = edx_6359->ptr0018;
				esp_6344->t0000 = esi_1003;
				word32 esp_6363;
				word32 ecx_6365;
				eax_6360();
				esp_1012 = esp_6363 + 0x04;
			}
			*((word32) ebp_1059 - 4) = eax_6347;
			if (eax_6347 == 0x00)
				goto l00708EE4;
			goto l00708F23;
		case 11:
			esi_1003 = *((word32) ebp_1059 - 4);
			struct Eq_99612 * esp_6297 = esp_11188 - 4;
			esp_6297->t0000 = esi_1003;
			word32 edx_10922;
			word32 ecx_10921;
			Eq_55932 eax_6299 = fn006DEA90(esp_6297->t0000, out ecx_10921, out edx_10922);
			word32 v128_6307 = (word32) *esi_1003 - 1;
			*esi_1003 = v128_6307;
			esp_6297->t001C = eax_6299;
			esp_1012 = (struct Eq_98733 *) ((const char *) &esp_6297->t0000 + 4);
			if (v128_6307 == 0x00)
			{
				struct Eq_107317 * ecx_6313 = *((word32) esi_1003 + 4);
				<anonymous> * edx_6314 = ecx_6313->ptr0018;
				esp_6297->t0000 = esi_1003;
				word32 esp_6317;
				word32 edx_6320;
				edx_6314();
				esp_1012 = esp_6317 + 0x04;
			}
			if (eax_6299 == 0x00)
			{
				++g_dwA191E4;
				*((word32) ebp_1059 - 4) = 0x00A191E4;
				goto l00708F23;
			}
			if (eax_6299 <= 0x00)
			{
				ebp_1059 += ~0x03;
				goto l00708EE4;
			}
			else
			{
				++g_dwA191D8;
				*((word32) ebp_1059 - 4) = 0x00A191D8;
				esp_1012[8] = (struct Eq_98733) 0x00;
				goto l00708F23;
			}
		case 0x0C:
			esi_1003 = *((word32) ebp_1059 - 4);
			union Eq_3 * esp_6283 = esp_11188 - 4;
			*esp_6283 = (union Eq_3 *) esi_1003;
			word32 edi_10924;
			word32 edx_10923;
			eax_6285 = fn006DDDB0(eax_4033, edx_2591, ebx_2263, esi_1003, edi_1088, es, ds, *esp_6283, out edx_10923, out edi_10924);
			esp_6295 = (union Eq_3 *) ((const char *) esp_6283 + 4);
l007094C9:
			word32 v130_6390 = (word32) *esi_1003 - 1;
			*esi_1003 = v130_6390;
			esp_1012 = (struct Eq_98733 *) ((const char *) esp_6295 + 4);
			esp_1012->dw0014 = (word32) eax_6285;
			edi_1088 = eax_6285;
			if (v130_6390 != 0x00)
				goto l007094E3;
			eax_6175 = (struct Eq_99422 *) *((word32) esi_1003 + 4);
			esp_1012->dwFFFFFFFC = (word32) esi_1003;
			goto l007094DB;
		case 0x0E:
			esi_1003 = *((word32) ebp_1059 - 4);
			struct Eq_99667 * esp_6257 = esp_11188 - 4;
			esp_6257->t0000 = esi_1003;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg4 = <invalid>;
			Eq_3 eax_6260 = fn007029D0(stackArg4);
			word32 v126_6266 = (word32) *esi_1003 - 1;
			*esi_1003 = v126_6266;
			esp_6257->t0018 = eax_6260;
			esp_1012 = (struct Eq_98733 *) ((const char *) &esp_6257->t0000 + 4);
			edi_1088 = eax_6260;
			if (v126_6266 != 0x00)
				goto l007094E3;
			struct Eq_107267 * edx_6272 = *((word32) esi_1003 + 4);
			<anonymous> * eax_6273 = edx_6272->ptr0018;
			esp_6257->t0000 = esi_1003;
			word32 ecx_6278;
			eax_6273();
			goto l007094E0;
		case 0x11:
			struct Eq_99694 * ebp_6180 = ebp_1059 - 0x04;
			Eq_3 ebx_6179 = *((word32) ebp_1059 - 4);
			esi_1003 = ebp_6180->tFFFFFFFC;
			struct Eq_99704 * esp_6184 = esp_11188 - 4;
			esp_6184->t0000 = ebx_6179;
			esp_6184->tFFFFFFFC = esi_1003;
			esp_6184->t0014 = ebx_6179;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg4 = <invalid>;
			word32 ecx_10927;
			word32 edx_10928;
			int32 eax_6190 = fn006F2A10(stackArg4, dwArg04, out ecx_10927, out edx_10928);
			word32 v125_6196 = (word32) *esi_1003 - 1;
			*esi_1003 = v125_6196;
			esp_6184->dw001C = eax_6190;
			ebp_1059 = ebp_6180 - 0x04;
			esp_1012 = (struct Eq_98733 *) ((const char *) &esp_6184->t0000 + 4);
			if (v125_6196 == 0x00)
			{
				struct Eq_107252 * edx_6201 = *((word32) esi_1003 + 4);
				<anonymous> * eax_6202 = edx_6201->ptr0018;
				esp_6184->t0000 = esi_1003;
				word32 esp_6205;
				word32 ecx_6207;
				eax_6202();
				esp_1012 = esp_6205 + 0x04;
			}
			word32 v127_6215 = (word32) *ebx_6179 - 1;
			*ebx_6179 = v127_6215;
			if (v127_6215 == 0x00)
			{
				Eq_3 ecx_6219 = *((word32) ebx_6179 + 4);
				<anonymous> * edx_6220 = *((word32) ecx_6219 + 24);
				esp_1012->dwFFFFFFFC = (word32) ebx_6179;
				word32 esp_6229;
				word32 edx_6232;
				edx_6220();
				esp_1012 = esp_6229 + 0x04;
			}
			if (esp_1012[8] != 0x00)
				goto l00708EE4;
			struct Eq_107370 * eax_6241 = esp_1012->ptr0020;
			if (eax_6241->b0000 != 113)
				goto l00708F23;
			ebx_2263 = ((word32) eax_6241->b0002 << 0x08) + (word32) eax_6241->b0001;
			goto l007098FE;
		case 0x12:
			ebx_3903 = *((word32) ebp_1059 - 4);
			esi_1003 = *((word32) ebp_1059 - 8);
			struct Eq_99748 * esp_6116 = esp_11188 - 4;
			esp_6116->dw0000 = 0x00A163B8;
			esp_6116->tFFFFFFFC = ebx_3903;
			esp_6116->tFFFFFFF8 = esi_1003;
			esp_6116->t0014 = ebx_3903;
			ebp_1059 -= 0x04;
			eax_3913 = fn00702570();
			goto l007095D5;
		case 0x13:
			ebx_3935 = *((word32) ebp_1059 - 4);
			esi_1003 = *((word32) ebp_1059 - 8);
			struct Eq_99775 * esp_6037 = esp_11188 - 4;
			esp_6037->t0000 = ebx_3935;
			esp_6037->tFFFFFFFC = esi_1003;
			esp_6037->t0014 = ebx_3935;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg4 = <invalid>;
			ebp_1059 -= 0x04;
			eax_3945 = fn00704560(stackArg4, dwArg04);
			goto l00709615;
		case 0x14:
			if (g_dwA6C61C != 0x00)
				goto l00709694;
			ebx_3920 = (struct Eq_99430 *) *((word32) ebp_1059 - 4);
			esi_1003 = *((word32) ebp_1059 - 8);
			struct Eq_107223 * esp_5975 = esp_11188 - 4;
			esp_5975->ptr0000 = ebx_3920;
			esp_5975->tFFFFFFFC = esi_1003;
			esp_5975->ptr0014 = ebx_3920;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg4 = <invalid>;
			ebp_1059 -= 0x04;
			eax_3930 = fn00702310(stackArg4, dwArg04);
			goto l00709663;
		case 0x15:
			ebx_3920 = (struct Eq_99430 *) *((word32) ebp_1059 - 4);
			esi_1003 = *((word32) ebp_1059 - 8);
			struct Eq_99803 * esp_5935 = esp_11188 - 4;
			esp_5935->ptr0000 = ebx_3920;
			esp_5935->tFFFFFFFC = esi_1003;
			esp_5935->ptr0014 = ebx_3920;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg4 = <invalid>;
			ebp_1059 -= 0x04;
			eax_3930 = fn00702510(stackArg4, dwArg04);
			goto l00709663;
		case 22:
			esi_1003 = *((word32) ebp_1059 - 8);
			word32 eax_5835 = *((word32) esi_1003 + 4);
			ebx_3903 = *((word32) ebp_1059 - 4);
			esp_11188->dw0010 = (word32) ebx_3903;
			ebp_1059 -= 0x04;
			if (eax_5835 == 10610664 && *((word32) ebx_3903 + 4) == 10610664)
			{
				word32 eax_5879 = *((word32) esi_1003 + 8);
				word32 edx_5880 = *((word32) ebx_3903 + 8);
				word32 ecx_5881 = edx_5880 + eax_5879;
				if ((ecx_5881 ^ eax_5879) >= 0x00 || (ecx_5881 ^ edx_5880) >= 0x00)
				{
					esp_11188->dwFFFFFFFC = ecx_5881;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_3 stackArg4 = <invalid>;
					word32 edx_10991;
					word32 ecx_10990;
					eax_3913 = fn007050A0(stackArg4, out ecx_10990, out edx_10991);
					goto l007095D8;
				}
			}
			else if (eax_5835 == 0x00A1B450 && *((word32) ebx_3903 + 4) == 0x00A1B450)
				goto l00709732;
			struct Eq_101837 * esp_5893 = esp_11188 - 4;
			esp_5893->t0000 = ebx_3903;
			esp_5893->tFFFFFFFC = esi_1003;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg4 = <invalid>;
			eax_3913 = fn007023D0(stackArg4, dwArg04);
			esp_5893->t0018 = eax_3913;
			edi_1088 = eax_3913;
			goto l007095DE;
		case 0x17:
			esi_1003 = *((word32) ebp_1059 - 8);
			ebx_3935 = *((word32) ebp_1059 - 4);
			esp_11188->dw0010 = (word32) ebx_3935;
			ebp_1059 -= 0x04;
			if (*((word32) esi_1003 + 4) == 10610664 && *((word32) ebx_3935 + 4) == 10610664)
			{
				word32 edx_5782 = *((word32) esi_1003 + 8);
				word32 ecx_5783 = *((word32) ebx_3935 + 8);
				word32 eax_5785 = edx_5782 - ecx_5783;
				if ((eax_5785 ^ edx_5782) >= 0x00 || (~ecx_5783 ^ eax_5785) >= 0x00)
				{
					struct Eq_107122 * esp_5816 = esp_11188 - 4;
					esp_5816->dw0000 = eax_5785;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_3 stackArg4 = <invalid>;
					word32 ecx_11185;
					word32 edx_11186;
					eax_3945 = fn007050A0(stackArg4, out ecx_11185, out edx_11186);
					esp_5816->t0018 = eax_3945;
					edi_1088 = eax_3945;
					esp_1012 = (struct Eq_98733 *) (&esp_5816->dw0000 + 1);
					goto l0070961E;
				}
			}
			struct Eq_107086 * esp_5797 = esp_11188 - 4;
			esp_5797->t0000 = ebx_3935;
			esp_5797->tFFFFFFFC = esi_1003;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg4 = <invalid>;
			eax_3945 = fn007022B0(stackArg4, dwArg04);
			esp_5797->t0018 = eax_3945;
			esp_5175 = esp_5797 - 4;
			edi_1088 = eax_3945;
			goto l0070961B;
		case 0x18:
			esi_1003 = *((word32) ebp_1059 - 8);
			ebx_3935 = *((word32) ebp_1059 - 4);
			esp_11188->dw0010 = (word32) ebx_3935;
			ebp_1059 -= 0x04;
			if (*((word32) esi_1003 + 4) == 0x00A1BAF0 && *((word32) ebx_3935 + 4) == 10610664)
			{
				struct Eq_107002 * esp_5723 = esp_11188 - 4;
				esp_5723->t0000 = ebx_3935;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_3 stackArg4 = <invalid>;
				word32 ecx_11180;
				word32 edx_11181;
				eax_3945 = fn007052C0(stackArg4, out ecx_11180, out edx_11181);
				esp_1012 = (struct Eq_98733 *) ((const char *) &esp_5723->t0000 + 4);
				if (eax_3945 < 0x00)
				{
					eax_3945 += Mem5724[esi_1003 + 0x08:word32];
					if (eax_3945 >= 0x00)
						goto l007097ED;
				}
				else
				{
l007097ED:
					if (eax_3945 < *((word32) esi_1003 + 8))
					{
						edi_1088 = *((word32) *((word32) esi_1003 + 0x0C) + eax_3945 * 0x04);
						*edi_1088.u0 = (word32) *edi_1088.u0 + 1;
						esp_5723->t0018 = edi_1088;
						goto l0070961E;
					}
				}
			}
			struct Eq_106976 * esp_5745 = esp_11188 - 4;
			esp_5745->t0000 = ebx_3935;
			esp_5745->tFFFFFFFC = esi_1003;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg4 = <invalid>;
			word32 edx_11178;
			word32 ecx_11177;
			eax_3945 = fn00704220(stackArg4, dwArg04, out ecx_11177, out edx_11178);
			esp_5745->t0018 = eax_3945;
			esp_5175 = esp_5745 - 4;
			edi_1088 = eax_3945;
			goto l0070961B;
		case 0x19:
			ebx_3935 = *((word32) ebp_1059 - 4);
			esi_1003 = *((word32) ebp_1059 - 8);
			struct Eq_99876 * esp_5704 = esp_11188 - 4;
			esp_5704->t0000 = ebx_3935;
			esp_5704->tFFFFFFFC = esi_1003;
			esp_5704->t0014 = ebx_3935;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg4 = <invalid>;
			ebp_1059 -= 0x04;
			eax_3945 = fn00702450(stackArg4, dwArg04);
			goto l00709615;
		case 0x1A:
l00709694:
			ebx_3903 = *((word32) ebp_1059 - 4);
			esi_1003 = *((word32) ebp_1059 - 8);
			struct Eq_99900 * esp_5955 = esp_11188 - 4;
			esp_5955->t0000 = ebx_3903;
			esp_5955->tFFFFFFFC = esi_1003;
			esp_5955->t0014 = ebx_3903;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg4 = <invalid>;
			ebp_1059 -= 0x04;
			eax_3913 = fn007024B0(stackArg4, dwArg04);
			goto l007095D8;
		case 0x1B:
			ebx_3935 = *((word32) ebp_1059 - 4);
			esi_1003 = *((word32) ebp_1059 - 8);
			struct Eq_99924 * esp_5689 = esp_11188 - 4;
			esp_5689->t0000 = ebx_3935;
			esp_5689->tFFFFFFFC = esi_1003;
			esp_5689->t0014 = ebx_3935;
			ebp_1059 -= 0x04;
			eax_3945 = fn00702770();
			goto l00709615;
		case 0x1C:
			goto l00709966;
		case 0x1D:
		case 0x1E:
		case 0x1F:
		case 0x20:
			if (((byte) (ecx_742 - 0x02) & 0x02) != 0x00)
			{
				esp_11188->dw0010 = (word32) *((word32) ebp_1059 - 4);
				ebp_1059 -= 0x04;
			}
			else
				esp_11188->dw0010 = (word32) 0x00;
			Eq_3 ebx_5562;
			if ((cl_5290 & 0x01) != 0x00)
			{
				ebx_5562 = *((word32) ebp_1059 - 4);
				ebp_1059 -= 0x04;
			}
			else
				ebx_5562.u0 = 0x00;
			esi_1003 = *((word32) ebp_1059 - 4);
			Eq_3 eax_5575 = esp_11188->dw0010;
			struct Eq_107059 * esp_5576 = esp_11188 - 4;
			esp_5576->t0000 = esi_1003;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg4 = <invalid>;
			Eq_3 eax_5587 = fn00707E00(eax_5575, ebx_5562, stackArg4);
			word32 v122_5593 = (word32) *esi_1003 - 1;
			*esi_1003 = v122_5593;
			esp_5576->t0018 = eax_5587;
			esp_1012 = (struct Eq_98733 *) ((const char *) &esp_5576->t0000 + 4);
			edi_1088 = eax_5587;
			if (v122_5593 == 0x00)
			{
				struct Eq_107146 * ecx_5599 = *((word32) esi_1003 + 4);
				<anonymous> * edx_5600 = ecx_5599->ptr0018;
				esp_5576->t0000 = esi_1003;
				word32 esp_5603;
				word32 edx_5606;
				edx_5600();
				esp_1012 = esp_5603 + 0x04;
			}
			if (ebx_5562 != 0x00)
			{
				word32 v123_5616 = (word32) *ebx_5562.u0 - 1;
				*ebx_5562.u0 = v123_5616;
				if (v123_5616 == 0x00)
				{
					struct Eq_107178 * eax_5620 = *((word64) ebx_5562.u0 + 4);
					<anonymous> * ecx_5621 = eax_5620->ptr0018;
					esp_1012->dwFFFFFFFC = (word32) ebx_5562;
					word32 esp_5629;
					word32 ecx_5631;
					word32 edx_5632;
					ecx_5621();
					esp_1012 = esp_5629 + 0x04;
				}
			}
			struct Eq_107161 * eax_5639 = esp_1012->dw0010;
			if (eax_5639 == null)
				goto l007094E3;
			word32 v124_5643 = eax_5639->dw0000 + ~0x00;
			eax_5639->dw0000 = v124_5643;
			if (v124_5643 != 0x00)
				goto l007094E3;
			struct Eq_107205 * edx_5647 = eax_5639->ptr0004;
			esp_1012->dwFFFFFFFC = eax_5639;
			<anonymous> * eax_5650 = edx_5647->ptr0018;
			word32 ecx_5658;
			eax_5650();
			goto l007094E0;
		case 0x27:
		case 0x28:
		case 0x29:
		case 0x2A:
			if ((cl_5290 & 0x02) != 0x00)
			{
				esp_11188->dw0010 = (word32) *((word32) ebp_1059 - 4);
				ebp_1059 -= 0x04;
			}
			else
				esp_11188->dw0010 = (word32) 0x00;
			if ((cl_5290 & 0x01) != 0x00)
			{
				esp_11188[0x0C] = (struct Eq_98733) *((word32) ebp_1059 - 4);
				ebp_1059 -= 0x04;
			}
			else
				esp_11188[0x0C] = (struct Eq_98733) 0x00;
			Eq_106786 ebp_5387 = ebp_1059 - 0x04;
			Eq_3 ebx_5383 = *((word32) ebp_1059 - 4);
			Eq_3 eax_5385 = esp_11188->dw0010;
			Eq_3 ecx_5386 = esp_11188[0x0C];
			esi_1003 = *((word32) ebp_5387 - 4);
			struct Eq_106804 * esp_5391 = esp_11188 - 4;
			esp_5391->t0000 = esi_1003;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg4 = <invalid>;
			word32 eax_5400 = fn00707F70(eax_5385, ecx_5386, ebx_5383, stackArg4);
			word32 v116_5406 = (word32) *esi_1003 - 1;
			*esi_1003 = v116_5406;
			esp_5391->dw001C = eax_5400;
			ebp_1059 = ebp_5387 - 0x04;
			esp_1012 = (struct Eq_98733 *) ((const char *) &esp_5391->t0000 + 4);
			if (v116_5406 == 0x00)
			{
				struct Eq_106867 * ecx_5411 = *((word32) esi_1003 + 4);
				<anonymous> * edx_5412 = ecx_5411->ptr0018;
				esp_5391->t0000 = esi_1003;
				word32 esp_5415;
				word32 edx_5418;
				edx_5412();
				esp_1012 = esp_5415 + 0x04;
			}
			word32 v118_5425 = (word32) *ebx_5383 - 1;
			*ebx_5383 = v118_5425;
			if (v118_5425 == 0x00)
			{
				Eq_3 eax_5429 = *((word32) ebx_5383 + 4);
				<anonymous> * ecx_5430 = *((word32) eax_5429 + 24);
				esp_1012->dwFFFFFFFC = (word32) ebx_5383;
				word32 esp_5438;
				word32 ecx_5440;
				word32 edx_5441;
				ecx_5430();
				esp_1012 = esp_5438 + 0x04;
			}
			struct Eq_106913 * eax_5448 = esp_1012[0x0C];
			if (eax_5448 == null)
				goto l00709C15;
			word32 v119_5452 = eax_5448->dw0000 + ~0x00;
			eax_5448->dw0000 = v119_5452;
			if (v119_5452 != 0x00)
				goto l00709C15;
			edx_5353 = eax_5448->ptr0004;
			esp_1012->dwFFFFFFFC = eax_5448;
			goto l00709C0D;
		case 0x31:
		case 0x32:
		case 0x33:
		case 0x34:
			if (((byte) (ecx_742 - 0x02) & 0x02) != 0x00)
			{
				esp_11188->dw0010 = (word32) *((word32) ebp_1059 - 4);
				ebp_1059 -= 0x04;
			}
			else
				esp_11188->dw0010 = (word32) 0x00;
			if ((cl_5290 & 0x01) != 0x00)
			{
				esi_1003 = *((word32) ebp_1059 - 4);
				ebp_1059 -= 0x04;
			}
			else
				esi_1003.u0 = 0x00;
			Eq_3 ebx_5304 = *((word32) ebp_1059 - 4);
			Eq_3 eax_5307 = esp_11188->dw0010;
			struct Eq_106733 * esp_5310 = esp_11188 - 4;
			esp_5310->t0000.u0 = 0x00;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg4 = <invalid>;
			word32 eax_5321 = fn00707F70(eax_5307, esi_1003, ebx_5304, stackArg4);
			word32 v114_5327 = (word32) *ebx_5304 - 1;
			*ebx_5304 = v114_5327;
			esp_5310->dw001C = eax_5321;
			ebp_1059 -= 0x04;
			esp_1012 = (struct Eq_98733 *) ((const char *) &esp_5310->t0000 + 4);
			if (v114_5327 == 0x00)
			{
				Eq_3 eax_5332 = *((word32) ebx_5304 + 4);
				<anonymous> * ecx_5333 = *((word32) eax_5332 + 24);
				esp_5310->t0000 = ebx_5304;
				word32 esp_5336;
				word32 ecx_5338;
				word32 edx_5339;
				ecx_5333();
				esp_1012 = esp_5336 + 0x04;
			}
			if (esi_1003 != 0x00)
			{
				word32 v117_5349 = (word32) *esi_1003 - 1;
				*esi_1003 = v117_5349;
				if (v117_5349 == 0x00)
				{
					edx_5353 = (struct Eq_99435 *) *((word32) esi_1003 + 4);
					esp_1012->dwFFFFFFFC = (word32) esi_1003;
l00709C0D:
					<anonymous> * eax_5461 = edx_5353[8];
					word32 esp_5477;
					word32 ecx_5479;
					word32 edx_5480;
					eax_5461();
					esp_1012 = esp_5477 + 0x04;
				}
			}
l00709C15:
			eax_2933 = esp_1012->dw0010;
			if (eax_2933 != 0x00)
				goto l00709C1D;
			goto l00709C2E;
		case 0x36:
			esi_1003 = *((word32) ebp_1059 - 8);
			word32 eax_5203 = *((word32) esi_1003 + 4);
			ebx_3903 = *((word32) ebp_1059 - 4);
			esp_11188->dw0010 = (word32) ebx_3903;
			ebp_1059 -= 0x04;
			if (eax_5203 == 10610664 && *((word32) ebx_3903 + 4) == 10610664)
			{
				word32 eax_5218 = *((word32) esi_1003 + 8);
				word32 edx_5219 = *((word32) ebx_3903 + 8);
				word32 ecx_5220 = edx_5219 + eax_5218;
				if ((ecx_5220 ^ eax_5218) >= 0x00 || (ecx_5220 ^ edx_5219) >= 0x00)
				{
					esp_11188->dwFFFFFFFC = ecx_5220;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_3 stackArg4 = <invalid>;
					word32 edx_11172;
					word32 ecx_11171;
					eax_3913 = fn007050A0(stackArg4, out ecx_11171, out edx_11172);
					goto l007095D8;
				}
			}
			else if (eax_5203 == 0x00A1B450 && *((word32) ebx_3903 + 4) == 0x00A1B450)
			{
l00709732:
				struct Eq_96956 * ecx_5853 = esp_11188->ptr0020;
				struct Eq_96957 * edx_5854 = esp_11188->dw0070;
				struct Eq_102253 * esp_5855 = esp_11188 - 4;
				esp_5855->t0000 = ebx_3903;
				esp_5855->tFFFFFFFC = esi_1003;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_3 stackArg4 = <invalid>;
				Eq_3 eax_5870 = fn00708410(ecx_5853, edx_5854, stackArg4, dwArg04);
				esp_5855->t0018 = eax_5870;
				edi_1088 = eax_5870;
				esp_1012 = (struct Eq_98733 *) ((const char *) &esp_5855->t0000 + 4);
				goto l007095EF;
			}
			struct Eq_106653 * esp_5233 = esp_11188 - 4;
			esp_5233->t0000 = ebx_3903;
			esp_5233->tFFFFFFFC = esi_1003;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg4 = <invalid>;
			eax_3913 = fn007027D0(stackArg4, dwArg04);
			esp_5233->t0018 = eax_3913;
			edi_1088 = eax_3913;
			goto l007095DE;
		case 55:
			esi_1003 = *((word32) ebp_1059 - 8);
			ebx_3935 = *((word32) ebp_1059 - 4);
			esp_11188->dw0010 = (word32) ebx_3935;
			ebp_1059 -= 0x04;
			if (*((word32) esi_1003 + 4) == 10610664 && *((word32) ebx_3935 + 4) == 10610664)
			{
				word32 edx_5150 = *((word32) esi_1003 + 8);
				word32 ecx_5151 = *((word32) ebx_3935 + 8);
				word32 eax_5153 = edx_5150 - ecx_5151;
				if ((eax_5153 ^ edx_5150) >= 0x00 || (~ecx_5151 ^ eax_5153) >= 0x00)
				{
					struct Eq_106587 * esp_5184 = esp_11188 - 4;
					esp_5184->dw0000 = eax_5153;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_3 stackArg4 = <invalid>;
					word32 ecx_11168;
					word32 edx_11169;
					eax_3945 = fn007050A0(stackArg4, out ecx_11168, out edx_11169);
					esp_5184->t0018 = eax_3945;
					edi_1088 = eax_3945;
					esp_1012 = (struct Eq_98733 *) (&esp_5184->dw0000 + 1);
					goto l0070961E;
				}
			}
			struct Eq_106552 * esp_5165 = esp_11188 - 4;
			esp_5165->t0000 = ebx_3935;
			esp_5165->tFFFFFFFC = esi_1003;
			eax_3945 = fn00702730();
			esp_5165->t0018 = eax_3945;
			esp_5175 = esp_5165 - 4;
			edi_1088 = eax_3945;
			goto l0070961B;
		case 0x38:
			ebx_3935 = *((word32) ebp_1059 - 4);
			esi_1003 = *((word32) ebp_1059 - 8);
			struct Eq_100021 * esp_5130 = esp_11188 - 4;
			esp_5130->t0000 = ebx_3935;
			esp_5130->tFFFFFFFC = esi_1003;
			esp_5130->t0014 = ebx_3935;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg4 = <invalid>;
			ebp_1059 -= 0x04;
			eax_3945 = fn00704610(stackArg4, dwArg04);
			goto l00709615;
		case 0x39:
			if (g_dwA6C61C != 0x00)
			{
l00709966:
				ebx_3903 = *((word32) ebp_1059 - 4);
				esi_1003 = *((word32) ebp_1059 - 8);
				struct Eq_99947 * esp_5669 = esp_11188 - 4;
				esp_5669->t0000 = ebx_3903;
				esp_5669->tFFFFFFFC = esi_1003;
				esp_5669->t0014 = ebx_3903;
				ebp_1059 -= 0x04;
				eax_3913 = fn007027A0();
				goto l007095D8;
			}
			else
			{
				ebx_3920 = (struct Eq_99430 *) *((word32) ebp_1059 - 4);
				esi_1003 = *((word32) ebp_1059 - 8);
				struct Eq_106535 * esp_5115 = esp_11188 - 4;
				esp_5115->ptr0000 = ebx_3920;
				esp_5115->tFFFFFFFC = esi_1003;
				esp_5115->ptr0014 = ebx_3920;
				ebp_1059 -= 0x04;
				eax_3930 = fn00702750();
				goto l00709663;
			}
		case 0x3A:
			ebx_3920 = (struct Eq_99430 *) *((word32) ebp_1059 - 4);
			esi_1003 = *((word32) ebp_1059 - 8);
			struct Eq_100049 * esp_5098 = esp_11188 - 4;
			esp_5098->ptr0000 = ebx_3920;
			esp_5098->tFFFFFFFC = esi_1003;
			esp_5098->ptr0014 = ebx_3920;
			ebp_1059 -= 0x04;
			eax_3930 = fn007028A0();
			goto l00709663;
		case 0x3B:
			esi_1003 = *((word32) ebp_1059 - 0x0C);
			word32 eax_5033 = *((word32) ebp_1059 - 4);
			struct Eq_100073 * ebx_5034 = *((word32) ebp_1059 - 8);
			struct Eq_100077 * esp_5035 = esp_11188 - 4;
			esp_5035->t0000 = esi_1003;
			esp_5035->dwFFFFFFFC = eax_5033;
			esp_5035->ptrFFFFFFF8 = ebx_5034;
			esp_5035->dw0014 = eax_5033;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg4 = <invalid>;
			word32 ecx_10935;
			Eq_3 eax_5045 = fn00704300(stackArg4, dwArg04, dwArg08, out ecx_10935);
			word32 v112_5051 = (word32) *esi_1003 - 1;
			*esi_1003 = v112_5051;
			esp_5035->t001C = eax_5045;
			ebp_1059 = (word32) ebp_1059 - 0x0C;
			esp_1012 = (struct Eq_98733 *) ((const char *) &esp_5035->t0000 + 4);
			if (v112_5051 == 0x00)
			{
				struct Eq_106513 * eax_5056 = *((word32) esi_1003 + 4);
				<anonymous> * ecx_5057 = eax_5056->ptr0018;
				esp_5035->t0000 = esi_1003;
				word32 esp_5060;
				word32 ecx_5062;
				word32 edx_5063;
				ecx_5057();
				esp_1012 = esp_5060 + 0x04;
			}
			word32 v113_5070 = ebx_5034->dw0000 + ~0x00;
			ebx_5034->dw0000 = v113_5070;
			if (v113_5070 == 0x00)
			{
				struct Eq_106688 * edx_5074 = ebx_5034->ptr0004;
				<anonymous> * eax_5075 = edx_5074->ptr0018;
				esp_1012->dwFFFFFFFC = ebx_5034;
				word32 esp_5083;
				word32 ecx_5085;
				eax_5075();
				esp_1012 = esp_5083 + 0x04;
			}
			eax_2933 = esp_1012->dw0010;
l00709C1D:
			word32 v115_5493 = (word32) *eax_2933 - 1;
			*eax_2933 = v115_5493;
			if (v115_5493 != 0x00)
				goto l00709C2E;
			ecx_2954 = (struct Eq_99434 *) *((word32) eax_2933 + 4);
			esp_1012->dwFFFFFFFC = (word32) eax_2933;
			goto l00709C26;
		case 0x3C:
			ebx_2779 = (struct Eq_99436 *) *((word32) ebp_1059 - 4);
			esi_1003 = *((word32) ebp_1059 - 8);
			struct Eq_100122 * esp_4971 = esp_11188 - 4;
			esp_4971->ptr0000 = ebx_2779;
			esp_4971->tFFFFFFFC = esi_1003;
			esp_4971->ptr0014 = ebx_2779;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg4 = <invalid>;
			ebp_1059 = (word32) ebp_1059 - 8;
			word32 ecx_10937;
			eax_2791 = fn00704400(stackArg4, dwArg04, out ecx_10937);
			goto l00709D0E;
		case 0x3D:
			ebx_3920 = (struct Eq_99430 *) *((word32) ebp_1059 - 4);
			esi_1003 = *((word32) ebp_1059 - 8);
			struct Eq_100147 * esp_4958 = esp_11188 - 4;
			esp_4958->ptr0000 = ebx_3920;
			esp_4958->tFFFFFFFC = esi_1003;
			esp_4958->ptr0014 = ebx_3920;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg4 = <invalid>;
			ebp_1059 -= 0x04;
			eax_3930 = fn007021F0(stackArg4, dwArg04);
			goto l00709663;
		case 0x3E:
			ebx_3903 = *((word32) ebp_1059 - 4);
			esi_1003 = *((word32) ebp_1059 - 8);
			struct Eq_100171 * esp_4941 = esp_11188 - 4;
			esp_4941->t0000 = ebx_3903;
			esp_4941->tFFFFFFFC = esi_1003;
			esp_4941->t0014 = ebx_3903;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg4 = <invalid>;
			ebp_1059 -= 0x04;
			eax_3913 = fn00702250(stackArg4, dwArg04);
			goto l007095D8;
		case 0x3F:
			ebx_3935 = *((word32) ebp_1059 - 4);
			esi_1003 = *((word32) ebp_1059 - 8);
			struct Eq_100195 * esp_4926 = esp_11188 - 4;
			esp_4926->t0000 = ebx_3935;
			esp_4926->tFFFFFFFC = esi_1003;
			esp_4926->t0014 = ebx_3935;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg4 = <invalid>;
			ebp_1059 -= 0x04;
			eax_3945 = fn00702190(stackArg4, dwArg04);
			goto l00709615;
		case 0x40:
			ebx_3920 = (struct Eq_99430 *) *((word32) ebp_1059 - 4);
			esi_1003 = *((word32) ebp_1059 - 8);
			struct Eq_100219 * esp_4911 = esp_11188 - 4;
			esp_4911->ptr0000 = ebx_3920;
			esp_4911->tFFFFFFFC = esi_1003;
			esp_4911->ptr0014 = ebx_3920;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg4 = <invalid>;
			ebp_1059 -= 0x04;
			eax_3930 = fn00702130(stackArg4, dwArg04);
			goto l00709663;
		case 0x41:
			ebx_3903 = *((word32) ebp_1059 - 4);
			esi_1003 = *((word32) ebp_1059 - 8);
			struct Eq_100243 * esp_4894 = esp_11188 - 4;
			esp_4894->t0000 = ebx_3903;
			esp_4894->tFFFFFFFC = esi_1003;
			esp_4894->t0014 = ebx_3903;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg4 = <invalid>;
			ebp_1059 -= 0x04;
			eax_3913 = fn007020D0(stackArg4, dwArg04);
			goto l007095D8;
		case 66:
			ebx_3903 = *((word32) ebp_1059 - 4);
			esi_1003 = *((word32) ebp_1059 - 8);
			struct Eq_100267 * esp_4877 = esp_11188 - 4;
			esp_4877->dw0000 = 0x00A163B8;
			esp_4877->tFFFFFFFC = ebx_3903;
			esp_4877->tFFFFFFF8 = esi_1003;
			esp_4877->t0014 = ebx_3903;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg4 = <invalid>;
			ebp_1059 -= 0x04;
			eax_3913 = fn007028C0(stackArg4);
l007095D5:
			goto l007095D8;
		case 0x43:
			esi_1003 = *((word32) ebp_1059 - 4);
			struct Eq_100292 * esp_4581 = esp_11188 - 4;
			esp_4581->t0000 = esi_1003;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg4 = <invalid>;
			word32 edx_10946;
			word32 ecx_10945;
			Eq_3 eax_4584 = fn00704B00(stackArg4, out ecx_10945, out edx_10946);
			word32 v107_4590 = (word32) *esi_1003 - 1;
			*esi_1003 = v107_4590;
			esp_4581->t0018 = eax_4584;
			esp_1012 = (struct Eq_98733 *) ((const char *) &esp_4581->t0000 + 4);
			edi_1088 = eax_4584;
			if (v107_4590 == 0x00)
			{
				struct Eq_106266 * eax_4596 = *((word64) esi_1003.u0 + 4);
				<anonymous> * ecx_4597 = eax_4596->ptr0018;
				esp_4581->t0000 = esi_1003;
				word32 esp_4600;
				word32 ecx_4602;
				word32 edx_4603;
				ecx_4597();
				esp_1012 = esp_4600 + 0x04;
			}
			if (eax_4584 == 0x00)
			{
				ebp_1059 -= 0x04;
				goto l00708EE4;
			}
			else
			{
				esi_1003 = esp_1012->ptr0020;
				*((word32) ebp_1059 - 4) = eax_4584;
				if (*esi_1003 != 0x5D)
					goto l00708F23;
				ebx_2263 = ((word32) *((word32) esi_1003 + 2) << 0x08) + (word32) (*((word32) esi_1003 + 1));
				Mem4627[esp_1012 + 0x20:word32] = esi_1003 + 0x03;
				esi_1003 += 0x03;
				goto l00709422;
			}
		case 0x45:
			Eq_3 ebx_4438 = *((word32) ebp_1059 - 4);
			struct Eq_100326 * esp_4441 = esp_11188 - 4;
			esp_4441->t0000.u0 = 0x008D7D18;
			word32 ecx_10947;
			word32 edx_10948;
			Eq_3 eax_4444 = fn00715DD0(out ecx_10947, out edx_10948);
			esp_4441->t0014 = eax_4444;
			ebp_1059 -= 0x04;
			esi_1003 = eax_4444;
			esp_1012 = (struct Eq_98733 *) ((const char *) &esp_4441->t0000 + 4);
			if (eax_4444 == 0x00)
			{
				Eq_3 ecx_4506 = g_tA175E0;
				esp_4441->t0000.u0 = 0x008D7D00;
				esp_4441->tFFFFFFFC = ecx_4506;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_3 stackArg4 = <invalid>;
				word32 ecx_11156;
				word32 edx_11157;
				eax_4444 = fn006E0F80(stackArg4, dwArg04, out ecx_11156, out edx_11157);
				esp_4441->t0018.u0 = 0x00;
				edi_1088.u0 = 0x00;
				goto l00709D71;
			}
			if (esp_4441->dw001C == 0x00)
			{
				esp_4441->t0000 = ebx_4438;
				esp_4441->tFFFFFFFC.u0 = 0x01;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_3 stackArg4 = <invalid>;
				word32 esi_11161;
				word32 edx_11160;
				word32 ecx_11159;
				eax_4444 = fn006DFF80(stackArg4, out ecx_11159, out edx_11160, out esi_11161);
				esp_4441->t0018 = eax_4444;
				edi_1088 = eax_4444;
				if (eax_4444 != 0x00)
				{
					esp_4441->t0000.u0 = 0x00;
					esp_4441->tFFFFFFFC = eax_4444;
					esp_4441->tFFFFFFF8 = eax_4444;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_3 stackArg4 = <invalid>;
					word32 edi_11166;
					word32 esi_11165;
					word32 ecx_11163;
					word32 edx_11164;
					eax_4444 = fn00707680(stackArg4, dwArg04, dwArg08, out ecx_11163, out edx_11164, out esi_11165, out edi_11166);
					esp_4441->t0014 = eax_4444;
					esp_1012 = (struct Eq_98733 *) ((const char *) &esp_4441->t0000 + 4);
					if (eax_4444 == 0x00)
						goto l00709D71;
					word32 v109_4490 = (word32) *eax_4444 - 1;
					*eax_4444 = v109_4490;
					if (v109_4490 == 0x00)
					{
						Eq_3 edx_4494 = *((word32) eax_4444 + 4);
						esp_4441->t0000 = eax_4444;
						<anonymous> * eax_4497 = *((word32) edx_4494 + 24);
						word32 esp_4498;
						word32 ecx_4500;
						eax_4497();
						esp_1012 = esp_4498 + 0x04;
					}
				}
				else
				{
l00709D71:
					esp_11188[8] = (struct Eq_98733) ~0x00;
					esp_1012 = esp_11188;
				}
			}
			word32 v106_4527 = (word32) *ebx_4438 - 1;
			*ebx_4438 = v106_4527;
			if (v106_4527 == 0x00)
			{
				Eq_3 ecx_4531 = *((word32) ebx_4438 + 4);
				<anonymous> * edx_4532 = *((word32) ecx_4531 + 24);
				esp_1012->dwFFFFFFFC = (word32) ebx_4438;
				word32 esp_4546;
				word32 edx_4549;
				edx_4532();
				esp_1012 = esp_4546 + 0x04;
			}
			if (edi_1088 != 0x00)
			{
				word32 v108_4559 = (word32) *edi_1088.u0 - 1;
				*edi_1088.u0 = v108_4559;
				if (v108_4559 == 0x00)
				{
					struct Eq_106345 * eax_4563 = *((word64) edi_1088.u0 + 4);
					<anonymous> * ecx_4564 = eax_4563->ptr0018;
					esp_1012->dwFFFFFFFC = (word32) edi_1088;
					word32 esp_4572;
					word32 ecx_4574;
					word32 edx_4575;
					ecx_4564();
					esp_1012 = esp_4572 + 0x04;
				}
			}
			goto l00708EE4;
		case 0x46:
			ebx_3987 = esp_11188->dw0010;
			goto l00709E03;
		case 0x47:
			esi_1003 = esp_11188->dw0034;
			ebx_3985 = esp_11188->dw0010;
			goto l00709F9E;
		case 0x48:
			ebx_3987 = *((word32) ebp_1059 - 4);
			esp_11188->dw0034 = (word32) ebx_3987;
			esp_11188->dw0010 = (word32) ebx_3987;
			ebp_1059 -= 0x04;
l00709E03:
			Eq_3 eax_4118 = esp_11188->dw0034;
			esi_1003 = *((word32) ebp_1059 - 4);
			ebp_1059 -= 0x04;
			if (eax_4118 != 0x00 && eax_4118 != 0x00A163B8)
			{
l00709E4B:
				if (ebx_3987 != 0x00)
					goto l00709E4F;
				goto l00709E73;
			}
			struct Eq_105828 * esp_4128 = esp_11188 - 4;
			esp_4128->dw0000 = 9094448;
			word32 ecx_11126;
			word32 edx_11127;
			Eq_3 eax_4140 = fn00715DD0(out ecx_11126, out edx_11127);
			esp_4128->t0014 = eax_4140;
			ebx_3987 = eax_4140;
			if (eax_4140 == 0x00)
			{
				Eq_3 edx_4151 = g_tA175E0;
				esp_4128->dw0000 = 0x008D7CF0;
				esp_4128->tFFFFFFFC = edx_4151;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_3 stackArg4 = <invalid>;
				word32 ecx_11133;
				word32 edx_11134;
				fn006E0F80(stackArg4, dwArg04, out ecx_11133, out edx_11134);
				esp_4128->dw001C = ~0x00;
				goto l00709E4B;
			}
l00709E4F:
			*ebx_3987 = (word32) *ebx_3987 + 1;
			struct Eq_105859 * esp_4177 = esp_11188 - 4;
			esp_4177->t0000.u0 = 0x00;
			esp_4177->tFFFFFFFC = ebx_3987;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg4 = <invalid>;
			word32 esi_11130;
			word32 edi_11131;
			word32 ebx_11129;
			if (fn00731A20(stackArg4, dwArg04, out ebx_11129, out esi_11130, out edi_11131) != 0x00)
			{
				esp_4177->t0000 = ebx_3987;
				esp_4177->tFFFFFFFC.u0 = 9070940;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_3 stackArg4 = <invalid>;
				word32 edi_11142;
				word32 edx_11140;
				word32 esi_11141;
				esp_4177->t001C = fn00731D30(stackArg4, dwArg04, out edx_11140, out esi_11141, out edi_11142);
			}
l00709E73:
			if (esp_11188[8] == 0x00)
			{
				struct Eq_106001 * esp_4218 = esp_11188 - 4;
				esp_4218->t0000.u0 = 0x01;
				esp_4218->tFFFFFFFC = ebx_3987;
				esp_4218->tFFFFFFF8 = esi_1003;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_3 stackArg4 = <invalid>;
				word32 esi_11146;
				word32 edx_11144;
				word32 ebx_11145;
				Eq_3 eax_4231 = fn00731B10(edi_1088, es, ds, stackArg4, dwArg04, dwArg08, out edx_11144, out ebx_11145, out esi_11146);
				esp_4218->t001C = eax_4231;
				if (eax_4231 != 0x00)
					goto l00709F3C;
				bool v160_8118;
				Eq_3 eax_4241 = *((word64) esi_1003.u0 + 4);
				if (eax_4241 == 0x00A1B450)
				{
l00709F08:
					Eq_106036 eax_4261 = *((word64) esi_1003.u0 + 8);
					esp_4218->t0054 = eax_4261;
					if (eax_4261 == 0x00)
						goto l00709F31;
					Mem4269[esp_4218 + 0x00:word32] = CONVERT(Mem4265[eax_4261 + 0x13 + esi_1003:byte], byte, word32);
					if (isspace(esp_4218->t0000) == 0x00)
						goto l00709F31;
					v160_8118 = Mem4269[Mem4269[esp_4218 + 0x54:word32] + 0x13 + esi_1003:byte] != 0x20;
					goto l00709F2F;
				}
				esp_4218->t0000.u0 = 0x00A1B450;
				esp_4218->tFFFFFFFC = eax_4241;
				word32 edx_11148;
				word32 ecx_11147;
				if (fn006D5670(esp_4218->tFFFFFFFC, esp_4218->t0000, out ecx_11147, out edx_11148) != 0x00)
					goto l00709F08;
				Eq_3 eax_4277 = *((word64) esi_1003.u0 + 4);
				if (eax_4277 != 0x00A23B20)
				{
					esp_4218->t0000.u0 = 0x00A23B20;
					esp_4218->tFFFFFFFC = eax_4277;
					word32 edx_11150;
					word32 ecx_11149;
					if (fn006D5670(esp_4218->tFFFFFFFC, esp_4218->t0000, out ecx_11149, out edx_11150) != 0x00)
						goto l00709ECE;
					goto l00709F31;
				}
l00709ECE:
				esp_4218->ptr0028 = (ptr32) *((word64) esi_1003.u0 + 0x0C);
				Eq_106036 eax_4300 = *((word64) esi_1003.u0 + 8);
				esp_4218->t0054 = eax_4300;
				if (eax_4300 != 0x00)
				{
					esp_4218->t0000 = (word32) (esp_4218->ptr0028 - 0x02)[eax_4300];
					if (fn00750FF0(esp_4218->t0000) == 0x00)
						goto l00709F31;
					v160_8118 = (esp_4218->ptr0028 - 0x02)[esp_4218->t0054] != 0x20;
l00709F2F:
					if (!v160_8118)
						goto l00709F31;
				}
				else
				{
l00709F31:
					esp_4218->t0000.u0 = 0x01;
					esp_4218->tFFFFFFFC = ebx_3987;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_3 stackArg4 = <invalid>;
					word32 ebx_11152;
					word32 edi_11154;
					word32 esi_11153;
					fn00731A20(stackArg4, dwArg04, out ebx_11152, out esi_11153, out edi_11154);
				}
			}
l00709F3C:
			esp_1012 = esp_11188;
			if (ebx_3987 != 0x00)
			{
				word32 v105_4365 = (word32) *ebx_3987 - 1;
				*ebx_3987 = v105_4365;
				if (v105_4365 == 0x00)
				{
					struct Eq_106204 * eax_4369 = *((word32) ebx_3987 + 4);
					<anonymous> * ecx_4370 = eax_4369->ptr0018;
					esp_11188->dwFFFFFFFC = (word32) ebx_3987;
					word32 esp_4378;
					word32 ecx_4380;
					word32 edx_4381;
					ecx_4370();
					esp_1012 = esp_4378 + 0x04;
				}
			}
			word32 v110_4388 = (word32) *esi_1003.u0 - 1;
			*esi_1003.u0 = v110_4388;
			if (v110_4388 == 0x00)
			{
				struct Eq_106457 * edx_4392 = *((word32) esi_1003 + 4);
				<anonymous> * eax_4393 = edx_4392->ptr0018;
				esp_1012->dwFFFFFFFC = (word32) esi_1003;
				word32 esp_4401;
				word32 ecx_4403;
				eax_4393();
				esp_1012 = esp_4401 + 0x04;
			}
			struct Eq_106451 * eax_4411 = esp_1012->dw0034;
			if (eax_4411 != null)
			{
				word32 v111_4415 = eax_4411->dw0000 + ~0x00;
				eax_4411->dw0000 = v111_4415;
				if (v111_4415 == 0x00)
				{
					struct Eq_106487 * ecx_4419 = eax_4411->ptr0004;
					<anonymous> * edx_4420 = ecx_4419->ptr0018;
					esp_1012->dwFFFFFFFC = eax_4411;
					word32 esp_4428;
					word32 edx_4431;
					edx_4420();
					esp_1012 = esp_4428 + 0x04;
				}
			}
			esp_1012->dw0034 = 0x00;
			goto l00709C2E;
		case 0x49:
			esi_1003 = *((word32) ebp_1059 - 4);
			esp_11188->dw0010 = (word32) esi_1003;
			ebp_1059 -= 0x04;
			ebx_3985 = esi_1003;
l00709F9E:
			if (esi_1003 == 0x00 || esi_1003 == 0x00A163B8)
			{
				struct Eq_105738 * esp_4002 = esp_11188 - 4;
				esp_4002->dw0000 = 9094448;
				word32 ecx_11117;
				word32 edx_11118;
				Eq_3 eax_4016 = fn00715DD0(out ecx_11117, out edx_11118);
				esp_4002->t0014 = eax_4016;
				ebx_3985 = eax_4016;
				if (eax_4016 != 0x00)
				{
l00709FD8:
					struct Eq_105761 * esp_4046 = esp_11188 - 4;
					esp_4046->t0000 = ebx_3985;
					esp_4046->tFFFFFFFC.u0 = 0x008A6DE8;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_3 stackArg4 = <invalid>;
					word32 edi_11122;
					word32 edx_11120;
					word32 esi_11121;
					eax_4033 = fn00731D30(stackArg4, dwArg04, out edx_11120, out esi_11121, out edi_11122);
					esp_4046->t001C = eax_4033;
					if (eax_4033 == 0x00)
					{
						esp_4046->t0000 = eax_4033;
						esp_4046->tFFFFFFFC = ebx_3985;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_3 stackArg4 = <invalid>;
						word32 ebx_11136;
						word32 esi_11137;
						word32 edi_11138;
						eax_4033 = fn00731A20(stackArg4, dwArg04, out ebx_11136, out esi_11137, out edi_11138);
					}
l00709FF8:
					esp_1012 = esp_11188;
					if (esi_1003 != 0x00)
					{
						word32 v104_4091 = (word32) *esi_1003.u0 - 1;
						*esi_1003.u0 = v104_4091;
						if (v104_4091 == 0x00)
						{
							struct Eq_105984 * ecx_4095 = *((word64) esi_1003.u0 + 4);
							<anonymous> * edx_4096 = ecx_4095->ptr0018;
							esp_11188->dwFFFFFFFC = (word32) esi_1003;
							word32 esp_4105;
							word32 edx_4108;
							edx_4096();
							esp_1012 = esp_4105 + 0x04;
						}
					}
					esp_1012->dw0034 = 0x00;
					goto l00708EE4;
				}
				Eq_3 eax_4027 = g_tA175E0;
				esp_4002->dw0000 = 0x008D7CF0;
				esp_4002->tFFFFFFFC = eax_4027;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_3 stackArg4 = <invalid>;
				word32 ecx_11124;
				word32 edx_11125;
				eax_4033 = fn006E0F80(stackArg4, dwArg04, out ecx_11124, out edx_11125);
			}
			if (ebx_3985 != 0x00)
				goto l00709FD8;
			goto l00709FF8;
		case 0x4A:
			ebx_3920 = (struct Eq_99430 *) *((word32) ebp_1059 - 4);
			esi_1003 = *((word32) ebp_1059 - 8);
			struct Eq_100383 * esp_3971 = esp_11188 - 4;
			esp_3971->ptr0000 = ebx_3920;
			esp_3971->tFFFFFFFC = esi_1003;
			esp_3971->ptr0014 = ebx_3920;
			ebp_1059 -= 0x04;
			eax_3930 = fn007026F0();
			goto l00709663;
		case 0x4B:
			ebx_3903 = *((word32) ebp_1059 - 4);
			esi_1003 = *((word32) ebp_1059 - 8);
			struct Eq_100406 * esp_3954 = esp_11188 - 4;
			esp_3954->t0000 = ebx_3903;
			esp_3954->tFFFFFFFC = esi_1003;
			esp_3954->t0014 = ebx_3903;
			ebp_1059 -= 0x04;
			eax_3913 = fn00702710();
			goto l007095D8;
		case 0x4C:
			ebx_3935 = *((word32) ebp_1059 - 4);
			esi_1003 = *((word32) ebp_1059 - 8);
			struct Eq_100429 * esp_3939 = esp_11188 - 4;
			esp_3939->t0000 = ebx_3935;
			esp_3939->tFFFFFFFC = esi_1003;
			esp_3939->t0014 = ebx_3935;
			ebp_1059 -= 0x04;
			eax_3945 = fn007026D0();
l00709615:
			esp_5175 = esp_11188 - 8;
			esp_5175->dw001C = (word32) eax_3945;
			edi_1088 = eax_3945;
l0070961B:
			esp_1012 = (struct Eq_98733 *) ((const char *) esp_5175 + 8);
l0070961E:
			word32 v98_6060 = (word32) *esi_1003 - 1;
			*esi_1003 = v98_6060;
			if (v98_6060 == 0x00)
			{
				struct Eq_105697 * edx_6064 = *((word64) esi_1003.u0 + 4);
				<anonymous> * eax_6065 = edx_6064->ptr0018;
				esp_1012->dwFFFFFFFC = (word32) esi_1003;
				word32 esp_6080;
				word32 ecx_6082;
				eax_6065();
				esp_1012 = esp_6080 + 0x04;
			}
			word32 v101_6090 = (word32) *ebx_3935 - 1;
			*ebx_3935 = v101_6090;
			if (v101_6090 != 0x00)
				goto l007094E3;
			struct Eq_105901 * ecx_6094 = *((word32) ebx_3935 + 4);
			<anonymous> * edx_6095 = ecx_6094->ptr0018;
			esp_1012->dwFFFFFFFC = (word32) ebx_3935;
			word32 edx_6109;
			edx_6095();
			goto l007094E0;
		case 77:
			ebx_3920 = (struct Eq_99430 *) *((word32) ebp_1059 - 4);
			esi_1003 = *((word32) ebp_1059 - 8);
			struct Eq_100452 * esp_3924 = esp_11188 - 4;
			esp_3924->ptr0000 = ebx_3920;
			esp_3924->tFFFFFFFC = esi_1003;
			esp_3924->ptr0014 = ebx_3920;
			ebp_1059 -= 0x04;
			eax_3930 = fn007026A0();
l00709663:
			struct Eq_101856 * esp_5986 = esp_11188 - 8;
			word32 v28_5990 = (word32) *esi_1003 - 1;
			*esi_1003 = v28_5990;
			esp_5986->t001C = eax_3930;
			esp_1012 = (struct Eq_98733 *) ((const char *) &esp_5986->t0004 + 4);
			edi_1088 = eax_3930;
			if (v28_5990 == 0x00)
			{
				struct Eq_101935 * eax_5997 = *((word32) esi_1003 + 4);
				<anonymous> * ecx_5998 = eax_5997->ptr0018;
				esp_5986->t0004 = esi_1003;
				word32 esp_6004;
				word32 ecx_6006;
				word32 edx_6007;
				ecx_5998();
				esp_1012 = esp_6004 + 0x04;
			}
			word32 v29_6014 = ebx_3920->dw0000 + ~0x00;
			ebx_3920->dw0000 = v29_6014;
			if (v29_6014 != 0x00)
				goto l007094E3;
			struct Eq_102036 * edx_6018 = ebx_3920->dw0004;
			<anonymous> * eax_6019 = edx_6018->ptr0018;
			esp_1012->dwFFFFFFFC = ebx_3920;
			word32 ecx_6029;
			eax_6019();
			goto l007094E0;
		case 0x4E:
			ebx_3903 = *((word32) ebp_1059 - 4);
			esi_1003 = *((word32) ebp_1059 - 8);
			struct Eq_100475 * esp_3907 = esp_11188 - 4;
			esp_3907->t0000 = ebx_3903;
			esp_3907->tFFFFFFFC = esi_1003;
			esp_3907->t0014 = ebx_3903;
			ebp_1059 -= 0x04;
			eax_3913 = fn00702670();
l007095D8:
			esp_11188->dw0014 = (word32) eax_3913;
			edi_1088 = eax_3913;
l007095DE:
			word32 v27_6141 = (word32) *esi_1003 - 1;
			*esi_1003 = v27_6141;
			esp_1012 = esp_11188;
			if (v27_6141 == 0x00)
			{
				struct Eq_101909 * ecx_6145 = *((word32) esi_1003 + 4);
				<anonymous> * edx_6146 = ecx_6145->ptr0018;
				esp_11188->dwFFFFFFFC = (word32) esi_1003;
				word32 esp_6161;
				word32 edx_6164;
				edx_6146();
				esp_1012 = esp_6161 + 0x04;
			}
l007095EF:
			word32 v33_6171 = (word32) *ebx_3903 - 1;
			*ebx_3903 = v33_6171;
			if (v33_6171 != 0x00)
				goto l007094E3;
			eax_6175 = (struct Eq_99422 *) *((word32) ebx_3903 + 4);
			esp_1012->dwFFFFFFFC = (word32) ebx_3903;
l007094DB:
			word32 ecx_6418;
			word32 edx_6419;
			eax_6175[8]();
			goto l007094E0;
		case 0x4F:
			esp_11188->dw001C = 0x10;
			goto l0070B089;
		case 0x50:
			struct Eq_100496 * ebx_3677;
			esi_1003 = *((word32) ebp_1059 - 8);
			Eq_3 eax_3656 = *((word32) esi_1003 + 4);
			word32 edi_3658 = *((word32) ebp_1059 - 4);
			if (eax_3656 != 10610664)
			{
				struct Eq_105418 * esp_3660 = esp_11188 - 4;
				esp_3660->t0000.u0 = 10610664;
				esp_3660->tFFFFFFFC = eax_3656;
				word32 edx_11111;
				word32 ecx_11110;
				if (fn006D5670(esp_3660->tFFFFFFFC, esp_3660->t0000, out ecx_11110, out edx_11111) != 0x00 || esi_1003 == 0x00A163B8)
					goto l0070ABBF;
				ebx_3677 = (struct Eq_100496 *) *((word32) ebp_1059 - 16);
				esp_3660->dw0028 = (word32) *((word32) ebp_1059 - 0x0C);
			}
			else
			{
l0070ABBF:
				esp_11188[0x0C] = (struct Eq_98733) 0x00A163B8;
				ebx_3677 = (struct Eq_100496 *) &g_dwA163B8;
				esi_1003.u0 = 0x00A163B8;
			}
			Eq_3 ecx_3686 = esp_11188[0x0C];
			struct Eq_105457 * esp_3687 = esp_11188 - 4;
			esp_3687->t0000.u0 = 0x00;
			esp_3687->ptrFFFFFFFC = ebx_3677;
			esp_3687->tFFFFFFF8 = ecx_3686;
			esp_3687->tFFFFFFF4 = esi_1003;
			esp_3687->dwFFFFFFF0 = edi_3658;
			esp_3687->ptr0014 = ebx_3677;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg4 = <invalid>;
			word32 ecx_11113;
			word32 edx_11114;
			Eq_3 eax_3709 = fn00703AF0(stackArg4, out ecx_11113, out edx_11114);
			esp_3687->t0018 = eax_3709;
			edi_1088 = eax_3709;
			esp_1012 = (struct Eq_98733 *) ((const char *) &esp_3687->t0000 + 4);
			if (eax_3709 == 0x00)
				goto l00708EE4;
			if (esi_1003 != 0x00A163B8)
			{
				esp_3687->t0000 = eax_3709;
				word32 edx_11116;
				word32 ecx_11115;
				Eq_55932 eax_3724 = fn006DEA90(esp_3687->t0000, out ecx_11115, out edx_11116);
				esp_1012 = (struct Eq_98733 *) ((const char *) &esp_3687->t0000 + 4);
				if (eax_3724 != 0x00)
				{
					word32 v93_3783 = (word32) *eax_3709 - 1;
					*eax_3709 = v93_3783;
					if (v93_3783 == 0x00)
					{
						Eq_3 edx_3787 = *((word32) eax_3709 + 4);
						<anonymous> * eax_3788 = *((word32) edx_3787 + 24);
						esp_3687->t0000 = eax_3709;
						word32 esp_3791;
						word32 ecx_3793;
						eax_3788();
						esp_1012 = esp_3791 + 0x04;
					}
					edi_1088 = *((word32) ebp_1059 - 4);
					++g_dwA163B8;
					ebp_1059 -= 0x0C;
					*((word32) ebp_1059 - 4) = 0x00A163B8;
					word32 v95_3806 = (word32) *edi_1088.u0 - 1;
					*edi_1088.u0 = v95_3806;
					esp_1012->dw0014 = (word32) edi_1088;
					if (v95_3806 == 0x00)
					{
						struct Eq_105598 * ecx_3812 = *((word64) edi_1088.u0 + 4);
						<anonymous> * edx_3813 = ecx_3812->ptr0018;
						esp_1012->dwFFFFFFFC = (word32) edi_1088;
						word32 esp_3820;
						word32 edx_3823;
						edx_3813();
						esp_1012 = esp_3820 + 0x04;
					}
					word32 v97_3830 = (word32) *esi_1003.u0 - 1;
					*esi_1003.u0 = v97_3830;
					if (v97_3830 == 0x00)
					{
						struct Eq_105668 * eax_3834 = *((word64) esi_1003.u0 + 4);
						<anonymous> * ecx_3835 = eax_3834->ptr0018;
						esp_1012->dwFFFFFFFC = (word32) esi_1003;
						word32 esp_3843;
						word32 ecx_3845;
						word32 edx_3846;
						ecx_3835();
						esp_1012 = esp_3843 + 0x04;
					}
					struct Eq_105653 * eax_3853 = esp_1012[0x0C];
					word32 v100_3854 = eax_3853->dw0000 + ~0x00;
					eax_3853->dw0000 = v100_3854;
					if (v100_3854 == 0x00)
					{
						struct Eq_105813 * edx_3858 = eax_3853->dw0004;
						esp_1012->dwFFFFFFFC = eax_3853;
						<anonymous> * eax_3861 = edx_3858->ptr0018;
						word32 esp_3867;
						word32 ecx_3869;
						eax_3861();
						esp_1012 = esp_3867 + 0x04;
					}
					word32 v102_3877 = ebx_3677->dw0000 + ~0x00;
					ebx_3677->dw0000 = v102_3877;
					if (v102_3877 == 0x00)
					{
						struct Eq_105913 * ecx_3881 = ebx_3677->dw0004;
						<anonymous> * edx_3882 = ecx_3881->ptr0018;
						esp_1012->dwFFFFFFFC = ebx_3677;
						word32 esp_3891;
						word32 edx_3894;
						edx_3882();
						esp_1012 = esp_3891 + 0x04;
					}
					goto l00708EE4;
				}
			}
			word32 v96_3737 = (word32) *eax_3709 - 1;
			*eax_3709 = v96_3737;
			esp_1012 = (struct Eq_98733 *) ((const char *) &esp_3687->t0000 + 4);
			if (v96_3737 == 0x00)
			{
				Eq_3 eax_3741 = *((word32) eax_3709 + 4);
				<anonymous> * ecx_3742 = *((word32) eax_3741 + 24);
				esp_3687->t0000 = eax_3709;
				word32 esp_3750;
				word32 ecx_3752;
				word32 edx_3753;
				ecx_3742();
				esp_1012 = esp_3750 + 0x04;
			}
			edi_1088 = *((word32) ebp_1059 - 4);
			word32 v99_3762 = (word32) *edi_1088.u0 - 1;
			*edi_1088.u0 = v99_3762;
			esp_1012->dw0014 = (word32) edi_1088;
			ebp_1059 += ~0x03;
			if (v99_3762 == 0x00)
			{
				struct Eq_105712 * edx_3768 = *((word64) edi_1088.u0 + 4);
				<anonymous> * eax_3769 = edx_3768->ptr0018;
				esp_1012->dwFFFFFFFC = (word32) edi_1088;
				word32 esp_3775;
				word32 ecx_3777;
				eax_3769();
				esp_1012 = esp_3775 + 0x04;
			}
			goto l00708EE4;
		case 0x51:
			edi_1088 = esp_11188->dw0070 + 0x1C;
			esp_11188->dw0014 = (word32) edi_1088;
			if (edi_1088 == 0x00)
			{
				Eq_3 edx_3637 = g_tA18720;
				struct Eq_105380 * esp_3638 = esp_11188 - 4;
				esp_3638->dw0000 = 0x008D7CCC;
				esp_3638->tFFFFFFFC = edx_3637;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_3 stackArg4 = <invalid>;
				word32 edx_11109;
				word32 ecx_11108;
				fn006E0F80(stackArg4, dwArg04, out ecx_11108, out edx_11109);
				esp_1012 = (struct Eq_98733 *) (&esp_3638->dw0000 + 1);
				goto l00708EE4;
			}
			else
			{
				*edi_1088.u0 = (word32) *edi_1088.u0 + 1;
				*ebp_1059 = edi_1088;
				ebp_1059 += 0x04;
				goto l00708F23;
			}
		case 0x52:
			esp_11188->ptr002C = (struct Eq_179984 *) *((word32) ebp_1059 - 4);
			esp_11188->dw001C = 0x08;
			ebp_1059 -= 0x04;
			goto l0070B089;
		case 0x53:
			Eq_3 ebx_3566 = esp_11188->dw0070;
			esi_1003 = *((word32) ebp_1059 - 4);
			struct Eq_100540 * esp_3570 = esp_11188 - 4;
			esp_3570->t0000 = ebx_3566;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg4 = <invalid>;
			fn0073B3D0(stackArg4);
			edi_1088 = *((word32) ebx_3566 + 28);
			esp_3570->t0018 = edi_1088;
			ebp_1059 -= 0x04;
			if (edi_1088 != 0x00)
			{
				esp_3570->t0000 = esi_1003;
				esp_3570->tFFFFFFFC = edi_1088;
				word32 eax_3589 = fn00708210(ebp_1059, dwArg04);
				esp_3570->dwFFFFFFF8 = 0x00;
				esp_3570->tFFFFFFF4 = ebx_3566;
				esp_3570->dw001C = eax_3589;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_3 stackArg4 = <invalid>;
				eax_2933 = fn0073B4E0(stackArg4);
				word32 v92_3606 = (word32) *esi_1003 - 1;
				*esi_1003 = v92_3606;
				esp_1012 = (struct Eq_98733 *) ((const char *) &esp_3570->t0000 + 4);
				if (v92_3606 != 0x00)
					goto l00709C2E;
				ecx_2954 = (struct Eq_99434 *) *((word64) esi_1003.u0 + 4);
				esp_3570->t0000 = esi_1003;
				goto l00709C26;
			}
			else
			{
				Eq_3 eax_3613 = g_tA18720;
				esp_3570->t0000.u0 = 9272204;
				esp_3570->tFFFFFFFC = eax_3613;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_3 stackArg4 = <invalid>;
				word32 ecx_11105;
				word32 edx_11106;
				fn006E0F80(stackArg4, dwArg04, out ecx_11105, out edx_11106);
				esp_1012 = (struct Eq_98733 *) ((const char *) &esp_3570->t0000 + 4);
				goto l00708EE4;
			}
		case 0x54:
			Eq_3 ebx_3479 = *((word32) ebp_1059 - 4);
			word32 eax_3480 = *((word32) ebp_1059 - 8);
			esi_1003 = *((word32) ebp_1059 - 0x0C);
			word32 ecx_3482 = esp_11188->dw0070;
			struct Eq_100576 * esp_3483 = esp_11188 - 4;
			esp_3483->t0000 = ebx_3479;
			esp_3483->dwFFFFFFFC = eax_3480;
			esp_3483->tFFFFFFF8 = esi_1003;
			esp_3483->dwFFFFFFF4 = ecx_3482;
			esp_3483->t0014 = ebx_3479;
			esp_3483->dw0028 = eax_3480;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg16 = <invalid>;
			word32 eax_3496 = fn0070BCC0(dwArg04, dwArg08, stackArg16);
			word32 v82_3502 = (word32) *esi_1003 - 1;
			*esi_1003 = v82_3502;
			esp_3483->dw001C = eax_3496;
			ebp_1059 = (word32) ebp_1059 - 0x0C;
			esp_1012 = (struct Eq_98733 *) ((const char *) &esp_3483->t0000 + 4);
			if (v82_3502 == 0x00)
			{
				struct Eq_104942 * edx_3507 = *((word32) esi_1003 + 4);
				<anonymous> * eax_3508 = edx_3507->ptr0018;
				esp_3483->t0000 = esi_1003;
				word32 esp_3511;
				word32 ecx_3513;
				eax_3508();
				esp_1012 = esp_3511 + 0x04;
			}
			struct Eq_104927 * eax_3521 = esp_1012[0x0C];
			word32 v84_3522 = eax_3521->dw0000 + ~0x00;
			eax_3521->dw0000 = v84_3522;
			if (v84_3522 == 0x00)
			{
				struct Eq_105069 * ecx_3526 = eax_3521->ptr0004;
				<anonymous> * edx_3527 = ecx_3526->ptr0018;
				esp_1012->dwFFFFFFFC = eax_3521;
				word32 esp_3535;
				word32 edx_3538;
				edx_3527();
				esp_1012 = esp_3535 + 0x04;
			}
			word32 v86_3545 = (word32) *ebx_3479 - 1;
			*ebx_3479 = v86_3545;
			if (v86_3545 == 0x00)
			{
				Eq_3 eax_3549 = *((word32) ebx_3479 + 4);
				<anonymous> * ecx_3550 = *((word32) eax_3549 + 24);
				esp_1012->dwFFFFFFFC = (word32) ebx_3479;
				word32 esp_3558;
				word32 ecx_3560;
				word32 edx_3561;
				ecx_3550();
				esp_1012 = esp_3558 + 0x04;
			}
			goto l00708EE4;
		case 0x55:
			struct Eq_93111 * eax_3246 = *((word32) ebp_1059 - 4);
			struct Eq_100627 * ecx_3247 = esp_11188->dw0070;
			esp_11188->dw001C = 0x40;
			ebx_1517 = esp_11188->dw001C;
			esp_11188->ptr002C = (struct Eq_179984 *) eax_3246;
			ecx_3247->ptr0024 = ebp_1059 - 0x04;
l0070B27A:
			struct Eq_93361 * edi_3257 = esp_1012->dw0028;
			struct Eq_104919 * esp_3260 = (const char *) &esp_1012->t0000 + 4;
			if (edi_3257->dw0014 != 0x00)
			{
				Eq_3 esi_3275;
				struct Eq_104919 * esp_3291;
				Eq_3 eax_3262 = edi_3257->t001C;
				if (eax_3262 == 0x00)
				{
l0070B2BA:
					esp_3291 = esp_3260;
					esi_3275 = esp_3260->t0028;
					goto l0070B2BE;
				}
				if (ebx_1517 != 0x08 && ebx_1517 != 0x40)
				{
					if (ebx_1517 == 0x02)
					{
						esp_3260->tFFFFFFFC.u0 = 0x00;
						Eq_3 edx_3332 = edi_3257->t0024;
						Eq_3 edi_3333 = esp_3260->t006C;
						esp_3260->tFFFFFFF8.u0 = 0x03;
						esp_3260->tFFFFFFF4 = edx_3332;
						esp_3260->tFFFFFFF0 = eax_3262;
						fn007086B0(edi_3333, esp_3260->tFFFFFFF0, esp_3260->tFFFFFFF4, esp_3260->tFFFFFFF8, esp_3260->tFFFFFFFC);
						edi_3257 = esp_3260->ptr0024;
					}
					goto l0070B2BA;
				}
				esi_3275 = esp_3260->t0028;
				esp_3260->tFFFFFFFC = edi_3257->t0024;
				esp_3260->tFFFFFFF8 = eax_3262;
				esp_3291 = esp_3260;
				if (fn007073E0(esp_3260->t006C, esi_3275, 0x03, esp_3260->tFFFFFFF8, esp_3260->tFFFFFFFC) != 0x00)
				{
					if (esi_3275 != 0x00)
					{
						word32 v87_3298 = (word32) *esi_3275.u0 - 1;
						*esi_3275.u0 = v87_3298;
						if (v87_3298 == 0x00)
						{
							Eq_3 edx_3302 = *((word64) esi_3275.u0 + 4);
							<anonymous> * eax_3303 = *((word32) edx_3302 + 24);
							esp_3260->tFFFFFFFC = esi_3275;
							word32 esp_3312;
							word32 ecx_3314;
							eax_3303();
							esp_3291 = esp_3312 + 0x04;
						}
					}
					esp_3291->dw0018 = 0x02;
					ebx_1517 = esp_3291->dw0018;
					esp_3291->t0028.u0 = 0x00;
					esi_3275.u0 = 0x00;
				}
l0070B2BE:
				Eq_3 eax_3357 = edi_3257->t0018;
				if (eax_3357 != 0x00)
				{
					if (ebx_1517 == 0x02)
					{
						Eq_3 edx_3414 = esp_3291->ptr0024->t0020;
						Eq_3 edi_3415 = esp_3291->t006C;
						struct Eq_105207 * esp_3416 = esp_3291 - 4;
						esp_3416->t0000.u0 = 0x00;
						esp_3416->tFFFFFFFC.u0 = 0x03;
						esp_3416->tFFFFFFF8 = edx_3414;
						esp_3416->tFFFFFFF4 = eax_3357;
						fn007086B0(edi_3415, esp_3416->tFFFFFFF4, esp_3416->tFFFFFFF8, esp_3416->tFFFFFFFC, esp_3416->t0000);
						edi_3257 = esp_3416->ptr0028;
					}
					else
					{
						struct Eq_105167 * esp_3367 = esp_3291 - 4;
						esp_3367->t0000 = edi_3257->t0020;
						esp_3367->tFFFFFFFC = eax_3357;
						struct Eq_105179 * esp_3382 = (const char *) &esp_3367->t0000 + 4;
						if (fn007073E0(esp_3367->t0070, esi_3275, 0x03, esp_3367->tFFFFFFFC, esp_3367->t0000) != 0x00)
						{
							if (esi_3275 != 0x00)
							{
								word32 v88_3389 = (word32) *esi_3275.u0 - 1;
								*esi_3275.u0 = v88_3389;
								if (v88_3389 == 0x00)
								{
									Eq_3 edx_3393 = *((word64) esi_3275.u0 + 4);
									<anonymous> * eax_3394 = *((word32) edx_3393 + 24);
									esp_3367->t0000 = esi_3275;
									word32 esp_3403;
									word32 ecx_3405;
									eax_3394();
									esp_3382 = esp_3403 + 0x04;
								}
							}
							esp_3382->dw0028 = 0x00;
						}
					}
				}
			}
			if (edi_3257->ptr0008->ptr002C != null)
				fn00706F10(edi_3257);
			goto l0070B382;
		case 0x56:
			Eq_3 edi_3197 = esp_11188->dw0070;
			union Eq_3 * esp_3198 = esp_11188 - 4;
			*esp_3198 = (union Eq_3 *) edi_3197;
			Eq_3 eax_3200 = fn0073B280(*esp_3198);
			esi_1003 = eax_3200;
			esp_1012 = (struct Eq_98733 *) ((const char *) esp_3198 + 4);
			while (ebp_1059 - *((word32) edi_3197 + 32) >> 0x02 > *((word32) eax_3200 + 8))
			{
				struct Eq_104873 * eax_3214 = *((word32) ebp_1059 - 4);
				word32 v81_3216 = eax_3214->dw0000 + ~0x00;
				eax_3214->dw0000 = v81_3216;
				ebp_1059 -= 0x04;
				if (v81_3216 == 0x00)
				{
					struct Eq_104900 * ecx_3220 = eax_3214->ptr0004;
					<anonymous> * edx_3221 = ecx_3220->ptr0018;
					esp_1012->dwFFFFFFFC = eax_3214;
					word32 esp_3229;
					word32 edx_3232;
					edx_3221();
					esp_1012 = esp_3229 + 0x04;
				}
			}
			goto l00708F23;
		case 0x57:
			esi_1003 = *((word32) ebp_1059 - 4);
			Eq_3 eax_3020 = *((word32) esi_1003 + 4);
			ebp_1059 -= 0x04;
			if (eax_3020 == 10610664)
			{
l0070A24B:
				Eq_104676 eax_3041 = *((word32) esi_1003 + 8);
				esp_11188->dw001C = (word32) eax_3041;
				esp_1012 = esp_11188;
				if (eax_3041 == 0x08 || eax_3041 == 0x20)
				{
					esp_11188->ptr002C = (struct Eq_179984 *) *((word32) ebp_1059 - 4);
					ebp_1059 -= 0x04;
				}
				goto l0070A266;
			}
			struct Eq_104685 * esp_3024 = esp_11188 - 4;
			esp_3024->t0000.u0 = 10610664;
			esp_3024->tFFFFFFFC = eax_3020;
			word32 edx_11091;
			word32 ecx_11090;
			if (fn006D5670(esp_3024->tFFFFFFFC, esp_3024->t0000, out ecx_11090, out edx_11091) != 0x00)
				goto l0070A24B;
			Eq_3 eax_3056 = *((word32) esi_1003 + 4);
			if (eax_3056 != 10611048)
			{
				if (eax_3056 != 0x00A15380)
				{
					esp_3024->t0000.u0 = 0x00A15380;
					esp_3024->tFFFFFFFC = eax_3056;
					word32 ecx_11096;
					word32 edx_11097;
					if (fn006D5670(esp_3024->tFFFFFFFC, esp_3024->t0000, out ecx_11096, out edx_11097) != 0x00)
						goto l0070A1C9;
					goto l0070A1DD;
				}
l0070A1C9:
				struct Eq_104759 * esp_3079 = esp_11188 - 4;
				esp_3079->t0000 = g_tA169F0;
				esp_3079->tFFFFFFFC = esi_1003;
				word32 edx_11095;
				word32 ecx_11094;
				if (fn006D5670(esp_3079->tFFFFFFFC, esp_3079->t0000, out ecx_11094, out edx_11095) == 0x00)
				{
l0070A1DD:
					Eq_3 eax_3097 = *((word32) esi_1003 + 4);
					if (eax_3097 != 0x00A1B450)
					{
						struct Eq_104811 * esp_3101 = esp_11188 - 4;
						esp_3101->t0000.u0 = 0x00A1B450;
						esp_3101->tFFFFFFFC = eax_3097;
						esp_1012 = (struct Eq_98733 *) ((const char *) &esp_3101->t0000 + 4);
						word32 ecx_11098;
						word32 edx_11099;
						if (fn006D5670(esp_3101->tFFFFFFFC, esp_3101->t0000, out ecx_11098, out edx_11099) == 0x00)
						{
							if (esi_1003 != 0x00A163B8)
							{
								Eq_3 edx_3147 = g_tA18720;
								esp_3101->t0000.u0 = 9272492;
								esp_3101->tFFFFFFFC = edx_3147;
								// Failed to bind call argument.
								// Please report this issue at https://github.com/uxmal/reko
								Eq_3 stackArg4 = <invalid>;
								word32 ecx_11101;
								word32 edx_11102;
								fn006E0F80(stackArg4, dwArg04, out ecx_11101, out edx_11102);
								esp_3101->dw0020 = 0x02;
								esp_1012 = (struct Eq_98733 *) ((const char *) &esp_3101->t0000 + 4);
							}
							goto l0070A266;
						}
					}
				}
			}
			word32 eax_3120 = *((word32) ebp_1059 - 4);
			struct Eq_104719 * esp_3126 = esp_11188 - 4;
			esp_3126->t0000 = *((word32) ebp_1059 - 8);
			esp_3126->dwFFFFFFFC = eax_3120;
			esp_3126->tFFFFFFF8 = esi_1003;
			esp_3126->dw0014 = eax_3120;
			word32 ecx_11092;
			word32 edx_11093;
			fn006E0E00(esp_3126->t0000, out ecx_11092, out edx_11093);
			esp_3126->dw0020 = 0x04;
			ebp_1059 -= 0x08;
			ebx_1517 = esp_3126->dw0020;
			esp_1012 = (struct Eq_98733 *) ((const char *) &esp_3126->t0000 + 4);
			goto l0070B019;
		case 88:
			esi_1003 = *((word32) ebp_1059 - 0x0C);
			Eq_3 eax_2958 = *((word32) ebp_1059 - 4);
			struct Eq_98294 * ebx_2959 = *((word32) ebp_1059 - 8);
			struct Eq_100696 * esp_2960 = esp_11188 - 4;
			esp_2960->t0000 = esi_1003;
			esp_2960->tFFFFFFFC = eax_2958;
			esp_2960->t0028 = eax_2958;
			esp_2960->t0014 = esi_1003;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg4 = <invalid>;
			Eq_3 eax_2969 = fn00708C10(ebx_2959, stackArg4);
			ebp_1059 += ~0x07;
			Eq_3 eax_2975 = esp_2960->t0028;
			*((word32) ebp_1059 - 4) = eax_2969;
			word32 v80_2978 = (word32) *eax_2975 - 1;
			*eax_2975 = v80_2978;
			esp_2960->t0018 = eax_2969;
			edi_1088 = eax_2969;
			esp_1012 = (struct Eq_98733 *) ((const char *) &esp_2960->t0000 + 4);
			if (v80_2978 == 0x00)
			{
				struct Eq_104661 * edx_2983 = *((word32) eax_2975 + 4);
				esp_2960->t0000 = eax_2975;
				<anonymous> * eax_2986 = edx_2983->ptr0018;
				word32 esp_2987;
				word32 ecx_2989;
				eax_2986();
				esp_1012 = esp_2987 + 0x04;
			}
			word32 v89_2997 = ebx_2959->dw0000 + ~0x00;
			ebx_2959->dw0000 = v89_2997;
			if (v89_2997 == 0x00)
			{
				Eq_3 ecx_3001 = ebx_2959->t0004;
				<anonymous> * edx_3002 = *((word32) ecx_3001 + 24);
				esp_1012->dwFFFFFFFC = ebx_2959;
				word32 esp_3011;
				word32 edx_3014;
				edx_3002();
				esp_1012 = esp_3011 + 0x04;
			}
l0070A266:
			word32 v85_3170 = (word32) *esi_1003 - 1;
			*esi_1003 = v85_3170;
			if (v85_3170 == 0x00)
			{
				struct Eq_105084 * eax_3174 = *((word32) esi_1003 + 4);
				<anonymous> * ecx_3175 = eax_3174->ptr0018;
				esp_1012->dwFFFFFFFC = (word32) esi_1003;
				word32 esp_3189;
				word32 ecx_3191;
				word32 edx_3192;
				ecx_3175();
				esp_1012 = esp_3189 + 0x04;
			}
			goto l00708EE4;
		case 0x59:
			Eq_3 eax_2883 = esp_11188->dw0070;
			Eq_3 edx_2884 = esp_11188[16];
			edi_1088 = *((word32) eax_2883 + 28);
			Eq_3 ebx_2886 = *((word32) edx_2884 + (ebx_2263 * 0x04 + 0x0C));
			esi_1003 = *((word32) ebp_1059 - 4);
			esp_11188->dw0010 = (word32) ebx_2886;
			esp_11188->dw0014 = (word32) edi_1088;
			ebp_1059 -= 0x04;
			if (edi_1088 == 0x00)
			{
				struct Eq_104560 * esp_2894 = esp_11188 - 4;
				esp_2894->t0000 = ebx_2886;
				word32 edx_11079;
				esp_2894->t0000 = (word32) fn006DDDB0(eax_2883, edx_2884, ebx_2886, esi_1003, edi_1088, es, ds, esp_2894->t0000, out edx_11079, out edi_1088) + 20;
				Eq_3 eax_2911 = g_tA18720;
				esp_2894->dwFFFFFFFC = 0x008D7C8C;
				esp_2894->tFFFFFFF8 = eax_2911;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_3 stackArg4 = <invalid>;
				word32 ecx_11081;
				word32 edx_11082;
				fn006E15D0(stackArg4, dwArg04, out ecx_11081, out edx_11082);
				esp_1012 = (struct Eq_98733 *) ((const char *) &esp_2894->t0000 + 8);
				goto l00708EE4;
			}
			else
			{
				struct Eq_104598 * esp_2925 = esp_11188 - 4;
				esp_2925->t0000 = esi_1003;
				esp_2925->tFFFFFFFC = ebx_2886;
				esp_2925->tFFFFFFF8 = edi_1088;
				if (*((word64) edi_1088.u0 + 4) == 0x00A1D1B8)
				{
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_3 stackArg4 = <invalid>;
					word32 ecx_11086;
					word32 edi_11089;
					word32 ebx_11088;
					word32 edx_11087;
					eax_2933 = fn006FBD90(stackArg4, dwArg04, dwArg08, out ecx_11086, out edx_11087, out ebx_11088, out edi_11089);
				}
				else
				{
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_3 stackArg4 = <invalid>;
					word32 ecx_11084;
					eax_2933 = fn00704300(stackArg4, dwArg04, dwArg08, out ecx_11084);
				}
				struct Eq_104631 * esp_2944 = esp_11188 - 0x0C;
				word32 v83_2948 = (word32) *esi_1003 - 1;
				*esi_1003 = v83_2948;
				esp_2944->t0024 = eax_2933;
				esp_1012 = (struct Eq_98733 *) ((const char *) &esp_2944->t0008 + 4);
				if (v83_2948 != 0x00)
					goto l00709C2E;
				ecx_2954 = (struct Eq_99434 *) *((word32) esi_1003 + 4);
				esp_2944->t0008 = esi_1003;
l00709C26:
				word32 ecx_5532;
				word32 edx_5533;
				ecx_2954[8]();
				goto l00709C2B;
			}
		case 0x5A:
			Eq_3 edx_2799 = esp_11188->dw0070;
			edi_1088 = *((word32) edx_2799 + 28);
			ebx_1685 = *((word32) esp_11188[16].t0000 + (ebx_2263 * 0x04 + 0x0C));
			esp_11188->dw0010 = (word32) ebx_1685;
			esp_11188->dw0014 = (word32) edi_1088;
			struct Eq_100792 * esp_2807 = esp_11188 - 4;
			esp_2807->t0000 = ebx_1685;
			if (edi_1088 == 0x00)
			{
				word32 edx_11069;
				Eq_3 eax_2810 = fn006DDDB0(eax_4033, edx_2799, ebx_1685, esi_1003, edi_1088, es, ds, esp_2807->t0000, out edx_11069, out edi_1088);
				Eq_3 ecx_2821 = g_tA18720;
				esp_2807->t0000 = (word32) eax_2810 + 20;
				esp_2807->tFFFFFFFC.u0 = 9272400;
				esp_2807->tFFFFFFF8 = ecx_2821;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_3 stackArg4 = <invalid>;
				word32 ecx_11071;
				word32 edx_11072;
				fn006E15D0(stackArg4, dwArg04, out ecx_11071, out edx_11072);
				esp_1012 = (struct Eq_98733 *) ((const char *) &esp_2807->t0000 + 8);
				goto l00708EE4;
			}
			else
			{
				esp_2807->tFFFFFFFC = edi_1088;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_3 stackArg4 = <invalid>;
				word32 ecx_11074;
				Eq_3 eax_2841 = fn00704400(stackArg4, dwArg04, out ecx_11074);
				esp_2807->t001C = eax_2841;
				esp_1012 = (struct Eq_98733 *) ((const char *) &esp_2807->t0000 + 4);
				if (eax_2841 != 0x00)
					goto l0070A374;
				goto l00708EE4;
			}
		case 0x5B:
			goto l0070AA3F;
		case 0x5C:
			esi_1003 = esp_11188->ptr0020;
l00709422:
			struct Eq_106312 * eax_4630 = *((word32) ebp_1059 - 4);
			struct Eq_106316 * ecx_4631 = eax_4630->ptr0004;
			<anonymous> * edx_4632 = ecx_4631->ptr0070;
			esp_1012->dwFFFFFFFC = eax_4630;
			struct Eq_104299 * esp_4641;
			Eq_3 eax_4642;
			word32 edx_4644;
			edx_4632();
			esp_4641->t0018 = eax_4642;
			edi_1088 = eax_4642;
			esp_1012 = (struct Eq_98733 *) ((const char *) &esp_4641->t0000 + 4);
			if (eax_4642 == 0x00)
			{
				if (fn006E0FC0() != 0x00)
				{
					esp_4641->t0000 = g_tA16D00;
					esp_1012 = (struct Eq_98733 *) ((const char *) &esp_4641->t0000 + 4);
					word32 ecx_11075;
					word32 edx_11076;
					if (fn006E1110(out ecx_11075, out edx_11076) == 0x00)
						goto l00708EE4;
					word32 ecx_11077;
					word32 edx_11078;
					fn006E1160(out ecx_11077, out edx_11078);
				}
				Eq_3 eax_4679 = *((word32) ebp_1059 - 4);
				word32 v90_4681 = (word32) *eax_4679 - 1;
				*eax_4679 = v90_4681;
				esp_4641->t0018 = eax_4679;
				esp_1012 = (struct Eq_98733 *) ((const char *) &esp_4641->t0000 + 4);
				ebp_1059 -= 0x04;
				if (v90_4681 == 0x00)
				{
					Eq_3 edx_4687 = *((word32) eax_4679 + 4);
					esp_4641->t0000 = eax_4679;
					<anonymous> * eax_4690 = *((word32) edx_4687 + 24);
					word32 esp_4695;
					word32 ecx_4697;
					eax_4690();
					esp_1012 = esp_4695 + 0x04;
				}
				goto l00708F1D;
			}
			*ebp_1059 = eax_4642;
			ebp_1059 += 0x04;
			if (*esi_1003 == 0x7D)
			{
				ebx_2263 = ((word32) *((word32) esi_1003 + 2) << 0x08) + (word32) (*((word32) esi_1003 + 1));
				esi_1003 = (word32) esi_1003 + 3;
				esp_4641->t0024 = esi_1003;
				goto l00709462;
			}
			if (*esi_1003 != 0x5C)
				goto l00708F23;
			ebx_2263 = ((word32) *((word32) esi_1003 + 2) << 0x08) + (word32) (*((word32) esi_1003 + 1));
			esp_4641->t0024 = (word32) esi_1003 + 3;
l0070AA3F:
			esi_1003 = *((word32) ebp_1059 - 4);
			word32 eax_4723 = *((word32) esi_1003 + 4);
			ebp_1059 -= 0x04;
			if (eax_4723 != 0x00A16588 || *((word32) esi_1003 + 8) != ebx_2263)
			{
				if (eax_4723 == 0x00A1BAF0 && *((word32) esi_1003 + 8) == ebx_2263)
				{
					ptr32 ecx_4767 = *((word32) esi_1003 + 0x0C);
					for (; ebx_2263 != 0x00; --ebx_2263)
					{
						word32 * eax_4772 = (ecx_4767 - 0x04)[ebx_2263];
						++*eax_4772;
						*ebp_1059 = eax_4772;
						esp_1012->dw0010 = eax_4772;
						ebp_1059 += 0x04;
					}
				}
				else
				{
					word32 ecx_4741 = ebp_1059 + ebx_2263 * 0x04;
					esp_1012->ptr0050 = (word32 *) ecx_4741;
					if (fn007072E0(ecx_4741, ebx_2263) != 0x00)
						ebp_1059 = esp_1012->ptr0050;
					else
						esp_1012->dw001C = 0x02;
				}
				goto l0070AACB;
			}
			else
			{
				for (; ebx_2263 != 0x00; --ebx_2263)
				{
					word32 * eax_4817 = *((word32) esi_1003 + (ebx_2263 * 0x04 + 8));
					++*eax_4817;
					*ebp_1059 = eax_4817;
					esp_1012->dw0010 = eax_4817;
					ebp_1059 += 0x04;
				}
				goto l0070A715;
			}
		case 0x5E:
			Eq_3 eax_2778 = *((word32) esp_11188[16].t0000 + (ebx_2263 * 0x04 + 0x0C));
			ebx_2779 = (struct Eq_99436 *) *((word32) ebp_1059 - 8);
			esi_1003 = *((word32) ebp_1059 - 4);
			struct Eq_100829 * esp_2781 = esp_11188 - 4;
			esp_2781->ptr0000 = ebx_2779;
			esp_2781->tFFFFFFFC = eax_2778;
			esp_2781->tFFFFFFF8 = esi_1003;
			esp_2781->t0014 = eax_2778;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg4 = <invalid>;
			ebp_1059 += ~0x07;
			word32 ecx_10953;
			word32 edx_10954;
			eax_2791 = fn006DE430(stackArg4, dwArg04, dwArg08, out ecx_10953, out edx_10954);
l00709D0E:
			word32 v77_4988 = (word32) *esi_1003 - 1;
			*esi_1003 = v77_4988;
			esp_11188[8] = (struct Eq_98733) eax_2791;
			esp_1012 = esp_11188;
			if (v77_4988 == 0x00)
			{
				struct Eq_104423 * eax_4995 = *((word32) esi_1003 + 4);
				<anonymous> * ecx_4996 = eax_4995->ptr0018;
				esp_11188->dwFFFFFFFC = (word32) esi_1003;
				word32 esp_5003;
				word32 ecx_5005;
				word32 edx_5006;
				ecx_4996();
				esp_1012 = esp_5003 + 0x04;
			}
			word32 v78_5013 = ebx_2779->dw0000 + ~0x00;
			ebx_2779->dw0000 = v78_5013;
			if (v78_5013 == 0x00)
			{
				struct Eq_104455 * edx_5017 = ebx_2779->dw0004;
				<anonymous> * eax_5018 = edx_5017->ptr0018;
				esp_1012->dwFFFFFFFC = ebx_2779;
				word32 ecx_5028;
				eax_5018();
l00709C2B:
				esp_1012 = esp_5026 + 0x04;
			}
			goto l00709C2E;
		case 0x5F:
			Eq_3 ebx_2757 = *((word32) esp_11188[16].t0000 + (ebx_2263 * 0x04 + 0x0C));
			esi_1003 = *((word32) ebp_1059 - 4);
			struct Eq_100865 * esp_2759 = esp_11188 - 4;
			esp_2759->dw0000 = 0x00;
			esp_2759->tFFFFFFFC = ebx_2757;
			esp_2759->tFFFFFFF8 = esi_1003;
			esp_2759->t0014 = ebx_2757;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg4 = <invalid>;
			word32 ecx_10956;
			word32 edx_10957;
			esp_2759->t001C = fn006DE430(stackArg4, dwArg04, dwArg08, out ecx_10956, out edx_10957);
			ebp_1059 -= 0x04;
			esp_1012 = (struct Eq_98733 *) (&esp_2759->dw0000 + 1);
l0070AACB:
			word32 v76_4787 = (word32) *esi_1003 - 1;
			*esi_1003 = v76_4787;
			if (v76_4787 == 0x00)
			{
				struct Eq_104397 * edx_4791 = *((word32) esi_1003 + 4);
				<anonymous> * eax_4792 = edx_4791->ptr0018;
				esp_1012->dwFFFFFFFC = (word32) esi_1003;
				word32 esp_4802;
				word32 ecx_4804;
				eax_4792();
				esp_1012 = esp_4802 + 0x04;
			}
			goto l00708EE4;
		case 0x60:
			esi_1003 = *((word32) ebp_1059 - 4);
			Eq_3 ebx_2715 = *((word32) esp_11188[16].t0000 + (ebx_2263 * 0x04 + 0x0C));
			word32 eax_2717 = esp_11188->dw0070 + 0x18;
			struct Eq_100914 * esp_2720 = esp_11188 - 4;
			esp_2720->t0000 = esi_1003;
			esp_2720->tFFFFFFFC = ebx_2715;
			esp_2720->dwFFFFFFF8 = eax_2717;
			esp_2720->t0014 = ebx_2715;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg4 = <invalid>;
			word32 ebx_10961;
			word32 edi_10962;
			word32 ecx_10959;
			word32 edx_10960;
			Eq_3 eax_2728 = fn006FBD90(stackArg4, dwArg04, dwArg08, out ecx_10959, out edx_10960, out ebx_10961, out edi_10962);
			word32 v74_2734 = (word32) *esi_1003 - 1;
			*esi_1003 = v74_2734;
			esp_2720->t001C = eax_2728;
			ebp_1059 -= 0x04;
			esp_1012 = (struct Eq_98733 *) ((const char *) &esp_2720->t0000 + 4);
			if (v74_2734 == 0x00)
			{
				struct Eq_104226 * ecx_2740 = *((word32) esi_1003 + 4);
				<anonymous> * edx_2741 = ecx_2740->ptr0018;
				esp_2720->t0000 = esi_1003;
				word32 esp_2744;
				word32 edx_2747;
				edx_2741();
				esp_1012 = esp_2744 + 0x04;
			}
			if (eax_2728 != 0x00)
				goto l00708EE4;
			goto l00708F23;
		case 0x61:
			ebx_1685 = *((word32) esp_11188[16].t0000 + (ebx_2263 * 0x04 + 0x0C));
			word32 edx_2694 = esp_11188->dw0070 + 0x18;
			struct Eq_99441 * esp_2695 = esp_11188 - 4;
			esp_2695->dw0000 = (word32) ebx_1685;
			esp_2695->dwFFFFFFFC = edx_2694;
			esp_2695->t0014 = ebx_1685;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg4 = <invalid>;
			int32 eax_2701 = fn006FBE60(stackArg4, dwArg04);
			esp_2695->dw001C = eax_2701;
			esp_1012 = (struct Eq_98733 *) (&esp_2695->dw0000 + 1);
			if (eax_2701 == 0x00)
				goto l00708EE4;
			esp_2695->dw0000 = (word32) 0x008D7C2C;
			esp_1782 = esp_2695;
			goto l0070A379;
		case 0x62:
			if (ebx_2263 == 0x02)
			{
				edi_1088 = *((word32) ebp_1059 - 4);
				*edi_1088.u0 = (word32) *edi_1088.u0 + 1;
				Eq_3 eax_2682 = *((word32) ebp_1059 - 8);
				*eax_2682 = (word32) *eax_2682 + 1;
				esp_11188->dw0014 = (word32) edi_1088;
				esp_11188->dw0010 = (word32) eax_2682;
				ebp_1059 += 0x08;
				*((word32) ebp_1059 - 4) = edi_1088;
				*((word32) ebp_1059 - 8) = eax_2682;
			}
			else
			{
				if (ebx_2263 != 0x03)
				{
					union Eq_3 * esp_2654 = esp_11188 - 4;
					*esp_2654 = (union Eq_3 *) 9272612;
					fn006E86F0(*esp_2654);
					esp_1012 = (struct Eq_98733 *) ((const char *) esp_2654 + 4);
					goto l00708EE4;
				}
				edi_1088 = *((word32) ebp_1059 - 4);
				*edi_1088.u0 = (word32) *edi_1088.u0 + 1;
				Eq_3 ecx_2666 = *((word32) ebp_1059 - 8);
				*ecx_2666 = (word32) *ecx_2666 + 1;
				word32 * eax_2669 = *((word32) ebp_1059 - 0x0C);
				++*eax_2669;
				esp_11188->dw0014 = (word32) edi_1088;
				esp_11188->dw0010 = (word32) ecx_2666;
				ebp_1059 += 0x0C;
				*((word32) ebp_1059 - 4) = edi_1088;
				*((word32) ebp_1059 - 8) = ecx_2666;
				*((word32) ebp_1059 - 0x0C) = eax_2669;
			}
			break;
		case 99:
			edi_1088 = esp_11188->ptr0068->a000C[ebx_2263];
			*edi_1088 = (word32) *edi_1088 + 1;
			*ebp_1059 = edi_1088;
			esp_11188->dw0014 = (word32) edi_1088;
			ebp_1059 += 0x04;
			break;
		case 100:
			esi_1003 = esp_11188->dw0070;
			ebx_1685 = *((word32) esp_11188[16].t0000 + (ebx_2263 * 0x04 + 0x0C));
			Eq_3 eax_2461 = *((word32) esi_1003 + 28);
			esp_11188->dw0010 = (word32) ebx_1685;
			struct Eq_101041 * esp_2465 = esp_11188 - 4;
			esp_2465->t0000 = ebx_1685;
			if (eax_2461 == 0x00)
			{
				word32 edx_11049;
				Eq_3 eax_2614 = fn006DDDB0(eax_2461, edx_2591, ebx_1685, esi_1003, edi_1088, es, ds, esp_2465->t0000, out edx_11049, out edi_1088);
				Eq_3 edx_2625 = g_tA18720;
				esp_2465->t0000 = (word32) eax_2614 + 20;
				esp_2465->tFFFFFFFC.u0 = 9272336;
				esp_2465->tFFFFFFF8 = edx_2625;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_3 stackArg4 = <invalid>;
				word32 ecx_11051;
				word32 edx_11052;
				fn006E15D0(stackArg4, dwArg04, out ecx_11051, out edx_11052);
				esp_1012 = (struct Eq_98733 *) ((const char *) &esp_2465->t0000 + 8);
				goto l00708EE4;
			}
			esp_2465->tFFFFFFFC = eax_2461;
			if (*((word32) eax_2461 + 4) == 0x00A1D1B8)
			{
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_3 stackArg4 = <invalid>;
				word32 ecx_11057;
				word32 edx_11058;
				Eq_3 eax_2509 = fn006FBCC0(stackArg4, dwArg04, out ecx_11057, out edx_11058);
				esp_2465->t0018 = eax_2509;
				edi_1088 = eax_2509;
				if (eax_2509 == 0x00)
					goto l0070A514;
				*eax_2509 = (word32) *eax_2509 + 1;
			}
			else
			{
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_3 stackArg4 = <invalid>;
				word32 ecx_11054;
				word32 edx_11055;
				Eq_3 eax_2473 = fn00704220(stackArg4, dwArg04, out ecx_11054, out edx_11055);
				esp_2465->t0018 = eax_2473;
				edi_1088 = eax_2473;
				esp_1012 = (struct Eq_98733 *) ((const char *) &esp_2465->t0000 + 4);
				if (eax_2473 != 0x00)
					goto l0070A5D1;
				if (fn006E0FC0() != 0x00)
				{
					esp_2465->t0000 = g_tA17E28;
					esp_1012 = (struct Eq_98733 *) ((const char *) &esp_2465->t0000 + 4);
					word32 edx_11066;
					word32 ecx_11065;
					if (fn006E1110(out ecx_11065, out edx_11066) == 0x00)
						goto l00708EE4;
					word32 ecx_11067;
					word32 edx_11068;
					fn006E1160(out ecx_11067, out edx_11068);
				}
			}
			esp_1012 = esp_11188;
			if (edi_1088 != 0x00)
				goto l0070A5D1;
l0070A514:
			word32 ecx_2531 = *((word32) esi_1003 + 24);
			struct Eq_104047 * esp_2534 = esp_11188 - 4;
			esp_2534->t0000 = ebx_1685;
			esp_2534->dwFFFFFFFC = ecx_2531;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg4 = <invalid>;
			word32 ecx_11060;
			word32 edx_11061;
			Eq_3 eax_2548 = fn006FBCC0(stackArg4, dwArg04, out ecx_11060, out edx_11061);
			esp_2534->t0018 = eax_2548;
			edi_1088 = eax_2548;
			esp_1012 = (struct Eq_98733 *) ((const char *) &esp_2534->t0000 + 4);
			if (eax_2548 != 0x00)
				goto l0070A5CE;
			word32 edx_2559 = *((word32) esi_1003 + 20);
			esp_2534->t0000 = ebx_1685;
			esp_2534->dwFFFFFFFC = edx_2559;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg4 = <invalid>;
			word32 edx_11064;
			word32 ecx_11063;
			Eq_3 eax_2565 = fn006FBCC0(stackArg4, dwArg04, out ecx_11063, out edx_11064);
			esp_2534->t0018 = eax_2565;
			edi_1088 = eax_2565;
			esp_1012 = (struct Eq_98733 *) ((const char *) &esp_2534->t0000 + 4);
			if (eax_2565 != 0x00)
				goto l0070A5CE;
l0070A374:
			esp_1782 = esp_11188 - 4;
			esp_1782->dw0000 = 9272428;
			goto l0070A379;
		case 101:
			struct Eq_101049 * esp_2420 = esp_11188 - 4;
			esp_2420->t0000 = ebx_2263;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg4 = <invalid>;
			word32 ecx_10965;
			word32 edx_10966;
			Eq_3 eax_2423 = fn006DFD20(stackArg4, out ecx_10965, out edx_10966);
			esp_2420->t0018 = eax_2423;
			edi_1088 = eax_2423;
			esp_1012 = (struct Eq_98733 *) ((const char *) &esp_2420->t0000 + 4);
			if (eax_2423 == 0x00)
				goto l00708EE4;
			Eq_103901 ebx_2434 = ebx_2263 - 0x01;
			if (ebx_2434 >= 0x00)
			{
				word32 * eax_2437 = (word32) eax_2423 + 0x0C + ebx_2434 * 0x04;
				do
				{
					word32 ecx_2440 = *((word32) ebp_1059 - 4);
					*eax_2437 = ecx_2440;
					esp_2420->dw0014 = ecx_2440;
					ebp_1059 -= 0x04;
					--ebx_2434;
					eax_2437 -= 0x04;
				} while (ebx_2434 >= 0x00);
			}
			*ebp_1059 = eax_2423;
			ebp_1059 += 0x04;
			goto l00708F23;
		case 0x66:
			struct Eq_101070 * esp_2384 = esp_11188 - 4;
			esp_2384->t0000 = ebx_2263;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg4 = <invalid>;
			word32 edx_10968;
			Eq_3 eax_2387 = fn006F2650(stackArg4, out edx_10968);
			esp_2384->t0018 = eax_2387;
			edi_1088 = eax_2387;
			esp_1012 = (struct Eq_98733 *) ((const char *) &esp_2384->t0000 + 4);
			if (eax_2387 == 0x00)
				goto l00708EE4;
			Eq_103870 ebx_2398 = ebx_2263 - 0x01;
			while (ebx_2398 >= 0x00)
			{
				Eq_3 eax_2404 = *((word32) ebp_1059 - 4);
				--ebx_2398;
				*((word32) *((word32) eax_2387 + 0x0C) + (ebx_2398 * 0x04 + 4)) = eax_2404;
				esp_2384->t0014 = eax_2404;
				ebp_1059 -= 0x04;
			}
			*ebp_1059 = eax_2387;
			ebp_1059 += 0x04;
			goto l00708F23;
		case 0x67:
			word32 ecx_10969;
			word32 edx_10970;
			Eq_3 eax_2374 = fn006FDCC0(out ecx_10969, out edx_10970);
			*ebp_1059 = eax_2374;
			esp_11188->dw0014 = (word32) eax_2374;
			esp_1012 = esp_11188;
			edi_1088 = eax_2374;
			ebp_1059 += 0x04;
			goto l007094E6;
		case 0x68:
			Eq_3 ebx_2343 = *((word32) esp_11188[16].t0000 + (ebx_2263 * 0x04 + 0x0C));
			esi_1003 = *((word32) ebp_1059 - 4);
			struct Eq_101116 * esp_2345 = esp_11188 - 4;
			esp_2345->t0000 = ebx_2343;
			esp_2345->tFFFFFFFC = esi_1003;
			esp_2345->t0014 = ebx_2343;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg4 = <invalid>;
			word32 edx_10973;
			word32 ecx_10972;
			Eq_3 eax_2351 = fn006DE330(stackArg4, dwArg04, out ecx_10972, out edx_10973);
			word32 v63_2357 = (word32) *esi_1003 - 1;
			*esi_1003 = v63_2357;
			esp_2345->t0018 = eax_2351;
			esp_1012 = (struct Eq_98733 *) ((const char *) &esp_2345->t0000 + 4);
			edi_1088 = eax_2351;
			if (v63_2357 != 0x00)
				goto l007094E3;
			struct Eq_103737 * ecx_2363 = *((word32) esi_1003 + 4);
			<anonymous> * edx_2364 = ecx_2363->ptr0018;
			esp_2345->t0000 = esi_1003;
			word32 edx_2370;
			edx_2364();
			goto l007094E0;
		case 0x69:
			esi_1003 = *((word32) ebp_1059 - 4);
			Eq_3 edx_2090 = *((word32) ebp_1059 - 8);
			esp_11188->dw0010 = (word32) esi_1003;
			esp_11188[0x0C] = (struct Eq_98733) edx_2090;
			ebp_1059 -= 0x04;
			if (*((word32) esi_1003 + 4) == 10610664 && *((word32) edx_2090 + 4) == 10610664)
			{
				int32 eax_2100 = *((word32) edx_2090 + 8);
				int32 ecx_2101 = *((word32) esi_1003 + 8);
				if (ebx_2263 > 0x09)
					goto l007092AD;
				uint32 eax_2135;
				switch (ebx_2263)
				{
				case 0x00:
					eax_2135 = (uint32) (int8) (eax_2100 < ecx_2101);
					break;
				case 0x01:
					eax_2135 = (uint32) (int8) (eax_2100 <= ecx_2101);
					break;
				case 0x02:
					eax_2135 = (uint32) (int8) (eax_2100 == ecx_2101);
					break;
				case 0x03:
					eax_2135 = (uint32) (int8) (eax_2100 != ecx_2101);
					break;
				case 0x04:
					eax_2135 = (uint32) (int8) (eax_2100 > ecx_2101);
					break;
				case 0x05:
					eax_2135 = (uint32) (int8) (eax_2100 >= ecx_2101);
					break;
				case 0x06:
				case 0x07:
					goto l007092AD;
				case 0x08:
					eax_2135 = (uint32) (int8) (edx_2090 == esi_1003);
					break;
				case 0x09:
					eax_2135 = (uint32) (int8) (edx_2090 != esi_1003);
					break;
				}
				edi_1088.u0 = 0x00A191E4;
				if (eax_2135 == 0x00)
					edi_1088.u0 = 0x00A191D8;
				*edi_1088 = (word32) *edi_1088 + 1;
			}
			else
			{
l007092AD:
				Eq_3 eax_2121 = fn00708130(esp_11188->dw0010, esp_11188[0x0C], ebx_2263);
				esi_1003 = esp_11188->dw0010;
				edx_2090 = esp_11188[0x0C];
				edi_1088 = eax_2121;
			}
			word32 v59_2191 = (word32) *edx_2090 - 1;
			*edx_2090 = v59_2191;
			esp_11188->dw0014 = (word32) edi_1088;
			esp_1012 = esp_11188;
			if (v59_2191 == 0x00)
			{
				struct Eq_103491 * eax_2200 = *((word32) edx_2090 + 4);
				<anonymous> * ecx_2201 = eax_2200->ptr0018;
				esp_11188->dwFFFFFFFC = (word32) edx_2090;
				word32 esp_2216;
				word32 ecx_2218;
				word32 edx_2219;
				ecx_2201();
				esp_1012 = esp_2216 + 0x04;
			}
			word32 v60_2226 = (word32) *esi_1003 - 1;
			*esi_1003 = v60_2226;
			if (v60_2226 == 0x00)
			{
				struct Eq_103596 * edx_2230 = *((word32) esi_1003 + 4);
				<anonymous> * eax_2231 = edx_2230->ptr0018;
				esp_1012->dwFFFFFFFC = (word32) esi_1003;
				word32 esp_2239;
				word32 ecx_2241;
				eax_2231();
				esp_1012 = esp_2239 + 0x04;
			}
			*((word32) ebp_1059 - 4) = edi_1088;
			if (edi_1088 == 0x00)
				goto l00708EE4;
			esi_1003 = esp_1012->ptr0020;
			Eq_103704 al_2255 = *esi_1003;
			if (al_2255 != 111)
			{
				if (al_2255 != 0x70)
					goto l00708F23;
				ebx_2263 = ((word32) *((word32) esi_1003 + 2) << 0x08) + (word32) (*((word32) esi_1003 + 1));
				esp_1012->ptr0020 = (word32) esi_1003 + 3;
				esi_1003 = (word32) esi_1003 + 3;
				goto l00709375;
			}
			else
			{
				ebx_2263 = ((word32) *((word32) esi_1003 + 2) << 0x08) + (word32) (*((word32) esi_1003 + 1));
				esp_1012->ptr0020 = (word32) esi_1003 + 3;
				esi_1003 = (word32) esi_1003 + 3;
				goto l00709342;
			}
		case 0x6A:
			esi_1003 = esp_11188->dw0070;
			Eq_3 edx_1820 = *((word32) esi_1003 + 20);
			Eq_3 ecx_1821 = *((word32) esp_11188[16].t0000 + (ebx_2263 * 0x04 + 0x0C));
			struct Eq_101188 * esp_1822 = esp_11188 - 4;
			esp_1822->t0000.u0 = 9264940;
			esp_1822->tFFFFFFFC = edx_1820;
			esp_1822->t0014 = ecx_1821;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg4 = <invalid>;
			word32 edi_10978;
			word32 ecx_10975;
			word32 edx_10976;
			word32 esi_10977;
			Eq_3 eax_1828 = fn006FD8B0(stackArg4, dwArg04, out ecx_10975, out edx_10976, out esi_10977, out edi_10978);
			esp_1822->t0018 = eax_1828;
			edi_1088 = eax_1828;
			if (eax_1828 == 0x00)
			{
				Eq_3 eax_2076 = g_tA16F8C;
				esp_1822->t0000.u0 = 9272240;
				esp_1822->tFFFFFFFC = eax_2076;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_3 stackArg4 = <invalid>;
				word32 ecx_11030;
				word32 edx_11031;
				fn006E0F80(stackArg4, dwArg04, out ecx_11030, out edx_11031);
				esp_1012 = (struct Eq_98733 *) ((const char *) &esp_1822->t0000 + 4);
				goto l00708EE4;
			}
			Eq_3 eax_1897;
			*eax_1828 = (word32) *eax_1828 + 1;
			Eq_3 eax_1841 = *((word32) ebp_1059 - 8);
			Eq_3 ebx_1842 = *((word32) ebp_1059 - 4);
			esp_1822->t0000 = eax_1841;
			esp_1822->t0028 = eax_1841;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg4 = <invalid>;
			ebp_1059 -= 0x04;
			word32 esi_11027;
			word32 edi_11028;
			word32 edx_11026;
			word32 ecx_11025;
			if (fn007051A0(eax_1828, stackArg4, out ecx_11025, out edx_11026, out esi_11027, out edi_11028) == ~0x00 && fn006E0FC0() == 0x00)
			{
				Eq_3 eax_1906 = *((word32) esi_1003 + 28);
				if (eax_1906 == 0x00)
					eax_1906.u0 = 0x00A163B8;
				word32 ecx_1913 = *((word32) esi_1003 + 24);
				Eq_3 edx_1915 = esp_1822->t0014;
				esp_1822->t0000 = ebx_1842;
				esp_1822->tFFFFFFFC = eax_1906;
				esp_1822->dwFFFFFFF8 = ecx_1913;
				esp_1822->tFFFFFFF4 = edx_1915;
				esp_1822->tFFFFFFF0.u0 = 0x04;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_3 stackArg4 = <invalid>;
				word32 esi_11035;
				word32 ecx_11033;
				word32 edx_11034;
				eax_1897 = fn006DFF80(stackArg4, out ecx_11033, out edx_11034, out esi_11035);
				esp_1822->t0014 = eax_1897;
				esi_1003 = eax_1897;
			}
			else
			{
				word32 eax_1863 = *((word32) esi_1003 + 28);
				if (eax_1863 == 0x00)
					eax_1863 = 0x00A163B8;
				Eq_3 edx_1873 = *((word32) esi_1003 + 24);
				esp_1822->t0000 = esp_1822->t0028;
				esp_1822->tFFFFFFFC = ebx_1842;
				esp_1822->dwFFFFFFF8 = eax_1863;
				Eq_3 eax_1883 = esp_1822->t0014;
				esp_1822->tFFFFFFF4 = edx_1873;
				esp_1822->tFFFFFFF0 = eax_1883;
				esp_1822->dwFFFFFFEC = 0x05;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_3 stackArg4 = <invalid>;
				word32 esi_11043;
				word32 ecx_11041;
				word32 edx_11042;
				eax_1897 = fn006DFF80(stackArg4, out ecx_11041, out edx_11042, out esi_11043);
				esp_1822->t0014 = eax_1897;
				esi_1003 = eax_1897;
			}
			word32 v61_1943 = (word32) *ebx_1842 - 1;
			*ebx_1842 = v61_1943;
			esp_1012 = esp_11188;
			if (v61_1943 == 0x00)
			{
				Eq_3 ecx_1947 = *((word32) ebx_1842 + 4);
				<anonymous> * edx_1948 = *((word32) ecx_1947 + 24);
				esp_11188->dwFFFFFFFC = (word32) ebx_1842;
				word32 esp_1957;
				word32 edx_1960;
				edx_1948();
				esp_1012 = esp_1957 + 0x04;
			}
			struct Eq_103611 * eax_1967 = esp_1012[0x0C];
			word32 v62_1968 = eax_1967->dw0000 + ~0x00;
			eax_1967->dw0000 = v62_1968;
			if (v62_1968 == 0x00)
			{
				struct Eq_103686 * ecx_1972 = eax_1967->ptr0004;
				<anonymous> * edx_1973 = ecx_1972->ptr0018;
				esp_1012->dwFFFFFFFC = eax_1967;
				word32 esp_1981;
				word32 edx_1984;
				edx_1973();
				esp_1012 = esp_1981 + 0x04;
			}
			if (esi_1003 != 0x00)
			{
				struct Eq_103749 * esp_1994 = esp_1012 - 4;
				esp_1994->t0000.u0 = 0x00;
				esp_1994->tFFFFFFFC = esi_1003;
				esp_1994->tFFFFFFF8 = eax_1828;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_3 stackArg4 = <invalid>;
				word32 edx_11046;
				word32 esi_11047;
				word32 edi_11048;
				word32 ecx_11045;
				Eq_3 eax_2006 = fn00707680(stackArg4, dwArg04, dwArg08, out ecx_11045, out edx_11046, out esi_11047, out edi_11048);
				word32 v65_2012 = (word32) *eax_1828 - 1;
				*eax_1828 = v65_2012;
				esp_1994->t0018 = eax_2006;
				esp_1012 = (struct Eq_98733 *) ((const char *) &esp_1994->t0000 + 4);
				edi_1088 = eax_2006;
				if (v65_2012 == 0x00)
				{
					Eq_3 edx_2018 = *((word32) eax_1828 + 4);
					<anonymous> * eax_2019 = *((word32) edx_2018 + 24);
					esp_1994->t0000 = eax_1828;
					word32 esp_2022;
					word32 ecx_2024;
					eax_2019();
					esp_1012 = esp_2022 + 0x04;
				}
				word32 v73_2032 = (word32) *esi_1003 - 1;
				*esi_1003 = v73_2032;
				if (v73_2032 != 0x00)
					goto l007094E3;
				struct Eq_104147 * ecx_2036 = *((word32) esi_1003 + 4);
				<anonymous> * edx_2037 = ecx_2036->ptr0018;
				esp_1012->dwFFFFFFFC = (word32) esi_1003;
				word32 edx_2049;
				edx_2037();
				goto l007094E0;
			}
			else
			{
				word32 v64_2054 = (word32) *eax_1828 - 1;
				*eax_1828 = v64_2054;
				ebp_1059 += ~0x03;
				if (v64_2054 == 0x00)
				{
					Eq_3 eax_2058 = *((word32) eax_1828 + 4);
					<anonymous> * ecx_2059 = *((word32) eax_2058 + 24);
					esp_1012->dwFFFFFFFC = (word32) eax_1828;
					word32 esp_2063;
					word32 ecx_2065;
					word32 edx_2066;
					ecx_2059();
					esp_1012 = esp_2063 + 0x04;
				}
				goto l0070A8FA;
			}
		case 0x6B:
			esp_11188->dw0010 = (word32) *((word32) esp_11188[16].t0000 + (ebx_2263 * 0x04 + 0x0C));
			word32 eax_1807 = fn007081C0();
			*ebp_1059 = eax_1807;
			esp_11188->dw0014 = eax_1807;
			esp_1012 = esp_11188;
			ebp_1059 += 0x04;
			if (eax_1807 == 0x00)
				goto l00708EE0;
			goto l00708F23;
		case 0x6D:
			Mem1800[esp_11188 + 0x20:word32] = Mem760[esp_11188 + 0x20:word32] + ebx_2263;
			break;
		case 110:
			esi_1003 = esp_11188->ptr0020;
l00709342:
			Eq_3 eax_2307 = *((word32) ebp_1059 - 4);
			esp_1012->dw0010 = (word32) eax_2307;
			if (eax_2307 == 0x00A191E4)
			{
				if (*esi_1003 == 0x01)
					goto l00709390;
			}
			else
			{
				if (eax_2307 != 0x00A191D8)
				{
					struct Eq_103507 * esp_2314 = esp_1012 - 4;
					esp_2314->t0000 = eax_2307;
					word32 ecx_11036;
					word32 edx_11037;
					Eq_55932 eax_2316 = fn006DEA90(esp_2314->t0000, out ecx_11036, out edx_11037);
					esp_2314->t001C = eax_2316;
					esp_1012 = (struct Eq_98733 *) ((const char *) &esp_2314->t0000 + 4);
					if (eax_2316 <= 0x00)
					{
						if (esp_2314->t001C == 0x00)
							goto l00708F1D;
						goto l00708EE4;
					}
					else
					{
						esp_2314->t001C.u0 = 0x00;
						goto l00708F23;
					}
				}
				esi_1003 += ebx_2263;
				esp_1012->ptr0020 = (byte *) esi_1003;
			}
			break;
		case 111:
			esi_1003 = esp_11188->ptr0020;
l00709375:
			Eq_3 eax_2269 = *((word32) ebp_1059 - 4);
			esp_1012->dw0010 = (word32) eax_2269;
			if (eax_2269 == 0x00A191D8)
			{
				if (*esi_1003 == 0x01)
				{
					esi_1003 = esp_1012->ptr0020;
l00709390:
					esi_1003 = (word32) esi_1003 + 1;
					esp_1012->ptr0020 = (byte *) esi_1003;
l00709397:
					eax_4865 = (struct Eq_99420 *) *((word32) ebp_1059 - 4);
					ebp_1059 -= 0x04;
					goto l0070939D;
				}
			}
			else
			{
				if (eax_2269 != 0x00A191E4)
				{
					struct Eq_103534 * esp_2276 = esp_1012 - 4;
					esp_2276->t0000 = eax_2269;
					word32 edx_11039;
					word32 ecx_11038;
					Eq_55932 eax_2278 = fn006DEA90(esp_2276->t0000, out ecx_11038, out edx_11039);
					esp_2276->t001C = eax_2278;
					esp_1012 = (struct Eq_98733 *) ((const char *) &esp_2276->t0000 + 4);
					if (eax_2278 <= 0x00)
					{
l00709C2E:
						if (esp_1012[8] != 0x00)
							goto l00708EE4;
						goto l00708F23;
					}
					else
					{
						esp_2276->t001C.u0 = 0x00;
l00708F1D:
						esi_1003 += ebx_2263;
						goto l00708F1F;
					}
				}
				esi_1003 += ebx_2263;
				esp_1012->ptr0020 = (byte *) esi_1003;
			}
			break;
		case 0x70:
l007098FE:
			esp_1012->ptr0020 = (word32) ebx_2263 + esp_1012->dw0038;
			goto l00708F23;
		case 115:
			ebx_1685 = *((word32) esp_11188[16].t0000 + (ebx_2263 * 0x04 + 0x0C));
			esp_11188->dw0010 = (word32) ebx_1685;
			if (*((word32) ebx_1685 + 4) == 0x00A1B450)
			{
				esi_1003 = *((word32) ebx_1685 + 0x0C);
				if (esi_1003 == ~0x00)
					goto l0070A5DC;
				struct Eq_102989 * edi_1734 = esp_11188->dw0070;
				struct Eq_102993 * eax_1735 = edi_1734->ptr0018;
				<anonymous> * edx_1736 = eax_1735->ptr0018;
				struct Eq_103001 * esp_1737 = esp_11188 - 4;
				esp_1737->t0000 = esi_1003;
				esp_1737->tFFFFFFFC = ebx_1685;
				esp_1737->ptrFFFFFFF8 = eax_1735;
				struct Eq_103013 * esp_1743;
				struct Eq_103014 * eax_1744;
				word32 ecx_1745;
				word32 edx_1746;
				edx_1736();
				esp_1012 = (struct Eq_98733 *) ((const char *) &esp_1743->t0008 + 4);
				if (eax_1744 == null)
				{
					esp_1743->ptr0020 = null;
					edi_1088.u0 = 0x00;
					goto l00708EE4;
				}
				word32 * eax_1753 = eax_1744->ptr0008;
				esp_1743->ptr0020 = eax_1753;
				if (eax_1753 != null)
				{
					++*eax_1753;
					*ebp_1059 = eax_1753;
					ebp_1059 += 0x04;
					goto l00708F23;
				}
				struct Eq_103035 * eax_1758 = edi_1734->ptr0014;
				esp_1743->t0008 = esi_1003;
				esp_1743->t0004 = ebx_1685;
				esp_1743->ptr0000 = eax_1758;
				<anonymous> * eax_1765 = eax_1758->ptr0018;
				struct Eq_103052 * esp_1766;
				struct Eq_103053 * eax_1767;
				word32 ecx_1768;
				word32 edx_1769;
				eax_1765();
				esp_1012 = (struct Eq_98733 *) ((const char *) esp_1766 + 0x0C);
				if (eax_1767 == null)
				{
					esp_1766->t0020.u0 = 0x00;
					edi_1088.u0 = 0x00;
					goto l00708EE4;
				}
				edi_1088 = eax_1767->t0008;
				esp_1766->t0020 = edi_1088;
				if (edi_1088 != 0x00)
					goto l0070A5CE;
				goto l0070A60E;
			}
l0070A5DC:
			esi_1003 = esp_11188->dw0070;
			word32 ecx_1695 = *((word32) esi_1003 + 24);
			struct Eq_102960 * esp_1696 = esp_11188 - 4;
			esp_1696->t0000 = ebx_1685;
			esp_1696->dwFFFFFFFC = ecx_1695;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg4 = <invalid>;
			word32 ecx_11015;
			word32 edx_11016;
			Eq_3 eax_1706 = fn006FBCC0(stackArg4, dwArg04, out ecx_11015, out edx_11016);
			esp_1696->t0018 = eax_1706;
			edi_1088 = eax_1706;
			esp_1012 = (struct Eq_98733 *) ((const char *) &esp_1696->t0000 + 4);
			if (eax_1706 == 0x00)
			{
				word32 edx_1717 = *((word32) esi_1003 + 20);
				esp_1696->t0000 = ebx_1685;
				esp_1696->dwFFFFFFFC = edx_1717;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_3 stackArg4 = <invalid>;
				word32 ecx_11018;
				word32 edx_11019;
				Eq_3 eax_1723 = fn006FBCC0(stackArg4, dwArg04, out ecx_11018, out edx_11019);
				esp_1696->t0018 = eax_1723;
				edi_1088 = eax_1723;
				esp_1012 = (struct Eq_98733 *) ((const char *) &esp_1696->t0000 + 4);
				if (eax_1723 == 0x00)
				{
l0070A60E:
					esp_1782 = esp_1012 - 4;
					esp_1782->dw0000 = 0x008D7C2C;
l0070A379:
					word32 * esp_2857 = esp_1782 - 4;
					*esp_2857 = g_dwA17768;
					fn007083E0(ebx_1685);
					esp_1012 = (struct Eq_98733 *) (esp_2857 + 2);
					goto l00708EE4;
				}
			}
l0070A5CE:
			*edi_1088.u0 = (word32) *edi_1088.u0 + 1;
l0070A5D1:
			*ebp_1059 = edi_1088;
			ebp_1059 += 0x04;
			goto l00708F23;
		case 118:
			struct Eq_101279 * esp_1666 = esp_11188 - 4;
			esp_1666->t0000 = ebx_2263;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg4 = <invalid>;
			word32 ecx_10980;
			word32 edx_10981;
			Eq_3 eax_1669 = fn007050A0(stackArg4, out ecx_10980, out edx_10981);
			esp_1666->t0030 = eax_1669;
			esp_1012 = (struct Eq_98733 *) ((const char *) &esp_1666->t0000 + 4);
			if (eax_1669 != 0x00)
			{
				esp_1666->dw0020 = 0x20;
				goto l0070B089;
			}
			else
			{
				esp_1666->dw0018 = 0x00;
				edi_1088.u0 = 0x00;
				goto l00708EE4;
			}
		case 0x77:
		case 0x78:
		case 121:
			Eq_3 eax_1639 = esp_11188->dw0070;
			Eq_3 ebx_1645 = esp_11188->ptr0020 + (ebx_2263 - esp_11188->dw0038);
			struct Eq_101313 * esp_1648 = esp_11188 - 4;
			esp_1648->t0000 = ebp_1059 - *((word32) eax_1639 + 32) >> 0x02;
			esp_1648->tFFFFFFFC = ebx_1645;
			esp_1648->dwFFFFFFF8 = ecx_742;
			esp_1648->tFFFFFFF4 = eax_1639;
			fn0073B240(esp_1648->tFFFFFFF4, esp_1648->dwFFFFFFF8, esp_1648->tFFFFFFFC, esp_1648->t0000);
			esp_1012 = (struct Eq_98733 *) ((const char *) &esp_1648->t0000 + 4);
			goto l00708F23;
		case 0x7B:
			edi_1088 = *((word32) esp_11188->dw0070 + (ebx_2263 * 0x04 + 312));
			esp_11188->dw0014 = (word32) edi_1088;
			if (edi_1088 == 0x00)
				goto l00709487;
			*edi_1088.u0 = (word32) *edi_1088.u0 + 1;
			*ebp_1059 = edi_1088;
			ebp_1059 += 0x04;
			break;
		case 0x7C:
l00709462:
			struct Eq_101363 * ecx_4863 = esp_1012->dw0070;
			eax_4865 = ecx_4863->a0138[ebx_2263].dw0000;
			ecx_4863->a0138[ebx_2263].dw0000 = (word32) *((word32) ebp_1059 - 4);
			ebp_1059 -= 0x04;
			if (eax_4865 != null)
			{
l0070939D:
				word32 v23_6526 = eax_4865->dw0000 + ~0x00;
				eax_4865->dw0000 = v23_6526;
				if (v23_6526 == 0x00)
				{
					struct Eq_101789 * ecx_6530 = eax_4865->dw0004;
					<anonymous> * edx_6531 = ecx_6530->ptr0018;
					esp_1012->dwFFFFFFFC = eax_4865;
					word32 esp_6556;
					word32 edx_6559;
					edx_6531();
					esp_1012 = esp_6556 + 0x04;
				}
			}
			break;
		case 0x7D:
			struct Eq_101384 * eax_1571 = esp_11188->dw0070;
			edi_1088 = eax_1571->a0138[ebx_2263];
			esp_11188->dw0014 = (word32) edi_1088;
			if (edi_1088 == 0x00)
			{
l00709487:
				word32 ecx_1603 = esp_11188->ptr0040->dw0024;
				struct Eq_102860 * esp_1604 = esp_11188 - 4;
				esp_1604->t0000 = ebx_2263;
				esp_1604->dwFFFFFFFC = ecx_1603;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_3 stackArg4 = <invalid>;
				Eq_3 eax_1614 = fn006DFE60(stackArg4, dwArg04);
				word32 edx_1619 = g_dwA1776C;
				esp_1604->dwFFFFFFF8 = 0x008D7D58;
				esp_1604->dwFFFFFFF4 = edx_1619;
				fn007083E0(eax_1614);
				esp_1012 = (struct Eq_98733 *) ((const char *) &esp_1604->t0000 + 4);
				goto l00708EE4;
			}
			else
			{
				eax_1571->a0138[ebx_2263].u0 = 0x00;
				word32 v49_1578 = (word32) *edi_1088.u0 - 1;
				*edi_1088.u0 = v49_1578;
				if (v49_1578 == 0x00)
				{
					struct Eq_102905 * ecx_1582 = *((word64) edi_1088.u0 + 4);
					<anonymous> * edx_1583 = ecx_1582->ptr0018;
					esp_11188->dwFFFFFFFC = (word32) edi_1088;
					word32 esp_1586;
					word32 edx_1589;
					edx_1583();
					esp_1012 = esp_1586 + 0x04;
				}
				goto l00708F23;
			}
		case 0x81:
			esp_11188->dw0010 = (word32) 0x00;
			Eq_3 eax_1499 = 0x00;
			word32 ecx_1500 = 0x00;
			word32 edx_1501 = 0x00;
			if (ebx_2263 > 0x03)
			{
				Eq_3 eax_1505 = g_tA18720;
				struct Eq_102528 * esp_1506 = esp_11188 - 4;
				esp_1506->dw0000 = 0x008D7CD8;
				esp_1506->tFFFFFFFC = eax_1505;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_3 stackArg4 = <invalid>;
				word32 ecx_11005;
				word32 edx_11006;
				fn006E0F80(stackArg4, dwArg04, out ecx_11005, out edx_11006);
				esp_1506->dw0020 = 0x02;
				ebx_1517 = esp_1506->dw0020;
				esp_1012 = (struct Eq_98733 *) (&esp_1506->dw0000 + 1);
				goto l0070B019;
			}
			else
			{
				switch (ebx_2263)
				{
				case 0x00:
					goto l0070A046;
				case 0x01:
					goto l0070A03C;
				case 0x02:
					break;
				case 0x03:
					edx_1501 = (word32) *((word32) ebp_1059 - 4);
					ebp_1059 -= 0x04;
					break;
				}
				ecx_1500 = (word32) *((word32) ebp_1059 - 4);
				ebp_1059 -= 0x04;
l0070A03C:
				eax_1499 = *((word32) ebp_1059 - 4);
				esp_11188->dw0010 = (word32) eax_1499;
				ebp_1059 -= 0x04;
l0070A046:
				struct Eq_102554 * esp_1537 = esp_11188 - 4;
				esp_1537->dw0000 = edx_1501;
				esp_1537->dwFFFFFFFC = ecx_1500;
				esp_1537->tFFFFFFF8 = eax_1499;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_3 stackArg4 = <invalid>;
				esp_1537->dw0020 = fn00707020(stackArg4, dwArg08);
				esp_1012 = (struct Eq_98733 *) (&esp_1537->dw0000 + 1);
				goto l00708EE4;
			}
		case 0x82:
			struct Eq_101410 * esp_1482 = esp_11188 - 4;
			esp_1482->ptr0000 = esp_11188 + 28;
			esp_1482->t0058 = ebp_1059;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg4 = <invalid>;
			Eq_3 eax_1487 = fn00708880(ebx_2263, stackArg4);
			Eq_3 eax_1493 = esp_1482->t0058;
			esp_1482->t0018 = eax_1487;
			*eax_1493 = eax_1487;
			edi_1088 = eax_1487;
			esp_1012 = (struct Eq_98733 *) (&esp_1482->ptr0000 + 1);
			ebp_1059 = (word32) eax_1493 + 4;
			goto l007094E6;
		case 131:
			esi_1003 = *((word32) ebp_1059 - 4);
			struct Eq_101443 * esp_1346 = esp_11188 - 4;
			esp_1346->t0000 = esp_11188->dw0070 + 0x18;
			esp_1346->tFFFFFFFC = esi_1003;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg4 = <invalid>;
			Eq_3 eax_1351 = fn00725010(stackArg4, dwArg04);
			word32 v42_1357 = (word32) *esi_1003 - 1;
			*esi_1003 = v42_1357;
			esp_1346->t0018 = eax_1351;
			ebp_1059 -= 0x04;
			esp_1012 = (struct Eq_98733 *) ((const char *) &esp_1346->t0000 + 4);
			edi_1088 = eax_1351;
			if (v42_1357 == 0x00)
			{
				struct Eq_102452 * edx_1363 = *((word32) esi_1003 + 4);
				<anonymous> * eax_1364 = edx_1363->ptr0018;
				esp_1346->t0000 = esi_1003;
				word32 esp_1367;
				word32 ecx_1369;
				eax_1364();
				esp_1012 = esp_1367 + 0x04;
			}
			if (eax_1351 == 0x00 || ebx_2263 <= 0x00)
				goto l0070AE65;
			struct Eq_102626 * esp_1383 = esp_1012 - 4;
			esp_1383->t0000 = ebx_2263;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg4 = <invalid>;
			word32 edx_11010;
			word32 ecx_11009;
			Eq_3 eax_1390 = fn006DFD20(stackArg4, out ecx_11009, out edx_11010);
			esi_1003 = eax_1390;
			esp_1012 = (struct Eq_98733 *) ((const char *) &esp_1383->t0000 + 4);
			if (eax_1390 != 0x00)
			{
				Eq_102644 ebx_1400 = ebx_2263 - 0x01;
				if (ebx_1400 >= 0x00)
				{
					word32 * eax_1403 = (word32) eax_1390 + 0x0C + ebx_1400 * 0x04;
					do
					{
						word32 ecx_1407 = *((word32) ebp_1059 - 4);
						*eax_1403 = ecx_1407;
						esp_1383->dw0014 = ecx_1407;
						ebp_1059 -= 0x04;
						--ebx_1400;
						eax_1403 -= 0x04;
					} while (ebx_1400 >= 0x00);
				}
				esp_1383->t0000 = eax_1390;
				esp_1383->tFFFFFFFC = eax_1351;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_3 stackArg4 = <invalid>;
				word32 eax_1434 = fn00725150(stackArg4, dwArg04);
				word32 v46_1440 = (word32) *eax_1390 - 1;
				*eax_1390 = v46_1440;
				esp_1383->dw001C = eax_1434;
				esp_1012 = (struct Eq_98733 *) ((const char *) &esp_1383->t0000 + 4);
				if (v46_1440 == 0x00)
				{
					Eq_3 eax_1445 = *((word32) eax_1390 + 4);
					<anonymous> * ecx_1446 = *((word32) eax_1445 + 24);
					esp_1383->t0000 = eax_1390;
					word32 esp_1449;
					word32 ecx_1451;
					word32 edx_1452;
					ecx_1446();
					esp_1012 = esp_1449 + 0x04;
				}
				goto l0070AE65;
			}
			else
			{
				word32 v44_1462 = (word32) *eax_1351 - 1;
				*eax_1351 = v44_1462;
				if (v44_1462 != 0x00)
					goto l0070A8FA;
				Eq_3 ecx_1466 = *((word32) eax_1351 + 4);
				<anonymous> * edx_1467 = *((word32) ecx_1466 + 24);
				esp_1383->t0000 = eax_1351;
				struct Eq_102676 * esp_1470;
				word32 edx_1473;
				edx_1467();
				esp_1470->dw0018 = 0x00;
				esp_1012 = (struct Eq_98733 *) ((const char *) esp_1470 + 4);
				edi_1088.u0 = 0x00;
				goto l00708EE4;
			}
		case 0x84:
			if (ebx_2263 == 0x03)
			{
				esp_11188->dw0010 = (word32) *((word32) ebp_1059 - 4);
				ebp_1059 -= 0x04;
			}
			else
				esp_11188->dw0010 = (word32) 0x00;
			struct Eq_102406 * ebx_1254 = *((word32) ebp_1059 - 4);
			esi_1003 = *((word32) ebp_1059 - 8);
			struct Eq_102413 * esp_1258 = esp_11188 - 4;
			esp_1258->t0000 = esp_11188->dw0010;
			esp_1258->ptrFFFFFFFC = ebx_1254;
			esp_1258->tFFFFFFF8 = esi_1003;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg4 = <invalid>;
			Eq_3 eax_1268 = fn0072F1E0(stackArg4, dwArg04, dwArg08);
			word32 v43_1274 = (word32) *esi_1003 - 1;
			*esi_1003 = v43_1274;
			esp_1258->t0018 = eax_1268;
			ebp_1059 -= 0x04;
			esp_1012 = (struct Eq_98733 *) ((const char *) &esp_1258->t0000 + 4);
			edi_1088 = eax_1268;
			if (v43_1274 == 0x00)
			{
				struct Eq_102604 * edx_1280 = *((word32) esi_1003 + 4);
				<anonymous> * eax_1281 = edx_1280->ptr0018;
				esp_1258->t0000 = esi_1003;
				word32 esp_1284;
				word32 ecx_1286;
				eax_1281();
				esp_1012 = esp_1284 + 0x04;
			}
			word32 v45_1294 = ebx_1254->dw0000 + ~0x00;
			ebx_1254->dw0000 = v45_1294;
			if (v45_1294 == 0x00)
			{
				struct Eq_102691 * ecx_1298 = ebx_1254->ptr0004;
				<anonymous> * edx_1299 = ecx_1298->ptr0018;
				esp_1012->dwFFFFFFFC = ebx_1254;
				word32 esp_1308;
				word32 edx_1311;
				edx_1299();
				esp_1012 = esp_1308 + 0x04;
			}
			struct Eq_102685 * eax_1318 = esp_1012->dw0010;
			if (eax_1318 != null)
			{
				word32 v47_1322 = eax_1318->dw0000 + ~0x00;
				eax_1318->dw0000 = v47_1322;
				if (v47_1322 == 0x00)
				{
					struct Eq_102786 * ecx_1326 = eax_1318->ptr0004;
					<anonymous> * edx_1327 = ecx_1326->ptr0018;
					esp_1012->dwFFFFFFFC = eax_1318;
					word32 edx_1338;
					edx_1327();
l007094E0:
					esp_1012 = esp_1335 + 0x04;
				}
			}
l007094E3:
			*((word32) ebp_1059 - 4) = edi_1088;
			goto l007094E6;
		case 133:
			esi_1003 = *((word32) ebp_1059 - 4);
			struct Eq_101488 * esp_1074 = esp_11188 - 4;
			esp_1074->t0000 = esp_11188->dw0070 + 0x18;
			esp_1074->tFFFFFFFC = esi_1003;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg4 = <invalid>;
			Eq_3 eax_1079 = fn00725010(stackArg4, dwArg04);
			word32 v41_1085 = (word32) *esi_1003 - 1;
			*esi_1003 = v41_1085;
			esp_1074->t0018 = eax_1079;
			ebp_1059 -= 0x04;
			esp_1012 = (struct Eq_98733 *) ((const char *) &esp_1074->t0000 + 4);
			edi_1088 = eax_1079;
			if (v41_1085 == 0x00)
			{
				struct Eq_102379 * ecx_1091 = *((word32) esi_1003 + 4);
				<anonymous> * edx_1092 = ecx_1091->ptr0018;
				esp_1074->t0000 = esi_1003;
				word32 esp_1095;
				word32 edx_1098;
				edx_1092();
				esp_1012 = esp_1095 + 0x04;
			}
			if (eax_1079 != 0x00)
			{
				esi_1003 = *((word32) ebp_1059 - 4);
				struct Eq_102801 * esp_1113 = esp_1012 - 4;
				esp_1113->t0000 = esi_1003;
				esp_1113->tFFFFFFFC = eax_1079;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_3 stackArg4 = <invalid>;
				word32 eax_1121 = fn007251F0(stackArg4, dwArg04);
				word32 v48_1127 = (word32) *esi_1003 - 1;
				*esi_1003 = v48_1127;
				esp_1113->dw001C = eax_1121;
				ebp_1059 -= 0x04;
				esp_1012 = (struct Eq_98733 *) ((const char *) &esp_1113->t0000 + 4);
				if (v48_1127 == 0x00)
				{
					struct Eq_102837 * eax_1132 = *((word32) esi_1003 + 4);
					<anonymous> * ecx_1133 = eax_1132->ptr0018;
					esp_1113->t0000 = esi_1003;
					word32 esp_1136;
					word32 ecx_1138;
					word32 edx_1139;
					ecx_1133();
					esp_1012 = esp_1136 + 0x04;
				}
				if (ebx_2263 > 0x00)
				{
					struct Eq_103124 * esp_1148 = esp_1012 - 4;
					esp_1148->t0000 = ebx_2263;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_3 stackArg4 = <invalid>;
					word32 ecx_11021;
					word32 edx_11022;
					Eq_3 eax_1156 = fn006DFD20(stackArg4, out ecx_11021, out edx_11022);
					esi_1003 = eax_1156;
					esp_1012 = (struct Eq_98733 *) ((const char *) &esp_1148->t0000 + 4);
					if (eax_1156 == 0x00)
					{
						word32 v52_1224 = (word32) *eax_1079 - 1;
						*eax_1079 = v52_1224;
						if (v52_1224 == 0x00)
						{
							Eq_3 edx_1228 = *((word32) eax_1079 + 4);
							<anonymous> * eax_1229 = *((word32) edx_1228 + 24);
							esp_1148->t0000 = eax_1079;
							struct Eq_103169 * esp_1232;
							word32 ecx_1234;
							eax_1229();
							esp_1232->dw0018 = 0x00;
							esp_1012 = (struct Eq_98733 *) ((const char *) esp_1232 + 4);
							edi_1088.u0 = 0x00;
						}
						else
						{
l0070A8FA:
							esp_1012->dw0014 = 0x00;
							edi_1088.u0 = 0x00;
						}
						goto l00708EE4;
					}
					Eq_103142 ebx_1166 = ebx_2263 - 0x01;
					if (ebx_1166 >= 0x00)
					{
						word32 * eax_1169 = (word32) eax_1156 + 0x0C + ebx_1166 * 0x04;
						do
						{
							word32 ecx_1172 = *((word32) ebp_1059 - 4);
							*eax_1169 = ecx_1172;
							esp_1148->dw0014 = ecx_1172;
							ebp_1059 -= 0x04;
							--ebx_1166;
							eax_1169 -= 0x04;
						} while (ebx_1166 >= 0x00);
					}
					esp_1148->t0000 = eax_1156;
					esp_1148->tFFFFFFFC = eax_1079;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_3 stackArg4 = <invalid>;
					word32 eax_1199 = fn00725150(stackArg4, dwArg04);
					word32 v54_1205 = (word32) *eax_1156 - 1;
					*eax_1156 = v54_1205;
					esp_1148->dw001C = eax_1199;
					esp_1012 = (struct Eq_98733 *) ((const char *) &esp_1148->t0000 + 4);
					if (v54_1205 == 0x00)
					{
						Eq_3 ecx_1210 = *((word32) eax_1156 + 4);
						<anonymous> * edx_1211 = *((word32) ecx_1210 + 24);
						esp_1148->t0000 = eax_1156;
						word32 esp_1214;
						word32 edx_1217;
						edx_1211();
						*ebp_1059 = eax_1079;
						esp_1012 = esp_1214 + 0x04;
						ebp_1059 += 0x04;
						goto l00708EE4;
					}
				}
			}
l0070AE65:
			*ebp_1059 = edi_1088;
			ebp_1059 += 0x04;
			goto l00708EE4;
		case 0x86:
			Eq_3 ebx_1062 = esp_11188->ptr0044[ebx_2263];
			*ebx_1062 = (word32) *ebx_1062 + 1;
			*ebp_1059 = ebx_1062;
			esp_11188->dw0014 = (word32) ebx_1062;
			ebp_1059 += 0x04;
			goto l00708F23;
		case 0x87:
			edi_1088 = esp_11188->ptr0044[ebx_2263];
			struct Eq_101554 * esp_999 = esp_11188 - 4;
			esp_999->t0000 = edi_1088;
			esp_999->t0018 = edi_1088;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg4 = <invalid>;
			word32 eax_1007 = fn007503F0(stackArg4);
			esp_999->dw0014 = eax_1007;
			esp_1012 = (struct Eq_98733 *) ((const char *) &esp_999->t0000 + 4);
			if (eax_1007 == 0x00)
			{
				esp_999->dw001C = ~0x00;
				if (fn006E0FC0() == 0x00)
				{
					struct Eq_102467 * edx_1022 = esp_999->ptr0044;
					struct Eq_102471 * ecx_1023 = edx_1022->ptr002C;
					Eq_3 eax_1024 = ecx_1023->t0008;
					if (ebx_2263 < eax_1024)
					{
						word32 edx_1044 = g_dwA1776C;
						Eq_3 eax_1045 = ecx_1023->a000C[ebx_2263];
						esp_999->t0000.u0 = 0x008D7D58;
						esp_999->dwFFFFFFFC = edx_1044;
						fn007083E0(eax_1045);
						esp_1012 = (struct Eq_98733 *) ((const char *) &esp_999->t0000 + 4);
					}
					else
					{
						word32 ecx_1027 = g_dwA17768;
						Eq_3 eax_1031 = edx_1022->ptr0028->a000C[ebx_2263 - eax_1024];
						esp_999->t0000.u0 = 9272264;
						esp_999->dwFFFFFFFC = ecx_1027;
						fn007083E0(eax_1031);
						esp_1012 = (struct Eq_98733 *) ((const char *) &esp_999->t0000 + 4);
					}
				}
				goto l00708EE4;
			}
			else
			{
				*ebp_1059 = eax_1007;
				ebp_1059 += 0x04;
				goto l00708F23;
			}
		case 0x88:
			esi_1003 = *((word32) ebp_1059 - 4);
			Eq_3 ebx_976 = esp_11188->ptr0044[ebx_2263];
			struct Eq_101586 * esp_979 = esp_11188 - 4;
			esp_979->t0000 = esi_1003;
			esp_979->tFFFFFFFC = ebx_976;
			esp_979->t0014 = esi_1003;
			esp_979->t0018 = ebx_976;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg4 = <invalid>;
			word32 ecx_10987;
			fn00750420(stackArg4, dwArg04, out ecx_10987);
			ebp_1059 -= 0x04;
			esp_1012 = (struct Eq_98733 *) ((const char *) &esp_979->t0000 + 4);
l0070A715:
			word32 v39_4831 = (word32) *esi_1003 - 1;
			*esi_1003 = v39_4831;
			if (v39_4831 == 0x00)
			{
				struct Eq_102348 * eax_4835 = *((word32) esi_1003 + 4);
				<anonymous> * ecx_4836 = eax_4835->ptr0018;
				esp_1012->dwFFFFFFFC = (word32) esi_1003;
				word32 esp_4846;
				word32 ecx_4848;
				word32 edx_4849;
				ecx_4836();
				esp_1012 = esp_4846 + 0x04;
			}
			goto l00708F23;
		case 0x8B:
		case 0x8C:
		case 141:
			int32 ecx_780 = ecx_742 + 0x01;
			Eq_3 eax_778 = (word32) bh_777;
			esp_11188[0x0C] = (struct Eq_98733) eax_778;
			esp_11188->ptr0050 = (word32 *) (ecx_780 & 0x03);
			ui32 edi_788 = ebx_2263 & 0xFF;
			byte cl_789 = (byte) (ecx_780 & 0x03);
			ui32 eax_795 = edi_788 + eax_778 * 0x02;
			if ((cl_789 & 0x01) != 0x00)
				++eax_795;
			ui32 ecx_864 = ecx_780 & 0x03;
			if ((cl_789 & 0x02) != 0x00)
				++eax_795;
			word32 ebx_815 = ebp_1059 - (eax_795 * 0x04 + 0x04);
			esi_1003 = *ebx_815;
			if (*((word32) esi_1003 + 4) == 10612000)
			{
				word32 * edx_821 = *((word32) esi_1003 + 0x0C);
				esp_11188->ptr0058 = edx_821;
				if (edx_821 == null)
					goto l0070AD5A;
				word32 * edx_863;
				++*edx_821;
				esi_1003 = *((word32) esi_1003 + 8);
				*esi_1003 = (word32) *esi_1003 + 1;
				word32 * eax_838 = *ebx_815;
				*eax_838 += ~0x00;
				struct Eq_102099 * eax_841 = *ebx_815;
				if (eax_841->dw0000 == 0x00)
				{
					struct Eq_102113 * ecx_844 = eax_841->ptr0004;
					<anonymous> * edx_845 = ecx_844->ptr0018;
					esp_11188->dwFFFFFFFC = eax_841;
					struct Eq_102124 * esp_857;
					edx_845();
					edx_863 = esp_857->ptr005C;
					ecx_864 = esp_857->dw0054;
					esp_1012 = (struct Eq_98733 *) ((const char *) esp_857 + 4);
					edx_821 = edx_863;
				}
				*ebx_815 = edx_821;
				++edi_788;
			}
			else
			{
l0070AD5A:
				*esi_1003 = (word32) *esi_1003 + 1;
			}
			struct Eq_102174 * esp_878 = esp_1012 - 4;
			esp_878->t0000 = esp_1012[0x0C];
			esp_878->dwFFFFFFFC = edi_788;
			esp_878->dwFFFFFFF8 = ecx_864;
			esp_878->tFFFFFFF4 = esi_1003;
			esp_878->t005C = ebp_1059;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg4 = <invalid>;
			Eq_3 eax_908 = fn00707BD0(&esp_878->t005C, stackArg4, dwArg04);
			Eq_3 ebp_913 = esp_878->t005C;
			word32 v35_915 = (word32) *esi_1003 - 1;
			*esi_1003 = v35_915;
			esp_878->t0018 = eax_908;
			esp_1012 = (struct Eq_98733 *) ((const char *) &esp_878->t0000 + 4);
			edi_1088 = eax_908;
			if (v35_915 == 0x00)
			{
				struct Eq_102225 * ecx_921 = *((word32) esi_1003 + 4);
				<anonymous> * edx_922 = ecx_921->ptr0018;
				esp_878->t0000 = esi_1003;
				word32 esp_925;
				word32 edx_928;
				edx_922();
				esp_1012 = esp_925 + 0x04;
			}
			while (ebp_913 > ebx_815)
			{
				struct Eq_102277 * eax_939 = *((word32) ebp_913 - 4);
				word32 v37_941 = eax_939->dw0000 + ~0x00;
				eax_939->dw0000 = v37_941;
				esp_1012->dw0010 = eax_939;
				ebp_913 -= 0x04;
				if (v37_941 == 0x00)
				{
					struct Eq_102298 * ecx_947 = eax_939->ptr0004;
					<anonymous> * edx_948 = ecx_947->ptr0018;
					esp_1012->dwFFFFFFFC = eax_939;
					word32 esp_955;
					word32 edx_958;
					edx_948();
					esp_1012 = esp_955 + 0x04;
				}
			}
			*ebp_913 = eax_908;
			ebp_1059 = (word32) ebp_913 + 4;
l007094E6:
			if (edi_1088 == 0x00)
				goto l00708EE4;
			goto l00708F23;
		case 0x8E:
			struct Eq_101637 * eax_763 = esp_11188->ptr0020;
			ecx_742 = (word32) eax_763->b0000;
			ui32 edx_765 = (word32) eax_763->b0002;
			esp_11188->ptr0020 = (byte *) (&eax_763->b0002 + 1);
			edx_2591 = (edx_765 << 0x08) + (word32) eax_763->b0001;
			ebx_2263 = ebx_2263 << 0x10 | edx_2591;
			goto l007090D0;
		}
		goto l00709030;
	}
	struct Eq_99217 * esp_700 = esp_11188 - 4;
	esp_700->ptr0000 = (union Eq_3 *) ((const char *) &esp_11188->ptr0058 + 4);
	esp_700->ptrFFFFFFFC = (union Eq_3 *) (&esp_700->dw003C + 0x0A);
	*((word32) edx_2591 + 36) = ebp_1059;
	Eq_3 edx_709 = eax_691->t001C;
	esp_700->tFFFFFFF8 = eax_691->t0024;
	esp_700->tFFFFFFF4 = edx_709;
	esp_700->dw001C = fn00707430(&esp_700->dw003C + 11, edx_2591, esp_700->tFFFFFFF4, esp_700->tFFFFFFF8, esp_700->ptrFFFFFFFC, esp_700->ptr0000, out edx_2591);
	esp_700->dw0024 = (word32) *((word32) edx_2591 + 60) + esp_700->dw003C;
	esi_1003 = edx_2591;
	esp_1012 = (struct Eq_98733 *) ((const char *) &esp_700->ptr0000 + 4);
	Eq_3 eax_728 = *((word32) edx_2591 + 36);
	if (eax_728 != 0x00)
	{
		*((word32) edx_2591 + 36) = 0x00;
		ebp_1059 = eax_728;
	}
	if (esp_700->dw001C == 0x00)
		goto l007090A4;
	goto l00708EE4;
}

// 0070B600: Register Eq_3 fn0070B600(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Stack word32 dwArg0C, Stack Eq_3 dwArg14, Stack Eq_3 dwArg1C, Register out Eq_3 edxOut)
// Called from:
//      fn00707850
//      fn0070BC90
Eq_3 fn0070B600(Eq_3 dwArg04, Eq_3 dwArg08, word32 dwArg0C, Eq_3 dwArg14, Eq_3 dwArg1C, union Eq_3 & edxOut)
{
	Eq_3 ecx_9 = g_tA6D67C;
	if (dwArg08 == 0x00)
	{
		word32 ecx_1819;
		Eq_3 edx_1216;
		fn006E0F80(g_tA18720, 9272984, out ecx_1819, out edx_1216);
		edxOut = edx_1216;
		return 0x00;
	}
	Eq_3 edx_29;
	Eq_3 eax_27 = fn0073AFB0(ecx_9, dwArg04, dwArg08, out edx_29);
	if (eax_27 == 0x00)
	{
		edxOut = edx_29;
		return eax_27;
	}
	Eq_3 edx_1069;
	struct Eq_107502 * esp_1072 = fp - 0x28;
	word32 * esi_139 = (word32) eax_27 + 312;
	if (*((word32) dwArg04 + 8) <= 0x00 && (*((word32) dwArg04 + 20) & 0x0C) == 0x00)
	{
		if (dwArg14 > 0x00 || dwArg1C > 0x00)
		{
			word32 edx_1821;
			word32 esi_1822;
			word32 ecx_1820;
			fn006ECC50(*((word32) dwArg04 + 52), out ecx_1820, out edx_1821, out esi_1822);
			word32 ecx_1823;
			fn006E15D0(g_tA16B7C, dwArg04, out ecx_1823, out edx_1069);
			esp_1072 = fp - 0x28;
			goto l0070BC5E;
		}
	}
	else
	{
		Eq_3 ebx_511 = dwArg14;
		Eq_3 ebp_123 = dwArg14;
		if ((*((word32) dwArg04 + 20) & 0x08) != 0x00)
		{
			word32 ecx_1824;
			word32 edx_1825;
			Eq_3 eax_68 = fn006FDCC0(out ecx_1824, out edx_1825);
			esp_1072 = fp - 0x28;
			edx_1069 = eax_68;
			if (eax_68 == 0x00)
				goto l0070BC5E;
			Eq_3 ecx_80 = *((word32) dwArg04 + 8);
			if ((*((word32) dwArg04 + 20) & 0x04) != 0x00)
				ecx_80 = (word32) ecx_80 + 1;
			Eq_3 eax_87 = *((word32) eax_27 + (ecx_80 * 0x04 + 312));
			*((word32) eax_27 + (ecx_80 * 0x04 + 312)) = eax_68;
			if (eax_87 != 0x00)
			{
				word32 v18_93 = (word32) *eax_87 - 1;
				*eax_87 = v18_93;
				if (v18_93 == 0x00)
				{
					struct Eq_107701 * edx_97 = *((word32) eax_87 + 4);
					word32 esp_106;
					edx_97[6]();
					esp_1072 = esp_106 + 0x04;
				}
			}
		}
		Eq_3 eax_116 = *((word32) dwArg04 + 8);
		if (dwArg14 > eax_116)
		{
			if ((*((word32) dwArg04 + 20) & 0x04) == 0x00)
			{
				word32 esi_701 = 9070991;
				if (eax_116 != 0x01)
					esi_701 = 9118380;
				word32 edx_707 = 0x008D7E88;
				if (esp_1072[0x0011] == 0x00)
					edx_707 = 9070991;
				word32 ecx_713 = 9255976;
				if (esp_1072[19] == 0x00)
					ecx_713 = 9255996;
				struct Eq_108159 * esp_717 = esp_1072 - 4;
				esp_717->t0000 = dwArg14;
				esp_717->dwFFFFFFFC = esi_701;
				esp_717->dwFFFFFFF8 = edx_707;
				esp_717->tFFFFFFF4 = eax_116;
				esp_717->dwFFFFFFF0 = ecx_713;
				esp_717->tFFFFFFEC = *((word32) dwArg04 + 52);
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_3 stackArg4 = <invalid>;
				word32 ecx_1833;
				word32 esi_1835;
				word32 edx_1834;
				Eq_3 eax_752 = fn006ECC50(stackArg4, out ecx_1833, out edx_1834, out esi_1835);
				Eq_3 edx_757 = g_tA16B7C;
				esp_717->tFFFFFFEC = eax_752;
				esp_717->dwFFFFFFE8 = 9272920;
				esp_717->tFFFFFFE4 = edx_757;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_3 stackArg4 = <invalid>;
				word32 ecx_1837;
				fn006E15D0(stackArg4, dwArg04, out ecx_1837, out edx_1069);
				esp_1072 = (struct Eq_107502 *) ((const char *) &esp_717->t0000 + 4);
				goto l0070BC5E;
			}
			esp_1072[4] = (struct Eq_107502) eax_116;
			ebp_123 = eax_116;
		}
		if (ebp_123 > 0x00)
		{
			int32 ebp_133 = esp_1072[4];
			Eq_108114 edi_136 = esp_1072[0x0E] - ((word32) eax_27 + 312);
			do
			{
				word32 eax_141 = Mem140[edi_136 + esi_139:word32];
				++*eax_141;
				struct Eq_108127 * ecx_144 = *esi_139;
				*esi_139 = eax_141;
				if (ecx_144 != null)
				{
					word32 v28_149 = ecx_144->dw0000 + ~0x00;
					ecx_144->dw0000 = v28_149;
					if (v28_149 == 0x00)
					{
						struct Eq_108138 * eax_153 = ecx_144->ptr0004;
						esp_1072->dwFFFFFFFC = ecx_144;
						word32 esp_161;
						eax_153->ptr0018();
						esp_1072 = esp_161 + 0x04;
					}
				}
				++esi_139;
				--ebp_133;
			} while (ebp_133 != 0x00);
		}
		struct Eq_108095 * ebp_184;
		edx_1069 = esp_1072[11];
		Eq_3 edi_182 = esp_1072[4];
		if ((*((word32) edx_1069 + 20) & 0x04) != 0x00)
		{
			struct Eq_108237 * esp_191 = esp_1072 - 4;
			esp_191->t0000 = dwArg14 - edi_182;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg4 = <invalid>;
			word32 ecx_1839;
			Eq_3 eax_200 = fn006DFD20(stackArg4, out ecx_1839, out edx_1069);
			esp_1072 = (struct Eq_107502 *) ((const char *) &esp_191->t0000 + 4);
			if (eax_200 == 0x00)
				goto l0070BC5E;
			edx_1069 = esp_191->ptr0030->t0008;
			ebp_184 = esp_191->ptr0034;
			Eq_3 ecx_214 = ebp_184->a0138[edx_1069];
			ebp_184->a0138[edx_1069] = eax_200;
			if (ecx_214 != 0x00)
			{
				word32 v29_220 = (word32) *ecx_214 - 1;
				*ecx_214 = v29_220;
				if (v29_220 == 0x00)
				{
					struct Eq_107701 * eax_224 = *((word32) ecx_214 + 4);
					esp_191->t0000 = ecx_214;
					word32 esp_228;
					eax_224[6]();
					esp_1072 = esp_228 + 0x04;
				}
			}
			Eq_3 ecx_239 = edi_182;
			if (edi_182 < dwArg14)
			{
				edx_1069 = (word32) eax_200 + 0x0C;
				word32 * esi_245[] = esp_1072[0x0E];
				do
				{
					word32 * eax_250 = esi_245[ecx_239];
					++*eax_250;
					*edx_1069 = eax_250;
					ecx_239 = (word32) ecx_239 + 1;
					edx_1069 = (word32) edx_1069 + 4;
				} while (ecx_239 < dwArg14);
			}
		}
		else
			ebp_184 = (struct Eq_108095 *) esp_1072[0x0C];
		esp_1072[5] = (struct Eq_107502) 0x00;
		Eq_3 edi_513 = edi_182;
		if (esp_1072[0x0011] > 0x00)
		{
			struct Eq_108310 * edi_266 = esp_1072[11];
			ui32 eax_267 = esp_1072[5];
			do
			{
				Eq_179649 ecx_270[] = esp_1072[16];
				Eq_3 ebp_272 = ecx_270[eax_267].t0000;
				struct Eq_108459 * ebx_275 = ecx_270[eax_267].ptr0004.dw0000;
				if (ebp_272 == 0x00)
				{
l0070B9DA:
					struct Eq_108318 * esp_300 = esp_1072 - 4;
					esp_300->t0000 = edi_266->t0034;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_3 stackArg4 = <invalid>;
					word32 ecx_1841;
					word32 edx_1842;
					word32 esi_1843;
					esp_300->tFFFFFFFC = fn006ECC50(stackArg4, out ecx_1841, out edx_1842, out esi_1843);
					Eq_3 eax_316 = g_tA16B7C;
					esp_300->dwFFFFFFF8 = 0x008D7DC0;
					esp_300->tFFFFFFF4 = eax_316;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_3 stackArg4 = <invalid>;
					word32 ecx_1845;
					fn006E15D0(stackArg4, dwArg04, out ecx_1845, out edx_1069);
					esp_1072 = (struct Eq_107502 *) ((const char *) &esp_300->t0000 + 4);
					goto l0070BC5E;
				}
				Eq_3 eax_277 = *((word32) ebp_272 + 4);
				if (eax_277 != 0x00A1B450)
				{
					struct Eq_108371 * esp_280 = esp_1072 - 4;
					esp_280->t0000.u0 = 0x00A1B450;
					esp_280->tFFFFFFFC = eax_277;
					word32 ecx_1846;
					if (fn006D5670(esp_280->tFFFFFFFC, esp_280->t0000, out ecx_1846, out edx_1069) != 0x00)
						goto l0070B876;
					goto l0070B9DA;
				}
l0070B876:
				Eq_3 esi_329 = 0x00;
				if (edi_266->t0008 > 0x00)
				{
					ptr32 edi_334 = 0x0C;
					do
					{
						word32 eax_340 = *((word32) esp_1072[11].dw0024->dwFFFFFFFC + (edi_334 + 4));
						struct Eq_108407 * esp_341 = esp_1072 - 4;
						esp_341->dw0000 = 0x02;
						esp_341->dwFFFFFFFC = eax_340;
						esp_341->tFFFFFFF8 = ebp_272;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_3 stackArg4 = <invalid>;
						int32 eax_352 = fn006DF5A0(stackArg4, dwArg04, dwArg08, out edx_1069);
						esp_1072 = (struct Eq_107502 *) (&esp_341->dw0000 + 1);
						if (eax_352 > 0x00)
							break;
						if (eax_352 < 0x00)
							goto l0070BC5E;
						esi_329 = (word32) esi_329 + 1;
						edi_334 += 0x04;
					} while (esi_329 < (esp_341->ptr0030)->t0008);
				}
				if (fn006E0FC0() != 0x00)
					goto l0070BC5E;
				edi_266 = (struct Eq_108310 *) esp_1072[11];
				if (esi_329 >= edi_266->t0008)
				{
					int32 eax_448 = esp_1072[6];
					if (eax_448 == 0x00)
					{
						struct Eq_108468 * esp_452 = esp_1072 - 4;
						esp_452->t0000 = ebp_272;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_3 stackArg4 = <invalid>;
						word32 esi_1851;
						word32 edx_1850;
						word32 ecx_1849;
						Eq_3 eax_455 = fn006ECC50(stackArg4, out ecx_1849, out edx_1850, out esi_1851);
						Eq_3 ecx_460 = edi_266->t0034;
						esp_452->t0000 = eax_455;
						esp_452->tFFFFFFFC = ecx_460;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_3 stackArg4 = <invalid>;
						word32 ecx_1853;
						word32 esi_1855;
						word32 edx_1854;
						Eq_3 eax_468 = fn006ECC50(stackArg4, out ecx_1853, out edx_1854, out esi_1855);
						Eq_3 edx_473 = g_tA16B7C;
						esp_452->tFFFFFFFC = eax_468;
						esp_452->dwFFFFFFF8 = 0x008D7E20;
						esp_452->tFFFFFFF4 = edx_473;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_3 stackArg4 = <invalid>;
						word32 ecx_1857;
						fn006E15D0(stackArg4, dwArg04, out ecx_1857, out edx_1069);
						esp_1072 = (struct Eq_107502 *) ((const char *) &esp_452->t0000 + 4);
						goto l0070BC5E;
					}
					struct Eq_108525 * esp_490 = esp_1072 - 4;
					esp_490->ptr0000 = ebx_275;
					esp_490->tFFFFFFFC = ebp_272;
					esp_490->dwFFFFFFF8 = eax_448;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_3 stackArg4 = <invalid>;
					word32 edi_1861;
					word32 ecx_1859;
					word32 ebx_1860;
					fn006FBD90(stackArg4, dwArg04, dwArg08, out ecx_1859, out edx_1069, out ebx_1860, out edi_1861);
					esp_1072 = (struct Eq_107502 *) ((const char *) &esp_490->ptr0000 + 4);
				}
				else
				{
					struct Eq_108451 * ecx_377 = esp_1072[0x0C];
					if (ecx_377->a0138[esi_329].dw0000 != null)
					{
						struct Eq_108624 * esp_381 = esp_1072 - 4;
						esp_381->t0000 = ebp_272;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_3 stackArg4 = <invalid>;
						word32 ecx_1863;
						word32 edx_1864;
						word32 esi_1865;
						esp_381->t0000 = fn006ECC50(stackArg4, out ecx_1863, out edx_1864, out esi_1865);
						esp_381->tFFFFFFFC = edi_266->t0034;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_3 stackArg4 = <invalid>;
						word32 esi_1869;
						word32 edx_1868;
						word32 ecx_1867;
						Eq_3 eax_403 = fn006ECC50(stackArg4, out ecx_1867, out edx_1868, out esi_1869);
						Eq_3 ecx_408 = g_tA16B7C;
						esp_381->tFFFFFFFC = eax_403;
						esp_381->dwFFFFFFF8 = 0x008D7DE4;
						esp_381->tFFFFFFF4 = ecx_408;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_3 stackArg4 = <invalid>;
						word32 ecx_1871;
						fn006E15D0(stackArg4, dwArg04, out ecx_1871, out edx_1069);
						esp_1072 = (struct Eq_107502 *) ((const char *) &esp_381->t0000 + 4);
						goto l0070BC5E;
					}
					++ebx_275->dw0000;
					struct Eq_108459 * eax_427 = ecx_377->a0138[esi_329].dw0000;
					ecx_377->a0138[esi_329].dw0000 = ebx_275;
					if (eax_427 != null)
					{
						word32 v32_432 = eax_427->dw0000 + ~0x00;
						eax_427->dw0000 = v32_432;
						if (v32_432 == 0x00)
						{
							struct Eq_108709 * edx_436 = eax_427->ptr0004;
							esp_1072->dwFFFFFFFC = eax_427;
							word32 esp_440;
							edx_436->ptr0018();
							esp_1072 = esp_440 + 0x04;
						}
					}
				}
				word32 eax_506 = esp_1072[5];
				esp_1072[5] = (struct Eq_107502) (eax_506 + 0x01);
				eax_267 = eax_506 + 0x01;
			} while (eax_506 + 0x01 < esp_1072[0x0011]);
			ebx_511 = esp_1072[0x0F];
			ebp_184 = (struct Eq_108095 *) esp_1072[0x0C];
			edi_513 = esp_1072[4];
		}
		Eq_3 eax_517 = *((word32) esp_1072[11].dwFFFFFFFC + 0x0C);
		if (ebx_511 < eax_517)
		{
			int32 esi_522 = esp_1072[19];
			Eq_3 eax_523 = eax_517 - esi_522;
			Eq_3 ecx_525 = ebx_511;
			if (ebx_511 < eax_523)
			{
				do
				{
					if (ebp_184->a0138[ecx_525] == 0x00)
					{
						word32 edi_539 = 9070991;
						if (eax_523 != 0x01)
							edi_539 = 9118380;
						word32 esi_546 = 0x008D7E88;
						if (esp_1072[0x0011] == 0x00)
							esi_546 = 9070991;
						word32 edx_556;
						struct Eq_108828 * ebx_551 = esp_1072[11];
						if ((ebx_551->b0014 & 0x04) == 0x00)
						{
							edx_556 = 9255996;
							if (esp_1072[19] != 0x00)
								goto l0070BA32;
						}
						else
						{
l0070BA32:
							edx_556 = 0x008D3C30;
						}
						struct Eq_108847 * esp_561 = esp_1072 - 4;
						esp_561->t0000 = ecx_525;
						esp_561->dwFFFFFFFC = edi_539;
						esp_561->dwFFFFFFF8 = esi_546;
						esp_561->tFFFFFFF4 = eax_523;
						esp_561->dwFFFFFFF0 = edx_556;
						esp_561->tFFFFFFEC = ebx_551->t0034;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_3 stackArg4 = <invalid>;
						word32 ecx_1873;
						word32 edx_1874;
						word32 esi_1875;
						esp_561->tFFFFFFEC = fn006ECC50(stackArg4, out ecx_1873, out edx_1874, out esi_1875);
						Eq_3 eax_611 = g_tA16B7C;
						esp_561->dwFFFFFFE8 = 9272920;
						esp_561->tFFFFFFE4 = eax_611;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_3 stackArg4 = <invalid>;
						word32 ecx_1877;
						fn006E15D0(stackArg4, dwArg04, out ecx_1877, out edx_1069);
						esp_1072 = (struct Eq_107502 *) ((const char *) &esp_561->t0000 + 4);
						goto l0070BC5E;
					}
					ecx_525 = (word32) ecx_525 + 1;
				} while (ecx_525 < eax_523);
			}
			int32 edi_632;
			if (edi_513 > eax_523)
				edi_632 = edi_513 - eax_523;
			else
				edi_632 = 0x00;
			if (edi_632 < esi_522)
			{
				word32 * ebx_647[] = esp_1072[18];
				word32 * esi_658 = ebp_184->a0138 + ((word32) eax_523 + edi_632);
				do
				{
					if (*esi_658 == 0x00)
					{
						word32 * eax_665 = ebx_647[edi_632];
						++*eax_665;
						struct Eq_108780 * ecx_668 = *esi_658;
						*esi_658 = eax_665;
						if (ecx_668 != null)
						{
							word32 v34_673 = ecx_668->dw0000 + ~0x00;
							ecx_668->dw0000 = v34_673;
							if (v34_673 == 0x00)
							{
								struct Eq_108800 * edx_677 = ecx_668->ptr0004;
								<anonymous> * eax_678 = edx_677->ptr0018;
								esp_1072->dwFFFFFFFC = ecx_668;
								word32 esp_684;
								eax_678();
								esp_1072 = esp_684 + 0x04;
							}
						}
					}
					++edi_632;
					++esi_658;
				} while (edi_632 < esp_1072[19]);
			}
		}
	}
	struct Eq_107554 * ebp_782 = esp_1072[11];
	struct Eq_107558 * eax_783 = ebp_782->ptr002C;
	int32 edx_784 = eax_783->dw0008;
	if (edx_784 != 0x00)
	{
		esp_1072[4] = (struct Eq_107502) ebp_782->dw0008;
		byte cl_791 = ebp_782->b0014;
		if ((cl_791 & 0x04) != 0x00)
			esp_1072[4] = (struct Eq_107502) ((word32) esp_1072[4].dwFFFFFFFC + 5);
		if ((cl_791 & 0x08) != 0x00)
			esp_1072[4] = (struct Eq_107502) ((word32) esp_1072[4].dwFFFFFFFC + 5);
		esp_1072[5] = (struct Eq_107502) 0x00;
		if (edx_784 > 0x00)
		{
			esp_1072[6] = (struct Eq_107502) 0x0C;
			do
			{
				word32 ebx_822 = Mem819[eax_783 + Mem819[esp_1072 + 0x18:word32]:word32];
				int32 edi_823 = 0x00;
				if (esp_1072[4] > 0x00)
				{
					word32 * esi_829 = ebp_782->dw0024 + 0x0C;
					do
					{
						struct Eq_107893 * eax_834 = *esi_829 + 0x14;
						struct Eq_107909 * ecx_837 = ebx_822 + 0x14;
						do
						{
							word32 eax_856;
							cu8 dl_840 = ecx_837->b0000;
							if (dl_840 != eax_834->b0000)
							{
l0070BB30:
								up32 eax_853 = 0x00 - (dl_840 < eax_834->b0000);
								eax_856 = eax_853 - ~0x00 - (eax_853 < 0x00);
								goto l0070BB35;
							}
							if (dl_840 == 0x00)
								break;
							byte dl_847 = ecx_837->b0001;
							if (dl_847 != eax_834->b0001)
								goto l0070BB30;
							++ecx_837;
							++eax_834;
						} while (dl_847 != 0x00);
						eax_856 = 0x00;
l0070BB35:
						if (eax_856 == 0x00)
						{
							struct Eq_107932 * esi_878 = esp_1072[0x0C];
							struct Eq_107936 * esp_887 = esp_1072 - 4;
							esp_887->ptr0000 = esi_878->a0138[edi_823].dw0000;
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							Eq_3 stackArg4 = <invalid>;
							struct Eq_107868 * eax_904 = fn00750380(stackArg4, out edx_1069);
							esp_1072 = (struct Eq_107502 *) ((const char *) &esp_887->ptr0000 + 4);
							if (eax_904 == null)
								goto l0070BC5E;
							esi_878->a0138[ebp_782->dw000C + esp_887->dw0018].dw0000 = eax_904;
							goto l0070BB88;
						}
						++edi_823;
						++esi_829;
					} while (edi_823 < esp_1072[4]);
				}
				struct Eq_107865 * esp_926 = esp_1072 - 4;
				esp_926->ptr0000 = null;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_3 stackArg4 = <invalid>;
				struct Eq_107868 * eax_936 = fn00750380(stackArg4, out edx_1069);
				esp_1072 = (struct Eq_107502 *) ((const char *) &esp_926->ptr0000 + 4);
				if (eax_936 == null)
					goto l0070BC5E;
				struct Eq_107868 ** ecx_949 = esp_926->dw0034 + 0x0138 + (ebp_782->dw000C + esp_926->dw0018) * 0x04;
				struct Eq_107868 * edx_950 = *ecx_949;
				*ecx_949 = (struct Eq_107868 **) eax_936;
				if (edx_950 != null)
				{
					word32 v25_955 = edx_950->dw0000 + ~0x00;
					edx_950->dw0000 = v25_955;
					if (v25_955 == 0x00)
					{
						struct Eq_108034 * eax_959 = edx_950->ptr0004;
						<anonymous> * ecx_960 = eax_959->ptr0018;
						esp_926->ptr0000 = edx_950;
						word32 esp_963;
						ecx_960();
						esp_1072 = esp_963 + 0x04;
					}
				}
l0070BB88:
				word32 ecx_973 = esp_1072[5];
				eax_783 = ebp_782->ptr002C;
				esp_1072[6] = (struct Eq_107502) ((word32) esp_1072[6].dwFFFFFFFC + 8);
				esp_1072[5] = (struct Eq_107502) (ecx_973 + 0x01);
			} while (ecx_973 + 0x01 < eax_783->dw0008);
		}
	}
	int32 eax_987 = ebp_782->ptr0028->dw0008;
	if (eax_987 != 0x00)
	{
		int32 ecx_1007 = 0x00;
		if (eax_987 > 0x00)
		{
			word32 * esi_996[] = esp_1072[8];
			word32 * edx_1013 = (word32) esp_1072[20].dwFFFFFFFC + 16;
			do
			{
				word32 * eax_1001 = *edx_1013;
				++*eax_1001;
				esi_996[ebp_782->ptr002C->dw0008 + ecx_1007] = eax_1001;
				++ecx_1007;
				++edx_1013;
			} while (ecx_1007 < (ebp_782->ptr0028)->dw0008);
		}
	}
	if ((ebp_782->b0014 & 0x20) != 0x00)
	{
		struct Eq_107804 * esi_1075 = esp_1072[0x0C];
		struct Eq_107808 * eax_1076 = esi_1075->ptr000C;
		if (eax_1076 != null)
		{
			eax_1076->dw0000 += ~0x00;
			struct Eq_107808 * eax_1082 = esi_1075->ptr000C;
			if (eax_1082->dw0000 == 0x00)
			{
				struct Eq_107847 * ecx_1085 = eax_1082->ptr0004;
				<anonymous> * edx_1086 = ecx_1085->ptr0018;
				esp_1072->dwFFFFFFFC = eax_1082;
				word32 esp_1089;
				edx_1086();
				esp_1072 = esp_1089 + 0x04;
			}
		}
		esp_1072->dwFFFFFFFC = esi_1075;
		esi_1075->ptr000C = null;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_3 stackArg4 = <invalid>;
		Eq_3 edx_1109;
		Eq_3 eax_1107 = fn007500E0(stackArg4, out edx_1109);
		edxOut = edx_1109;
		return eax_1107;
	}
	word32 eax_1023 = esp_1072[0x0C];
	struct Eq_107783 * esp_1024 = esp_1072 - 4;
	esp_1024->dw0000 = 0x00;
	esp_1024->dwFFFFFFFC = eax_1023;
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_3 stackArg4 = <invalid>;
	esp_1024->t0020 = fn00708DC0(es, ds, stackArg4, dwArg04, out edx_1069);
	esp_1072 = (struct Eq_107502 *) (&esp_1024->dw0000 + 1);
l0070BC5E:
	struct Eq_107568 * esi_1163 = esp_1072[9];
	struct Eq_107572 * eax_1164 = esp_1072[0x0C];
	++esi_1163->dw000C;
	word32 v15_1167 = eax_1164->dw0000 + ~0x00;
	eax_1164->dw0000 = v15_1167;
	if (v15_1167 == 0x00)
	{
		struct Eq_107644 * ecx_1171 = eax_1164->ptr0004;
		<anonymous> * edx_1172 = ecx_1171->ptr0018;
		esp_1072->dwFFFFFFFC = eax_1164;
		edx_1172();
	}
	esi_1163->dw000C += ~0x00;
	edxOut = edx_1069;
	return 0x00;
}

// 0070BC90: Register Eq_3 fn0070BC90(Register out ptr32 edxOut)
// Called from:
//      fn006E83E0
//      fn006F6490
//      fn0070BCC0
Eq_3 fn0070BC90(ptr32 & edxOut)
{
	ptr32 edx_31;
	Eq_3 eax_29 = fn0070B600(dwArg04, dwArg08, dwArg0C, 0x00, 0x00, out edx_31);
	edxOut = edx_31;
	return eax_29;
}

// 0070BCC0: Register word32 fn0070BCC0(Stack Eq_3 dwArg08, Stack Eq_3 dwArg0C, Stack Eq_3 dwArg10)
// Called from:
//      fn00708DC0
word32 fn0070BCC0(Eq_3 dwArg08, Eq_3 dwArg0C, Eq_3 dwArg10)
{
	Eq_3 ebp_104;
	Eq_3 ebx_116;
	struct Eq_108915 * esp_139;
	Eq_3 esi_115 = dwArg08;
	Eq_3 eax_15 = *((word32) dwArg08 + 4);
	if (eax_15 != 0x00A16588)
	{
		word32 ecx_1060;
		word32 edx_1061;
		if (fn006D5670(eax_15, 0x00A16588, out ecx_1060, out edx_1061) == 0x00)
		{
			ebp_104 = dwArg10;
			ebx_116 = dwArg0C;
			goto l0070BD56;
		}
	}
	ebx_116 = dwArg0C;
	ebp_104 = dwArg10;
	if (dwArg0C != 0x00A163B8)
		goto l0070BDD3;
	if (dwArg10 == 0x00A163B8)
	{
		word32 ecx_1062;
		word32 edx_1063;
		Eq_3 eax_53 = fn006DFE20(dwArg08, out ecx_1062, out edx_1063);
		if (eax_53 == 0x02 || eax_53 == 0x03)
		{
			ebx_116 = fn006DFE60(dwArg08, 0x01);
			if (eax_53 == 0x03)
				ebp_104 = fn006DFE60(dwArg08, 0x02);
			esi_115 = fn006DFE60(dwArg08, 0x00);
		}
	}
l0070BD56:
	if (ebx_116 == 0x00A163B8)
	{
		Eq_3 eax_126 = g_tA6D67C;
		union Eq_3 * esp_133;
		struct Eq_109066 * eax_134;
		g_ptrA6D680();
		esp_139 = (struct Eq_108915 *) ((const char *) esp_133 + 4);
		if (eax_134 == null)
			ebx_116.u0 = 0x00;
		else
			ebx_116 = eax_134->t0018;
		if (ebp_104 == 0x00A163B8)
		{
			Eq_3 eax_151 = g_tA6D67C;
			*esp_133 = (union Eq_3 *) eax_151;
			struct Eq_109087 * esp_159;
			struct Eq_109088 * eax_160;
			g_ptrA6D680();
			if (eax_160 == null)
				ebp_104.u0 = 0x00;
			else
			{
				esp_159->ptr0000 = eax_160;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_3 stackArg4 = <invalid>;
				fn0073B3D0(stackArg4);
				ebp_104 = eax_160->t001C;
			}
			esp_159->dw0018 = 0x01;
			esp_139 = (struct Eq_108915 *) ((const char *) &esp_159->ptr0000 + 4);
		}
		if (ebx_116 == 0x00 || ebp_104 == 0x00)
		{
			Eq_3 eax_758 = g_tA18720;
			struct Eq_109112 * esp_760 = esp_139 - 4;
			esp_760->dw0000 = 9273212;
			esp_760->tFFFFFFFC = eax_758;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg4 = <invalid>;
			Eq_3 stackArg8 = <invalid>;
			word32 ecx_1073;
			word32 edx_1074;
			fn006E0F80(stackArg4, stackArg8, out ecx_1073, out edx_1074);
			return ~0x00;
		}
l0070BDDD:
		struct Eq_108965 * esp_679;
		Eq_3 eax_203 = *((word32) esi_115 + 4);
		if (eax_203 != 0x00A1B450)
		{
			struct Eq_108965 * esp_209 = esp_139 - 4;
			esp_209->t0000.u0 = 0x00A1B450;
			esp_209->tFFFFFFFC = eax_203;
			word32 ecx_1064;
			word32 edx_1065;
			if (fn006D5670(esp_209->tFFFFFFFC, esp_209->t0000, out ecx_1064, out edx_1065) == 0x00)
			{
				Eq_3 eax_224 = *((word32) esi_115 + 4);
				if (eax_224 != 0x00A23B20)
				{
					esp_209->t0000.u0 = 0x00A23B20;
					esp_209->tFFFFFFFC = eax_224;
					word32 ecx_1066;
					word32 edx_1067;
					if (fn006D5670(esp_209->tFFFFFFFC, esp_209->t0000, out ecx_1066, out edx_1067) == 0x00)
					{
						Eq_3 eax_242 = *((word32) esi_115 + 4);
						if (eax_242 != 10646616 && eax_242 != 0x00A26EF0)
						{
							esp_209->t0000.u0 = 0x00A26EF0;
							esp_209->tFFFFFFFC = eax_242;
							word32 edx_1069;
							word32 ecx_1068;
							if (fn006D5670(esp_209->tFFFFFFFC, esp_209->t0000, out ecx_1068, out edx_1069) == 0x00)
							{
								esp_209->t0000.u0 = 0x008D7F48;
								esp_679 = esp_209;
								goto l0070BE3D;
							}
						}
					}
				}
			}
		}
		Eq_3 eax_265 = *((word32) ebx_116 + 4);
		if (eax_265 != 0x00A1D1B8)
		{
			struct Eq_109144 * esp_269 = esp_139 - 4;
			esp_269->t0000.u0 = 0x00A1D1B8;
			esp_269->tFFFFFFFC = eax_265;
			word32 ecx_1076;
			word32 edx_1077;
			if (fn006D5670(esp_269->tFFFFFFFC, esp_269->t0000, out ecx_1076, out edx_1077) == 0x00)
			{
				Eq_3 edx_704 = g_tA16B7C;
				esp_269->t0000.u0 = 9273116;
				esp_269->tFFFFFFFC = edx_704;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_3 stackArg4 = <invalid>;
				Eq_3 stackArg8 = <invalid>;
				word32 edx_1081;
				word32 ecx_1080;
				fn006E0F80(stackArg4, stackArg8, out ecx_1080, out edx_1081);
				return ~0x00;
			}
		}
		struct Eq_109132 * esp_285 = esp_139 - 4;
		esp_285->t0000 = ebp_104;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_3 stackArg4 = <invalid>;
		if (fn00703640(stackArg4) == 0x00)
		{
			Eq_3 eax_681 = g_tA16B7C;
			esp_285->t0000.u0 = 9273076;
			esp_285->tFFFFFFFC = eax_681;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg4 = <invalid>;
			Eq_3 stackArg8 = <invalid>;
			word32 ecx_1090;
			word32 edx_1091;
			fn006E0F80(stackArg4, stackArg8, out ecx_1090, out edx_1091);
			return ~0x00;
		}
		esp_285->t0000.u0 = 0x008D41A4;
		esp_285->tFFFFFFFC = ebx_116;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_3 stackArg4 = <invalid>;
		Eq_3 stackArg8 = <invalid>;
		word32 ecx_1084;
		word32 edx_1085;
		word32 edi_1087;
		word32 esi_1086;
		if (fn006FD8B0(stackArg4, stackArg8, out ecx_1084, out edx_1085, out esi_1086, out edi_1087) == 0x00)
		{
			esp_285->t0000 = esp_285->ptr0020->t0014;
			esp_285->tFFFFFFFC.u0 = 0x008D41A4;
			esp_285->tFFFFFFF8 = ebx_116;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg4 = <invalid>;
			Eq_3 stackArg8 = <invalid>;
			word32 ecx_1094;
			word32 edx_1095;
			word32 esi_1096;
			fn006FD8F0(stackArg4, stackArg8, dwArg08, out ecx_1094, out edx_1095, out esi_1096);
		}
		Eq_3 esi_573;
		struct Eq_108915 * esp_570;
		Eq_3 eax_447;
		Eq_3 eax_347 = *((word32) esi_115 + 4);
		if (eax_347 == 10646616)
		{
			if (*((word32) *((word32) esi_115 + 40) + 8) > 0x00)
			{
				esp_679 = esp_139 - 4;
				esp_679->t0000.u0 = 0x008D7EB8;
l0070BE3D:
				esp_679->tFFFFFFFC = g_tA16B7C;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_3 stackArg4 = <invalid>;
				Eq_3 stackArg8 = <invalid>;
				word32 ecx_1100;
				word32 edx_1101;
				fn006E0F80(stackArg4, stackArg8, out ecx_1100, out edx_1101);
				return ~0x00;
			}
			struct Eq_109272 * esp_595 = esp_139 - 4;
			esp_595->t0000 = ebp_104;
			esp_595->tFFFFFFFC = ebx_116;
			esp_595->tFFFFFFF8 = esi_115;
			word32 edx_1097;
			eax_447 = fn0070BC90(out edx_1097);
l0070C033:
			esp_570 = esp_139;
			esi_573 = eax_447;
			goto l0070C035;
		}
		if (eax_347 != 0x00A26EF0)
		{
			struct Eq_109353 * esp_353 = esp_139 - 4;
			esp_353->t0000.u0 = 0x00A26EF0;
			esp_353->tFFFFFFFC = eax_347;
			word32 edx_1109;
			word32 ecx_1108;
			if (fn006D5670(esp_353->tFFFFFFFC, esp_353->t0000, out ecx_1108, out edx_1109) == 0x00)
			{
				Eq_3 eax_454 = *((word32) esi_115 + 4);
				esp_353->dw0028 = 0x00;
				Eq_3 edi_455 = 0x00;
				if (eax_454 != 0x00A23B20)
				{
					esp_353->t0000.u0 = 0x00A23B20;
					esp_353->tFFFFFFFC = eax_454;
					word32 edx_1114;
					word32 ecx_1113;
					if (fn006D5670(esp_353->tFFFFFFFC, esp_353->t0000, out ecx_1113, out edx_1114) == 0x00)
						goto l0070BF72;
				}
				struct Eq_109389 * esp_475 = esp_139 - 4;
				esp_475->t0000 = esi_115;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_3 stackArg4 = <invalid>;
				word32 ecx_1111;
				word32 edx_1112;
				Eq_3 eax_483 = fn00718B50(stackArg4, out ecx_1111, out edx_1112);
				edi_455 = eax_483;
				if (eax_483 == 0x00)
					return ~0x00;
				esp_475->dw0028 |= 0x0100;
				esi_115 = eax_483;
l0070BF72:
				struct Eq_109430 * esp_499 = esp_139 - 4;
				esp_499->t0000.u0 = 0x00;
				esp_499->tFFFFFFFC = &esp_499->dw0024;
				esp_499->tFFFFFFF8 = esi_115;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_3 stackArg4 = <invalid>;
				Eq_3 stackArg8 = <invalid>;
				word32 edx_1117;
				if (fn006EA420(stackArg4, stackArg8, dwArg08, out edx_1117) != 0x00)
					return ~0x00;
				esp_499->t0000 = &esp_499->dw0024 + 1;
				if (fn00707600(esp_499->t0000) != 0x00)
				{
					word32 edx_546 = esp_499->dw0024;
					esp_499->t0000 = &esp_499->dw0024 + 1;
					esp_499->tFFFFFFFC = ebp_104;
					esp_499->tFFFFFFF8 = ebx_116;
					esp_499->dwFFFFFFF4 = 0x0101;
					esp_499->dwFFFFFFF0 = edx_546;
				}
				else
				{
					word32 eax_535 = esp_499->dw0024;
					esp_499->t0000.u0 = 0x00;
					esp_499->tFFFFFFFC = ebp_104;
					esp_499->tFFFFFFF8 = ebx_116;
					esp_499->dwFFFFFFF4 = 0x0101;
					esp_499->dwFFFFFFF0 = eax_535;
				}
				esp_570 = (struct Eq_108915 *) ((const char *) &esp_499->t0000 + 4);
				esi_573 = fn006E9040();
				if (edi_455 != 0x00)
				{
					word32 v16_576 = (word32) *edi_455 - 1;
					*edi_455 = v16_576;
					if (v16_576 == 0x00)
					{
						Eq_3 ecx_580 = *((word32) edi_455 + 4);
						<anonymous> * edx_581 = *((word32) ecx_580 + 24);
						esp_499->t0000 = edi_455;
						word32 esp_584;
						edx_581();
						esp_570 = esp_584 + 0x04;
					}
				}
l0070C035:
				if (esp_570->dw0014 != 0x00)
				{
					word32 edx_618 = esp_570->dw001C;
					struct Eq_109468 * esp_619 = esp_570 - 4;
					esp_619->dw0000 = 0x00;
					esp_619->dwFFFFFFFC = edx_618;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_3 stackArg4 = <invalid>;
					fn0073B4E0(stackArg4);
				}
				if (esi_573 == 0x00)
					return ~0x00;
				word32 v15_645 = (word32) *esi_573 - 1;
				*esi_573 = v15_645;
				if (v15_645 == 0x00)
				{
					Eq_3 eax_649 = *((word32) esi_573 + 4);
					<anonymous> * ecx_650 = *((word32) eax_649 + 24);
					esp_570->tFFFFFFFC = esi_573;
					ecx_650();
				}
				return 0x00;
			}
		}
		struct Eq_109308 * esp_369 = esp_139 - 4;
		esp_369->t0000 = esi_115;
		word32 ecx_1102;
		word32 edx_1103;
		Eq_3 eax_372 = fn0072FC60(esp_369->t0000, out ecx_1102, out edx_1103);
		esp_369->tFFFFFFFC = esi_115;
		esp_369->tFFFFFFF8 = fn0072FC90(esp_369->tFFFFFFFC);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_3 stackArg4 = <invalid>;
		word32 ecx_1105;
		word32 edx_1106;
		word32 esi_1107;
		Eq_3 eax_398 = fn006ECC50(stackArg4, out ecx_1105, out edx_1106, out esi_1107);
		if (eax_398 == 0x00)
			return ~0x00;
		esp_369->t0000 = &esp_369->dw0014;
		esp_369->dw0014 = 0x00;
		if (fn00707600(esp_369->t0000) != 0x00)
			esp_369->t0000 = &esp_369->dw0014;
		else
			esp_369->t0000.u0 = 0x00;
		esp_369->tFFFFFFFC.u0 = 0x00;
		esp_369->tFFFFFFF8 = ebp_104;
		esp_369->tFFFFFFF4 = ebx_116;
		esp_369->dwFFFFFFF0 = 0x0101;
		esp_369->tFFFFFFEC = eax_398;
		esp_369->tFFFFFFE8 = eax_372;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_3 stackArg4 = <invalid>;
		Eq_3 stackArg24 = <invalid>;
		eax_447 = fn006E90B0(stackArg4, stackArg24);
		goto l0070C033;
	}
l0070BDD3:
	esp_139 = fp - 0x18;
	if (ebp_104 == 0x00A163B8)
		ebp_104 = ebx_116;
	goto l0070BDDD;
}

// 0070C1A0: Register Eq_3 fn0070C1A0(Stack Eq_3 dwArg04, Stack Eq_3 dwArg0C)
// Called from:
//      fn0070C1A0
//      fn0070C9E0
Eq_3 fn0070C1A0(Eq_3 dwArg04, Eq_3 dwArg0C)
{
	word32 ecx_178;
	word32 edx_179;
	Eq_3 eax_18 = fn006FBCC0(*((word32) dwArg04 + 0x0C), dwArg08, out ecx_178, out edx_179);
	if (eax_18 == 0x00)
	{
		Eq_3 eax_119;
		Eq_3 esi_43 = 0x00;
		word32 edx_181;
		word32 ecx_180;
		if (fn006DFE20(*((word32) dwArg04 + 8), out ecx_180, out edx_181) > 0x00)
		{
			do
			{
				eax_119 = fn0070C1A0(fn006DFE60(*((word32) dwArg04 + 8), dwArg04), dwArg08);
				if (eax_119 != 0x00)
					return eax_119;
				esi_43 = (word32) esi_43 + 1;
			} while (esi_43 < dwArg04);
		}
		eax_119.u0 = 0x00;
		return eax_119;
	}
	else
	{
		*dwArg0C = dwArg04;
		return eax_18;
	}
}

// 0070C700: Register word32 fn0070C700(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Register out ptr32 ecxOut)
// Called from:
//      fn00703D00
//      fn00703F10
//      fn0070C700
word32 fn0070C700(Eq_3 dwArg04, Eq_3 dwArg08, ptr32 & ecxOut)
{
	if (dwArg04 != dwArg08)
	{
		Eq_3 eax_14 = *((word32) dwArg08 + 4);
		if (eax_14 != 0x00A16588)
		{
			word32 edx_260;
			if (fn006D5670(eax_14, 0x00A16588, out ecx, out edx_260) == 0x00)
			{
				if (dwArg04 != 0x00 && *((word32) dwArg04 + 4) == 10611048)
				{
					word32 edx_261;
					Eq_3 eax_104 = fn006DFE20(*((word32) dwArg04 + 8), out ecx, out edx_261);
					Eq_3 esi_111 = 0x00;
					if (eax_104 > 0x00)
					{
						do
						{
							if (fn0070C700(fn006DFE60(*((word32) dwArg04 + 8), dwArg04), dwArg04, out ecx) != 0x00)
							{
								ecxOut = ecx;
								return 0x01;
							}
							esi_111 = (word32) esi_111 + 1;
						} while (esi_111 < eax_104);
					}
				}
				ecxOut = ecx;
				return 0x00;
			}
		}
		Eq_3 ebx_41 = *((word32) dwArg08 + 8);
		Eq_3 esi_42 = 0x00;
		if (ebx_41 > 0x00)
		{
			do
			{
				if (fn0070C700(dwArg04, dwArg04, out ecx) != 0x00)
				{
					ecxOut = ecx;
					return 0x01;
				}
				esi_42 = (word32) esi_42 + 1;
			} while (esi_42 < ebx_41);
		}
		ecxOut = ecx;
		return 0x00;
	}
	else
	{
		ecxOut = ecx;
		return 0x01;
	}
}

// 0070C9E0: Register Eq_3 fn0070C9E0(Stack Eq_3 dwArg04)
// Called from:
//      fn006FE070
//      fn006FE2A0
Eq_3 fn0070C9E0(Eq_3 dwArg04)
{
	word32 edx_79;
	word32 ecx_78;
	Eq_3 eax_18 = fn006FBCC0(*((word32) dwArg04 + 0x0C), dwArg08, out ecx_78, out edx_79);
	if (eax_18 == 0x00)
		eax_18 = fn0070C1A0(*((word32) dwArg04 + 8), dwArg08);
	return eax_18;
}

<anonymous> g_t70D9A0 = <code>; // 0070D9A0
// 0070E820: void fn0070E820()
// Called from:
//      fn006E8910
void fn0070E820()
{
	Eq_3 eax_10 = g_tA6D37C;
	if (eax_10 != 0x00)
	{
		union Eq_3 * esp_13 = fp;
		do
		{
			Eq_3 ecx_12 = *((word32) eax_10 + 0x0C);
			union Eq_3 * esp_14 = esp_13 - 4;
			*esp_14 = (union Eq_3 *) eax_10;
			g_tA6D37C = ecx_12;
			fn006FEFD0(*esp_14);
			eax_10 = g_tA6D37C;
			esp_13 = esp_14;
		} while (eax_10 != 0x00);
	}
}

<anonymous> g_t70EFF0 = <code>; // 0070EFF0
// 007105C0: Register Eq_3 fn007105C0(Stack Eq_3 dwArg04, Register out Eq_109814 edxOut)
// Called from:
//      fn007120F0
//      fn007367D0
Eq_3 fn007105C0(Eq_3 dwArg04, union Eq_109814 & edxOut)
{
	if (dwArg04 <= 0x7FFFFFFF)
	{
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_3 stackArg8 = <invalid>;
		Eq_3 stackArg12 = <invalid>;
		Eq_109814 edx_35;
		word32 ecx_76;
		word32 edx_77;
		word32 ecx_80;
		Eq_3 eax_33 = fn006DDD50(fn00723860(g_dwA1F414 *s dwArg04 + 0x03 + g_dwA1F410 & ~0x03, out ecx_76, out edx_77), stackArg8, stackArg12, out ecx_80, out edx_35);
		edxOut = edx_35;
		return eax_33;
	}
	else
	{
		Eq_109814 edx_44;
		word32 ecx_81;
		fn006E1210(out ecx_81, out edx_44);
		edxOut = edx_44;
		return 0x00;
	}
}

// 00710690: Register Eq_3 fn00710690(Stack Eq_91924 dwArg04, Register out Eq_91924 ecxOut, Register out (ptr32 word16) edxOut)
// Called from:
//      fn00710CB0
Eq_3 fn00710690(Eq_91924 dwArg04, union Eq_91924 & ecxOut, word16 & edxOut)
{
	Eq_91924 edi_13 = dwArg04;
	Eq_3 esi_14 = 0x00;
	word32 ebx_15 = 0x00;
	if (dwArg04 < 0x00)
	{
		edi_13 = -dwArg04;
		ebx_15 = 0x01;
	}
	Eq_91924 eax_26 = edi_13;
	if (edi_13 != 0x00)
	{
		do
		{
			esi_14 = (word32) esi_14 + 1;
			eax_26 >>= 0x0F;
		} while (eax_26 != 0x00);
		if (esi_14 > 0x7FFFFFFF)
		{
			Eq_91924 ecx_126;
			word16 * edx_127;
			fn006E1210(out ecx_126, out edx_127);
			ecxOut = ecx_126;
			edxOut = edx_127;
			return 0x00;
		}
	}
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_3 stackArg8 = <invalid>;
	Eq_3 stackArg12 = <invalid>;
	word32 edx_209;
	word32 ecx_208;
	Eq_91924 ecx_101;
	word16 * edx_108;
	Eq_3 eax_78 = fn006DDD50(fn00723860(g_dwA1F414 *s esi_14 + 0x03 + g_dwA1F410 & ~0x03, out ecx_208, out edx_209), stackArg8, stackArg12, out ecx_101, out edx_108);
	if (eax_78 != 0x00)
	{
		edx_108 = (word32) eax_78 + 0x0C;
		if (ebx_15 != 0x00)
			esi_14 = -esi_14;
		*((word32) eax_78 + 8) = esi_14;
		ecx_101 = edi_13;
		if (edi_13 != 0x00)
		{
			do
			{
				*edx_108 = (word16) (ecx_101 & 0x7FFF);
				++edx_108;
				ecx_101 >>= 0x0F;
			} while (ecx_101 != 0x00);
		}
	}
	ecxOut = ecx_101;
	edxOut = edx_108;
	return eax_78;
}

// 00710730: Register Eq_3 fn00710730(Stack Eq_3 dwArg04, Register out Eq_68096 edxOut)
// Called from:
//      fn006E9BD0
//      fn00711280
Eq_3 fn00710730(Eq_3 dwArg04, union Eq_68096 & edxOut)
{
	Eq_3 esi_11 = 0x00;
	Eq_3 eax_14 = dwArg04;
	if (dwArg04 != 0x00)
	{
		do
		{
			esi_11 = (word32) esi_11 + 1;
			eax_14 >>= 0x0F;
		} while (eax_14 != 0x00);
		if (esi_11 > 0x7FFFFFFF)
		{
			word32 ecx_145;
			word32 edx_146;
			fn006E1210(out ecx_145, out edx_146);
			edxOut = edx;
			return 0x00;
		}
	}
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	word32 ecx_147;
	Eq_68096 edx_121;
	Eq_3 eax_43 = fn00723860(g_dwA1F414 *s esi_11 + 0x03 + g_dwA1F410 & ~0x03, out ecx_147, out edx_121);
	Eq_3 stackArg4 = <invalid>;
	Eq_3 stackArg8 = <invalid>;
	Eq_3 stackArg12 = <invalid>;
	word32 edx_152;
	word32 ecx_151;
	fn006DDD50(stackArg4, stackArg8, stackArg12, out ecx_151, out edx_152);
	Eq_3 edi_59 = dwArg04;
	if (eax_43 != 0x00)
	{
		*((word32) eax_43 + 8) = esi_11;
		word16 * ecx_63 = (word32) eax_43 + 0x0C;
		if (dwArg04 != 0x00)
		{
			do
			{
				edx_121 = edi_59 & 0x7FFF;
				*ecx_63 = (word16) edx_121;
				++ecx_63;
				edi_59 >>= 0x0F;
			} while (edi_59 != 0x00);
		}
	}
	edxOut = edx_121;
	return eax_43;
}

// 007108F0: Register Eq_3 fn007108F0(Stack Eq_3 dwArg04, Register out Eq_3 ecxOut, Register out (ptr32 word16) edxOut)
// Called from:
//      fn007051A0
Eq_3 fn007108F0(Eq_3 dwArg04, union Eq_3 & ecxOut, word16 & edxOut)
{
	if (dwArg04 != 0x00)
	{
		Eq_3 eax_11 = *((word32) dwArg04 + 4);
		if (eax_11 == 0x00A1F400)
		{
l00710919:
			Eq_3 ecx_83 = *((word32) dwArg04 + 8);
			Eq_3 eax_113 = 0x00;
			int32 edi_130 = 0x01;
			if (ecx_83 < 0x00)
			{
				edi_130 = ~0x00;
				ecx_83 = -ecx_83;
			}
			Eq_3 ecx_121 = ecx_83 - 0x01;
			if (ecx_121 >= 0x00)
			{
				edx = (word32) dwArg04 + 0x0C + ecx_121 * 0x02;
				do
				{
					eax_113 = (eax_113 << 0x0F) + (word32) (*edx);
					if (eax_113 >> 0x0F != eax_113)
						goto l00710971;
					--ecx_121;
					edx -= 0x02;
				} while (ecx_121 >= 0x00);
				if (eax_113 > 0x7FFFFFFF)
				{
					if (edi_130 >= 0x00 || eax_113 != 0x80000000)
					{
l00710971:
						Eq_3 ecx_153;
						word16 * edx_154;
						fn006E0F80(g_tA18598, 0x008D8738, out ecx_153, out edx_154);
						ecxOut = ecx_153;
						edxOut = edx_154;
						return ~0x00;
					}
					else
					{
						ecxOut = ecx_121;
						edxOut = edx;
						return eax_113;
					}
				}
			}
			ecxOut = ecx_121;
			edxOut = edx;
			return eax_113 *s edi_130;
		}
		word32 ecx_266;
		if (fn006D5670(eax_11, 0x00A1F400, out ecx_266, out edx) != 0x00)
			goto l00710919;
		Eq_3 eax_29 = *((word32) dwArg04 + 4);
		if (eax_29 == 10610664)
		{
l007109A7:
			Eq_3 ecx_73;
			word16 * edx_74;
			word32 edi_268;
			word32 esi_267;
			Eq_3 eax_72 = fn007051A0(edi, dwArg04, out ecx_73, out edx_74, out esi_267, out edi_268);
			ecxOut = ecx_73;
			edxOut = edx_74;
			return eax_72;
		}
		word32 ecx_269;
		word32 edx_270;
		if (fn006D5670(eax_29, 10610664, out ecx_269, out edx_270) != 0x00)
			goto l007109A7;
	}
	word16 * edx_57;
	ecxOut = fn006E1DC0(out edx_57);
	edxOut = edx_57;
	return ~0x00;
}

// 007109D0: Register Eq_110106 fn007109D0(Stack Eq_3 dwArg04, Register out Eq_3 ecxOut, Register out (ptr32 word16) edxOut)
// Called from:
//      fn007052C0
Eq_110106 fn007109D0(Eq_3 dwArg04, union Eq_3 & ecxOut, word16 & edxOut)
{
	if (dwArg04 != 0x00)
	{
		Eq_3 eax_11 = *((word32) dwArg04 + 4);
		if (eax_11 == 0x00A1F400)
		{
l007109F9:
			Eq_3 ecx_50 = *((word32) dwArg04 + 8);
			Eq_110106 eax_144 = 0x00;
			int32 edi_59 = 0x01;
			if (ecx_50 < 0x00)
			{
				edi_59 = ~0x00;
				ecx_50 = -ecx_50;
			}
			Eq_3 ecx_185 = ecx_50 - 0x01;
			if (ecx_185 >= 0x00)
			{
				edx = (word32) dwArg04 + 0x0C + ecx_185 * 0x02;
				do
				{
					eax_144 = (eax_144 << 0x0F) + (word32) (*edx);
					if (eax_144 >> 0x0F != eax_144)
						goto l00710A51;
					--ecx_185;
					edx -= 0x02;
				} while (ecx_185 >= 0x00);
				if (eax_144 > 0x7FFFFFFF)
				{
					if (edi_59 >= 0x00 || eax_144 != 0x80000000)
					{
l00710A51:
						Eq_3 ecx_120;
						word16 * edx_121;
						fn006E0F80(g_tA18598, 0x008D8738, out ecx_120, out edx_121);
						ecxOut = ecx_120;
						edxOut = edx_121;
						return ~0x00;
					}
					else
					{
						ecxOut = ecx_185;
						edxOut = edx;
						return eax_144;
					}
				}
			}
			ecxOut = ecx_185;
			edxOut = edx;
			return eax_144 *s edi_59;
		}
		word32 ecx_220;
		if (fn006D5670(eax_11, 0x00A1F400, out ecx_220, out edx) != 0x00)
			goto l007109F9;
	}
	word16 * edx_39;
	ecxOut = fn006E1DC0(out edx_39);
	edxOut = edx_39;
	return ~0x00;
}

// 00710B80: Register Eq_3 fn00710B80(Stack Eq_3 dwArg04)
// Called from:
//      fn006E5C60
//      fn00705340
Eq_3 fn00710B80(Eq_3 dwArg04)
{
	if (dwArg04 != 0x00)
	{
		Eq_3 eax_11 = *((word32) dwArg04 + 4);
		if (eax_11 == 0x00A1F400)
		{
l00710BA5:
			Eq_3 ecx_83 = *((word32) dwArg04 + 8);
			int32 eax_107 = 0x00;
			int32 edi_119 = 0x01;
			if (ecx_83 < 0x00)
			{
				edi_119 = ~0x00;
				ecx_83 = -ecx_83;
			}
			int32 ecx_109 = ecx_83 - 0x01;
			if (ecx_109 >= 0x00)
			{
				word16 * edx_103 = (word32) dwArg04 + 0x0C + ecx_109 * 0x02;
				do
				{
					--ecx_109;
					eax_107 = (eax_107 << 0x0F) + (word32) (*edx_103);
					edx_103 -= 0x02;
				} while (ecx_109 >= 0x00);
			}
			return eax_107 *s edi_119;
		}
		word32 ecx_191;
		word32 edx_192;
		if (fn006D5670(eax_11, 0x00A1F400, out ecx_191, out edx_192) != 0x00)
			goto l00710BA5;
		Eq_3 eax_29 = *((word32) dwArg04 + 4);
		if (eax_29 == 10610664)
			return fn00705340(edi, dwArg04);
		word32 ecx_193;
		word32 edx_194;
		if (fn006D5670(eax_29, 10610664, out ecx_193, out edx_194) != 0x00)
			return fn00705340(edi, dwArg04);
	}
	word32 edx_190;
	fn006E1DC0(out edx_190);
	return ~0x00;
}

// 00710C20: Register Eq_3 fn00710C20(Stack Eq_3 dwArg04, Register out Eq_3 ecxOut)
// Called from:
//      fn00702C30
Eq_3 fn00710C20(Eq_3 dwArg04, union Eq_3 & ecxOut)
{
	Eq_3 eax_6 = *((word32) dwArg04 + 8);
	if (eax_6 != 0x00)
	{
		uint32 ecx_16 = (uint32) (int8) (eax_6 >= 0x00);
		Eq_3 ecx_17 = ecx_16 - 0x01 + ecx_16;
		ecxOut = ecx_17;
		return ecx_17;
	}
	else
	{
		ecxOut = ecx;
		return eax_6;
	}
}

// 00710CB0: Register Eq_3 fn00710CB0(Stack (ptr32 cu8) dwArg04, Stack Eq_91924 dwArg08, Stack word32 dwArg0C, Stack word32 dwArg10, Register out Eq_3 ecxOut, Register out Eq_3 edxOut)
// Called from:
//      fn00705120
//      fn00736780
Eq_3 fn00710CB0(cu8 * dwArg04, Eq_91924 dwArg08, word32 dwArg0C, word32 dwArg10, union Eq_3 & ecxOut, union Eq_3 & edxOut)
{
	Eq_3 dwLoc08_374 = 0x00;
	if (dwArg08 != 0x00)
	{
		word32 dwLoc04_379;
		cu8 * ebx_133;
		cu8 * edi_19;
		if (dwArg0C != 0x00)
		{
			ebx_133 = dwArg04;
			edi_19 = (word32) dwArg08 + (dwArg04 - 0x01);
			dwLoc04_379 = 0x01;
		}
		else
		{
			edi_19 = dwArg04;
			ebx_133 = (word32) dwArg08 + (dwArg04 - 0x01);
			dwLoc04_379 = ~0x00;
		}
		word32 ebp_31 = dwArg10;
		if (dwArg10 != 0x00)
		{
			word32 eax_38 = 0x00 - (*edi_19 < 0x80);
			dwArg10 = eax_38 + 0x01;
			ebp_31 = eax_38 + 0x01;
		}
		word32 eax_49 = -ebp_31;
		int32 ecx_46 = -dwLoc04_379;
		Eq_91924 esi_57 = 0x00;
		cu8 al_361 = (byte) (SEQ(SLICE(eax_49, word24, 8), 0x00 - (eax_49 == 0x00)) & 0xFF);
		if (dwArg08 > 0x00)
		{
			while (*edi_19 == al_361)
			{
				esi_57 = (word32) esi_57 + 1;
				edi_19 += ecx_46;
				if (esi_57 >= dwArg08)
					break;
			}
		}
		Eq_91924 edi_213 = dwArg08 - esi_57;
		if (ebp_31 != 0x00 && edi_213 < dwArg08)
			edi_213 = (word32) edi_213.u1 + 1;
		uint32 edx_96 = SLICE((edi_213 * 0x08 + 0x0E) *64 0x88888889, word32, 32);
		if (edx_96 >> 0x03 <= 0x7FFFFFFF)
		{
			if (edx_96 >> 0x03 <= 0x7FFFFFFF)
			{
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_3 stackArg8 = <invalid>;
				Eq_3 stackArg12 = <invalid>;
				Eq_3 ecx_145;
				word32 edx_567;
				word32 edx_564;
				word32 ecx_563;
				Eq_3 eax_144 = fn006DDD50(fn00723860(g_dwA1F414 *s (edx_96 >> 0x03) + 0x03 + g_dwA1F410 & ~0x03, out ecx_563, out edx_564), stackArg8, stackArg12, out ecx_145, out edx_567);
				if (eax_144 != 0x00)
				{
					Eq_3 eax_163;
					uint32 esi_155 = 0x00;
					uint32 ebp_159 = 0x01;
					cu8 * eax_160 = ebx_133;
					if (edi_213 > 0x00)
					{
						word16 * ebx_164 = (word32) eax_144 + 0x0C;
						up32 ecx_186 = 0x00;
						do
						{
							byte cl_181 = (byte) ecx_186;
							ui32 edx_169 = (word32) *eax_160;
							if (dwArg10 != 0x00)
							{
								uint32 edx_173 = (edx_169 ^ 0xFF) + ebp_159;
								ebp_159 = edx_173 >> 0x08;
								edx_169 = edx_173 & 0xFF;
							}
							ecx_186 += 0x08;
							uint32 esi_189 = esi_155 | edx_169 << cl_181;
							if (ecx_186 >= 0x07)
							{
								*ebx_164 = (word16) (esi_189 & 0x7FFF);
								dwLoc08_374 = (word32) dwLoc08_374 + 1;
								++ebx_164;
								ecx_186 -= 0x07;
								esi_189 >>= 0x0F;
							}
							word16 si_224 = (word16) esi_189;
							eax_160 += dwLoc04_379;
							--edi_213;
							esi_155 = esi_189;
						} while (edi_213 != 0x00);
						eax_163 = dwLoc08_374;
						if (ecx_186 != 0x00)
						{
							*((word32) eax_144 + (dwLoc08_374 * 0x02 + 0x0C)) = si_224;
							eax_163 = (word32) dwLoc08_374 + 1;
						}
					}
					else
						eax_163.u0 = 0x00;
					if (dwArg10 != 0x00)
						eax_163 = -eax_163;
					*((word32) eax_144 + 8) = eax_163;
					Eq_3 esi_244 = eax_163;
					if (eax_163 < 0x00)
						esi_244 = -eax_163;
					Eq_3 ecx_252 = esi_244;
					if (esi_244 > 0x00)
					{
						word16 * edx_254 = (word32) eax_144 + 0x0A + esi_244 * 0x02;
						while (*edx_254 == 0x00)
						{
							--ecx_252;
							edx_254 -= 0x02;
							if (ecx_252 <= 0x00)
								break;
						}
						if (ecx_252 != esi_244)
						{
							if (eax_163 < 0x00)
								ecx_252 = -ecx_252;
							*((word32) eax_144 + 8) = ecx_252;
						}
					}
					ecxOut = ecx_252;
					edxOut = eax_144;
					return eax_144;
				}
				else
				{
					ecxOut = ecx_145;
					edxOut = eax_144;
					return eax_144;
				}
			}
			else
			{
				Eq_3 edx_317;
				Eq_3 ecx_319;
				fn006E1210(out ecx_319, out edx_317);
				ecxOut = ecx_319;
				edxOut = edx_317;
				return 0x00;
			}
		}
		else
		{
			Eq_3 edx_344;
			Eq_3 ecx_346;
			Eq_3 eax_345 = fn006E1210(out ecx_346, out edx_344);
			ecxOut = ecx_346;
			edxOut = edx_344;
			return eax_345;
		}
	}
	else
	{
		Eq_3 edx_352;
		Eq_3 ecx_354;
		Eq_3 eax_353 = fn00710690(dwArg08, out ecx_354, out edx_352);
		ecxOut = ecx_354;
		edxOut = edx_352;
		return eax_353;
	}
}

// 00710E90: Register word32 fn00710E90(Stack Eq_3 dwArg04, Stack (ptr32 byte) dwArg08, Stack up32 dwArg0C, Stack word32 dwArg10, Stack word32 dwArg14)
// Called from:
//      fn007114E0
word32 fn00710E90(Eq_3 dwArg04, byte * dwArg08, up32 dwArg0C, word32 dwArg10, word32 dwArg14)
{
	uint32 dwLoc18_368;
	Eq_3 dwLoc14_367;
	Eq_3 eax_6 = *((word32) dwArg04 + 8);
	int32 ebp_13 = 0x01;
	if (eax_6 < 0x00)
	{
		dwLoc14_367 = -eax_6;
		if (dwArg14 == 0x00)
		{
			word32 ecx_602;
			word32 edx_603;
			fn006E0F80(g_tA16B7C, 0x008D8800, out ecx_602, out edx_603);
			return ~0x00;
		}
		dwLoc18_368 = 0x01;
	}
	else
	{
		dwLoc14_367 = eax_6;
		dwLoc18_368 = 0x00;
	}
	byte * esi_150;
	if (dwArg10 != 0x00)
		esi_150 = dwArg08;
	else
	{
		esi_150 = dwArg08 - 0x01 + dwArg0C;
		ebp_13 = ~0x00;
	}
	up32 edi_135 = 0x00;
	uint32 ebx_159 = 0x00;
	up32 dwLoc04_386 = 0x00;
	Eq_3 dwLoc10_387 = 0x00;
	uint32 dwLoc0C_388 = (uint32) (int8) (dwLoc18_368 != 0x00);
	if (dwLoc14_367 > 0x00)
	{
		word16 * dwArg04_391 = (word32) dwArg04 + 0x0C;
		up32 ecx_139 = 0x00;
		do
		{
			byte cl_88 = (byte) ecx_139;
			ui32 eax_75 = (word32) *dwArg04_391;
			if (dwLoc18_368 != 0x00)
			{
				uint32 eax_78 = (eax_75 ^ 0x7FFF) + dwLoc0C_388;
				dwLoc0C_388 = eax_78 >> 0x0F;
				eax_75 = eax_78 & 0x7FFF;
			}
			ecx_139 += 0x0F;
			ebx_159 |= eax_75 << cl_88;
			if (dwLoc10_387 == (word32) dwLoc14_367 - 1)
			{
				int32 eax_104 = eax_75 << 0x11;
				int32 edi_106 = eax_104;
				up32 edx_107 = 0x00;
				if ((uint32) (int8) (eax_104 < 0x00) == dwLoc18_368)
				{
					while (edx_107 < 0x0F)
					{
						edi_106 *= 0x02;
						++edx_107;
						if ((uint32) (int8) (edi_106 < 0x00) != dwLoc18_368)
							break;
					}
				}
				edi_135 = dwLoc04_386;
				ecx_139 = ecx_139 + 0x0F - edx_107;
			}
			for (; ecx_139 >= 0x08; ecx_139 -= 0x08)
			{
				byte bl_149 = (byte) ebx_159;
				if (edi_135 >= dwArg0C)
					goto l00711022;
				*esi_150 = bl_149;
				++edi_135;
				esi_150 += ebp_13;
				ebx_159 >>= 0x08;
				dwLoc04_386 = edi_135;
				ebx_159 >>= 0x08;
			}
			Eq_3 v21_167 = (word32) dwLoc10_387 + 1;
			byte cl_273 = (byte) ecx_139;
			dwLoc10_387 = v21_167;
			++dwArg04_391;
		} while (v21_167 < dwLoc14_367);
		if (ecx_139 > 0x00)
		{
			if (edi_135 < dwArg0C)
			{
				++edi_135;
				if (dwLoc18_368 != 0x00)
					ebx_159 |= ~0x00 << cl_273;
				*esi_150 = (byte) ebx_159;
				esi_150 += ebp_13;
l00711045:
				word32 eax_290 = -dwLoc18_368;
				byte al_360 = (byte) (SEQ(SLICE(eax_290, word24, 8), 0x00 - (eax_290 == 0x00)) & 0xFF);
				if (edi_135 < dwArg0C)
				{
					up32 ecx_305 = dwArg0C - edi_135;
					do
					{
						*esi_150 = al_360;
						esi_150 += ebp_13;
						--ecx_305;
					} while (ecx_305 != 0x00);
				}
				return 0x00;
			}
			goto l00711022;
		}
	}
	if (edi_135 != dwArg0C || (dwArg0C <= 0x00 || dwArg14 == 0x00))
		goto l00711045;
	if (0x00 - (esi_150 - ebp_13 < 0x80) + 0x01 == dwLoc18_368)
		return 0x00;
l00711022:
	word32 ecx_604;
	word32 edx_605;
	fn006E0F80(g_tA18598, 0x008D87E8, out ecx_604, out edx_605);
	return ~0x00;
}

