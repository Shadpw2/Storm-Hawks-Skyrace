// sho_text_0032.c
// Generated by decompiling sho.exe
// using Reko decompiler version 0.10.0.0.

#include "sho.h"

// 00721290: Register Eq_3 fn00721290(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Register out Eq_3 edxOut)
// Called from:
//      fn006EA9D0
//      fn0073D660
Eq_3 fn00721290(Eq_3 dwArg04, Eq_3 dwArg08, union Eq_3 & edxOut)
{
	Eq_3 esi_10 = dwArg04;
	Eq_3 eax_11 = *((word32) dwArg04 + 4);
	if (eax_11 == 0x00A23B20)
		*dwArg04 = (word32) *dwArg04 + 1;
	else
	{
		Eq_3 eax_39;
		word32 edx_548;
		word32 ecx_547;
		if (fn006D5670(eax_11, 0x00A23B20, out ecx_547, out edx_548) == 0x00)
			eax_39 = fn00720070(dwArg04, out edx);
		else
			eax_39 = fn00717A20(*((word32) dwArg04 + 0x0C), *((word32) dwArg04 + 8), out edx);
		esi_10 = eax_39;
	}
	if (esi_10 != 0x00)
	{
		Eq_3 eax_83 = fn007203E0(dwArg08, out edx);
		if (eax_83 != 0x00)
		{
			Eq_3 eax_93 = g_tA6DBB4;
			if (eax_83 == eax_93)
			{
				Eq_3 v13_342 = (word32) *eax_83 - 1;
				*eax_83 = v13_342;
				if (v13_342 == 0x00)
				{
					Eq_3 eax_346 = *((word32) eax_83 + 4);
					word32 ecx_353;
					(*((word32) eax_346 + 24))();
				}
				edxOut = edx;
				return esi_10;
			}
			if (esi_10 == eax_93)
			{
				Eq_3 v15_316 = (word32) *esi_10 - 1;
				*esi_10 = v15_316;
				if (v15_316 == 0x00)
				{
					Eq_3 edx_320 = *((word32) esi_10 + 4);
					word32 ecx_327;
					(*((word32) edx_320 + 24))();
				}
				edxOut = edx;
				return eax_83;
			}
			word32 ecx_549;
			word32 eax_102 = fn00717740(Mem75[eax_83 + 0x08:word32] + Mem75[esi_10 + 0x08:word32], out ecx_549, out edx);
			if (eax_102 != 0x00)
			{
				Eq_3 eax_111 = *((word32) esi_10 + 8);
				Eq_3 ecx_112 = *((word32) eax_102 + 0x0C);
				Eq_3 edx_113 = *((word32) esi_10 + 0x0C);
				if (eax_111 * 0x02 >= 0x10)
					memcpy(ecx_112, edx_113, eax_111 * 0x02);
				else if (eax_111 * 0x02 > 0x00)
				{
					int32 edx_126 = edx_113 - ecx_112;
					ui32 ebp_128 = eax_111 * 0x02;
					do
					{
						*ecx_112 = *((word32) ecx_112 + edx_126);
						ecx_112 = (word32) ecx_112 + 1;
						--ebp_128;
					} while (ebp_128 != 0x00);
				}
				Eq_3 eax_151 = *((word32) eax_83 + 8);
				Eq_3 ecx_160 = (word32) *((word32) eax_102 + 0x0C) + *((word32) esi_10 + 8) * 0x02;
				Eq_3 edx_161 = *((word32) eax_83 + 0x0C);
				if (eax_151 * 0x02 >= 0x10)
					memcpy(ecx_160, edx_161, eax_151 * 0x02);
				else if (eax_151 * 0x02 > 0x00)
				{
					edx_161 -= ecx_160;
					ui32 ebp_169 = eax_151 * 0x02;
					do
					{
						Mem177[ecx_160 + 0x00:byte] = Mem175[edx_161 + ecx_160:byte];
						ecx_160 = (word32) ecx_160 + 1;
						--ebp_169;
					} while (ebp_169 != 0x00);
				}
				Eq_3 v21_195 = (word32) *esi_10 - 1;
				*esi_10 = v21_195;
				struct Eq_119720 * esp_201 = fp - 0x0C;
				if (v21_195 == 0x00)
				{
					Eq_3 ecx_203 = *((word32) esi_10 + 4);
					word32 esp_215;
					(*((word32) ecx_203 + 24))();
					esp_201 = esp_215 + 0x04;
				}
				Eq_3 v22_225 = (word32) *eax_83 - 1;
				*eax_83 = v22_225;
				if (v22_225 == 0x00)
				{
					Eq_3 eax_229 = *((word32) eax_83 + 4);
					<anonymous> * ecx_230 = *((word32) eax_229 + 24);
					esp_201->tFFFFFFFC = eax_83;
					word32 ecx_241;
					ecx_230();
				}
				edxOut = edx_161;
				return eax_102;
			}
		}
		Eq_3 v16_258 = (word32) *esi_10 - 1;
		*esi_10 = v16_258;
		struct Eq_119562 * esp_264 = fp - 0x0C;
		if (v16_258 == 0x00)
		{
			Eq_3 ecx_262 = *((word32) esi_10 + 4);
			word32 esp_271;
			(*((word32) ecx_262 + 24))();
			esp_264 = esp_271 + 0x04;
		}
		if (eax_83 != 0x00)
		{
			Eq_3 v18_284 = (word32) *eax_83 - 1;
			*eax_83 = v18_284;
			if (v18_284 == 0x00)
			{
				Eq_3 eax_288 = *((word32) eax_83 + 4);
				<anonymous> * ecx_289 = *((word32) eax_288 + 24);
				esp_264->tFFFFFFFC = eax_83;
				word32 ecx_300;
				ecx_289();
			}
		}
	}
	edxOut = edx;
	return 0x00;
}

// 00723330: Register (ptr32 byte) fn00723330(Register (ptr32 byte) eax, Stack (ptr32 byte) dwArg04)
// Called from:
//      fn00723540
byte * fn00723330(byte * eax, byte * dwArg04)
{
	byte * ebp_10 = dwArg04;
	byte * ebx_19 = eax;
	do
	{
		int32 eax_26 = tolower((int32) *ebx_19);
		int32 eax_32 = tolower((int32) *ebp_10);
		++ebx_19;
		++ebp_10;
	} while (eax_26 != 0x00 && eax_26 == eax_32);
	return eax_26 - eax_32;
}

// 00723370: Register Eq_3 fn00723370(Stack Eq_3 dwArg04, Register out Eq_3 edxOut)
// Called from:
//      fn00723540
Eq_3 fn00723370(Eq_3 dwArg04, union Eq_3 & edxOut)
{
	if (dwArg04 == 0x00)
	{
		edxOut = edx;
		return 0x00;
	}
	word32 edi_14 = *((word32) dwArg04 + 60);
	up32 eax_18;
	struct Eq_119826 * ecx_19 = &g_t8D9B3C;
	Eq_3 edx_126 = (word32) dwArg04 + edi_14;
	for (eax_18 = 0x04; eax_18 >= 0x04; eax_18 -= 0x04)
	{
		word32 eax_81;
		if (*edx_126 != ecx_19->b0000)
			goto l007233A8;
		++ecx_19;
		edx_126 = (word32) edx_126 + 4;
	}
	if (eax_18 != 0x00)
	{
l007233A8:
		Eq_119832 esi_44 = *edx_126 - ecx_19->b0000;
		if (esi_44 != 0x00)
		{
l007233F7:
			eax_81 = 0x01;
			if (esi_44 <= 0x00)
				eax_81 = ~0x00;
l00723407:
			if (eax_81 == 0x00)
			{
				word32 eax_115;
				word32 ecx_114;
				word16 ax_109 = *((word32) dwArg04 + (edi_14 + 0x18));
				if (ax_109 == 0x010B)
				{
					ecx_114 = 0x5C;
					eax_115 = 0x68;
				}
				else
				{
					if (ax_109 != 0x020B)
						goto l007234C5;
					ecx_114 = 0x6C;
					eax_115 = 0x78;
				}
				if (*((word32) dwArg04 + ((ecx_114 + 0x18) + edi_14)) >= 0x02)
				{
					edx_126 = eax_115 + 0x18 + edi_14;
					word32 eax_128 = edx_126 + dwArg04;
					if (Mem23[edx_126 + 0x04 + dwArg04:word32] != 0x00)
					{
						struct Eq_119942 * edi_131 = (word32) dwArg04 + *eax_128 + 0x0C;
						while (edi_131->dw0000 != 0x00)
						{
							Eq_3 esi_139 = (word32) dwArg04 + edi_131->dw0000;
							Eq_3 eax_141 = esi_139;
							edx_126 = (word32) esi_139 + 1;
							do
							{
								eax_141 = (word32) eax_365 + 1;
								eax_365 = eax_141;
							} while (*eax_365 != 0x00);
							if (eax_141 - ((word32) esi_139 + 1) >= 0x06)
							{
								edx_126.u0 = <invalid>;
								if (strncmp(esi_139, 9256664, 0x06) == 0x00)
								{
									ci8 al_179 = *((word32) esi_139 + 6);
									byte * ecx_182 = (word32) esi_139 + 6 + 0x01;
									if (al_179 != 0x00)
									{
										while (al_179 != 0x2E)
										{
											if (al_179 < 0x30 || al_179 > 0x39)
												goto l007234BD;
											al_179 = *ecx_182;
											++ecx_182;
											if (al_179 == 0x00)
												break;
										}
									}
									edxOut = edx_126;
									return esi_139;
								}
							}
l007234BD:
							++edi_131;
						}
					}
				}
			}
l007234C5:
			edxOut = edx_126;
			return 0x00;
		}
		up32 eax_48 = eax_18 - 0x01;
		struct Eq_119867 * ecx_49 = &ecx_19->b0000 + 1;
		edx_126 = (word32) edx_126 + 1;
		if (eax_48 != 0x00)
		{
			esi_44 = *edx_126 - ecx_49->b0000;
			if (esi_44 != 0x00)
				goto l007233F7;
			edx_126 = (word32) edx_126 + 1;
			if (eax_48 != 0x01)
			{
				esi_44 = *((word32) edx_126 + 1) - ecx_49->b0001;
				if (esi_44 != 0x00)
					goto l007233F7;
				edx_126 = (word32) edx_126 + 2;
				if (eax_48 != 0x02)
				{
					esi_44 = *((word32) edx_126 + 2) - ecx_49->b0002;
					if (esi_44 != 0x00)
						goto l007233F7;
				}
			}
		}
	}
	eax_81 = 0x00;
	goto l00723407;
}

// 007234D0: Register word32 fn007234D0(Register Eq_3 edx, Register Eq_3 ebx, Register Eq_3 ebp, Register Eq_3 esi, Register Eq_3 edi, Register (ptr16 Eq_7) es, Register (ptr16 Eq_8) ds, Stack Eq_3 dwArg04)
// Called from:
//      fn00657290
word32 fn007234D0(Eq_3 edx, Eq_3 ebx, Eq_3 ebp, Eq_3 esi, Eq_3 edi, struct Eq_7 * es, struct Eq_8 * ds, Eq_3 dwArg04)
{
	ui32 eax_7 = g_tA14188 ^ fp - 0x010C;
	Eq_3 eax_23 = GetFullPathNameA(dwArg04, 0x0104, fp - 0x0108, fp - 0x010C);
	if (eax_23 != 0x00)
	{
		word32 ecx_107;
		return fn00694B8E(LoadLibraryExA(dwArg04, 0x00, 0x08), eax_7 ^ fp - 0x010C, edx, ebx, ebp, esi, edi, es, ds, esi, out ecx_107);
	}
	else
	{
		word32 ecx_108;
		return fn00694B8E(eax_23, eax_7 ^ fp - 0x010C, edx, ebx, ebp, esi, edi, es, ds, esi, out ecx_108);
	}
}

// 00723540: Register word32 fn00723540(Register Eq_3 ebx, Register Eq_3 ebp, Register Eq_3 esi, Register Eq_3 edi, Register (ptr16 Eq_7) es, Register (ptr16 Eq_8) ds, Stack Eq_3 dwArg0C, Register out Eq_3 edxOut)
// Called from:
//      fn0074F9E0
word32 fn00723540(Eq_3 ebx, Eq_3 ebp, Eq_3 esi, Eq_3 edi, struct Eq_7 * es, struct Eq_8 * ds, Eq_3 dwArg0C, union Eq_3 & edxOut)
{
	ui32 eax_7 = g_tA14188 ^ fp - 776;
	fn00724FE0(fp - 0x0108, 0x0102, &g_b8D9BC8);
	Eq_3 ebp_45;
	Eq_3 ebx_46;
	Eq_3 eax_44 = fn00657290(ebx, ebp, dwArg0C, edi, es, ds, dwArg0C, 0x00, out ebx_46, out ebp_45);
	if (eax_44 != 0x00)
	{
		fn00724FE0(fp - 776, 0x0100, &g_b8D9B80);
		Eq_3 edx_83;
		byte * eax_81 = fn00723370(eax_44, out edx_83);
		if (eax_81 == null || fn00723330(fp - 776, eax_81) == 0x00)
		{
			word32 ecx_442;
			word32 eax_132 = fn00694B8E(GetProcAddress(eax_44, fp - 0x0108), eax_7 ^ fp - 776, edx_83, ebx_46, ebp_45, esi, edi, es, ds, esi, out ecx_442);
			edxOut = edx_83;
			return eax_132;
		}
		else
		{
			fn00724FE0(fp - 776, 0x0100, &g_b8D9B44);
			Eq_3 edx_166;
			word32 ecx_443;
			fn006E0F80(g_tA16F8C, fp - 776, out ecx_443, out edx_166);
			FreeLibrary(eax_44);
			word32 ecx_444;
			word32 eax_183 = fn00694B8E(0x00, eax_7 ^ fp - 776, edx_166, ebx_46, ebp_45, esi, edi, es, ds, esi, out ecx_444);
			edxOut = edx_166;
			return eax_183;
		}
	}
	else
	{
		Eq_3 eax_210 = FormatMessageA(0x1000, null, GetLastError(), 0x00, fp - 0x0208, 0x0100, null);
		if (eax_210 == 0x00)
			fn00724FE0(fp - 776, 0x0100, &g_b8D9BA4);
		else
		{
			if (eax_210 >= 0x02)
			{
				word32 eax_218 = fp - 0x0208 + eax_210;
				if (Mem209[fp - 522 + eax_210:byte] == 0x0D && eax_218->bFFFFFFFF == 0x0A)
					eax_218->bFFFFFFFE = 0x00;
			}
			byte * eax_233 = fp - 776;
			do
			{
				eax_233 = eax_445 + 1;
				eax_445 = eax_233;
			} while (*eax_445 != 0x00);
			const char * eax_245 = eax_233 - (fp - (const char *) 775);
			strncpy(fp - 776 + eax_245, fp - 0x0208, 0x0100 - eax_245);
		}
		Eq_3 edx_322;
		word32 ecx_440;
		fn006E0F80(g_tA16F8C, fp - 776, out ecx_440, out edx_322);
		word32 ecx_441;
		word32 eax_333 = fn00694B8E(0x00, eax_7 ^ fp - 776, edx_322, ebx_46, ebp_45, esi, edi, es, ds, esi, out ecx_441);
		edxOut = edx_322;
		return eax_333;
	}
}

// 00723740: Register Eq_3 fn00723740(Register out Eq_3 ecxOut, Register out (ptr32 Eq_120237) edxOut)
// Called from:
//      fn00723860
Eq_3 fn00723740(union Eq_3 & ecxOut, struct Eq_120237 & edxOut)
{
	Eq_3 esi_10 = g_tA6DBC8;
	if (esi_10 == 0x00)
	{
		Eq_3 edi_21;
		Eq_3 ebx_17 = g_tA6DBC4;
		if (ebx_17 != 0x00)
		{
			edi_21 = ebx_17 * 0x02;
			if (ebx_17 * 0x02 <= ebx_17 || ebx_17 * 0x02 > 0x09249249)
				goto l00723810;
		}
		else
			edi_21.u0 = 0x10;
		ecx = g_tA6DBC0;
		Eq_3 eax_39 = realloc(ecx, (edi_21 * 0x08 - edi_21) * 0x04);
		if (eax_39 == 0x00)
		{
l00723810:
			ecxOut = ecx;
			edxOut = edx;
			return 0x00;
		}
		g_tA6DBC0 = eax_39;
		Eq_3 edx_47 = ebx_17;
		if (ebx_17 < edi_21)
		{
			Eq_3 ebp_56 = edi_21 - 0x01;
			ecx = (word32) eax_39 + 20 + (ebx_17 * 0x08 - ebx_17) * 0x04;
			do
			{
				ptr32 esi_64;
				*((word32) ecx - 20) = 0x00;
				if (edx_47 < ebp_56)
					esi_64 = (word32) ecx + 8;
				else
					esi_64 = 0x00;
				*ecx = esi_64;
				edx_47 = (word32) edx_47 + 1;
				ecx = (word32) ecx + 28;
			} while (edx_47 < edi_21);
		}
		edx = ebx_17 * 0x08 - ebx_17;
		g_tA6DBC4 = edi_21;
		esi_10 = (word32) eax_39 + edx * 0x04;
	}
	Eq_3 ebx_96 = *((word32) esi_10 + 20);
	g_tA6DBC8 = ebx_96;
	Eq_3 eax_103 = malloc(0x00040000);
	*esi_10 = eax_103;
	word32 * edi_97 = (word32) esi_10 + 20;
	if (eax_103 != 0x00)
	{
		++g_dwA6DBD0;
		((word32) esi_10 + 16)->u0 = 0x00;
		*((word32) esi_10 + 4) = eax_103;
		((word32) esi_10 + 8)->u0 = 0x40;
		if ((eax_103 & 0x0FFF) != 0x00)
		{
			((word32) esi_10 + 8)->u0 = 0x3F;
			*((word32) esi_10 + 4) = eax_103 - (eax_103 & 0x0FFF) + 0x1000;
		}
		*((word32) esi_10 + 0x0C) = *((word32) esi_10 + 8);
		ecxOut = eax_103 & 0x0FFF;
		edxOut = edx;
		return esi_10;
	}
	*edi_97 = (word32) ebx_96;
	g_tA6DBC8 = esi_10;
	goto l00723810;
}

// 00723860: Register Eq_3 fn00723860(Stack Eq_3 dwArg04, Register out Eq_3 ecxOut, Register out Eq_3 edxOut)
// Called from:
//      fn006DDD80
//      fn006EA9D0
//      fn006EC9B0
//      fn006ECAC0
//      fn006F1AA0
//      fn006F2090
//      fn006FEEB0
//      fn007105C0
//      fn00710690
//      fn00710CB0
//      fn00711280
//      fn00711330
//      fn00711400
//      fn00711F50
//      fn007120F0
//      fn00723B60
//      fn00727340
//      fn00727380
//      fn007273D0
//      fn00727420
//      fn007279E0
//      fn00727D50
//      fn00728650
//      fn00728E40
//      fn00729300
//      fn00729810
//      fn00729F50
//      fn0072CC90
//      fn0072CEE0
//      fn0072D130
//      fn0072D3D0
//      fn0072DD60
//      fn0072E920
//      fn007331D0
//      fn00734BB0
//      fn007379B0
//      fn0073B660
//      fn0073E590
//      fn007406A0
//      fn007514B0
//      fn00752DC0
//      fn00755020
Eq_3 fn00723860(Eq_3 dwArg04, union Eq_3 & ecxOut, union Eq_3 & edxOut)
{
	Eq_3 eax_134;
	Eq_3 edi_13 = dwArg04;
	if (dwArg04 < 0x0101)
	{
		Eq_3 eax_17 = dwArg04 - 0x01 >> 0x03;
		ecx = g_aA23BE0[eax_17];
		edx = *((word32) ecx + 8);
		if (ecx != edx)
		{
			eax_134 = *((word32) ecx + 4);
			*ecx = (word32) *ecx + 1;
			Eq_3 esi_137 = *eax_134;
			*((word32) ecx + 4) = esi_137;
			if (esi_137 == 0x00)
			{
				Eq_3 esi_150 = *((word32) ecx + 24);
				if (esi_150 > *((word32) ecx + 28))
				{
					Eq_3 ecx_153 = *((word32) ecx + 0x0C);
					*((word32) edx + 0x0C) = ecx_153;
					*((word32) ecx_153 + 8) = edx;
					ecxOut = ecx_153;
					edxOut = edx;
					return eax_134;
				}
				else
				{
					Mem163[ecx + 0x04:word32] = esi_150 + ecx;
					Eq_3 edx_164 = (word32) esi_150 + 8 + eax_17 * 0x08;
					*((word32) ecx + 24) = edx_164;
					Eq_3 ecx_168 = *((word32) ecx + 4);
					ecx_168->u0 = 0x00;
					ecxOut = ecx_168;
					edxOut = edx_164;
					return eax_134;
				}
			}
			goto l007239B9;
		}
		Eq_3 esi_23 = g_tA6DBCC;
		if (esi_23 != 0x00)
		{
l007238F7:
			Eq_3 ecx_56 = *((word32) esi_23 + 16);
			if (ecx_56 != 0x00)
				*((word32) esi_23 + 16) = *((word32) ecx_56 + 8);
			else
			{
				Eq_120487 edi_62 = esi_23 - g_tA6DBC0;
				int32 edx_66 = (word32) edi_62 + SLICE(edi_62 *s64 0x92492493, word32, 32);
				ecx_56 = *((word32) esi_23 + 4);
				*((word32) ecx_56 + 16) = (edx_66 >> 0x04 >> 0x1F) + (edx_66 >> 0x04);
				((word32) ecx_56 + 20)->u0 = 0xFFFF;
				*((word32) esi_23 + 4) = (word32) *((word32) esi_23 + 4) + 0x00001000;
			}
			Eq_3 v15_80 = (word32) *((word32) esi_23 + 8) - 1;
			*((word32) esi_23 + 8) = v15_80;
			if (v15_80 == 0x00)
			{
				Eq_3 esi_84 = *((word32) esi_23 + 20);
				g_tA6DBCC = esi_84;
				if (esi_84 != 0x00)
					((word32) esi_84 + 24)->u0 = 0x00;
			}
			Eq_3 eax_94 = g_aA23BE0[eax_17];
			*((word32) ecx_56 + 8) = eax_94;
			*((word32) ecx_56 + 0x0C) = eax_94;
			*((word32) eax_94 + 8) = ecx_56;
			*((word32) eax_94 + 0x0C) = ecx_56;
			ecx_56->u0 = 0x01;
			if (*((word32) ecx_56 + 20) != eax_17)
			{
				ui32 edx_104 = eax_17 * 0x08 + 0x08;
				*((word32) ecx_56 + 24) = edx_104 + 0x20 + edx_104;
				*((word32) ecx_56 + 28) = 0x1000 - edx_104;
				*((word32) ecx_56 + 20) = eax_17;
				Eq_3 eax_109 = (word32) ecx_56 + 32;
				Eq_3 edx_116 = (word32) eax_109 + edx_104;
				*((word32) ecx_56 + 4) = edx_116;
				edx_116->u0 = 0x00;
				ecxOut = ecx_56;
				edxOut = edx_116;
				return eax_109;
			}
			else
			{
				Eq_3 eax_125 = *((word32) ecx_56 + 4);
				Eq_3 edx_126 = *eax_125;
				*((word32) ecx_56 + 4) = edx_126;
				ecxOut = ecx_56;
				edxOut = edx_126;
				return eax_125;
			}
		}
		Eq_3 eax_27 = fn00723740(out ecx, out edx);
		g_tA6DBCC = eax_27;
		esi_23 = eax_27;
		if (eax_27 != 0x00)
		{
			((word32) eax_27 + 24)->u0 = 0x00;
			((word32) eax_27 + 20)->u0 = 0x00;
			goto l007238F7;
		}
	}
	if (dwArg04 == 0x00)
		edi_13.u0 = 0x01;
	eax_134 = malloc(edi_13);
l007239B9:
	ecxOut = ecx;
	edxOut = edx;
	return eax_134;
}

// 007239C0: Register Eq_3 fn007239C0(Stack Eq_3 dwArg04, Register out Eq_3 ecxOut, Register out Eq_3 edxOut)
// Called from:
//      fn006E8430
//      fn006EC4F0
//      fn006FEFD0
//      fn00717740
//      fn0071F9C0
//      fn00723B60
//      fn00727170
//      fn0072A350
//      fn0072E790
//      fn00737950
//      fn007379B0
//      fn0073B790
//      fn0073B7F0
//      fn0073E590
//      fn007406A0
//      fn00752DC0
Eq_3 fn007239C0(Eq_3 dwArg04, union Eq_3 & ecxOut, union Eq_3 & edxOut)
{
	Eq_3 ecx_164 = dwArg04;
	if (dwArg04 == 0x00)
	{
l00723AA9:
		ecxOut = ecx_164;
		edxOut = edx;
		return eax;
	}
	else
	{
		eax = dwArg04 & ~0x0FFF;
		Eq_3 edx_11 = (dwArg04 & ~0x0FFF)->t0010;
		if (edx_11 < g_tA6DBC4)
		{
			Eq_3 esi_20 = g_tA6DBC0;
			edx_11 = *((word32) esi_20 + (edx_11 * 0x08 - edx_11) * 0x04);
			if (dwArg04 - edx_11 < 0x00040000 && edx_11 != 0x00)
			{
				edx = (dwArg04 & ~0x0FFF)->t0004;
				*dwArg04 = edx;
				(dwArg04 & ~0x0FFF)->t0004 = dwArg04;
				if (edx == 0x00)
				{
					*(dwArg04 & ~0x0FFF) += ~0x00;
					Eq_3 ecx_49 = g_aA23BE0[(dwArg04 & ~0x0FFF)->dw0014];
					Eq_3 edx_50 = *((word32) ecx_49 + 0x0C);
					(dwArg04 & ~0x0FFF)->t0008 = ecx_49;
					(dwArg04 & ~0x0FFF)->t000C = edx_50;
					*((word32) ecx_49 + 0x0C) = dwArg04 & ~0x0FFF;
					*((word32) edx_50 + 8) = dwArg04 & ~0x0FFF;
					ecxOut = ecx_49;
					edxOut = edx_50;
					return dwArg04 & ~0x0FFF;
				}
				word32 v12_59 = *(dwArg04 & ~0x0FFF) + ~0x00;
				*(dwArg04 & ~0x0FFF) = v12_59;
				if (v12_59 == 0x00)
				{
					struct Eq_120714 * ecx_63 = (dwArg04 & ~0x0FFF)->ptr0008;
					struct Eq_120719 * edx_64 = (dwArg04 & ~0x0FFF)->ptr000C;
					ecx_63->ptr000C = edx_64;
					edx_64->ptr0008 = ecx_63;
					ui32 ecx_67 = (dwArg04 & ~0x0FFF)->dw0010;
					edx = ecx_67 * 0x08 - ecx_67;
					(dwArg04 & ~0x0FFF)->t0008 = *((word32) esi_20 + (edx * 0x04 + 16));
					Eq_3 esi_71 = (word32) esi_20 + edx * 0x04;
					*((word32) esi_71 + 8) = (word32) *((word32) esi_71 + 8) + 1;
					ecx_164 = *((word32) esi_71 + 8);
					*((word32) esi_71 + 16) = dwArg04 & ~0x0FFF;
					if (ecx_164 == *((word32) esi_71 + 0x0C))
					{
						Eq_3 eax_145 = *((word32) esi_71 + 24);
						if (eax_145 == 0x00)
						{
							edx = *((word32) esi_71 + 20);
							g_tA6DBCC = edx;
						}
						else
							*((word32) eax_145 + 20) = *((word32) esi_71 + 20);
						Eq_3 eax_155 = *((word32) esi_71 + 20);
						if (eax_155 != 0x00)
						{
							edx = *((word32) esi_71 + 24);
							*((word32) eax_155 + 24) = edx;
						}
						eax = g_tA6DBC8;
						ecx_164 = *esi_71;
						*((word32) esi_71 + 20) = eax;
						g_tA6DBC8 = esi_71;
						free(ecx_164);
						--g_dwA6DBD0;
						esi_71->u0 = 0x00;
					}
					else
					{
						if (ecx_164 == 0x01)
						{
							Eq_3 eax_130 = g_tA6DBCC;
							*((word32) esi_71 + 20) = eax_130;
							((word32) esi_71 + 24)->u0 = 0x00;
							if (eax_130 != 0x00)
								*((word32) eax_130 + 24) = esi_71;
							g_tA6DBCC = esi_71;
							ecxOut = ecx_164;
							edxOut = edx;
							return eax_130;
						}
						eax = *((word32) esi_71 + 20);
						if (eax != 0x00 && ecx_164 > *((word32) eax + 8))
						{
							Eq_3 edx_88 = *((word32) esi_71 + 24);
							if (edx_88 != 0x00)
								*((word32) edx_88 + 20) = eax;
							else
								g_tA6DBCC = eax;
							edx = *((word32) esi_71 + 20);
							*((word32) edx + 24) = *((word32) esi_71 + 24);
							if (*((word32) esi_71 + 20) != 0x00)
							{
								do
								{
									Eq_3 eax_105 = *((word32) esi_71 + 20);
									if (ecx_164 <= *((word32) eax_105 + 8))
										break;
									*((word32) esi_71 + 24) = eax_105;
									edx = *((word32) eax_105 + 20);
									*((word32) esi_71 + 20) = edx;
								} while (edx != 0x00);
							}
							*((word32) *((word32) esi_71 + 24) + 20) = esi_71;
							eax = *((word32) esi_71 + 20);
							if (eax != 0x00)
							{
								*((word32) eax + 24) = esi_71;
								ecxOut = ecx_164;
								edxOut = edx;
								return eax;
							}
						}
					}
				}
				goto l00723AA9;
			}
		}
		free(dwArg04);
		ecxOut = dwArg04;
		edxOut = edx_11;
		return dwArg04 & ~0x0FFF;
	}
}

// 00723B60: Register Eq_3 fn00723B60(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Register out Eq_3 ecxOut, Register out Eq_68913 edxOut)
// Called from:
//      fn006EC4F0
//      fn006FEF90
//      fn00727420
//      fn0073B6B0
Eq_3 fn00723B60(Eq_3 dwArg04, Eq_3 dwArg08, union Eq_3 & ecxOut, union Eq_68913 & edxOut)
{
	if (dwArg04 == 0x00)
	{
		Eq_3 ecx_129;
		Eq_68913 edx_130;
		Eq_3 eax_128 = fn00723860(dwArg08, out ecx_129, out edx_130);
		ecxOut = ecx_129;
		edxOut = edx_130;
		return eax_128;
	}
	Eq_3 eax_118;
	Eq_3 ecx_13 = (dwArg04 & ~0x0FFF)->t0010;
	if (ecx_13 < g_tA6DBC4)
	{
		ecx_13 = *((word32) g_tA6DBC0 + (ecx_13 * 0x08 - ecx_13) * 0x04);
		edx = dwArg04 - ecx_13;
		if (edx < 0x00040000 && ecx_13 != 0x00)
		{
			Eq_3 edi_60 = (dwArg04 & ~0x0FFF)->dw0014 * 0x08 + 0x08;
			if (dwArg08 <= edi_60)
			{
				ecx_13 = edi_60 * 0x03;
				edx = dwArg08 * 0x04;
				if (dwArg08 * 0x04 > edi_60 * 0x03)
				{
					eax_118 = dwArg04;
					goto l00723BD0;
				}
				edi_60 = dwArg08;
			}
			Eq_3 ecx_177;
			Eq_68913 edx_101;
			Eq_3 eax_76 = fn00723860(dwArg08, out ecx_177, out edx_101);
			if (eax_76 != 0x00)
			{
				memcpy(eax_76, dwArg04, edi_60);
				fn007239C0(dwArg04, out ecx_177, out edx_101);
			}
			ecxOut = ecx_177;
			edxOut = edx_101;
			return eax_76;
		}
	}
	if (dwArg08 != 0x00)
	{
		Eq_3 eax_50 = realloc(dwArg04, dwArg08);
		ecxOut = ecx_13;
		edxOut = edx;
		return eax_50;
	}
	eax_118 = realloc(dwArg04, 0x01);
	if (eax_118 == 0x00)
	{
		ecxOut = ecx_13;
		edxOut = edx;
		return dwArg04;
	}
l00723BD0:
	ecxOut = ecx_13;
	edxOut = edx;
	return eax_118;
}

<anonymous> g_t724880 = <code>; // 00724880
// 00724FB0: Register word32 fn00724FB0(Stack ptr32 dwArg04, Stack int32 dwArg08, Stack word32 dwArg0C, Stack Eq_3 dwArg10)
// Called from:
//      fn00716A00
word32 fn00724FB0(ptr32 dwArg04, int32 dwArg08, word32 dwArg0C, Eq_3 dwArg10)
{
	word32 eax_24;
	vsnprintf();
	dwArg04 - 0x01 + dwArg08 = (byte *) 0x00;
	return eax_24;
}

// 00724FE0: Register word32 fn00724FE0(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Stack (ptr32 byte) dwArg0C)
// Called from:
//      fn006E5590
//      fn006E5710
//      fn006E5920
//      fn006E5C60
//      fn006E7660
//      fn006E8060
//      fn006FF4A0
//      fn00723540
//      fn007272E0
//      fn00727910
//      fn0072F830
//      fn0073BBE0
//      fn00747960
//      fn00748310
//      fn00748E50
//      fn0074F280
word32 fn00724FE0(Eq_3 dwArg04, Eq_3 dwArg08, byte * dwArg0C)
{
	word32 ecx_24;
	vsnprintf();
	*((word32) dwArg08 + (dwArg04 - 0x01)) = 0x00;
	return ecx_24;
}

// 00725010: Register Eq_3 fn00725010(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08)
// Called from:
//      fn00708DC0
Eq_3 fn00725010(Eq_3 dwArg04, Eq_3 dwArg08)
{
	word32 edx_331;
	word32 ecx_330;
	Eq_3 eax_13 = fn006FEF30(&g_tA249B8, out ecx_330, out edx_331);
	if (eax_13 == 0x00)
		return 0x00;
	Eq_3 edi_112;
	((word32) eax_13 + 36)->u0 = 0x00;
	*dwArg04 = (word32) *dwArg04 + 1;
	*((word32) eax_13 + 8) = dwArg04;
	*dwArg08 = (word32) *dwArg08 + 1;
	*((word32) eax_13 + 0x0C) = dwArg08;
	Eq_3 ecx_42 = *((word32) dwArg04 + 52);
	*((word32) eax_13 + 28) = ecx_42;
	*ecx_42 = (word32) *ecx_42 + 1;
	((word32) eax_13 + 16)->u0 = 0x00;
	((word32) eax_13 + 20)->u0 = 0x00;
	Eq_3 edi_52 = *((word32) dwArg04 + 28);
	word32 edx_333;
	word32 ecx_332;
	if (fn006DFE20(edi_52, out ecx_332, out edx_333) < 0x01)
	{
l007250A8:
		edi_112.u0 = 0x00A163B8;
		goto l007250AD;
	}
	else
	{
		Eq_3 eax_69 = fn006DFE60(edi_52, 0x00);
		edi_112 = eax_69;
		Eq_3 eax_75 = *((word32) eax_69 + 4);
		if (eax_75 != 0x00A1B450)
		{
			word32 ecx_334;
			word32 edx_335;
			if (fn006D5670(eax_75, 0x00A1B450, out ecx_334, out edx_335) == 0x00)
			{
				Eq_3 eax_94 = *((word32) eax_69 + 4);
				if (eax_94 != 0x00A23B20)
				{
					word32 ecx_336;
					word32 edx_337;
					if (fn006D5670(eax_94, 0x00A23B20, out ecx_336, out edx_337) == 0x00)
						goto l007250A8;
				}
			}
		}
l007250AD:
		*edi_112.u0 = (word32) *edi_112.u0 + 1;
		Eq_3 eax_118 = g_tA6DBD4;
		*((word32) eax_13 + 24) = edi_112;
		*((word32) eax_13 + 32) = null;
		((word32) eax_13 + 40)->u0 = 0x00;
		if (eax_118 == 0x00)
		{
			word32 ecx_340;
			word32 edx_341;
			eax_118 = fn006F1A70(out ecx_340, out edx_341);
			g_tA6DBD4 = eax_118;
			if (eax_118 == 0x00)
			{
				word32 v18_206 = (word32) *eax_13 - 1;
				*eax_13 = v18_206;
				if (v18_206 == 0x00)
				{
					Eq_3 eax_210 = *((word32) eax_13 + 4);
					(*((word32) eax_210 + 24))();
				}
				return 0x00;
			}
		}
		word32 edx_339;
		word32 ecx_338;
		Eq_3 eax_158 = fn006FBCC0(dwArg08, eax_118, out ecx_338, out edx_339);
		if (eax_158 != 0x00)
		{
			*eax_158 = (word32) *eax_158 + 1;
			*((word32) eax_13 + 40) = eax_158;
		}
		if (*((word32) eax_13 - 8) != ~0x01)
			fn006E86F0(0x008D0E04);
		*((word32) eax_13 - 8) = ~0x02;
		*((word32) eax_13 - 16) = g_tA1D558;
		Eq_3 eax_190 = *((word32) g_tA1D558 + 4);
		*((word32) eax_13 - 0x0C) = eax_190;
		*eax_190 = eax_13 - 0x10;
		*((word32) g_tA1D558 + 4) = eax_13 - 0x10;
		return eax_13;
	}
}

// 00725150: Register word32 fn00725150(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08)
// Called from:
//      fn00708DC0
word32 fn00725150(Eq_3 dwArg04, Eq_3 dwArg08)
{
	if (*((word32) dwArg04 + 4) != 0x00A249B8)
	{
		word32 edx_184;
		fn006E1DC0(out edx_184);
		return ~0x00;
	}
	Eq_3 esi_13 = dwArg08;
	if (dwArg08 == 0x00A163B8)
	{
		esi_13.u0 = 0x00;
		goto l007251A6;
	}
	if (dwArg08 != 0x00)
	{
		Eq_3 eax_19 = *((word32) dwArg08 + 4);
		if (eax_19 == 0x00A16588)
		{
l007251A3:
			*dwArg08 = (word32) *dwArg08 + 1;
l007251A6:
			Eq_3 eax_72 = *((word32) dwArg04 + 16);
			if (eax_72 != 0x00)
			{
				*eax_72 = (word32) *eax_72 - 1;
				Eq_3 eax_78 = *((word32) dwArg04 + 16);
				if (*eax_78 == 0x00)
				{
					Eq_3 ecx_81 = *((word32) eax_78 + 4);
					word32 edx_93;
					(*((word32) ecx_81 + 24))();
				}
			}
			*((word32) dwArg04 + 16) = esi_13;
			return 0x00;
		}
		word32 ecx_187;
		word32 edx_188;
		if (fn006D5670(eax_19, 0x00A16588, out ecx_187, out edx_188) != 0x00)
			goto l007251A3;
	}
	word32 ecx_185;
	word32 edx_186;
	fn006E0F80(g_tA18720, 9282148, out ecx_185, out edx_186);
	return ~0x00;
}

// 007251F0: Register word32 fn007251F0(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08)
// Called from:
//      fn00708DC0
word32 fn007251F0(Eq_3 dwArg04, Eq_3 dwArg08)
{
	if (*((word32) dwArg04 + 4) == 0x00A249B8)
	{
		Eq_3 esi_13 = dwArg08;
		if (dwArg08 == 0x00A163B8)
			esi_13.u0 = 0x00;
		else
		{
			Eq_3 eax_16 = *((word32) dwArg08 + 4);
			if (eax_16 != 0x00A16588)
			{
				word32 ecx_178;
				word32 edx_179;
				if (fn006D5670(eax_16, 0x00A16588, out ecx_178, out edx_179) == 0x00)
				{
					word32 ecx_180;
					word32 edx_181;
					fn006E15D0(g_tA18720, 9282172, out ecx_180, out edx_181);
					return ~0x00;
				}
			}
			*dwArg08 = (word32) *dwArg08 + 1;
		}
		Eq_3 eax_68 = *((word32) dwArg04 + 20);
		if (eax_68 != 0x00)
		{
			*eax_68 = (word32) *eax_68 - 1;
			Eq_3 eax_74 = *((word32) dwArg04 + 20);
			if (*eax_74 == 0x00)
			{
				Eq_3 ecx_77 = *((word32) eax_74 + 4);
				word32 edx_89;
				(*((word32) ecx_77 + 24))();
			}
		}
		*((word32) dwArg04 + 20) = esi_13;
		return 0x00;
	}
	else
	{
		word32 edx_177;
		fn006E1DC0(out edx_177);
		return ~0x00;
	}
}

// 00725DA0: Register Eq_3 fn00725DA0(Stack Eq_3 dwArg04, Register out Eq_3 ecxOut, Register out Eq_3 edxOut)
// Called from:
//      fn00704B00
Eq_3 fn00725DA0(Eq_3 dwArg04, union Eq_3 & ecxOut, union Eq_3 & edxOut)
{
	word32 edx_135;
	if (fn00704700(dwArg04, out edx_135) != 0x00)
	{
		Eq_3 ecx_27;
		Eq_3 edx_28;
		Eq_3 eax_26 = fn006FEF30(&g_tA250F8, out ecx_27, out edx_28);
		if (eax_26 != 0x00)
		{
			((word32) eax_26 + 8)->u0 = 0x00;
			*dwArg04 = (word32) *dwArg04 + 1;
			*((word32) eax_26 + 0x0C) = dwArg04;
			if (*((word32) eax_26 - 8) != ~0x01)
				fn006E86F0(0x008D0E04);
			*((word32) eax_26 - 8) = ~0x02;
			*((word32) eax_26 - 16) = g_tA1D558;
			Eq_3 ecx_56 = g_tA1D558;
			Eq_3 eax_57 = *((word32) ecx_56 + 4);
			*((word32) eax_26 - 0x0C) = eax_57;
			*eax_57 = eax_26 - 0x10;
			Eq_3 edx_60 = g_tA1D558;
			*((word32) edx_60 + 4) = eax_26 - 0x10;
			ecxOut = ecx_56;
			edxOut = edx_60;
			return eax_26;
		}
		else
		{
			ecxOut = ecx_27;
			edxOut = edx_28;
			return eax_26;
		}
	}
	else
	{
		Eq_3 edx_80;
		ecxOut = fn006E1DC0(out edx_80);
		edxOut = edx_80;
		return 0x00;
	}
}

// 00726150: Register Eq_3 fn00726150(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Register out (ptr32 byte) edxOut)
// Called from:
//      fn00728FE0
//      fn00729510
//      fn00729810
//      fn00729D20
//      fn0072A740
//      fn0072A940
//      fn0072AC20
//      fn0072B830
//      fn0072BF10
//      fn0072C160
//      fn0072C510
//      fn0072DD60
//      fn00748140
//      fn00748190
Eq_3 fn00726150(Eq_3 dwArg04, Eq_3 dwArg08, byte & edxOut)
{
	word32 esi_344;
	word32 ecx_343;
	byte * edx_18;
	Eq_3 eax_17 = fn006ECC50(dwArg08, out ecx_343, out edx_18, out esi_344);
	if (dwArg04 != 0x00)
	{
		Eq_3 eax_28 = *((word32) dwArg04 + 4);
		if (eax_28 == 0x00A1B450)
		{
l0072618E:
			if (eax_17 != 0x00 && (*eax_17 == 0x5F && *((word32) eax_17 + 1) == 0x5F))
			{
				word32 ecx_346;
				word32 edx_347;
				word32 esi_348;
				Eq_3 eax_79 = fn006ECC50(dwArg04, out ecx_346, out edx_347, out esi_348);
				Eq_3 ebp_109 = eax_79;
				Eq_3 eax_85 = eax_17;
				do
				{
					eax_85 = (word32) eax_350 + 1;
					eax_350 = eax_85;
				} while (*eax_350 != 0x00);
				int32 eax_98 = eax_85 - ((word32) eax_17 + 1);
				if (*((word32) eax_17 + (eax_98 - 0x01)) != 0x5F || *((word32) eax_17 + (eax_98 - 0x02)) != 0x5F)
				{
					if (*eax_79 == 0x5F)
					{
						do
							ebp_109 = (word32) ebp_109 + 1;
						while (*ebp_109 == 0x5F);
					}
					if (*ebp_109 != 0x00)
					{
						Eq_3 ecx_118 = ebp_109;
						byte * esi_119 = (word32) ebp_109 + 1;
						do
						{
							ecx_118 = (word32) ecx_351 + 1;
							ecx_351 = ecx_118;
						} while (*ecx_351 != 0x00);
						Eq_3 ecx_133 = ecx_118 - esi_119;
						byte * edx_162;
						word32 ecx_349;
						Eq_3 eax_161 = fn006EC9B0(0x00, (word32) ecx_133 + 1 + eax_98, out ecx_349, out edx_162);
						if (eax_161 != 0x00)
						{
							((word32) eax_161 + 20)->u0 = 0x5F;
							strncpy((word32) eax_161 + 21, ebp_109, ecx_133);
							Eq_3 eax_182 = eax_17;
							word32 edx_183 = eax_161 + 0x15 + ecx_133 - eax_17;
							do
							{
								byte cl_187 = *eax_182;
								Mem189[edx_183 + eax_182:byte] = cl_187;
								eax_182 = (word32) eax_182 + 1;
							} while (cl_187 != 0x00);
							edxOut = edx_183;
							return eax_161;
						}
						else
						{
							edxOut = edx_162;
							return eax_161;
						}
					}
				}
				*dwArg08 = (word32) *dwArg08 + 1;
				edxOut = (word32) eax_17 + 1;
				return dwArg08;
			}
			goto l00726255;
		}
		word32 ecx_345;
		if (fn006D5670(eax_28, 0x00A1B450, out ecx_345, out edx_18) != 0x00)
			goto l0072618E;
	}
l00726255:
	*dwArg08 = (word32) *dwArg08 + 1;
	edxOut = edx_18;
	return dwArg08;
}

// 00726260: Register Eq_3 fn00726260(Stack Eq_3 dwArg04)
// Called from:
//      fn00728E40
Eq_3 fn00726260(Eq_3 dwArg04)
{
	word32 ecx_347;
	word32 edx_348;
	Eq_3 eax_12 = fn006FDCC0(out ecx_347, out edx_348);
	if (eax_12 == 0x00)
		return eax_12;
	struct Eq_121636 * esp_115 = fp - 0x14;
	word32 ecx_349;
	word32 edx_350;
	if (fn006F2750(dwArg04, out ecx_349, out edx_350) > 0x00)
	{
		Eq_3 ebx_218 = 0x00;
		do
		{
			struct Eq_121662 * esp_45 = esp_115 - 4;
			esp_45->t0000 = ebx_218;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg4 = <invalid>;
			word32 ecx_361;
			word32 edx_362;
			Eq_3 eax_55 = fn007050A0(stackArg4, out ecx_361, out edx_362);
			esp_115 = (struct Eq_121636 *) ((const char *) &esp_45->t0000 + 4);
			if (eax_55 == 0x00)
			{
l00726326:
				word32 v16_142 = (word32) *eax_12 - 1;
				*eax_12 = v16_142;
				if (v16_142 == 0x00)
				{
					Eq_3 eax_146 = *((word32) eax_12 + 4);
					<anonymous> * ecx_147 = *((word32) eax_146 + 24);
					esp_115->dwFFFFFFFC = (word32) eax_12;
					ecx_147();
				}
				return 0x00;
			}
			Eq_3 eax_66 = esp_45->ptr001C->ptr000C[ebx_218];
			esp_45->t0000 = *((word32) eax_66 + 4);
			esp_45->tFFFFFFFC = eax_66;
			esp_45->tFFFFFFF8.u0 = 0x02;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg4 = <invalid>;
			word32 edx_353;
			word32 esi_354;
			word32 ecx_352;
			Eq_3 eax_76 = fn006DFF80(stackArg4, out ecx_352, out edx_353, out esi_354);
			esp_115 = (struct Eq_121636 *) ((const char *) &esp_45->t0000 + 4);
			if (eax_76 == 0x00)
			{
l00726315:
				word32 v19_119 = (word32) *eax_55 - 1;
				*eax_55 = v19_119;
				if (v19_119 == 0x00)
				{
					Eq_3 ecx_123 = *((word32) eax_55 + 4);
					<anonymous> * edx_124 = *((word32) ecx_123 + 24);
					esp_115->dwFFFFFFFC = (word32) eax_55;
					word32 esp_132;
					edx_124();
					esp_115 = esp_132 + 0x04;
				}
				goto l00726326;
			}
			esp_45->t0000 = eax_55;
			esp_45->tFFFFFFFC = eax_76;
			esp_45->tFFFFFFF8 = eax_12;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg4 = <invalid>;
			Eq_3 stackArg12 = <invalid>;
			esp_115 = (struct Eq_121636 *) ((const char *) &esp_45->t0000 + 4);
			word32 ecx_92;
			word32 edx_357;
			word32 edi_359;
			word32 ebx_358;
			if (fn006FBD90(stackArg4, dwArg04, stackArg12, out ecx_92, out edx_357, out ebx_358, out edi_359) < 0x00)
			{
				word32 v17_101 = (word32) *eax_76 - 1;
				*eax_76 = v17_101;
				if (v17_101 == 0x00)
				{
					Eq_3 edx_105 = *((word32) eax_76 + 4);
					<anonymous> * eax_106 = *((word32) edx_105 + 24);
					esp_45->t0000 = eax_76;
					word32 esp_109;
					eax_106();
					esp_115 = esp_109 + 0x04;
				}
				goto l00726315;
			}
			word32 v15_178 = (word32) *eax_76 - 1;
			*eax_76 = v15_178;
			if (v15_178 == 0x00)
			{
				Eq_3 edx_182 = *((word32) eax_76 + 4);
				<anonymous> * eax_183 = *((word32) edx_182 + 24);
				esp_45->t0000 = eax_76;
				word32 esp_186;
				eax_183();
				esp_115 = esp_186 + 0x04;
			}
			word32 v18_196 = (word32) *eax_55 - 1;
			*eax_55 = v18_196;
			if (v18_196 == 0x00)
			{
				Eq_3 ecx_200 = *((word32) eax_55 + 4);
				<anonymous> * edx_201 = *((word32) ecx_200 + 24);
				esp_115->dwFFFFFFFC = (word32) eax_55;
				word32 esp_209;
				edx_201();
				esp_115 = esp_209 + 0x04;
			}
			ebx_218 = (word32) ebx_218 + 1;
		} while (ebx_218 < esp_115[4]);
	}
	return eax_12;
}

// 00726340: Register Eq_3 fn00726340(Stack Eq_3 dwArg04, Stack Eq_3 dwArg10)
// Called from:
//      fn00728E40
Eq_3 fn00726340(Eq_3 dwArg04, Eq_3 dwArg10)
{
	Eq_3 ebp_12 = dwArg10;
	word32 ecx_443;
	word32 edx_444;
	Eq_3 eax_15 = fn006FDCC0(out ecx_443, out edx_444);
	if (eax_15 == 0x00)
		return eax_15;
	struct Eq_121872 * esp_149 = fp - 0x18;
	word32 edx_445;
	if (fn006FC050(dwArg04, fp - 0x04, fp - 0x08, fp + 0x10, out edx_445) != 0x00)
	{
		do
		{
			int32 eax_56 = *((word32) esp_149[0x0A].dwFFFFFFFC + 0x0C);
			if ((eax_56 >> 11 & 0x07) == esp_149[8] || (esp_149[9] & eax_56) != 0x00)
			{
				struct Eq_121903 * esp_67 = esp_149 - 4;
				esp_67->t0000 = ebp_12;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_3 stackArg4 = <invalid>;
				word32 ecx_447;
				word32 edx_448;
				Eq_3 eax_80 = fn007050A0(stackArg4, out ecx_447, out edx_448);
				if (eax_80 != 0x00)
				{
					Eq_3 eax_116 = esp_67->t0014;
					esp_67->t0000 = *((word32) eax_116 + 4);
					esp_67->tFFFFFFFC = eax_116;
					esp_67->tFFFFFFF8.u0 = 0x02;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_3 stackArg4 = <invalid>;
					ebp_12 = (word32) ebp_12 + 1;
					word32 ecx_451;
					word32 esi_453;
					word32 edx_452;
					Eq_3 eax_127 = fn006DFF80(stackArg4, out ecx_451, out edx_452, out esi_453);
					if (eax_127 != 0x00)
					{
						esp_67->t0000 = eax_80;
						esp_67->tFFFFFFFC = eax_127;
						esp_67->tFFFFFFF8 = eax_15;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_3 stackArg4 = <invalid>;
						Eq_3 stackArg12 = <invalid>;
						esp_149 = (struct Eq_121872 *) ((const char *) &esp_67->t0000 + 4);
						word32 edi_459;
						word32 edx_457;
						word32 ebx_458;
						word32 ecx_456;
						if (fn006FBD90(stackArg4, dwArg04, stackArg12, out ecx_456, out edx_457, out ebx_458, out edi_459) < 0x00)
							goto l00726452;
						word32 v15_238 = (word32) *eax_80 - 1;
						*eax_80 = v15_238;
						if (v15_238 == 0x00)
						{
							Eq_3 eax_242 = *((word32) eax_80 + 4);
							<anonymous> * ecx_243 = *((word32) eax_242 + 24);
							esp_67->t0000 = eax_80;
							word32 esp_246;
							ecx_243();
							esp_149 = esp_246 + 0x04;
						}
						word32 v16_256 = (word32) *eax_127 - 1;
						*eax_127 = v16_256;
						if (v16_256 == 0x00)
						{
							Eq_3 edx_260 = *((word32) eax_127 + 4);
							<anonymous> * eax_261 = *((word32) edx_260 + 24);
							esp_149->dwFFFFFFFC = (word32) eax_127;
							word32 esp_269;
							eax_261();
							esp_149 = esp_269 + 0x04;
						}
						goto l00726409;
					}
l00726452:
					word32 v17_155 = (word32) *eax_80 - 1;
					*eax_80 = v17_155;
					struct Eq_121872 * esp_161 = esp_149;
					if (v17_155 == 0x00)
					{
						Eq_3 ecx_159 = *((word32) eax_80 + 4);
						<anonymous> * edx_160 = *((word32) ecx_159 + 24);
						esp_149->dwFFFFFFFC = (word32) eax_80;
						word32 esp_168;
						edx_160();
						esp_161 = esp_168 + 0x04;
					}
					word32 v19_178 = (word32) *eax_15 - 1;
					*eax_15 = v19_178;
					if (v19_178 == 0x00)
					{
						Eq_3 eax_182 = *((word32) eax_15 + 4);
						<anonymous> * ecx_183 = *((word32) eax_182 + 24);
						esp_161->dwFFFFFFFC = (word32) eax_15;
						word32 esp_191;
						ecx_183();
						esp_161 = esp_191 + 0x04;
					}
					if (eax_127 != 0x00)
					{
						word32 v20_204 = (word32) *eax_127 - 1;
						*eax_127 = v20_204;
						if (v20_204 == 0x00)
						{
							Eq_3 edx_208 = *((word32) eax_127 + 4);
							<anonymous> * eax_209 = *((word32) edx_208 + 24);
							esp_161->dwFFFFFFFC = (word32) eax_127;
							eax_209();
						}
					}
				}
				else
				{
					word32 v18_90 = (word32) *eax_15 - 1;
					*eax_15 = v18_90;
					if (v18_90 == 0x00)
					{
						Eq_3 edx_94 = *((word32) eax_15 + 4);
						<anonymous> * eax_95 = *((word32) edx_94 + 24);
						esp_67->t0000 = eax_15;
						eax_95();
						return 0x00;
					}
				}
				return 0x00;
			}
l00726409:
			struct Eq_121925 * esp_279 = esp_149 - 4;
			esp_279->ptr0000 = (struct Eq_73053 **) (esp_149 + 0x0A);
			Eq_3 ecx_281 = esp_279->t0020;
			esp_279->ptrFFFFFFFC = (union Eq_3 *) ((const char *) &esp_279->ptr0000 + 20);
			esp_279->ptrFFFFFFF8 = (union Eq_3 *) ((const char *) &esp_279->ptr0000 + 24);
			esp_279->tFFFFFFF4 = ecx_281;
			esp_149 = (struct Eq_121872 *) ((const char *) &esp_279->ptr0000 + 4);
			word32 edx_449;
		} while (fn006FC050(esp_279->tFFFFFFF4, esp_279->ptrFFFFFFF8, esp_279->ptrFFFFFFFC, esp_279->ptr0000, out edx_449) != 0x00);
	}
	return eax_15;
}

// 007264A0: Register word32 fn007264A0(Register Eq_3 edi, Stack Eq_3 dwArg04, Stack Eq_3 dwArg08)
// Called from:
//      fn00726930
word32 fn007264A0(Eq_3 edi, Eq_3 dwArg04, Eq_3 dwArg08)
{
	word32 edx_225;
	word32 ecx_224;
	Eq_3 eax_22 = fn006DFD20(dwArg08, out ecx_224, out edx_225);
	Eq_3 esi_26 = eax_22;
	if (eax_22 == 0x00)
		return 0x00;
	Eq_3 eax_35 = *((word32) edi + 8);
	if (dwArg08 > 0x00)
	{
		word32 * edx_37 = (word32) eax_22 + 0x0C;
		struct Eq_122207 * ecx_38 = (word32) dwArg04 + 1;
		Eq_3 esi_39 = dwArg08;
		do
		{
			Eq_3 eax_48 = *((word32) *((word32) edi + 0x0C) + (((word32) ecx_38->b0001 << 0x08) + (word32) ecx_38->b0000) * 0x04);
			*eax_48 = (word32) *eax_48 + 1;
			*edx_37 = (word32) eax_48;
			++edx_37;
			++ecx_38;
			--esi_39;
		} while (esi_39 != 0x00);
		esi_26 = dwArg08;
	}
	word32 edx_227;
	word32 ecx_226;
	if (fn006F2A10(edi, dwArg04, out ecx_226, out edx_227) == 0x00)
	{
		word32 v16_85 = (word32) *esi_26 - 1;
		*esi_26 = v16_85;
		if (v16_85 == 0x00)
		{
			Eq_3 eax_89 = *((word32) esi_26 + 4);
			<anonymous> * ecx_90 = *((word32) eax_89 + 24);
			ecx_90();
		}
		memset(dwArg04, 0x09, dwArg08 * 0x03);
		*((word32) dwArg04 + (dwArg08 * 0x03 + 0x01)) = (byte) eax_35;
		*((word32) dwArg04 + dwArg08 * 0x03) = 100;
		*((word32) dwArg04 + (dwArg08 * 0x03 + 0x02)) = (byte) (eax_35 >> 0x08);
		return 0x01;
	}
	else
	{
		word32 v15_131 = (word32) *esi_26 - 1;
		*esi_26 = v15_131;
		if (v15_131 == 0x00)
		{
			Eq_3 ecx_135 = *((word32) esi_26 + 4);
			(*((word32) ecx_135 + 24))();
		}
		return 0x00;
	}
}

// 00726570: Register word32 fn00726570(Register Eq_122309 edi, Stack Eq_3 dwArg04)
// Called from:
//      fn00726930
word32 fn00726570(Eq_122309 edi, Eq_3 dwArg04)
{
	Eq_3 ecx_15 = *((word32) dwArg04 + 0x0C);
	Eq_3 eax_16 = *((word32) ecx_15 + (((word32) (*((word32) edi + 2)) << 0x08) + (word32) (*((word32) edi + 1))) * 0x04);
	struct Eq_122330 * esi_23 = (word32) *((word32) edi + 6);
	Eq_3 ecx_24 = *((word32) ecx_15 + (((word32) (*((word32) edi + 5)) << 0x08) + (word32) (*((word32) edi + 4))) * 0x04);
	if (esi_23 > (struct Eq_122330 *) 66)
	{
l007266CB:
		word32 edx_498;
		word32 ecx_497;
		fn006E15D0(g_tA18720, 0x008DA5F0, out ecx_497, out edx_498);
		return 0x00;
	}
	else
	{
		Eq_3 eax_111;
		switch ((word32) esi_23->b726711)
		{
		case 0x00:
			eax_111 = fn00702570();
			goto l00726635;
		case 0x01:
			eax_111 = fn00704560(eax_16, ecx_24);
			break;
		case 0x02:
			return 0x00;
		case 0x03:
			eax_111 = fn00702510(eax_16, ecx_24);
			break;
		case 0x04:
			eax_111 = fn007023D0(eax_16, ecx_24);
			break;
		case 0x05:
			eax_111 = fn007022B0(eax_16, ecx_24);
			break;
		case 0x06:
			word32 edx_500;
			word32 ecx_499;
			eax_111 = fn00704220(eax_16, ecx_24, out ecx_499, out edx_500);
			break;
		case 0x07:
			eax_111 = fn00702450(eax_16, ecx_24);
			break;
		case 0x08:
			eax_111 = fn007024B0(eax_16, ecx_24);
			break;
		case 0x09:
		case 0x0A:
		case 11:
		case 0x0C:
		case 0x0D:
		case 0x0E:
		case 0x0F:
		case 0x10:
		case 0x11:
		case 0x12:
		case 0x13:
		case 0x14:
		case 0x15:
		case 22:
		case 0x17:
		case 0x18:
		case 0x19:
		case 0x1A:
		case 0x1B:
		case 0x1C:
		case 0x1D:
		case 0x1E:
		case 0x1F:
		case 0x20:
		case 33:
		case 0x22:
		case 0x23:
		case 0x24:
		case 0x25:
		case 0x26:
		case 0x27:
		case 0x28:
		case 0x29:
		case 0x2A:
			goto l007266CB;
		case 0x2B:
			eax_111 = fn007021F0(eax_16, ecx_24);
			break;
		case 44:
			eax_111 = fn00702250(eax_16, ecx_24);
			break;
		case 0x2D:
			eax_111 = fn00702190(eax_16, ecx_24);
			break;
		case 0x2E:
			eax_111 = fn00702130(eax_16, ecx_24);
			break;
		case 0x2F:
			eax_111 = fn007020D0(eax_16, ecx_24);
			break;
		}
l00726635:
		if (eax_111 != 0x00)
		{
			word32 edx_501;
			Eq_3 eax_209 = fn00704080(eax_111, out edx_501);
			if (eax_209 == ~0x00)
			{
				word32 ecx_504;
				word32 edx_505;
				fn006E1160(out ecx_504, out edx_505);
			}
			else if (eax_209 > 0x14)
			{
				word32 v19_219 = (word32) *eax_111 - 1;
				*eax_111 = v19_219;
				if (v19_219 == 0x00)
				{
					Eq_3 eax_223 = *((word32) eax_111 + 4);
					(*((word32) eax_223 + 24))();
				}
				return 0x00;
			}
			Eq_3 ebx_259 = *((word32) dwArg04 + 8);
			byte bl_297 = (byte) ebx_259;
			word32 edx_507;
			word32 ecx_506;
			if (fn006F2A10(dwArg04, dwArg04, out ecx_506, out edx_507) == 0x00)
			{
				word32 v16_277 = (word32) *eax_111 - 1;
				*eax_111 = v16_277;
				if (v16_277 == 0x00)
				{
					Eq_3 ecx_281 = *((word32) eax_111 + 4);
					(*((word32) ecx_281 + 24))();
				}
				*edi = 0x09090909;
				*((word32) edi + 5) = bl_297;
				*((word32) edi + 6) = (byte) (ebx_259 >> 0x08);
				*((word32) edi + 4) = 100;
				return 0x01;
			}
			else
			{
				word32 v15_312 = (word32) *eax_111 - 1;
				*eax_111 = v15_312;
				if (v15_312 == 0x00)
				{
					Eq_3 edx_316 = *((word32) eax_111 + 4);
					(*((word32) edx_316 + 24))();
				}
				return 0x00;
			}
		}
		else
		{
			word32 ecx_502;
			word32 edx_503;
			fn006E1160(out ecx_502, out edx_503);
			return 0x00;
		}
	}
}

// 00726760: Register word32 fn00726760(Register Eq_3 ebx, Register Eq_3 esi, Register (ptr16 Eq_7) es, Register (ptr16 Eq_8) ds, Stack Eq_3 dwArg04)
// Called from:
//      fn00726930
word32 fn00726760(Eq_3 ebx, Eq_3 esi, struct Eq_7 * es, struct Eq_8 * ds, Eq_3 dwArg04)
{
	ptr32 esp_38;
	Eq_3 eax_39;
	Eq_3 edx_15 = *((word32) dwArg04 + 0x0C);
	word32 ecx_10 = (word32) *((word32) esi + 3);
	Eq_3 edi_19 = *((word32) edx_15 + (((word32) (*((word32) esi + 2)) << 0x08) + (word32) (*((word32) esi + 1))) * 0x04);
	if (ecx_10 != 11)
	{
		if (ecx_10 != 0x0D)
		{
			if (ecx_10 != 0x0F)
			{
				word32 edx_306;
				word32 ecx_305;
				fn006E15D0(g_tA18720, 0x008DA620, out ecx_305, out edx_306);
				return 0x00;
			}
			eax_39 = fn007029D0(edi_19);
			esp_38 = fp - 0x0C;
		}
		else
		{
			word32 edi_304;
			word32 edx_303;
			eax_39 = fn006DDDB0(ecx_10 - 0x0D, edx_15, ebx, esi, edi_19, es, ds, edi_19, out edx_303, out edi_304);
			esp_38 = fp - 0x08;
		}
	}
	else
	{
		word32 edx_302;
		word32 ecx_301;
		if (fn006DEA90(edi_19, out ecx_301, out edx_302) != 0x01)
			goto l007267D4;
		eax_39 = fn00702910(edi_19);
		esp_38 = fp - 0x0C;
	}
	struct Eq_122591 * esp_81 = esp_38 + 0x04;
	if (eax_39 != 0x00)
	{
		esp_81->tFFFFFFFC = ebx;
		Eq_3 ebx_89 = *((word32) dwArg04 + 8);
		esp_81->tFFFFFFF8 = eax_39;
		esp_81->tFFFFFFF4 = dwArg04;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_3 stackArg4 = <invalid>;
		byte bl_130 = (byte) ebx_89;
		word32 ecx_310;
		word32 edx_311;
		if (fn006F2A10(stackArg4, dwArg04, out ecx_310, out edx_311) == 0x00)
		{
			word32 v15_112 = (word32) *eax_39 - 1;
			*eax_39 = v15_112;
			if (v15_112 == 0x00)
			{
				Eq_3 eax_116 = *((word32) eax_39 + 4);
				<anonymous> * ecx_117 = *((word32) eax_116 + 24);
				esp_81->tFFFFFFF8 = eax_39;
				ecx_117();
			}
			*((word32) esi + 2) = bl_130;
			*esi = 0x09;
			*((word32) esi + 1) = 100;
			*((word32) esi + 3) = (byte) (ebx_89 >> 0x08);
			return 0x01;
		}
		else
		{
			word32 v14_147 = (word32) *eax_39 - 1;
			*eax_39 = v14_147;
			if (v14_147 == 0x00)
			{
				Eq_3 ecx_151 = *((word32) eax_39 + 4);
				<anonymous> * edx_152 = *((word32) ecx_151 + 24);
				esp_81->tFFFFFFF8 = eax_39;
				edx_152();
			}
			return 0x00;
		}
	}
l007267D4:
	word32 edx_308;
	word32 ecx_307;
	fn006E1160(out ecx_307, out edx_308);
	return 0x00;
}

// 00726840: Register Eq_3 fn00726840(Register Eq_3 ebx, Stack Eq_3 dwArg04)
// Called from:
//      fn00726930
Eq_3 fn00726840(Eq_3 ebx, Eq_3 dwArg04)
{
	Eq_3 ebp_10 = dwArg04;
	Eq_3 eax_20 = fn006DECD0(dwArg04 * 0x04);
	word32 dwLoc04_163 = 0x00;
	if (eax_20 != 0x00)
	{
		memset(eax_20, 0x00, dwArg04 * 0x04);
		Eq_3 eax_39 = 0x00;
		if (dwArg04 > 0x00)
		{
			do
			{
				byte cl_45 = Mem44[eax_39 + ebx:byte];
				struct Eq_122719 * edi_46 = (word32) cl_45;
				if (edi_46 <= (struct Eq_122719 *) 122)
				{
					switch ((word32) edi_46->b7268AF)
					{
					case 0x00:
					case 0x11:
					case 0x12:
					case 0x13:
					case 0x14:
					case 0x1A:
					case 0x1B:
					case 0x1C:
					case 0x1D:
						struct Eq_122737 * ecx_56;
						if (cl_45 != 113 && cl_45 != 0x77)
							ecx_56 = eax_39 + 0x03;
						else
							ecx_56 = null;
						eax_20[(CONVERT(Mem44[eax_39 + 0x01 + ebx:byte], byte, word32) + ((CONVERT(Mem44[(eax_39 + 0x02) + ebx:byte], byte, word32) << 0x08) + ecx_56)) * 0x04] = 0x01;
						ebp_10 = dwArg04;
						break;
					case 0x01:
					case 0x02:
					case 0x03:
					case 0x04:
					case 0x05:
					case 0x06:
					case 0x07:
					case 0x08:
					case 0x09:
					case 0x0A:
					case 11:
					case 0x0C:
					case 0x0D:
					case 0x0E:
					case 0x0F:
					case 0x10:
					case 0x15:
					case 22:
					case 0x17:
					case 0x18:
					case 0x19:
						break;
					}
				}
				Eq_122723 ecx_95 = (uint32) (int8) (edi_46 >= (struct Eq_122719 *) 0x5A);
				eax_39 = (word32) eax_39 + ((word32) ecx_95 + ((word32) ecx_95 + 1));
			} while (eax_39 < ebp_10);
		}
		Eq_3 eax_103 = 0x00;
		if (ebp_10 > 0x00)
		{
			do
			{
				*((word32) eax_20 + eax_103 * 0x04) = (word32) *((word32) eax_20 + eax_103 * 0x04) + dwLoc04_163;
				eax_103 = (word32) eax_103 + 1;
				dwLoc04_163 = (word32) *((word32) eax_20 + eax_103 * 0x04);
			} while (eax_103 < ebp_10);
		}
		return eax_20;
	}
	else
	{
		word32 edx_246;
		word32 ecx_245;
		fn006E1210(out ecx_245, out edx_246);
		return 0x00;
	}
}

// 00726930: Register Eq_3 fn00726930(Register Eq_3 eax, Stack Eq_3 dwArg04)
// Called from:
//      fn00728BE0
Eq_3 fn00726930(Eq_3 eax, Eq_3 dwArg04)
{
	Eq_3 ebp_12 = dwArg04;
	if (fn006E0FC0() == 0x00 && memchr((word32) eax + 20, 0xFF, *((word32) eax + 8)) == null)
	{
		Eq_3 eax_44 = fn006ECC00(dwArg04);
		Eq_3 edi_49 = eax_44;
		if (eax_44 <= 32700)
		{
			Eq_3 eax_56 = fn006DECD0(eax_44);
			if (eax_56 != 0x00)
			{
				Eq_3 eax_72 = memcpy(eax_56, (word32) dwArg04 + 20, eax_44);
				ptr32 esp_455 = fp - 0x30;
				if (Mem71[eax_44 - 0x01 + eax_72:byte] == 0x53)
				{
					Eq_3 eax_80 = fn006DECD0(eax_44 * 0x04);
					Eq_3 esi_447 = eax_80;
					esp_455 = fp - 0x30;
					if (eax_80 != 0x00)
					{
						Eq_3 eax_94 = fn00726840(eax_72, eax_44);
						struct Eq_122847 * esp_112 = fp - 0x30;
						if (eax_94 != 0x00)
						{
							Eq_122865 ebp_104 = 0x00;
							if (eax_44 > 0x00)
							{
								Eq_3 edi_107 = eax_94;
								while (true)
								{
									byte cl_111 = Mem110[eax_72 + ebp_104:byte];
									int32 esi_113 = esp_112[4];
									struct Eq_122883 * edx_114 = (word32) cl_111;
									esp_112[8] = (struct Eq_122847) edx_114;
									esp_112[7] = (struct Eq_122847) esi_113;
									esp_112[4] = (struct Eq_122847) 0x00;
									if (edx_114 <= (struct Eq_122883 *) 0x8F)
									{
										word32 eax_652;
										struct Eq_123903 ** esp_651;
										switch ((word32) edx_114->b727051)
										{
										case 0x00:
										case 0x02:
										case 0x04:
											if (esi_113 >= 0x01 && (edi_107 - 0x0C)[ebp_104] == *((word32) edi_107 + ebp_104 * 0x04))
											{
												struct Eq_123903 ** esp_694 = esp_112 - 4;
												*esp_694 = (struct Eq_123903 **) esp_112[0x0E];
												// Failed to bind call argument.
												// Please report this issue at https://github.com/uxmal/reko
												Eq_3 stackArg4 = <invalid>;
												eax_652 = fn00726760(eax_72, eax_72 - 0x03 + ebp_104, es, ds, stackArg4);
												esp_651 = esp_694;
												goto l00726D3B;
											}
											break;
										case 0x01:
											if (Mem119[eax_72 + 0x01 + ebp_104:byte] == 111 && (Mem119[(eax_72 + 0x04) + ebp_104:byte] == 0x01 && *((word32) edi_107 + ebp_104 * 0x04) == *((word32) edi_107 + (ebp_104 * 0x04 + 16))))
											{
												word32 eax_668 = (CONVERT(Mem119[eax_72 + 0x03 + ebp_104:byte], byte, word32) << 0x08) + CONVERT(Mem119[(eax_72 + 0x02) + ebp_104:byte], byte, word32);
												if (*((word32) eax_72 + ((word32) ebp_104 + (eax_668 + 0x04))) == 0x01)
												{
													Mem676[eax_72 + ebp_104:byte] = 0x70;
													Mem678[eax_72 + 0x02 + ebp_104:byte] = SLICE(eax_668 + 0x01 >> 0x08, byte, 0);
													Mem680[eax_72 + 0x01 + ebp_104:byte] = SLICE(eax_668 + 0x01, byte, 0);
													Mem681[eax_72 + 0x03 + ebp_104:byte] = 0x01;
													Mem682[eax_72 + 0x04 + ebp_104:byte] = 0x09;
												}
											}
											break;
										case 0x03:
										case 0x05:
										case 0x06:
										case 0x07:
										case 0x0A:
										case 0x11:
										case 0x12:
										case 0x13:
										case 0x14:
										case 0x15:
										case 22:
										case 0x17:
										case 0x18:
										case 0x19:
										case 0x1A:
										case 0x1B:
										case 0x1C:
										case 0x1D:
										case 0x1E:
										case 0x1F:
										case 0x20:
										case 33:
										case 0x22:
										case 0x23:
										case 0x24:
										case 0x25:
										case 0x26:
										case 0x27:
										case 0x28:
										case 0x29:
										case 0x2A:
										case 0x2B:
										case 44:
										case 0x2D:
										case 0x2E:
										case 0x2F:
										case 0x30:
										case 0x31:
										case 0x32:
										case 0x38:
										case 0x39:
										case 0x3A:
										case 0x3B:
										case 0x3C:
										case 0x3D:
										case 0x3E:
										case 0x3F:
										case 0x40:
										case 0x41:
										case 66:
										case 0x43:
										case 0x44:
										case 0x45:
										case 0x46:
										case 0x47:
										case 0x49:
										case 0x4A:
										case 0x4B:
										case 0x4C:
										case 77:
										case 0x4E:
										case 0x4F:
										case 0x50:
										case 0x51:
										case 0x53:
										case 0x54:
										case 0x55:
										case 0x56:
										case 0x57:
										case 88:
										case 0x5D:
										case 0x5E:
										case 0x60:
										case 0x61:
										case 0x62:
										case 0x67:
										case 0x68:
										case 0x6A:
										case 0x6B:
										case 0x70:
										case 113:
										case 114:
										case 115:
										case 116:
										case 117:
										case 118:
										case 0x77:
										case 0x78:
										case 121:
										case 122:
										case 0x7B:
										case 0x7C:
										case 0x7D:
										case 0x7E:
										case 0x7F:
										case 0x80:
										case 0x81:
										case 0x82:
										case 131:
											break;
										case 0x08:
										case 0x09:
										case 11:
										case 0x0C:
										case 0x0D:
										case 0x0E:
										case 0x0F:
										case 0x10:
										case 0x33:
										case 0x34:
										case 0x35:
										case 0x36:
										case 55:
											if (esi_113 >= 0x02 && (edi_107 - 0x18)[ebp_104] == *((word32) edi_107 + ebp_104 * 0x04))
											{
												struct Eq_123806 ** esp_646 = esp_112 - 4;
												*esp_646 = (struct Eq_123806 **) esp_112[0x0E];
												// Failed to bind call argument.
												// Please report this issue at https://github.com/uxmal/reko
												Eq_3 stackArg4 = <invalid>;
												eax_652 = fn00726570(eax_72 - 0x06 + ebp_104, stackArg4);
												esp_651 = (struct Eq_123903 **) ((const char *) esp_646 + 4);
l00726D3B:
												esp_112 = (struct Eq_122847 *) esp_651;
												if (eax_652 != 0x00)
												{
													esp_112[4] = (struct Eq_122847) 0x01;
													ebp_104 -= 0x02;
												}
											}
											break;
										case 0x48:
											word32 eax_626 = ebp_104 + 0x04;
											if (eax_626 < esp_112[5] && (Mem119[(eax_72 + 0x04) + ebp_104:byte] == 0x53 && *((word32) edi_107 + ebp_104 * 0x04) == *((word32) edi_107 + eax_626 * 0x04)))
												Mem634[eax_72 + 0x01 + ebp_104:word32] = 0x09090909;
											break;
										case 0x52:
										case 99:
										case 0x66:
										case 0x6C:
										case 0x6D:
										case 110:
										case 111:
											goto l00726E04;
										case 0x59:
											word32 eax_508 = (CONVERT(Mem119[eax_72 + 0x02 + ebp_104:byte], byte, word32) << 0x08) + CONVERT(Mem119[(eax_72 + 0x01) + ebp_104:byte], byte, word32);
											esp_112[4] = (struct Eq_122847) (esi_113 + 0x01);
											if (Mem119[eax_72 + 0x03 + ebp_104:byte] == 111 && (Mem510[(eax_72 + 0x06) + ebp_104:byte] == 0x01 && *((word32) edi_107 + ebp_104 * 0x04) == *((word32) edi_107 + (ebp_104 * 0x04 + 24))))
											{
												struct Eq_123116 * esp_520 = esp_112 - 4;
												esp_520->t0000 = *((word32) ((word32) esp_112[0x0E].dw0000 + 0x0C)->dw0000 + eax_508 * 0x04);
												esp_112 = (struct Eq_122847 *) ((const char *) &esp_520->t0000 + 4);
												word32 ecx_1367;
												word32 edx_1368;
												if (fn006DEA90(esp_520->t0000, out ecx_1367, out edx_1368) != 0x00)
												{
													Mem534[eax_72 + ebp_104:word32] = 0x09090909;
													Mem536[eax_72 + 0x04 + ebp_104:word16] = 0x0909;
													Mem538[eax_72 + 0x06 + ebp_104:byte] = 0x09;
													esp_520->dw0014 = 0x00;
												}
											}
											break;
										case 0x5A:
										case 0x69:
											struct Eq_122965 * esp_340 = esp_112 - 4;
											Mem341[esp_340 + 0x00:word32] = (Mem119[esp_112 + 0x3C:word32] + 0x0C)[((CONVERT(Mem119[eax_72 + 0x02 + ebp_104:byte], byte, word32) << 0x08) + CONVERT(Mem119[(eax_72 + 0x01) + ebp_104:byte], byte, word32)) * 0x04];
											// Failed to bind call argument.
											// Please report this issue at https://github.com/uxmal/reko
											Eq_3 stackArg4 = <invalid>;
											word32 edx_1365;
											word32 esi_1366;
											word32 ecx_1364;
											Eq_3 eax_346 = fn006ECC50(stackArg4, out ecx_1364, out edx_1365, out esi_1366);
											esp_112 = (struct Eq_122847 *) (&esp_340->dw0000 + 1);
											if (eax_346 != 0x00)
											{
												byte * edi_355 = &g_b8ABDD0;
												Eq_3 esi_356 = eax_346;
												word32 ecx_357 = 0x05;
												bool v25_987 = false;
												while (ecx_357 != 0x00)
												{
													v25_987 = *esi_1380 != *edi_1381;
													esi_356 = (word32) esi_1380 + 1;
													edi_355 = edi_1381 + 1;
													--ecx_357;
													esi_1380 = esi_356;
													edi_1381 = edi_355;
													if (*esi_1380 == *edi_1381)
														break;
												}
												if (!v25_987)
												{
													struct Eq_123510 * edx_376 = esp_340->ptr003C;
													int32 ecx_377 = edx_376->dw0008;
													esp_340->dw0014 = 0x00;
													int32 eax_378 = 0x00;
													if (ecx_377 > 0x00)
													{
														word32 * edx_382 = edx_376->ptr000C;
														while (*edx_382 != 0x00A163B8)
														{
															++eax_378;
															++edx_382;
															if (eax_378 >= ecx_377)
																break;
														}
														esp_340->dw0014 = eax_378;
													}
													if (eax_378 == ecx_377)
													{
														struct Eq_123510 * eax_407 = esp_340->ptr003C;
														esp_340->dw0000 = 0x00A163B8;
														esp_340->ptrFFFFFFFC = eax_407;
														// Failed to bind call argument.
														// Please report this issue at https://github.com/uxmal/reko
														Eq_3 stackArg4 = <invalid>;
														word32 edx_1375;
														word32 ecx_1374;
														if (fn006F2A10(stackArg4, dwArg04, out ecx_1374, out edx_1375) == ~0x00)
															goto l00726F51;
														eax_378 = esp_340->dw0014;
													}
													int32 edx_490 = esp_112[7];
													Mem498[eax_72 + ebp_104:byte] = 100;
													Mem500[eax_72 + 0x02 + ebp_104:byte] = SLICE(eax_378 >> 0x08, byte, 0);
													Mem502[eax_72 + 0x01 + ebp_104:byte] = SLICE(eax_378, byte, 0);
													esp_112[4] = (struct Eq_122847) (edx_490 + 0x01);
												}
											}
											break;
										case 0x5B:
										case 0x5C:
											word32 esi_232 = (CONVERT(Mem119[eax_72 + 0x02 + ebp_104:byte], byte, word32) << 0x08) + CONVERT(Mem119[(eax_72 + 0x01) + ebp_104:byte], byte, word32);
											Eq_123020 eax_235 = ebp_104 - esi_232 * 0x03;
											if (eax_235 >= 0x00 && esi_232 <= esp_112[7])
											{
												if (edx_114 == (struct Eq_122883 *) 0x66)
												{
													if (*((word32) edi_107 + eax_235 * 0x04) != *((word32) edi_107 + (((word32) eax_235 + esi_232 * 0x03) * 0x04 + 8)))
														goto l00726C97;
													goto l00726C72;
												}
												if (edx_114 != (struct Eq_122883 *) 0x67 || (Mem119[(eax_72 + 0x03) + ebp_104:byte] != 0x6A || *((word32) edi_107 + eax_235 * 0x04) != *((word32) edi_107 + (((word32) eax_235 + esi_232 * 0x03) * 0x04 + 20))))
													goto l00726C97;
												word32 ecx_257 = (CONVERT(Mem119[eax_72 + 0x05 + ebp_104:byte], byte, word32) << 0x08) + CONVERT(Mem119[(eax_72 + 0x04) + ebp_104:byte], byte, word32);
												if (ecx_257 != 0x06 && ecx_257 != 0x07)
													goto l00726C97;
l00726C72:
												Eq_3 edi_269 = esp_112[0x0E];
												struct Eq_123461 * esp_274 = esp_112 - 4;
												esp_274->dw0000 = esi_232;
												Mem278[esp_274 + -4:word32] = eax_235 + eax_72;
												// Failed to bind call argument.
												// Please report this issue at https://github.com/uxmal/reko
												Eq_3 stackArg4 = <invalid>;
												esp_112 = (struct Eq_122847 *) (&esp_274->dw0000 + 1);
												if (fn007264A0(edi_269, stackArg4, dwArg04) == 0x00)
												{
													edi_107 = esp_274->t001C;
													goto l00726C97;
												}
												esp_274->dw0014 = 0x01;
											}
											else
											{
l00726C97:
												if (Mem297[eax_72 + 0x03 + ebp_104:byte] == 0x5C && (*((word32) edi_107 + ebp_104 * 0x04) == *((word32) edi_107 + (ebp_104 * 0x04 + 20)) && esi_232 == (CONVERT(Mem297[(eax_72 + 0x05) + ebp_104:byte], byte, word32) << 0x08) + CONVERT(Mem297[(eax_72 + 0x04) + ebp_104:byte], byte, word32)))
												{
													if (esi_232 == 0x01)
													{
														Mem326[eax_72 + ebp_104:word32] = 0x09090909;
														Mem328[eax_72 + 0x04 + ebp_104:word16] = 0x0909;
													}
													else if (esi_232 == 0x02)
													{
														Mem321[eax_72 + ebp_104:byte] = 0x02;
														Mem322[eax_72 + 0x01 + ebp_104:word32] = 0x09090909;
														Mem324[eax_72 + 0x05 + ebp_104:byte] = 0x09;
													}
													else if (esi_232 == 0x03)
													{
														Mem317[eax_72 + ebp_104:byte] = 0x03;
														Mem318[eax_72 + 0x01 + ebp_104:byte] = 0x02;
														Mem319[eax_72 + 0x02 + ebp_104:word32] = 0x09090909;
													}
												}
											}
											break;
										case 0x5F:
											word32 eax_206 = (CONVERT(Mem119[eax_72 + 0x02 + ebp_104:byte], byte, word32) << 0x08) + CONVERT(Mem119[(eax_72 + 0x01) + ebp_104:byte], byte, word32);
											byte al_218 = (byte) eax_206;
											if (eax_206 <= 0x09 && (Mem119[(eax_72 + 0x03) + ebp_104:byte] == 0x0C && *((word32) edi_107 + ebp_104 * 0x04) == *((word32) edi_107 + (ebp_104 * 0x04 + 0x0C))))
											{
												Mem223[eax_72 + 0x02 + ebp_104:byte] = SLICE(eax_206 >> 0x08, byte, 0);
												Mem224[eax_72 + 0x01 + ebp_104:byte] = al_218 ^ 0x01;
												Mem225[eax_72 + 0x03 + ebp_104:byte] = 0x09;
											}
											break;
										case 100:
										case 101:
											Eq_123044 edx_127;
											if (cl_111 != 113 && cl_111 != 0x77)
												edx_127 = ebp_104 + 0x03;
											else
												edx_127.u0->a0000 = 0x00;
											word32 eax_145 = CONVERT(Mem119[eax_72 + 0x01 + ebp_104:byte], byte, word32) + ((CONVERT(Mem119[(eax_72 + 0x02) + ebp_104:byte], byte, word32) << 0x08) + edx_127);
											byte dl_146 = Mem119[eax_145 + eax_72:byte];
											word32 esi_147 = (word32) dl_146;
											if (esi_147 != 111 && esi_147 != 0x70)
											{
												edx_114 = (struct Eq_122883 *) esp_112[8];
l00726E04:
												Eq_122935 ecx_547;
												Eq_122450 dl_613 = (byte) edx_114;
												if (cl_111 != 113 && cl_111 != 0x77)
													ecx_547 = ebp_104 + 0x03;
												else
													ecx_547.u0->a0000 = 0x00;
												int32 ecx_575;
												word32 eax_565 = CONVERT(Mem119[eax_72 + 0x01 + ebp_104:byte], byte, word32) + ((CONVERT(Mem119[(eax_72 + 0x02) + ebp_104:byte], byte, word32) << 0x08) + ecx_547);
												byte cl_566 = Mem119[eax_565 + eax_72:byte];
												if (cl_566 == 113)
												{
l00726E42:
													ecx_575 = 0x00;
													goto l00726E44;
												}
												if (cl_566 == 110)
												{
													if (cl_566 == 113 || cl_566 == 0x77)
														goto l00726E42;
													ecx_575 = (word32) eax_565 + 3;
l00726E44:
													word32 eax_590 = CONVERT(Mem119[eax_72 + 0x01 + eax_565:byte], byte, word32) + ((CONVERT(Mem119[(eax_72 + 0x02) + eax_565:byte], byte, word32) << 0x08) + ecx_575);
													if (edx_114 == (struct Eq_122883 *) 110)
														dl_613.u0 = 113;
													else if (edx_114 != (struct Eq_122883 *) 113 && edx_114 != (struct Eq_122883 *) 0x77)
														eax_590 += ~0x02 - ebp_104;
													Eq_122450 al_624 = (byte) eax_590;
													if (eax_590 >= 0x00)
													{
														Mem618[eax_72 + ebp_104:byte] = dl_613;
														Mem623[eax_72 + 0x02 + ebp_104:byte] = SLICE(eax_590 >> 0x08, byte, 0);
														Mem625[eax_72 + 0x01 + ebp_104:byte] = al_624;
													}
												}
											}
											else if (esi_147 == esp_112[8])
											{
												int32 ecx_177;
												if (dl_146 != 113 && dl_146 != 0x77)
													ecx_177 = (word32) eax_145 + 3;
												else
													ecx_177 = 0x00;
												word32 eax_195 = (CONVERT(Mem119[eax_72 + 0x02 + eax_145:byte], byte, word32) << 0x08) + CONVERT(Mem119[(eax_72 + 0x01) + eax_145:byte], byte, word32) - ebp_104 - 0x03 + ecx_177;
												Mem200[eax_72 + 0x02 + ebp_104:byte] = SLICE(eax_195 >> 0x08, byte, 0);
												Mem202[eax_72 + 0x01 + ebp_104:byte] = SLICE(eax_195, byte, 0);
											}
											else
											{
												int32 eax_163 = eax_145 - ebp_104;
												Mem169[eax_72 + 0x02 + ebp_104:byte] = SLICE(eax_163 >> 0x08, byte, 0);
												Mem171[eax_72 + 0x01 + ebp_104:byte] = SLICE(eax_163, byte, 0);
											}
											break;
										case 0x84:
l00726F51:
											struct Eq_123047 * esp_445 = esp_112 - 4;
											esp_445->t0000 = esp_112[6];
											free(esp_445->t0000);
											esi_447 = esp_445->t0028;
											ebp_12 = esp_445->t0038;
											esp_112 = (struct Eq_122847 *) ((const char *) &esp_445->t0000 + 4);
											goto l00726F66;
										}
									}
									ebp_104 += (0x00 - (Mem718[eax_72 + ebp_104:byte] <u 0x5A) & ~0x01) + 0x03;
									if (ebp_104 >= esp_112[5])
										break;
									edi_107 = esp_112[6];
								}
								esi_447 = esp_112[9];
								edi_49 = esp_112[5];
							}
							Eq_3 eax_742 = 0x00;
							word32 edx_743 = 0x00;
							if (edi_49 > 0x00)
							{
								do
								{
									*((word32) esi_447 + eax_742 * 0x04) = eax_742 - edx_743;
									byte cl_755 = Mem752[eax_742 + eax_72:byte];
									if (cl_755 == 0x09)
										++edx_743;
									eax_742 = (word32) eax_742 + ((0x00 - (cl_755 < 0x5A) & ~0x01) + 0x03);
								} while (eax_742 < edi_49);
							}
							byte edi_772[] = null;
							ui32 ebp_773 = 0x00;
							byte cl_795 = 0x00;
							if (esp_112[11] > 0x00)
							{
								do
								{
									ebp_773 += CONVERT(Mem785[edi_772 + Mem785[esp_112 + 0x28:word32]:byte], byte, word32);
									int32 eax_792 = *((word32) esi_447 + ebp_773 * 0x04);
									Mem798[edi_772 + Mem785[esp_112 + 0x28:word32]:byte] = SLICE(eax_792, byte, 0) - cl_795;
									edi_772 = (byte (*)[]) (edi_772 + 2);
									cl_795 = (byte) eax_792;
								} while (edi_772 < esp_112[11]);
							}
							Eq_123188 ebp_803 = 0x00;
							int32 eax_804 = 0x00;
							if (esp_112[5] > 0x00)
							{
								do
								{
									Eq_123245 edi_812 = (word32) *((word32) eax_72 + eax_804);
									if (edi_812 <= 122)
									{
										int32 ecx_827;
										switch (edi_812)
										{
										case 0x09:
											++eax_804;
											goto l00726FF3;
										case 0x0A:
										case 11:
										case 0x0C:
										case 0x0D:
										case 0x0E:
										case 0x0F:
										case 0x10:
										case 0x11:
										case 0x12:
										case 0x13:
										case 0x14:
										case 0x15:
										case 22:
										case 0x17:
										case 0x18:
										case 0x19:
										case 0x1A:
										case 0x1B:
										case 0x1C:
										case 0x1D:
										case 0x1E:
										case 0x1F:
										case 0x20:
										case 33:
										case 0x22:
										case 0x23:
										case 0x24:
										case 0x25:
										case 0x26:
										case 0x27:
										case 0x28:
										case 0x29:
										case 0x2A:
										case 0x2B:
										case 44:
										case 0x2D:
										case 0x2E:
										case 0x2F:
										case 0x30:
										case 0x31:
										case 0x32:
										case 0x33:
										case 0x34:
										case 0x35:
										case 0x36:
										case 55:
										case 0x38:
										case 0x39:
										case 0x3A:
										case 0x3B:
										case 0x3C:
										case 0x3D:
										case 0x3E:
										case 0x3F:
										case 0x40:
										case 0x41:
										case 66:
										case 0x43:
										case 0x44:
										case 0x45:
										case 0x46:
										case 0x47:
										case 0x48:
										case 0x49:
										case 0x4A:
										case 0x4B:
										case 0x4C:
										case 77:
										case 0x4E:
										case 0x4F:
										case 0x50:
										case 0x51:
										case 0x52:
										case 0x53:
										case 0x54:
										case 0x55:
										case 0x56:
										case 0x57:
										case 88:
										case 0x59:
										case 0x5A:
										case 0x5B:
										case 0x5C:
										case 0x5E:
										case 0x5F:
										case 0x60:
										case 0x61:
										case 0x62:
										case 99:
										case 100:
										case 101:
										case 0x66:
										case 0x67:
										case 0x68:
										case 0x69:
										case 0x6A:
										case 0x6B:
										case 0x6C:
										case 0x6D:
										case 114:
										case 115:
										case 116:
										case 117:
										case 118:
											goto l00726FCB;
										case 0x5D:
										case 110:
										case 111:
										case 0x70:
										case 0x78:
										case 121:
										case 122:
											ecx_827 = *((word32) esi_447 + (((word32) (*((word32) eax_72 + (eax_804 + 0x01))) + (((word32) (*((word32) eax_72 + (eax_804 + 0x02))) << 0x08) + eax_804)) * 0x04 + 0x0C)) - *((word32) esi_447 + eax_804 * 0x04) - 0x03;
											break;
										case 113:
										case 0x77:
											ecx_827 = (int32) *((word32) esi_447 + (((word32) (*((word32) eax_72 + (eax_804 + 0x02))) << 0x08) + (word32) (*((word32) eax_72 + (eax_804 + 0x01)))) * 0x04);
											break;
										}
										*((word32) eax_72 + (eax_804 + 0x01)) = (byte) ecx_827;
										*((word32) eax_72 + (eax_804 + 0x02)) = (byte) (ecx_827 >> 0x08);
									}
l00726FCB:
									uint32 ecx_860 = (uint32) (int8) (edi_812 >= 0x5A);
									uint32 ecx_861 = ecx_860 + 0x01 + ecx_860;
									uint32 edi_862 = ecx_861;
									if (ecx_861 != 0x00)
									{
										do
										{
											Mem874[eax_72 + ebp_803:byte] = Mem869[eax_804 + eax_72:byte];
											--edi_862;
											++ebp_803;
											++eax_804;
										} while (edi_862 != 0x00);
									}
l00726FF3:
								} while (eax_804 < esp_112[5]);
							}
							struct Eq_123222 * esp_896 = esp_112 - 4;
							esp_896->t0000 = ebp_803;
							esp_896->tFFFFFFFC = eax_72;
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							Eq_3 stackArg4 = <invalid>;
							word32 edx_1371;
							word32 ecx_1370;
							Eq_3 eax_959 = fn006EC9B0(stackArg4, dwArg04, out ecx_1370, out edx_1371);
							free(esi_447);
							free(eax_72);
							free(eax_94);
							return eax_959;
						}
l00726F66:
						union Eq_3 * esp_452 = esp_112 - 4;
						*esp_452 = (union Eq_3 *) esi_447;
						free(*esp_452);
						esp_455 = (const char *) esp_452 + 4;
					}
				}
				if (eax_72 != 0x00)
				{
					union Eq_3 * esp_464 = esp_455 - 4;
					*esp_464 = (union Eq_3 *) eax_72;
					free(*esp_464);
				}
			}
		}
	}
	*ebp_12 = (word32) *ebp_12 + 1;
	return ebp_12;
}

// 00727170: void fn00727170(Register Eq_3 esi)
// Called from:
//      fn00727290
//      fn00728E40
//      fn0072C160
void fn00727170(Eq_3 esi)
{
	Eq_3 edi_11 = *((word32) esi + 36);
	if (edi_11 != 0x00)
	{
		do
		{
			Eq_3 eax_21 = *((word32) edi_11 + 0x0C);
			if (eax_21 != 0x00)
			{
				word32 edx_342;
				word32 ecx_341;
				fn007239C0(eax_21, out ecx_341, out edx_342);
			}
			Eq_3 ebx_39 = *edi_11;
			word32 ecx_339;
			word32 edx_340;
			fn007239C0(edi_11, out ecx_339, out edx_340);
			edi_11 = ebx_39;
		} while (ebx_39 != 0x00);
	}
	struct Eq_123947 * esp_101 = fp - 8;
	struct Eq_123951 * eax_61 = *esi;
	if (eax_61 != null)
	{
		*esi = null;
		word32 v12_66 = eax_61->dw0000 + ~0x00;
		eax_61->dw0000 = v12_66;
		if (v12_66 == 0x00)
		{
			struct Eq_123997 * ecx_70 = eax_61->ptr0004;
			word32 esp_80;
			ecx_70->ptr0018();
			esp_101 = esp_80 + 0x04;
		}
	}
	Eq_3 eax_90 = *((word32) esi + 4);
	if (eax_90 != 0x00)
	{
		((word32) esi + 4)->u0 = 0x00;
		word32 v15_95 = (word32) *eax_90 - 1;
		*eax_90 = v15_95;
		if (v15_95 == 0x00)
		{
			Eq_3 ecx_99 = *((word32) eax_90 + 4);
			Eq_3 edx_100 = *((word32) ecx_99 + 24);
			esp_101->tFFFFFFFC = eax_90;
			word32 esp_107;
			edx_100();
			esp_101 = esp_107 + 0x04;
		}
	}
	Eq_3 eax_117 = *((word32) esi + 8);
	if (eax_117 != 0x00)
	{
		((word32) esi + 8)->u0 = 0x00;
		word32 v16_122 = (word32) *eax_117 - 1;
		*eax_117 = v16_122;
		if (v16_122 == 0x00)
		{
			Eq_3 ecx_126 = *((word32) eax_117 + 4);
			Eq_3 edx_127 = *((word32) ecx_126 + 24);
			esp_101->tFFFFFFFC = eax_117;
			word32 esp_134;
			edx_127();
			esp_101 = esp_134 + 0x04;
		}
	}
	Eq_3 eax_144 = *((word32) esi + 0x0C);
	if (eax_144 != 0x00)
	{
		((word32) esi + 0x0C)->u0 = 0x00;
		word32 v17_149 = (word32) *eax_144 - 1;
		*eax_144 = v17_149;
		if (v17_149 == 0x00)
		{
			Eq_3 ecx_153 = *((word32) eax_144 + 4);
			Eq_3 edx_154 = *((word32) ecx_153 + 24);
			esp_101->tFFFFFFFC = eax_144;
			word32 esp_161;
			edx_154();
			esp_101 = esp_161 + 0x04;
		}
	}
	Eq_3 eax_171 = *((word32) esi + 16);
	if (eax_171 != 0x00)
	{
		((word32) esi + 16)->u0 = 0x00;
		word32 v18_176 = (word32) *eax_171 - 1;
		*eax_171 = v18_176;
		if (v18_176 == 0x00)
		{
			Eq_3 ecx_180 = *((word32) eax_171 + 4);
			Eq_3 edx_181 = *((word32) ecx_180 + 24);
			esp_101->tFFFFFFFC = eax_171;
			word32 esp_188;
			edx_181();
			esp_101 = esp_188 + 0x04;
		}
	}
	Eq_3 eax_198 = *((word32) esi + 24);
	if (eax_198 != 0x00)
	{
		((word32) esi + 24)->u0 = 0x00;
		word32 v19_203 = (word32) *eax_198 - 1;
		*eax_198 = v19_203;
		if (v19_203 == 0x00)
		{
			Eq_3 ecx_207 = *((word32) eax_198 + 4);
			Eq_3 edx_208 = *((word32) ecx_207 + 24);
			esp_101->tFFFFFFFC = eax_198;
			word32 esp_215;
			edx_208();
			esp_101 = esp_215 + 0x04;
		}
	}
	Eq_3 eax_225 = *((word32) esi + 20);
	if (eax_225 != 0x00)
	{
		((word32) esi + 20)->u0 = 0x00;
		word32 v20_230 = (word32) *eax_225 - 1;
		*eax_225 = v20_230;
		if (v20_230 == 0x00)
		{
			Eq_3 ecx_234 = *((word32) eax_225 + 4);
			Eq_3 edx_235 = *((word32) ecx_234 + 24);
			esp_101->tFFFFFFFC = eax_225;
			word32 esp_242;
			edx_235();
			esp_101 = esp_242 + 0x04;
		}
	}
	Eq_3 eax_252 = *((word32) esi + 28);
	if (eax_252 != 0x00)
	{
		((word32) esi + 28)->u0 = 0x00;
		word32 v21_257 = (word32) *eax_252 - 1;
		*eax_252 = v21_257;
		if (v21_257 == 0x00)
		{
			Eq_3 ecx_261 = *((word32) eax_252 + 4);
			Eq_3 edx_262 = *((word32) ecx_261 + 24);
			esp_101->tFFFFFFFC = eax_252;
			edx_262();
		}
	}
	word32 ecx_343;
	word32 edx_344;
	fn007239C0(esi, out ecx_343, out edx_344);
}

// 00727290: void fn00727290(Register Eq_3 edi)
// Called from:
//      fn0072A5D0
//      fn0072B360
//      fn0072C160
//      fn0072C510
//      fn0072E660
void fn00727290(Eq_3 edi)
{
	*((word32) edi + 20) = (word32) *((word32) edi + 20) - 1;
	fn00727170(*((word32) edi + 24));
	Eq_3 eax_20 = *((word32) edi + 28);
	Eq_3 esi_21 = *((word32) eax_20 + 8);
	if (esi_21 < 0x01)
		((word32) edi + 24)->u0 = 0x00;
	else
	{
		word32 edx_105;
		Eq_3 eax_31 = fn0072E9C0(*((word32) *((word32) eax_20 + 0x0C) + (esi_21 - 0x01) * 0x04), out edx_105);
		Eq_3 ecx_36 = *((word32) edi + 28);
		*((word32) edi + 24) = eax_31;
		word32 ecx_106;
		word32 edx_107;
		if (fn00703390(ecx_36, esi_21 - 0x01, out ecx_106, out edx_107) >= 0x00)
			return;
		fn006E86F0(9283148);
	}
}

// 007272E0: Register word32 fn007272E0(Register Eq_3 ebx, Register Eq_3 ebp, Register Eq_3 esi, Register Eq_3 edi, Register (ptr16 Eq_7) es, Register (ptr16 Eq_8) ds, Stack Eq_3 dwArg04)
// Called from:
//      fn00729D20
//      fn0072DD60
word32 fn007272E0(Eq_3 ebx, Eq_3 ebp, Eq_3 esi, Eq_3 edi, struct Eq_7 * es, struct Eq_8 * ds, Eq_3 dwArg04)
{
	Eq_3 ecx_10 = *((word32) dwArg04 + 24);
	ui32 eax_7 = g_tA14188 ^ fp - 0x0104;
	*((word32) ecx_10 + 44) = (word32) *((word32) ecx_10 + 44) + 1;
	Eq_3 ecx_15 = *((word32) *((word32) dwArg04 + 24) + 44);
	fn00724FE0(fp - 0x0104, 0x0100, &g_b8DA664);
	Eq_3 edx_37;
	word32 ecx_81;
	word32 ecx_82;
	return fn00694B8E(fn006ECAC0(fp - 0x0104, out ecx_81, out edx_37), eax_7 ^ fp - 0x0104, edx_37, ebx, ebp, esi, edi, es, ds, ecx_15, out ecx_82);
}

// 00727340: Register Eq_3 fn00727340(Register Eq_3 eax)
// Called from:
//      fn00728030
//      fn0072D130
//      fn0072D3D0
//      fn0072D830
Eq_3 fn00727340(Eq_3 eax)
{
	Eq_3 esi_8 = *((word32) eax + 24);
	word32 ecx_69;
	word32 edx_70;
	Eq_3 eax_11 = fn00723860(0x20, out ecx_69, out edx_70);
	if (eax_11 != 0x00)
	{
		eax_11->u0 = 0x00;
		((word32) eax_11 + 4)->u0 = 0x00;
		((word32) eax_11 + 8)->u0 = 0x00;
		((word32) eax_11 + 0x0C)->u0 = 0x00;
		((word32) eax_11 + 16)->u0 = 0x00;
		((word32) eax_11 + 20)->u0 = 0x00;
		((word32) eax_11 + 24)->u0 = 0x00;
		((word32) eax_11 + 28)->u0 = 0x00;
		*eax_11 = *((word32) esi_8 + 36);
		*((word32) esi_8 + 36) = eax_11;
		return eax_11;
	}
	else
	{
		word32 ecx_71;
		word32 edx_72;
		fn006E1210(out ecx_71, out edx_72);
		return 0x00;
	}
}

// 00727380: Register Eq_3 fn00727380(Register Eq_3 edi)
// Called from:
//      fn00728E40
Eq_3 fn00727380(Eq_3 edi)
{
	Eq_3 esi_8 = *((word32) edi + 24);
	word32 ecx_71;
	word32 edx_72;
	Eq_3 eax_11 = fn00723860(0x20, out ecx_71, out edx_72);
	if (eax_11 != 0x00)
	{
		eax_11->u0 = 0x00;
		((word32) eax_11 + 4)->u0 = 0x00;
		((word32) eax_11 + 8)->u0 = 0x00;
		((word32) eax_11 + 0x0C)->u0 = 0x00;
		((word32) eax_11 + 16)->u0 = 0x00;
		((word32) eax_11 + 20)->u0 = 0x00;
		((word32) eax_11 + 24)->u0 = 0x00;
		((word32) eax_11 + 28)->u0 = 0x00;
		*eax_11 = *((word32) esi_8 + 36);
		*((word32) esi_8 + 36) = eax_11;
		*((word32) *((word32) edi + 24) + 40) = eax_11;
		return eax_11;
	}
	else
	{
		word32 ecx_73;
		word32 edx_74;
		fn006E1210(out ecx_73, out edx_74);
		return 0x00;
	}
}

// 007273D0: Register Eq_3 fn007273D0(Register Eq_3 edi)
// Called from:
//      fn00728030
//      fn00729810
//      fn00729F50
//      fn0072A350
Eq_3 fn007273D0(Eq_3 edi)
{
	Eq_3 esi_8 = *((word32) edi + 24);
	word32 ecx_74;
	word32 edx_75;
	Eq_3 eax_11 = fn00723860(0x20, out ecx_74, out edx_75);
	if (eax_11 != 0x00)
	{
		eax_11->u0 = 0x00;
		((word32) eax_11 + 4)->u0 = 0x00;
		((word32) eax_11 + 8)->u0 = 0x00;
		((word32) eax_11 + 0x0C)->u0 = 0x00;
		((word32) eax_11 + 16)->u0 = 0x00;
		((word32) eax_11 + 20)->u0 = 0x00;
		((word32) eax_11 + 24)->u0 = 0x00;
		((word32) eax_11 + 28)->u0 = 0x00;
		*eax_11 = *((word32) esi_8 + 36);
		*((word32) esi_8 + 36) = eax_11;
		*((word32) *((word32) *((word32) edi + 24) + 40) + 16) = eax_11;
		*((word32) *((word32) edi + 24) + 40) = eax_11;
		return eax_11;
	}
	else
	{
		word32 ecx_76;
		word32 edx_77;
		fn006E1210(out ecx_76, out edx_77);
		return 0x00;
	}
}

// 00727420: Register Eq_3 fn00727420(Register Eq_3 esi, Register out ptr32 ecxOut)
// Called from:
//      fn00727670
//      fn00727810
//      fn00727880
//      fn00727D50
//      fn00728030
//      fn00729300
//      fn0072A5D0
//      fn0072AC20
//      fn0072B040
//      fn0072C160
//      fn0072CA10
Eq_3 fn00727420(Eq_3 esi, ptr32 & ecxOut)
{
	Eq_3 dwLoc0C_112;
	Eq_3 eax_50;
	Eq_3 ecx_6 = *((word32) esi + 0x0C);
	if (ecx_6 != 0x00)
	{
		Eq_3 eax_16 = *((word32) esi + 8);
		if (*((word32) esi + 4) != eax_16)
			goto l0072749A;
		if (eax_16 * 0x14 <= 0x7FFFFFFF && eax_16 * 0x28 != 0x00)
		{
			*((word32) esi + 8) = eax_16 * 0x02;
			word32 ecx_160;
			word32 edx_161;
			Eq_3 eax_35 = fn00723B60(ecx_6, eax_16 * 0x28, out ecx_160, out edx_161);
			if (eax_35 != 0x00)
			{
				*((word32) esi + 0x0C) = eax_35;
				dwLoc0C_112 = eax_16 * 0x28 - eax_16 * 0x14;
				eax_50 = (word32) eax_35 + eax_16 * 0x14;
				goto l0072748F;
			}
		}
l0072743D:
		ptr32 ecx_95;
		word32 edx_159;
		fn006E1210(out ecx_95, out edx_159);
		ecxOut = ecx_95;
		return ~0x00;
	}
	else
	{
		word32 ecx_157;
		word32 edx_158;
		eax_50 = fn00723860(0x0140, out ecx_157, out edx_158);
		*((word32) esi + 0x0C) = eax_50;
		if (eax_50 == 0x00)
			goto l0072743D;
		((word32) esi + 8)->u0 = 0x10;
		dwLoc0C_112.u0 = 0x0140;
l0072748F:
		memset(eax_50, 0x00, dwLoc0C_112);
l0072749A:
		Eq_3 eax_81 = *((word32) esi + 4);
		*((word32) esi + 4) = (word32) eax_81 + 1;
		ecxOut = (word32) eax_81 + 1;
		return eax_81;
	}
}

// 007274B0: Register Eq_3 fn007274B0(Register Eq_3 ecx, Register (ptr32 Eq_124670) edx)
// Called from:
//      fn00728540
Eq_3 fn007274B0(Eq_3 ecx, struct Eq_124670 * edx)
{
	if (edx > (struct Eq_124670 *) 0x8E)
	{
l00727578:
		struct Eq_124673 * esp_107;
		word32 eax_109;
		_iob_func();
		esp_107->tFFFFFFFC = eax_109 + 0x40;
		fprintf(esp_107->tFFFFFFFC, esp_107->t0000, 0x00);
		esp_107->tFFFFFFF8.u0 = 0x008DA66C;
		fn006E86F0(esp_107->tFFFFFFF8);
		return 0x00;
	}
	else
	{
		ui32 edx_20;
		word32 eax_21;
		switch ((word32) edx->b7275DF)
		{
		case 0x00:
		case 0x12:
		case 0x13:
		case 0x14:
		case 0x15:
		case 22:
		case 0x17:
		case 0x18:
		case 0x19:
		case 0x1A:
		case 0x1B:
		case 0x1C:
		case 0x20:
		case 0x31:
		case 0x36:
		case 55:
		case 0x38:
		case 0x39:
		case 0x3A:
		case 0x3D:
		case 0x3E:
		case 0x3F:
		case 0x40:
		case 0x41:
		case 66:
		case 0x45:
		case 0x46:
		case 0x49:
		case 0x4A:
		case 0x4B:
		case 0x4C:
		case 77:
		case 0x4E:
		case 0x50:
		case 0x52:
		case 0x53:
		case 0x57:
		case 0x59:
		case 0x5F:
		case 0x60:
		case 0x69:
		case 0x7C:
		case 0x88:
			return ~0x00;
		case 0x01:
		case 0x02:
		case 0x04:
		case 0x09:
		case 0x0A:
		case 11:
		case 0x0C:
		case 0x0E:
		case 0x1E:
		case 0x1F:
		case 0x43:
		case 0x47:
		case 0x4F:
		case 0x55:
		case 0x56:
		case 0x5A:
		case 0x61:
		case 0x68:
		case 0x6A:
		case 0x6D:
		case 110:
		case 111:
		case 0x70:
		case 118:
		case 0x77:
		case 0x7D:
			return 0x00;
		case 0x03:
		case 0x1D:
		case 0x51:
		case 0x5C:
		case 99:
		case 100:
		case 0x67:
		case 0x6B:
		case 115:
		case 0x7B:
		case 0x86:
		case 0x87:
			return 0x01;
		case 0x05:
		case 0x06:
		case 0x07:
		case 0x08:
		case 0x0D:
		case 0x0F:
		case 0x10:
		case 33:
		case 0x22:
		case 0x23:
		case 0x24:
		case 0x25:
		case 0x26:
		case 0x2B:
		case 44:
		case 0x2D:
		case 0x2E:
		case 0x2F:
		case 0x30:
		case 0x35:
		case 0x44:
		case 0x5D:
		case 0x6C:
		case 113:
		case 114:
		case 116:
		case 117:
		case 122:
		case 0x7E:
		case 0x7F:
		case 0x80:
		case 0x89:
		case 0x8A:
			goto l00727578;
		case 0x11:
		case 0x27:
		case 0x32:
		case 0x33:
		case 0x3C:
		case 0x48:
		case 88:
		case 0x5E:
			return ~0x01;
		case 0x28:
		case 0x29:
		case 0x34:
		case 0x3B:
		case 0x54:
			return ~0x02;
		case 0x2A:
			return ~0x03;
		case 0x5B:
			return ecx - 0x01;
		case 0x62:
			return ecx;
		case 101:
		case 0x66:
			return 0x01 - ecx;
		case 0x78:
		case 121:
			return 0x03;
		case 0x81:
		case 131:
		case 133:
			return -ecx;
		case 0x82:
			int64 edx_eax_61 = (int64) ecx;
			ui32 eax_67 = ((word32) edx_eax_61 + (SLICE(edx_eax_61, word32, 32) & 0xFF) >> 0x08) * 0x02;
			ui32 eax_70 = ecx & 0x800000FF;
			if ((ecx & 0x800000FF) < 0x00)
				eax_70 = ((ecx & 0x800000FF) - 0x01 | ~0xFF) + 0x01;
			return -eax_70 - eax_67;
		case 0x84:
			return (uint32) (int8) (ecx != 0x03) + ~0x01;
		case 0x8B:
		case 0x8C:
			int64 edx_eax_24 = (int64) ecx;
			edx_20 = ((word32) edx_eax_24 + (SLICE(edx_eax_24, word32, 32) & 0xFF) >> 0x08) * 0x02;
			eax_21 = ~0x00;
			break;
		case 141:
			int64 edx_eax_12 = (int64) ecx;
			edx_20 = ((word32) edx_eax_12 + (SLICE(edx_eax_12, word32, 32) & 0xFF) >> 0x08) * 0x02;
			eax_21 = ~0x01;
			break;
		}
		word32 eax_37 = eax_21 - edx_20;
		ui32 ecx_39 = ecx & 0x800000FF;
		if ((ecx & 0x800000FF) < 0x00)
			ecx_39 = ((ecx & 0x800000FF) - 0x01 | ~0xFF) + 0x01;
		return eax_37 - ecx_39;
	}
}

// 00727670: Register Eq_3 fn00727670(Register Eq_3 eax, Register Eq_3 ebx)
// Called from:
//      fn007279E0
//      fn00728030
//      fn00728420
//      fn00729300
//      fn00729810
//      fn00729D20
//      fn00729F50
//      fn0072A350
//      fn0072AC20
//      fn0072B360
//      fn0072B830
//      fn0072BBE0
//      fn0072C510
//      fn0072CA10
//      fn0072CC90
//      fn0072CEE0
//      fn0072D130
//      fn0072D3D0
//      fn0072D830
//      fn0072D920
//      fn0072DD60
Eq_3 fn00727670(Eq_3 eax, Eq_3 ebx)
{
	byte bl_35 = (byte) ebx;
	word32 ecx_106;
	int32 eax_15 = fn00727420(*((word32) *((word32) eax + 24) + 40), out ecx_106);
	if (eax_15 < 0x00)
		return 0x00;
	Eq_3 esi_24 = *((word32) *((word32) eax + 24) + 40);
	Eq_3 eax_26 = *((word32) esi_24 + 0x0C);
	*((word32) eax_26 + eax_15 * 0x14) &= ~0x04;
	(word32) eax_26 + eax_15 * 0x14 + 0x04 = (ptr32) bl_35;
	if (ebx == 0x53)
		*((word32) esi_24 + 20) |= 0x02;
	Eq_3 edx_44 = *((word32) eax + 24);
	if (*((word32) edx_44 + 220) == 0x00)
	{
		*((word32) edx_44 + 220) = 0x01;
		Eq_3 edi_49 = *((word32) eax + 24);
		*((word32) *((word32) *((word32) edi_49 + 40) + 0x0C) + (eax_15 * 0x14 + 16)) = *((word32) edi_49 + 0x00D8);
	}
	return 0x01;
}

// 007276E0: Register Eq_3 fn007276E0(Register Eq_3 eax, Stack Eq_3 dwArg04, Register out ptr32 ecxOut)
// Called from:
//      fn00728FB0
//      fn00728FE0
//      fn00729040
//      fn00729300
//      fn0072A350
//      fn0072A740
//      fn0072A940
//      fn0072AC20
//      fn0072B040
//      fn0072BB20
//      fn0072BD40
//      fn0072C160
//      fn0072C510
Eq_3 fn007276E0(Eq_3 eax, Eq_3 dwArg04, ptr32 & ecxOut)
{
	Eq_3 eax_62;
	ptr32 ecx_356;
	Eq_3 eax_14 = *((word32) eax + 4);
	if (eax_14 != 10609848)
	{
		word32 edx_463;
		word32 ecx_462;
		if (fn006D5670(eax_14, 10609848, out ecx_462, out edx_463) == 0x00)
			goto l0072773C;
	}
	Eq_3 rLoc1_328 = *((word32) eax + 8);
	byte bLoc01_331 = SLICE(rLoc1_328, byte, 56);
	if ((byte) rLoc1_328 == 0x00 && bLoc01_331 == 0x00)
	{
		word32 esi_467;
		word32 edx_466;
		eax_62 = fn006DFF80(0x03, out ecx_356, out edx_466, out esi_467);
l00727747:
		if (eax_62 == 0x00)
		{
			ecxOut = ecx_356;
			return ~0x00;
		}
		ptr32 ecx_133;
		struct Eq_124924 * esp_171;
		Eq_3 ebx_136;
		ptr32 esp_130;
		word32 edx_469;
		word32 ecx_468;
		Eq_3 eax_119 = fn006FBCC0(dwArg04, dwArg04, out ecx_468, out edx_469);
		if (eax_119 == 0x00)
		{
			Eq_3 eax_140 = fn006FCF20(dwArg04);
			ebx_136 = eax_140;
			word32 edx_473;
			Eq_3 eax_149 = fn007050A0(eax_140, out ecx_133, out edx_473);
			if (eax_149 == 0x00)
			{
				word32 v15_275 = (word32) *eax_62 - 1;
				*eax_62 = v15_275;
				if (v15_275 == 0x00)
				{
					Eq_3 eax_293 = *((word32) eax_62 + 4);
					ptr32 ecx_300;
					(*((word32) eax_293 + 24))();
					ecxOut = ecx_300;
					return ~0x00;
				}
				goto l007277CA;
			}
			word32 edi_476;
			word32 ebx_475;
			word32 edx_474;
			Eq_3 eax_166 = fn006FBD90(dwArg04, dwArg04, eax_149, out ecx_133, out edx_474, out ebx_475, out edi_476);
			esp_171 = fp - 0x18;
			if (eax_166 < 0x00)
			{
				word32 v17_235 = (word32) *eax_62 - 1;
				*eax_62 = v17_235;
				if (v17_235 == 0x00)
				{
					Eq_3 edx_239 = *((word32) eax_62 + 4);
					Eq_3 eax_240 = *((word32) edx_239 + 24);
					word32 esp_243;
					eax_240();
					esp_171 = esp_243 + 0x04;
				}
				word32 v20_253 = (word32) *eax_149 - 1;
				*eax_149 = v20_253;
				if (v20_253 == 0x00)
				{
					Eq_3 ecx_257 = *((word32) eax_149 + 4);
					Eq_3 edx_258 = *((word32) ecx_257 + 24);
					esp_171->tFFFFFFFC = eax_149;
					edx_258();
				}
l007277CA:
				ecxOut = ecx_133;
				return ~0x00;
			}
			word32 v19_175 = (word32) *eax_149 - 1;
			*eax_149 = v19_175;
			if (v19_175 != 0x00)
			{
l007277F0:
				word32 v18_196 = (word32) *eax_62 - 1;
				*eax_62 = v18_196;
				if (v18_196 == 0x00)
				{
					Eq_3 edx_200 = *((word32) eax_62 + 4);
					Eq_3 eax_201 = *((word32) edx_200 + 24);
					esp_171->tFFFFFFFC = eax_62;
					eax_201();
				}
				ecxOut = ecx_133;
				return ebx_136;
			}
			Eq_3 eax_179 = *((word32) eax_149 + 4);
			(*((word32) eax_179 + 24))();
		}
		else
		{
			esp_130 = fp - 0x1C;
			word32 edx_470;
			word32 edi_472;
			word32 esi_471;
			ebx_136 = fn007051A0(edi, eax_119, out ecx_133, out edx_470, out esi_471, out edi_472);
		}
		esp_171 = esp_130 + 0x04;
		goto l007277F0;
	}
l0072773C:
	word32 esi_465;
	word32 edx_464;
	eax_62 = fn006DFF80(0x02, out ecx_356, out edx_464, out esi_465);
	goto l00727747;
}

// 00727810: Register Eq_3 fn00727810(Register Eq_3 eax, Stack Eq_125083 bArg04, Stack Eq_3 dwArg08, Register out Eq_125085 ecxOut)
// Called from:
//      fn00727EF0
//      fn00727F90
//      fn00728030
//      fn00728420
//      fn00728FB0
//      fn00728FE0
//      fn00729040
//      fn00729300
//      fn00729810
//      fn00729D20
//      fn00729F50
//      fn0072A350
//      fn0072A740
//      fn0072A940
//      fn0072AC20
//      fn0072B040
//      fn0072B360
//      fn0072BB20
//      fn0072BBE0
//      fn0072BD40
//      fn0072BDC0
//      fn0072C510
//      fn0072D3D0
//      fn0072D830
//      fn0072D920
//      fn0072DD60
Eq_3 fn00727810(Eq_3 eax, Eq_125083 bArg04, Eq_3 dwArg08, union Eq_125085 & ecxOut)
{
	Eq_125085 ecx_17;
	int32 eax_15 = fn00727420(*((word32) *((word32) eax + 24) + 40), out ecx_17);
	if (eax_15 >= 0x00)
	{
		Eq_3 eax_26 = *((word32) *((word32) *((word32) eax + 24) + 40) + 0x0C);
		*((word32) eax_26 + eax_15 * 0x14) |= 0x04;
		struct Eq_125116 * eax_33 = (word32) eax_26 + eax_15 * 0x14;
		eax_33->t0004 = bArg04;
		eax_33->t0008 = dwArg08;
		Eq_3 edx_37 = *((word32) eax + 24);
		if (*((word32) edx_37 + 220) == 0x00)
		{
			*((word32) edx_37 + 220) = 0x01;
			Eq_3 edi_42 = *((word32) eax + 24);
			*((word32) *((word32) *((word32) edi_42 + 40) + 0x0C) + (eax_15 * 0x14 + 16)) = *((word32) edi_42 + 0x00D8);
		}
		ecxOut = eax_15 * 0x14;
		return 0x01;
	}
	else
	{
		ecxOut = ecx_17;
		return 0x00;
	}
}

// 00727880: Register Eq_3 fn00727880(Register Eq_3 eax, Stack Eq_125083 bArg04, Stack Eq_3 dwArg08, Stack Eq_3 dwArg0C)
// Called from:
//      fn007279E0
//      fn00728030
//      fn00729300
//      fn00729810
//      fn00729F50
//      fn0072CC90
//      fn0072CEE0
//      fn0072D130
//      fn0072D3D0
//      fn0072D830
//      fn0072D920
//      fn0072DD60
Eq_3 fn00727880(Eq_3 eax, Eq_125083 bArg04, Eq_3 dwArg08, Eq_3 dwArg0C)
{
	word32 ecx_112;
	int32 eax_15 = fn00727420(*((word32) *((word32) eax + 24) + 40), out ecx_112);
	if (eax_15 < 0x00)
		return 0x00;
	ui32 edx_40;
	Eq_3 eax_26 = *((word32) *((word32) *((word32) eax + 24) + 40) + 0x0C);
	*((word32) eax_26 + eax_15 * 0x14) |= 0x04;
	struct Eq_125193 * eax_33 = (word32) eax_26 + eax_15 * 0x14;
	eax_33->t0004 = bArg04;
	eax_33->t000C = dwArg08;
	ui32 edx_38 = eax_33->dw0000;
	if (dwArg0C != 0x00)
		edx_40 = edx_38 | 0x01;
	else
		edx_40 = edx_38 | 0x02;
	eax_33->dw0000 = edx_40;
	Eq_3 eax_50 = *((word32) eax + 24);
	if (*((word32) eax_50 + 220) == 0x00)
	{
		*((word32) eax_50 + 220) = 0x01;
		Eq_3 edi_55 = *((word32) eax + 24);
		*((word32) *((word32) *((word32) edi_55 + 40) + 0x0C) + (eax_15 * 0x14 + 16)) = *((word32) edi_55 + 0x00D8);
	}
	return 0x01;
}

// 00727910: Register word32 fn00727910(Register Eq_3 ecx, Register Eq_3 ebx, Register Eq_3 ebp, Register Eq_3 esi, Register Eq_3 edi, Register (ptr16 Eq_7) es, Register (ptr16 Eq_8) ds)
// Called from:
//      fn00729040
word32 fn00727910(Eq_3 ecx, Eq_3 ebx, Eq_3 ebp, Eq_3 esi, Eq_3 edi, struct Eq_7 * es, struct Eq_8 * ds)
{
	ui32 eax_7 = g_tA14188 ^ fp - 0x0164;
	Eq_3 dwLoc016C_193 = edi;
	word32 ecx_222;
	Eq_3 edx_129;
	Eq_3 eax_159 = fn007475E0(**((word32) esi + 24), out ecx_222, out edx_129);
	if (eax_159 == 0x00)
	{
		Eq_3 edx_37 = *((word32) esi + 24);
		Eq_3 eax_38 = *((word32) edx_37 + 0x0C);
		Eq_3 edi_49;
		word32 edx_224;
		Eq_3 eax_47 = fn006DDDB0(eax_38, edx_37, ecx, esi, eax_159, es, ds, eax_38, out edx_224, out edi_49);
		Eq_3 edx_59 = *((word32) *((word32) esi + 24) + 16);
		Eq_3 edi_69;
		word32 edx_225;
		fn006DDDB0((word32) eax_47 + 20, edx_59, ecx, esi, edi_49, es, ds, edx_59, out edx_225, out edi_69);
		Eq_3 eax_83 = *((word32) esi + 24);
		Eq_3 edx_85 = *((word32) *eax_83 + 0x0C);
		Eq_3 edi_90;
		word32 edx_226;
		Eq_3 eax_88 = fn006DDDB0(eax_83, edx_85, ecx, esi, edi_69, es, ds, edx_85, out edx_226, out edi_90);
		Eq_3 edx_100 = **((word32) esi + 24);
		Eq_3 eax_109 = *((word32) edx_100 + 8);
		Eq_3 edi_114;
		word32 edx_227;
		fn006DDDB0(eax_109, edx_100, ecx, esi, edi_90, es, ds, eax_109, out edx_227, out edi_114);
		edx_129 = (word32) *((word32) *((word32) esi + 24) + 4) + 20;
		fn00724FE0(fp - 0x0154, 0x015E, &g_b8DA698);
		fn006E86F0(fp - 0x0154);
		dwLoc016C_193 = (word32) eax_88 + 20;
		eax_159 = edi_114;
	}
	word32 ecx_223;
	return fn00694B8E(eax_159, eax_7 ^ fp - 356, edx_129, ebx, ebp, esi, dwLoc016C_193, es, ds, ebx, out ecx_223);
}

// 007279E0: Register word32 fn007279E0(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08)
// Called from:
//      fn0072B360
word32 fn007279E0(Eq_3 dwArg04, Eq_3 dwArg08)
{
	Eq_3 esi_11 = *((word32) dwArg04 + 24);
	word32 edx_312;
	word32 ecx_311;
	Eq_3 eax_17 = fn00723860(0x20, out ecx_311, out edx_312);
	if (eax_17 != 0x00)
	{
		eax_17->u0 = 0x00;
		((word32) eax_17 + 4)->u0 = 0x00;
		((word32) eax_17 + 8)->u0 = 0x00;
		((word32) eax_17 + 0x0C)->u0 = 0x00;
		((word32) eax_17 + 16)->u0 = 0x00;
		((word32) eax_17 + 20)->u0 = 0x00;
		((word32) eax_17 + 24)->u0 = 0x00;
		((word32) eax_17 + 28)->u0 = 0x00;
		*eax_17 = *((word32) esi_11 + 36);
		*((word32) esi_11 + 36) = eax_17;
		Eq_3 ebx_46 = *((word32) dwArg04 + 24);
		word32 edx_314;
		word32 ecx_313;
		Eq_3 eax_49 = fn00723860(0x20, out ecx_313, out edx_314);
		if (eax_49 != 0x00)
		{
			eax_49->u0 = 0x00;
			((word32) eax_49 + 4)->u0 = 0x00;
			((word32) eax_49 + 8)->u0 = 0x00;
			((word32) eax_49 + 0x0C)->u0 = 0x00;
			((word32) eax_49 + 16)->u0 = 0x00;
			((word32) eax_49 + 20)->u0 = 0x00;
			((word32) eax_49 + 24)->u0 = 0x00;
			((word32) eax_49 + 28)->u0 = 0x00;
			*eax_49 = *((word32) ebx_46 + 36);
			*((word32) ebx_46 + 36) = eax_49;
			if (fn0072B360(dwArg04, *((word32) dwArg08 + 4)) == 0x00 || (fn00727880(dwArg04, 111, dwArg04, dwArg08) == 0x00 || (fn00727670(dwArg04, 0x01) == 0x00 || (fn0072B360(dwArg04, dwArg04) == 0x00 || fn00727880(dwArg04, 110, dwArg04, dwArg08) == 0x00))))
				return 0x00;
			*((word32) *((word32) *((word32) dwArg04 + 24) + 40) + 16) = eax_49;
			*((word32) *((word32) dwArg04 + 24) + 40) = eax_49;
			if (fn00727670(dwArg04, 0x01) == 0x00 || fn0072B360(dwArg04, dwArg04) == 0x00)
				return 0x00;
			*((word32) *((word32) *((word32) dwArg04 + 24) + 40) + 16) = eax_17;
			*((word32) *((word32) dwArg04 + 24) + 40) = eax_17;
			return 0x01;
		}
		else
		{
			word32 ecx_317;
			word32 edx_318;
			fn006E1210(out ecx_317, out edx_318);
			return 0x00;
		}
	}
	else
	{
		word32 ecx_315;
		word32 edx_316;
		fn006E1210(out ecx_315, out edx_316);
		return 0x00;
	}
}

// 00727B20: Register Eq_3 fn00727B20(Register Eq_3 eax)
// Called from:
//      fn0072B360
Eq_3 fn00727B20(Eq_3 eax)
{
	if (eax > 0x04)
		return 0x00;
	switch ((word32) eax)
	{
	case 0x01:
		return 0x0F;
	case 0x02:
		return 0x0C;
	case 0x03:
		return 0x0A;
	case 0x04:
		return 11;
	}
}

// 00727B60: Register Eq_3 fn00727B60(Register Eq_3 eax, Stack Eq_3 dwArg04)
// Called from:
//      fn0072B360
Eq_3 fn00727B60(Eq_3 eax, Eq_3 dwArg04)
{
	if (eax > 0x0C)
		return 0x00;
	switch ((word32) eax)
	{
	case 0x01:
		return 0x17;
	case 0x02:
		return 0x18;
	case 0x03:
		return 0x14;
	case 0x04:
		Eq_3 eax_21 = *((word32) dwArg04 + 0x0C);
		if (eax_21 == 0x00 || (*eax_21 & 0x2000) == 0x00)
			return 0x15;
		else
			return 0x1B;
	case 0x05:
		return 22;
	case 0x06:
		return 0x13;
	case 0x07:
		return 0x3E;
	case 0x08:
		return 0x3F;
	case 0x09:
		return 66;
	case 0x0A:
		return 0x41;
	case 11:
		return 0x40;
	case 0x0C:
		return 0x1A;
	}
}

// 00727C10: void fn00727C10(Register up32 eax)
// Called from:
//      fn00728030
void fn00727C10(up32 eax)
{
	if (eax > 0x0A)
		return;
	switch (eax)
	{
	case 0x01:
		return;
	case 0x02:
		return;
	case 0x03:
		return;
	case 0x04:
		return;
	case 0x05:
		return;
	case 0x06:
		return;
	case 0x07:
		return;
	case 0x08:
		return;
	case 0x09:
		return;
	case 0x0A:
		return;
	}
}

// 00727C90: Register word32 fn00727C90(Register Eq_3 ecx, Stack Eq_3 dwArg04)
// Called from:
//      fn0072B830
word32 fn00727C90(Eq_3 ecx, Eq_3 dwArg04)
{
	if (ecx > 0x0C)
	{
		word32 ecx_78;
		word32 edx_79;
		fn006E15D0(g_tA18720, 9283308, out ecx_78, out edx_79);
		return 0x00;
	}
	else
	{
		switch (ecx)
		{
		case 0x01:
			return 55;
		case 0x02:
			return 0x38;
		case 0x03:
			return 0x39;
		case 0x04:
			Eq_3 eax_34 = *((word32) dwArg04 + 0x0C);
			if (eax_34 == 0x00 || (*eax_34 & 0x2000) == 0x00)
				return 0x3A;
			else
				return 0x1D;
		case 0x05:
			return 0x3B;
		case 0x06:
			return 0x43;
		case 0x07:
			return 0x4B;
		case 0x08:
			return 0x4C;
		case 0x09:
			return 0x4F;
		case 0x0A:
			return 0x4E;
		case 11:
			return 77;
		case 0x0C:
			return 0x1C;
		}
	}
}

// 00727D50: Register Eq_3 fn00727D50(Register Eq_3 eax, Register Eq_3 edi)
// Called from:
//      fn0072B360
Eq_3 fn00727D50(Eq_3 eax, Eq_3 edi)
{
	Eq_3 esi_21 = *((word32) edi + 24);
	byte bLoc08_320 = (byte) ((uint32) (int8) (*((word32) eax + 4) != 0x01) + 111);
	word32 edx_324;
	word32 ecx_323;
	Eq_3 eax_29 = fn00723860(0x20, out ecx_323, out edx_324);
	if (eax_29 != 0x00)
	{
		word32 eax_58;
		eax_29->u0 = 0x00;
		((word32) eax_29 + 4)->u0 = 0x00;
		((word32) eax_29 + 8)->u0 = 0x00;
		((word32) eax_29 + 0x0C)->u0 = 0x00;
		((word32) eax_29 + 16)->u0 = 0x00;
		((word32) eax_29 + 20)->u0 = 0x00;
		((word32) eax_29 + 24)->u0 = 0x00;
		((word32) eax_29 + 28)->u0 = 0x00;
		*eax_29 = *((word32) esi_21 + 36);
		*((word32) esi_21 + 36) = eax_29;
		Eq_3 ecx_53 = *((word32) eax + 8);
		if (ecx_53 == 0x00)
			eax_58 = 0x00;
		else
			eax_58 = (word32) *ecx_53;
		int32 eax_63 = eax_58 + ~0x00;
		int32 ebx_175 = 0x00;
		if (eax_63 > 0x00)
		{
			union Eq_125765 * dwLoc10_251 = (word32) ecx_53 + 4;
			do
			{
				if (fn0072B360(edi, *dwLoc10_251) == 0x00)
					return 0x00;
				word32 ecx_327;
				int32 eax_100 = fn00727420(*((word32) *((word32) edi + 24) + 40), out ecx_327);
				if (eax_100 < 0x00)
					return 0x00;
				Eq_3 eax_111 = *((word32) *((word32) *((word32) edi + 24) + 40) + 0x0C);
				*((word32) eax_111 + eax_100 * 0x14) |= 0x06;
				struct Eq_125799 * eax_118 = (word32) eax_111 + eax_100 * 0x14;
				eax_118->b0004 = bLoc08_320;
				eax_118->t000C = eax_29;
				Eq_3 eax_121 = *((word32) edi + 24);
				if (*((word32) eax_121 + 220) == 0x00)
				{
					*((word32) eax_121 + 220) = 0x01;
					Eq_3 eax_126 = *((word32) edi + 24);
					*((word32) *((word32) *((word32) eax_126 + 40) + 0x0C) + (eax_100 * 0x14 + 16)) = *((word32) eax_126 + 0x00D8);
				}
				word32 ecx_328;
				int32 eax_141 = fn00727420(*((word32) *((word32) edi + 24) + 40), out ecx_328);
				if (eax_141 < 0x00)
					return 0x00;
				Eq_3 eax_152 = *((word32) *((word32) *((word32) edi + 24) + 40) + 0x0C);
				*((word32) eax_152 + eax_141 * 0x14) &= ~0x04;
				(word32) eax_152 + eax_141 * 0x14 + 0x04 = (ptr32) 0x01;
				Eq_3 edx_160 = *((word32) edi + 24);
				if (*((word32) edx_160 + 220) == 0x00)
				{
					*((word32) edx_160 + 220) = 0x01;
					Eq_3 eax_165 = *((word32) edi + 24);
					*((word32) *((word32) *((word32) eax_165 + 40) + 0x0C) + (eax_141 * 0x14 + 16)) = *((word32) eax_165 + 0x00D8);
				}
				dwLoc10_251 = (union Eq_125765 *) ((const char *) dwLoc10_251 + 4);
				++ebx_175;
			} while (ebx_175 < eax_63);
		}
		if (fn0072B360(edi, *((word32) ecx_53 + (eax_63 * 0x04 + 4))) == 0x00)
			return 0x00;
		*((word32) *((word32) *((word32) edi + 24) + 40) + 16) = eax_29;
		*((word32) *((word32) edi + 24) + 40) = eax_29;
		return 0x01;
	}
	else
	{
		word32 ecx_325;
		word32 edx_326;
		fn006E1210(out ecx_325, out edx_326);
		return 0x00;
	}
}

// 00727EF0: Register Eq_3 fn00727EF0(Stack Eq_3 dwArg08)
// Called from:
//      fn0072B360
Eq_3 fn00727EF0(Eq_3 dwArg08)
{
	Eq_3 dwArg08_149;
	Eq_3 eax_8 = *((word32) dwArg08 + 4);
	int32 edi_12 = 0x00;
	if (eax_8 == 0x00)
		dwArg08_149.u0 = 0x00;
	else
		dwArg08_149 = *eax_8;
	if (*((word32) dwArg08 + 8) == 0x02)
	{
		word32 ecx_237;
		Eq_3 eax_32 = fn00727810(dwArg04, 0x5C, dwArg08_149, out ecx_237);
		if (eax_32 == 0x00)
			return eax_32;
	}
	Eq_3 ebx_48 = *((word32) dwArg08 + 4);
	while (true)
	{
		int32 eax_60;
		if (ebx_48 == 0x00)
			eax_60 = 0x00;
		else
			eax_60 = (int32) *ebx_48;
		if (edi_12 >= eax_60)
			break;
		if (fn0072B360(dwArg04, dwArg04) == 0x00)
			return 0x00;
		++edi_12;
	}
	if (*((word32) dwArg08 + 8) != 0x01)
		return 0x01;
	word32 ecx_238;
	if (fn00727810(dwArg04, 0x67, dwArg04, out ecx_238) != 0x00)
		return 0x01;
	return 0x00;
}

// 00727F90: Register Eq_3 fn00727F90(Stack Eq_3 dwArg08)
// Called from:
//      fn0072B360
Eq_3 fn00727F90(Eq_3 dwArg08)
{
	Eq_3 dwArg08_149;
	Eq_3 eax_8 = *((word32) dwArg08 + 4);
	int32 edi_12 = 0x00;
	if (eax_8 == 0x00)
		dwArg08_149.u0 = 0x00;
	else
		dwArg08_149 = *eax_8;
	if (*((word32) dwArg08 + 8) == 0x02)
	{
		word32 ecx_237;
		Eq_3 eax_32 = fn00727810(dwArg04, 0x5C, dwArg08_149, out ecx_237);
		if (eax_32 == 0x00)
			return eax_32;
	}
	Eq_3 ebx_48 = *((word32) dwArg08 + 4);
	while (true)
	{
		int32 eax_60;
		if (ebx_48 == 0x00)
			eax_60 = 0x00;
		else
			eax_60 = (int32) *ebx_48;
		if (edi_12 >= eax_60)
			break;
		if (fn0072B360(dwArg04, dwArg04) == 0x00)
			return 0x00;
		++edi_12;
	}
	if (*((word32) dwArg08 + 8) != 0x01)
		return 0x01;
	word32 ecx_238;
	if (fn00727810(dwArg04, 0x66, dwArg04, out ecx_238) != 0x00)
		return 0x01;
	return 0x00;
}

// 00728030: Register Eq_3 fn00728030(Register Eq_3 eax, Stack Eq_3 dwArg04)
// Called from:
//      fn0072B360
Eq_3 fn00728030(Eq_3 eax, Eq_3 dwArg04)
{
	int32 esi_20 = 0x00;
	Eq_3 dwLoc04_416 = 0x00;
	if (fn0072B360(eax, *((word32) dwArg04 + 4)) == 0x00)
		return 0x00;
	int32 dwLoc08_460;
	Eq_3 eax_36 = *((word32) dwArg04 + 8);
	if (eax_36 == 0x00)
		dwLoc08_460 = 0x00;
	else
	{
		int32 eax_39 = *eax_36;
		dwLoc08_460 = eax_39;
		if (eax_39 > 0x01)
		{
			Eq_3 eax_46 = fn00727340(eax);
			dwLoc04_416 = eax_46;
			if (eax_46 == 0x00 || fn0072B360(eax, dwArg04) == 0x00)
				return 0x00;
			esi_20 = eax_39;
		}
		else
			esi_20 = eax_39;
	}
	int32 ebp_252 = 0x01;
	if (esi_20 > 0x01)
	{
		do
		{
			word32 ecx_558;
			int32 eax_92 = fn00727420(*((word32) *((word32) eax + 24) + 40), out ecx_558);
			if (eax_92 < 0x00)
				return 0x00;
			Eq_3 eax_103 = *((word32) *((word32) *((word32) eax + 24) + 40) + 0x0C);
			*((word32) eax_103 + eax_92 * 0x14) &= ~0x04;
			(word32) eax_103 + eax_92 * 0x14 + 0x04 = (ptr32) 0x04;
			Eq_3 edx_111 = *((word32) eax + 24);
			if (*((word32) edx_111 + 220) == 0x00)
			{
				*((word32) edx_111 + 220) = 0x01;
				Eq_3 eax_116 = *((word32) eax + 24);
				*((word32) *((word32) *((word32) eax_116 + 40) + 0x0C) + (eax_92 * 0x14 + 16)) = *((word32) eax_116 + 0x00D8);
			}
			word32 ecx_555;
			int32 eax_131 = fn00727420(*((word32) *((word32) eax + 24) + 40), out ecx_555);
			if (eax_131 < 0x00)
				return 0x00;
			Eq_3 eax_142 = *((word32) *((word32) *((word32) eax + 24) + 40) + 0x0C);
			*((word32) eax_142 + eax_131 * 0x14) &= ~0x04;
			(word32) eax_142 + eax_131 * 0x14 + 0x04 = (ptr32) 0x03;
			Eq_3 edx_150 = *((word32) eax + 24);
			if (*((word32) edx_150 + 220) == 0x00)
			{
				*((word32) edx_150 + 220) = 0x01;
				Eq_3 eax_155 = *((word32) eax + 24);
				*((word32) *((word32) *((word32) eax_155 + 40) + 0x0C) + (eax_131 * 0x14 + 16)) = *((word32) eax_155 + 0x00D8);
			}
			fn00727C10(*((word32) *((word32) dwArg04 + 8) + ebp_252 * 0x04));
			word32 ecx_556;
			if (fn00727810(eax, 0x6A, dwArg04, out ecx_556) == 0x00 || (fn00727880(eax, 111, dwArg04, 0x00) == 0x00 || (fn007273D0(eax) == 0x00 || (fn00727670(eax, 0x01) == 0x00 || ebp_252 < dwLoc08_460 - 0x01 && fn0072B360(eax, dwArg04) == 0x00))))
				return 0x00;
			++ebp_252;
		} while (ebp_252 < dwLoc08_460);
		esi_20 = dwLoc08_460;
	}
	if (fn0072B360(eax, dwArg04) == 0x00)
		return 0x00;
	fn00727C10(*((word32) *((word32) dwArg04 + 8) + esi_20 * 0x04));
	word32 ecx_557;
	if (fn00727810(eax, 0x6A, dwArg04, out ecx_557) == 0x00)
		return 0x00;
	if (esi_20 <= 0x01)
		return 0x01;
	Eq_3 eax_314 = fn00727340(eax);
	if (eax_314 == 0x00 || fn00727880(eax, 110, dwArg04, 0x00) == 0x00)
		return 0x00;
	*((word32) *((word32) *((word32) eax + 24) + 40) + 16) = dwLoc04_416;
	*((word32) *((word32) eax + 24) + 40) = dwLoc04_416;
	if (fn00727670(eax, 0x02) == 0x00 || fn00727670(eax, 0x01) == 0x00)
		return 0x00;
	*((word32) *((word32) *((word32) eax + 24) + 40) + 16) = eax_314;
	*((word32) *((word32) eax + 24) + 40) = eax_314;
	return 0x01;
}

// 007282B0: Register Eq_55932 fn007282B0(Register Eq_3 ecx)
// Called from:
//      fn0072CC90
//      fn0072D130
Eq_55932 fn007282B0(Eq_3 ecx)
{
	word32 eax_6 = *ecx;
	if (eax_6 == 0x0D)
	{
		word32 ecx_132;
		word32 edx_133;
		return fn006DEA90(*((word32) ecx + 4), out ecx_132, out edx_133);
	}
	else if (eax_6 == 0x0E)
	{
		word32 ecx_134;
		word32 edx_135;
		return fn006DEA90(*((word32) ecx + 4), out ecx_134, out edx_135);
	}
	else
	{
		if (eax_6 != 0x11)
			return ~0x00;
		byte * esi_47 = (word32) *((word32) ecx + 4) + 20;
		byte * edi_48 = &g_b8DA718;
		word32 ecx_49 = 0x0A;
		bool v16_81 = false;
		while (ecx_49 != 0x00)
		{
			v16_81 = *esi_136 != *edi_137;
			esi_47 = esi_136 + 1;
			edi_48 = edi_137 + 1;
			--ecx_49;
			esi_136 = esi_47;
			edi_137 = edi_48;
			if (*esi_136 == *edi_137)
				break;
		}
		if (v16_81)
			return ~0x00;
		return (uint32) (int8) (g_dwA6DBF4 == 0x00);
	}
}

// 00728310: Register Eq_3 fn00728310(Register Eq_3 eax, Stack word32 dwArg04, Stack Eq_3 dwArg08)
// Called from:
//      fn00729300
//      fn00729F50
//      fn0072CEE0
//      fn0072D130
//      fn0072D3D0
//      fn0072DD60
Eq_3 fn00728310(Eq_3 eax, word32 dwArg04, Eq_3 dwArg08)
{
	Eq_3 ecx_6 = *((word32) eax + 24);
	if (*((word32) ecx_6 + 48) < 0x14)
	{
		int32 ecx_10 = *((word32) ecx_6 + 48);
		*((word32) ecx_6 + 48) = ecx_10 + 0x01;
		*((word32) ecx_6 + (ecx_10 * 0x08 + 52)) = dwArg04;
		*((word32) ecx_6 + (ecx_10 * 0x08 + 56)) = dwArg08;
		return 0x01;
	}
	else
	{
		word32 ecx_55;
		word32 edx_56;
		fn006E0F80(g_tA18720, 9283364, out ecx_55, out edx_56);
		return 0x00;
	}
}

// 00728360: Register Eq_3 fn00728360(Register Eq_3 eax, Stack Eq_3 dwArg04)
// Called from:
//      fn00729510
//      fn00729810
//      fn00729D20
//      fn0072A740
//      fn0072A940
//      fn0072AC20
//      fn0072B360
//      fn0072B830
//      fn0072BF10
//      fn0072C160
//      fn0072C510
//      fn0072D3D0
//      fn0072D920
//      fn0072DD60
Eq_3 fn00728360(Eq_3 eax, Eq_3 dwArg04)
{
	Eq_3 edx_17 = *eax;
	Eq_3 eax_26 = fn006E1AB0(edx_17, 0x00, ebp, esi, eax, es, ds, edx_17, *((word32) *((word32) eax + 24) + 0x00D8));
	Eq_3 ebx_113 = 0x00;
	Eq_3 esi_31 = eax_26;
	if (eax_26 == 0x00)
	{
		++g_dwA163B8;
		esi_31.u0 = 0x00A163B8;
	}
	Eq_3 eax_117;
	word32 edx_247;
	word32 esi_248;
	Eq_3 eax_60 = fn006EA200(out edx_247, out esi_248);
	eax_117 = eax_60;
	if (eax_60 != 0x00)
	{
		word32 edx_249;
		word32 esi_250;
		eax_117 = fn006EA200(out edx_249, out esi_250);
		ebx_113 = eax_117;
		if (eax_117 != 0x00)
		{
			word32 ecx_251;
			word32 edx_252;
			eax_117 = fn006E0E90(g_tA178F4, eax_117, out ecx_251, out edx_252);
		}
	}
	word32 v14_104 = (word32) *esi_31.u0 - 1;
	*esi_31.u0 = v14_104;
	struct Eq_126511 * esp_110 = fp - 0x0C;
	if (v14_104 == 0x00)
	{
		Eq_3 edx_108 = *((word64) esi_31.u0 + 4);
		Eq_3 eax_109 = *((word32) edx_108 + 24);
		word32 esp_116;
		eax_109();
		esp_110 = esp_116 + 0x04;
	}
	if (eax_60 != 0x00)
	{
		word32 v15_129 = (word32) *eax_60 - 1;
		*eax_60 = v15_129;
		if (v15_129 == 0x00)
		{
			Eq_3 ecx_133 = *((word32) eax_60 + 4);
			Eq_3 edx_134 = *((word32) ecx_133 + 24);
			esp_110->tFFFFFFFC = eax_60;
			word32 esp_143;
			edx_134();
			esp_110 = esp_143 + 0x04;
		}
	}
	if (ebx_113 != 0x00)
	{
		word32 v16_156 = (word32) *ebx_113 - 1;
		*ebx_113 = v16_156;
		if (v16_156 == 0x00)
		{
			Eq_3 eax_160 = *((word32) ebx_113 + 4);
			Eq_3 ecx_161 = *((word32) eax_160 + 24);
			esp_110->tFFFFFFFC = ebx_113;
			ecx_161();
		}
	}
	return 0x00;
}

// 00728420: Register Eq_3 fn00728420(Register Eq_3 ecx)
// Called from:
//      fn0072BDC0
Eq_3 fn00728420(Eq_3 ecx)
{
	Eq_3 esi_33 = 0x00;
	if (ecx <= 0x06)
	{
		switch (ecx)
		{
		case 0x01:
		case 0x04:
			esi_33.u0 = 0x19;
			break;
		case 0x02:
		case 0x05:
			esi_33.u0 = 0x3C;
			break;
		case 0x03:
			esi_33.u0 = 0x3D;
			break;
		case 0x06:
			word32 edx_162;
			word32 ecx_161;
			fn006E15D0(g_tA18720, 0x008DA758, out ecx_161, out edx_162);
			return 0x00;
		}
	}
	if (ecx != 0x04)
	{
		if (ecx != 0x05)
			return fn00727670(edi, esi_33) == 0x00;
		Eq_3 eax_64 = fn00727670(edi, 0x03);
		if (eax_64 != 0x00)
			return fn00727670(edi, esi_33) == 0x00;
		return eax_64;
	}
	else
	{
		word32 ecx_163;
		Eq_3 eax_81 = fn00727810(edi, 99, 0x02, out ecx_163);
		if (eax_81 != 0x00)
			return fn00727670(edi, esi_33) == 0x00;
		return eax_81;
	}
}

// 007284C0: Register word32 fn007284C0(Stack Eq_3 dwArg08, Stack Eq_3 dwArg0C)
// Called from:
//      fn007284C0
//      fn0072A350
word32 fn007284C0(Eq_3 dwArg08, Eq_3 dwArg0C)
{
	Eq_3 eax_8 = *((word32) dwArg08 + 20);
	if (((byte) eax_8 & 0x01) == 0x00)
	{
		*((word32) dwArg08 + 20) = eax_8 | 0x01;
		Eq_3 eax_15 = *((word32) dwArg08 + 16);
		if (eax_15 != 0x00)
			fn007284C0(eax_15, dwArg0C);
		Eq_3 ebx_41 = 0x00;
		if (*((word32) dwArg08 + 4) > 0x00)
		{
			int32 edi_51 = 0x00;
			do
			{
				if ((*((word32) *((word32) dwArg08 + 0x0C) + edi_51) & 0x03) != 0x00)
					fn007284C0(dwArg04, dwArg08);
				ebx_41 = (word32) ebx_41 + 1;
				edi_51 += 0x14;
			} while (ebx_41 < *((word32) dwArg08 + 4));
		}
		*((word32) *((word32) dwArg0C + 0x0C) + *((word32) dwArg0C + 8) * 0x04) = dwArg08;
		*((word32) dwArg0C + 8) = (word32) *((word32) dwArg0C + 8) + 1;
	}
	return ebp;
}

// 00728540: Register Eq_3 fn00728540(Stack Eq_3 dwArg08, Stack Eq_3 dwArg0C, Stack Eq_3 dwArg10, Register out Eq_540 ebpOut, Register out Eq_540 esiOut)
// Called from:
//      fn00728540
//      fn00728610
Eq_3 fn00728540(Eq_3 dwArg08, Eq_3 dwArg0C, Eq_3 dwArg10, union Eq_540 & ebpOut, union Eq_540 & esiOut)
{
	Eq_3 eax_11 = *((word32) dwArg08 + 20);
	if (((byte) eax_11 & 0x01) == 0x00)
	{
		Eq_3 ebp_19 = dwArg0C;
		if (*((word32) dwArg08 + 24) < dwArg0C)
		{
			Eq_3 dwArg08_180;
			*((word32) dwArg08 + 20) = eax_11 | 0x01;
			*((word32) dwArg08 + 24) = dwArg0C;
			Eq_3 edi_121 = dwArg10;
			word32 dwLoc04_179 = 0x01;
			dwArg08_180 = dwArg08;
			if (*((word32) dwArg08 + 4) > 0x00)
			{
				dwArg08_180.u0 = 0x00;
				do
				{
					Eq_3 esi_49 = *((word32) dwArg08 + 0x0C);
					ebp_19 = (word32) ebp_19 + fn007274B0(*((word32) esi_49 + 8), (word32) (*((word32) esi_49 + 4)));
					if (ebp_19 > edi_121)
						edi_121 = ebp_19;
					if ((*esi_49 & 0x03) != 0x00)
					{
						word32 ebp_277;
						word32 esi_278;
						edi_121 = fn00728540(*((word32) esi_49 + 0x0C), 0x00, dwArg0C, out ebp_277, out esi_278);
						Eq_3 al_96 = *((word32) esi_49 + 4);
						if (al_96 == 113 || al_96 == 110)
							goto l007285ED;
					}
					dwLoc04_179 = dwLoc04_279 + 0x01;
					dwLoc04_279 = dwLoc04_179;
				} while (dwLoc04_279 + 0x00 < *((word32) dwArg08 + 4));
			}
			Eq_3 eax_114 = *((word32) dwArg08 + 16);
			if (eax_114 != 0x00)
			{
				word32 ebp_275;
				word32 esi_276;
				edi_121 = fn00728540(eax_114, dwArg08_180, dwArg0C, out ebp_275, out esi_276);
			}
l007285ED:
			*((word32) dwArg08 + 20) &= ~0x01;
			ebpOut.u0 = <invalid>;
			esiOut.u0 = <invalid>;
			return edi_121;
		}
	}
	ebpOut.u0 = <invalid>;
	esiOut.u0 = <invalid>;
	return dwArg10;
}

// 00728610: Register Eq_3 fn00728610(Register Eq_3 edi, Register out ptr32 ebpOut, Register out ptr32 esiOut)
// Called from:
//      fn00728BE0
Eq_3 fn00728610(Eq_3 edi, ptr32 & ebpOut, ptr32 & esiOut)
{
	Eq_3 eax_12 = *((word32) *((word32) edi + 24) + 36);
	if (eax_12 != 0x00)
	{
		do
		{
			*((word32) eax_96 + 20) &= ~0x01;
			((word32) eax_96 + 24)->u0 = 0x80000000;
			eax_12 = *eax_96;
			eax_96 = eax_12;
		} while (eax_12 != 0x00);
		if (eax_96 != 0x00)
		{
			ptr32 ebp_38;
			ptr32 esi_42;
			Eq_3 eax_37 = fn00728540(eax_96, 0x00, 0x00, out ebp_38, out esi_42);
			ebpOut = ebp_38;
			esiOut = esi_42;
			return eax_37;
		}
	}
	ebpOut = ebp;
	esiOut = esi;
	return 0x00;
}

// 00728650: Register word32 fn00728650(Register (ptr32 Eq_126868) esi, Register uint32 edi, Stack Eq_3 dwArg04)
// Called from:
//      fn0072A350
word32 fn00728650(struct Eq_126868 * esi, uint32 edi, Eq_3 dwArg04)
{
	esi->t0000.u0 = 0x00;
	esi->dw0004 = 0x00;
	esi->dw0008 = 0x00;
	esi->t000C.u0 = 0x00;
	esi->t0010.u0 = 0x00;
	esi->dw0014 = 0x00;
	esi->dw001C = 0x00;
	esi->t0018 = dwArg04;
	word32 ecx_110;
	word32 edx_111;
	Eq_3 eax_22 = fn006EC9B0(0x00, 0x80, out ecx_110, out edx_111);
	esi->t0000 = eax_22;
	if (eax_22 == 0x00)
		return 0x00;
	word32 ecx_112;
	word32 edx_113;
	Eq_3 eax_36 = fn006EC9B0(0x00, dwArg04, out ecx_112, out edx_113);
	esi->t0010 = eax_36;
	if (eax_36 == 0x00)
		return 0x00;
	if (edi <= 0x3FFFFFFF)
	{
		word32 ecx_114;
		word32 edx_115;
		Eq_3 eax_51 = fn00723860(edi * 0x04, out ecx_114, out edx_115);
		esi->t000C = eax_51;
		if (eax_51 != 0x00)
			return 0x01;
	}
	word32 ecx_116;
	word32 edx_117;
	fn006E1210(out ecx_116, out edx_117);
	return 0x00;
}

// 007286D0: Register word32 fn007286D0(Register Eq_3 esi, Stack Eq_3 dwArg04)
// Called from:
//      fn007288B0
word32 fn007286D0(Eq_3 esi, Eq_3 dwArg04)
{
	int32 ecx_9 = *((word32) dwArg04 + 16) - *((word32) esi + 24);
	int32 ebx_102 = *((word32) esi + 4) - *((word32) esi + 28);
	int32 dwLoc08_341 = ecx_9;
	if (ebx_102 == 0x00)
	{
		if (ecx_9 == 0x00)
			return 0x01;
	}
	else if (ebx_102 > 0xFF)
	{
		int32 edx_31 = SLICE(ebx_102 *s64 0x80808081, word32, 32) + ebx_102;
		Eq_126991 edi_35 = (edx_31 >> 0x07 >> 0x1F) + (edx_31 >> 0x07);
		Eq_3 eax_37 = (word32) *((word32) esi + 20) + edi_35 * 0x02;
		Eq_3 edx_40 = *((word32) *((word32) esi + 16) + 8);
		if (eax_37 >= edx_40)
		{
			if (edx_40 > 0x3FFFFFFF)
				goto l00728762;
			if (edx_40 * 0x02 >= eax_37)
				eax_37 = edx_40 * 0x02;
			word32 ecx_465;
			word32 edx_466;
			if (fn006EC4F0((word32) esi + 16, eax_37, out ecx_465, out edx_466) < 0x00)
				return 0x00;
		}
		byte * eax_80 = (word32) *((word32) esi + 16) + ((word32) (*((word32) esi + 20)) + 20);
		if (edi_35 > 0x00)
		{
			Eq_126991 edx_81 = edi_35;
			do
			{
				*eax_80 = ~0x00;
				byte * eax_84 = eax_80 + 1;
				*eax_84 = 0x00;
				eax_80 = eax_84 + 1;
				--edx_81;
			} while (edx_81 != 0x00);
		}
		*((word32) esi + 20) = (word32) *((word32) esi + 20) + edi_35 * 0x02;
		ebx_102 += edi_35 *s ~0xFE;
	}
	byte bl_198 = (byte) ebx_102;
	byte cl_307 = (byte) ecx_9;
	if (ecx_9 <= 0xFF)
	{
l0072884A:
		byte bl_300 = (byte) ebx_102;
		if ((word32) *((word32) esi + 20) + 2 >= *((word32) (*((word32) esi + 16)) + 8))
		{
			word32 ecx_469;
			word32 edx_470;
			if (fn006EC4F0((word32) esi + 16, dwArg04, out ecx_469, out edx_470) < 0x00)
				return 0x00;
			cl_307 = (byte) dwLoc08_341;
		}
		Eq_3 eax_289 = *((word32) esi + 20);
		struct Eq_127158 * edx_292 = (word32) eax_289 + ((word32) (*((word32) esi + 16)) + 20);
		*((word32) esi + 20) = (word32) eax_289 + 2;
		if (ebx_102 != 0x00)
			edx_292->b0000 = bl_300;
		else
			edx_292->b0000 = 0x00;
		edx_292->b0001 = cl_307;
		Eq_3 edx_316 = *((word32) esi + 4);
		*((word32) esi + 24) = *((word32) dwArg04 + 16);
		*((word32) esi + 28) = edx_316;
		return 0x01;
	}
	int32 edx_132 = SLICE(ecx_9 *s64 0x80808081, word32, 32) + ecx_9;
	Eq_127095 edi_136 = (edx_132 >> 0x07 >> 0x1F) + (edx_132 >> 0x07);
	Eq_3 eax_138 = (word32) *((word32) esi + 20) + edi_136 * 0x02;
	Eq_3 edx_142 = *((word32) *((word32) esi + 16) + 8);
	if (eax_138 < edx_142)
	{
l00728807:
		struct Eq_127117 * eax_196 = (word32) *((word32) esi + 16) + ((word32) (*((word32) esi + 20)) + 20);
		eax_196->b0000 = bl_198;
		eax_196->b0001 = ~0x00;
		byte * eax_202 = &eax_196->b0001 + 1;
		ebx_102 = 0x00;
		if (edi_136 > 0x01)
		{
			Eq_127220 edx_207 = edi_136 - 0x01;
			do
			{
				*eax_202 = 0x00;
				byte * eax_210 = eax_202 + 1;
				*eax_210 = ~0x00;
				eax_202 = eax_210 + 1;
				--edx_207;
			} while (edx_207 != 0x00);
		}
		*((word32) esi + 20) = (word32) *((word32) esi + 20) + edi_136 * 0x02;
		int32 ecx_228 = ecx_9 + edi_136 *s ~0xFE;
		cl_307 = (byte) ecx_228;
		dwLoc08_341 = ecx_228;
		goto l0072884A;
	}
	if (edx_142 <= 0x3FFFFFFF)
	{
		word32 ecx_467;
		word32 edx_468;
		if (fn006EC4F0((word32) esi + 16, dwArg04, out ecx_467, out edx_468) < 0x00)
			return 0x00;
		goto l00728807;
	}
l00728762:
	word32 ecx_463;
	word32 edx_464;
	fn006E1210(out ecx_463, out edx_464);
	return 0x00;
}

// 007288B0: Register Eq_3 fn007288B0(Register Eq_3 eax, Register Eq_3 edi)
// Called from:
//      fn0072A350
Eq_3 fn007288B0(Eq_3 eax, Eq_3 edi)
{
	ui32 ebp_39;
	int32 edx_17 = *((word32) *eax + 8);
	Eq_3 ecx_113 = 0x00;
	int32 ebx_22 = 0x00;
	ui32 eax_23 = *edi >> 0x02 & 0x01;
	Eq_3 dwLoc08_193 = 0x00;
	if (eax_23 == 0x00)
		ebp_39 = 0x01;
	else
		ebp_39 = ((uint32) (int8) (*((word32) edi + 8) <= 0xFFFF) - 0x01 & 0x03) + 0x03;
	if (eax_23 != 0x00)
	{
		Eq_3 ebx_48 = *((word32) edi + 8);
		dwLoc08_193 = ebx_48;
		ecx_113 = ebx_48;
		ebx_22 = ebx_48 >> 0x10;
	}
	byte bl_127 = (byte) ebx_22;
	if (*((word32) edi + 16) != 0x00)
	{
		if (fn007286D0(eax, edi) == 0x00)
			return 0x00;
		ecx_113 = dwLoc08_193;
	}
	if ((word32) *((word32) eax + 4) + ebp_39 >= edx_17)
	{
		if (edx_17 > 0x3FFFFFFF)
			return 0x00;
		word32 edx_263;
		word32 ecx_262;
		if (fn006EC4F0(eax, edx_17 * 0x02, out ecx_262, out edx_263) < 0x00)
			return 0x00;
		ecx_113 = dwLoc08_193;
	}
	Eq_3 edx_116 = *((word32) eax + 4);
	struct Eq_127310 * eax_118 = (word32) edx_116 + ((word32) (*eax) + 20);
	*((word32) eax + 4) = (word32) edx_116 + ebp_39;
	if (ebp_39 == 0x06)
	{
		eax_118->t0000.u0 = ~0x70;
		eax_118->b0001 = bl_127;
		eax_118->b0002 = (byte) (ebx_22 >> 0x08);
		eax_118 = &eax_118->b0002 + 1;
		ecx_113 &= 0xFFFF;
	}
	eax_118->t0000 = *((word32) edi + 4);
	byte cl_154 = (byte) ecx_113;
	struct Eq_127343 * eax_150 = &eax_118->b0001;
	if ((*edi & 0x04) != 0x00)
	{
		eax_150->b0000 = cl_154;
		eax_150->b0001 = (byte) (ecx_113 >> 0x08);
	}
	return 0x01;
}

// 007289A0: void fn007289A0(Stack (ptr32 Eq_127380) dwArg04, Stack Eq_3 dwArg08)
// Called from:
//      fn0072A350
void fn007289A0(struct Eq_127380 * dwArg04, Eq_3 dwArg08)
{
	word32 dwLoc04_208 = 0x00;
	while (true)
	{
		int32 ebp_22 = dwArg04->dw0008;
		word32 ebx_23 = 0x00;
		int32 ebp_24 = ebp_22 - 0x01;
		if (ebp_22 >= 0x01)
		{
			do
			{
				struct Eq_127398 * edi_34 = dwArg04->ptr000C[ebp_24];
				word32 edx_35 = 0x00;
				if (edi_34->dw0004 > 0x00)
				{
					struct Eq_127409 * eax_38 = edi_34->ptr000C;
					int32 esi_39 = edi_34->dw0004;
					do
					{
						ui32 ecx_53;
						if ((eax_38->b0000 & 0x04) == 0x00)
							ecx_53 = 0x01;
						else
							ecx_53 = ((uint32) (int8) (eax_38->dw0008 <= 0xFFFF) - 0x01 & 0x03) + 0x03;
						edx_35 += ecx_53;
						++eax_38;
						--esi_39;
					} while (esi_39 != 0x00);
				}
				edi_34->dw001C = ebx_23;
				ebx_23 += edx_35;
				--ebp_24;
			} while (ebp_24 >= 0x00);
		}
		Eq_3 esi_175 = *((word32) *((word32) dwArg08 + 24) + 36);
		word32 eax_181 = 0x00;
		word32 dwLoc08_218 = 0x00;
		if (esi_175 != 0x00)
		{
			do
			{
				Eq_3 ebx_129 = *((word32) esi_175 + 28);
				Eq_3 ebp_161 = 0x00;
				if (*((word32) esi_175 + 4) > 0x00)
				{
					int32 edi_102 = 0x00;
					do
					{
						ui32 edx_125;
						Eq_3 eax_109 = *((word32) esi_175 + 0x0C);
						byte cl_113 = *((word32) eax_109 + edi_102);
						struct Eq_127458 * eax_112 = (word32) eax_109 + edi_102;
						if ((cl_113 & 0x04) == 0x00)
							edx_125 = 0x01;
						else
							edx_125 = ((uint32) (int8) (eax_112->dw0008 <= 0xFFFF) - 0x01 & 0x03) + 0x03;
						int32 edx_143;
						ebx_129 = (word32) ebx_129 + edx_125;
						if ((cl_113 & 0x01) != 0x00)
						{
							edx_143 = eax_112->ptr000C->dw001C;
							goto l00728A75;
						}
						if ((cl_113 & 0x02) != 0x00)
						{
							edx_143 = eax_112->ptr000C->dw001C - ebx_129;
l00728A75:
							eax_112->dw0008 = edx_143;
							if (edx_143 > 0xFFFF)
								++dwLoc08_218;
						}
						ebp_161 = (word32) ebp_161 + 1;
						edi_102 += 0x14;
					} while (ebp_161 < *((word32) esi_175 + 4));
				}
				esi_175 = *esi_175;
			} while (esi_175 != 0x00);
			eax_181 = dwLoc08_218;
		}
		if (dwLoc04_208 == eax_181)
			break;
		dwLoc04_208 = eax_181;
	}
}

// 00728AC0: Register word32 fn00728AC0(Register Eq_3 ebx, Register Eq_3 edi)
// Called from:
//      fn00728BE0
word32 fn00728AC0(Eq_3 ebx, Eq_3 edi)
{
	word32 ecx_150;
	word32 edx_151;
	Eq_3 eax_22 = fn006DFD20(fn006FCF20(edi), out ecx_150, out edx_151);
	if (eax_22 == 0x00)
		return;
	word32 edx_152;
	if (fn006FC050(edi, fp - 0x04, fp - 0x0C, fp - 0x08, out edx_152) != 0x00)
	{
		do
		{
			Eq_3 ecx_59 = *((word32) dwLoc0C + 0x0C);
			ui32 eax_58 = dwLoc08->dw0008;
			*ecx_59 = (word32) *ecx_59 + 1;
			*((word32) eax_22 + ((eax_58 - ebx) * 0x04 + 0x0C)) = ecx_59;
			dwLoc0C = ecx_59;
			word32 edx_153;
		} while (fn006FC050(edi, fp - 0x04, fp - 0x0C, fp - 0x08, out edx_153) != 0x00);
	}
	return;
}

// 00728B50: Register ui32 fn00728B50(Register Eq_3 edi)
// Called from:
//      fn00728BE0
ui32 fn00728B50(Eq_3 edi)
{
	Eq_3 edx_6 = *((word32) edi + 24);
	struct Eq_127620 * ecx_7 = *edx_6;
	word32 eax_8 = ecx_7->dw001C;
	ui32 esi_106 = 0x00;
	if (eax_8 != 0x02)
		esi_106 = 0x02;
	if (eax_8 == 0x00)
	{
		if (ecx_7->dw0020 == eax_8)
			esi_106 |= 0x01;
		byte al_31 = ecx_7->b0024;
		if ((al_31 & 0x01) != 0x00)
			esi_106 |= 0x10;
		if ((al_31 & 0x08) != 0x00)
			esi_106 |= 0x20;
	}
	byte cl_52 = ecx_7->b0024;
	if ((cl_52 & 0x10) != 0x00)
		esi_106 |= 0x04;
	if ((cl_52 & 0x20) != 0x00)
		esi_106 |= 0x08;
	if ((cl_52 & 0x08) != 0x00)
		esi_106 |= 0x20;
	ui32 esi_107 = esi_106 | *(*((word32) edi + 0x0C)) & 0xE000;
	Eq_3 eax_120 = fn006FCF20(*((word32) edx_6 + 24));
	if (eax_120 < 0x00)
		return ~0x00;
	if (eax_120 != 0x00)
		return esi_107;
	Eq_3 eax_135 = fn006FCF20(*((word32) *((word32) edi + 24) + 20));
	if (eax_135 < 0x00)
		return ~0x00;
	if (eax_135 == 0x00)
		esi_107 |= 0x40;
	return esi_107;
}

// 00728BE0: Register word32 fn00728BE0(Register Eq_3 esi)
// Called from:
//      fn0072A350
word32 fn00728BE0(Eq_3 esi)
{
	Eq_3 eax_27 = fn00728AC0(0x00, *((word32) *((word32) esi + 24) + 8));
	if (eax_27 == 0x00)
		return;
	Eq_3 eax_47 = fn007035C0(eax_27);
	word32 v12_53 = (word32) *eax_27 - 1;
	*eax_27 = v12_53;
	struct Eq_127742 * esp_52 = fp - 0x30;
	Eq_3 ebp_270 = eax_47;
	if (v12_53 == 0x00)
	{
		Eq_3 ecx_58 = *((word32) eax_27 + 4);
		word32 esp_62;
		(*((word32) ecx_58 + 24))();
		esp_52 = esp_62 + 0x04;
	}
	Eq_3 eax_81 = fn00728AC0(0x00, *((word32) *((word32) esi + 24) + 0x0C));
	Eq_3 edi_87 = *((word32) *((word32) esi + 24) + 16);
	esp_52->t0014 = eax_81;
	Eq_3 eax_90 = fn00728AC0(0x00, edi_87);
	esp_52->t0010 = eax_90;
	Eq_3 ebx_113 = 0x00;
	struct Eq_127742 * esp_107 = esp_52;
	Eq_3 edi_304 = eax_90;
	if (eax_47 != 0x00)
	{
		if (esp_52->t0014 != 0x00 && eax_90 != 0x00)
		{
			Eq_3 eax_108 = fn00728AC0(0x00, *((word32) *((word32) esi + 24) + 20));
			esp_52->t000C = eax_108;
			esp_107 = esp_52;
			ebx_113 = eax_108;
			if (eax_108 != 0x00)
			{
				esp_52->tFFFFFFFC = eax_108;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_3 stackArg4 = <invalid>;
				struct Eq_127829 * esp_120 = esp_52 - 4;
				word32 ecx_645;
				word32 edx_646;
				Eq_3 eax_132 = fn00728AC0(fn006DFE20(stackArg4, out ecx_645, out edx_646), *((word32) *((word32) esi + 24) + 24));
				esp_120->t0024 = eax_132;
				esp_107 = (struct Eq_127742 *) ((const char *) &esp_120->t0000 + 4);
				if (eax_132 != 0x00)
				{
					esp_120->t0000 = *esi;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_3 stackArg4 = <invalid>;
					word32 ecx_648;
					word32 edx_649;
					Eq_3 eax_145 = fn006ECAC0(stackArg4, out ecx_648, out edx_649);
					esp_120->t0020 = eax_145;
					esp_107 = (struct Eq_127742 *) ((const char *) &esp_120->t0000 + 4);
					if (eax_145 != 0x00)
					{
						esp_120->t0000 = *((word32) *((word32) esi + 24) + 16);
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_3 stackArg4 = <invalid>;
						esp_120->t0030 = fn006FCF20(stackArg4);
						int32 eax_170 = fn00728B50(esi);
						esp_120->dw002C = eax_170;
						esp_107 = (struct Eq_127742 *) ((const char *) &esp_120->t0000 + 4);
						if (eax_170 >= 0x00)
						{
							struct Eq_127904 * ebx_180 = esp_120->ptr0038;
							word32 eax_181 = ebx_180->dw0000;
							esp_120->t0000 = esp_120->t0018;
							esp_120->tFFFFFFFC = eax_47;
							esp_120->dwFFFFFFF8 = eax_181;
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							Eq_3 stackArg4 = <invalid>;
							word32 eax_190 = fn00726930(ebx_180->t0010, stackArg4);
							esp_120->dw0028 = eax_190;
							esp_107 = (struct Eq_127742 *) ((const char *) &esp_120->t0000 + 4);
							if (eax_190 != 0x00)
							{
								esp_120->t0000 = eax_47;
								// Failed to bind call argument.
								// Please report this issue at https://github.com/uxmal/reko
								Eq_3 stackArg4 = <invalid>;
								Eq_3 eax_203 = fn006F4F00(stackArg4);
								esp_107 = (struct Eq_127742 *) ((const char *) &esp_120->t0000 + 4);
								if (eax_203 != 0x00)
								{
									word32 v16_213 = (word32) *eax_47 - 1;
									*eax_47 = v16_213;
									if (v16_213 == 0x00)
									{
										Eq_3 ecx_217 = *((word32) eax_47 + 4);
										Eq_3 edx_218 = *((word32) ecx_217 + 24);
										esp_120->t0000 = eax_47;
										word32 esp_221;
										edx_218();
										esp_107 = esp_221 + 0x04;
									}
									Eq_3 eax_231 = *((word32) esi + 24);
									Eq_3 edx_232 = *((word32) eax_231 + 212);
									Eq_3 eax_235 = *((word32) eax_231 + 4);
									struct Eq_127973 * esp_237 = esp_107 - 4;
									esp_237->t0000 = ebx_180->t0010;
									word32 ecx_239 = esp_237->dw0020;
									esp_237->tFFFFFFFC = edx_232;
									word32 edx_242 = esp_237->dw0010;
									esp_237->tFFFFFFF8 = eax_235;
									word32 eax_245 = esp_237->dw0024;
									esp_237->dwFFFFFFF4 = ecx_239;
									word32 ecx_248 = esp_237->dw0014;
									esp_237->dwFFFFFFF0 = edx_242;
									word32 edx_251 = esp_237->dw0018;
									esp_237->dwFFFFFFEC = eax_245;
									word32 eax_254 = esp_237->dw0028;
									esp_237->dwFFFFFFE8 = ecx_248;
									word32 ecx_257 = esp_237->dw002C;
									esp_237->dwFFFFFFE4 = edx_251;
									esp_237->tFFFFFFE0 = eax_203;
									esp_237->dwFFFFFFDC = eax_254;
									esp_237->dwFFFFFFD8 = ecx_257;
									struct Eq_128040 * esi_275;
									word32 eax_269 = fn00728610(esi, out ebp_270, out esi_275);
									word32 edx_280 = esp_237->dw0030;
									esp_237->dwFFFFFFD4 = eax_269;
									word32 ecx_284 = esi_275->ptr0018->dw0020;
									esp_237->dwFFFFFFD0 = edx_280;
									esp_237->dwFFFFFFCC = ecx_284;
									// Failed to bind call argument.
									// Please report this issue at https://github.com/uxmal/reko
									// Failed to bind call argument.
									// Please report this issue at https://github.com/uxmal/reko
									// Failed to bind call argument.
									// Please report this issue at https://github.com/uxmal/reko
									// Failed to bind call argument.
									// Please report this issue at https://github.com/uxmal/reko
									// Failed to bind call argument.
									// Please report this issue at https://github.com/uxmal/reko
									// Failed to bind call argument.
									// Please report this issue at https://github.com/uxmal/reko
									// Failed to bind call argument.
									// Please report this issue at https://github.com/uxmal/reko
									// Failed to bind call argument.
									// Please report this issue at https://github.com/uxmal/reko
									// Failed to bind call argument.
									// Please report this issue at https://github.com/uxmal/reko
									// Failed to bind call argument.
									// Please report this issue at https://github.com/uxmal/reko
									// Failed to bind call argument.
									// Please report this issue at https://github.com/uxmal/reko
									// Failed to bind call argument.
									// Please report this issue at https://github.com/uxmal/reko
									// Failed to bind call argument.
									// Please report this issue at https://github.com/uxmal/reko
									// Failed to bind call argument.
									// Please report this issue at https://github.com/uxmal/reko
									Eq_3 stackArg4 = <invalid>;
									Eq_3 stackArg8 = <invalid>;
									Eq_3 stackArg12 = <invalid>;
									Eq_3 stackArg16 = <invalid>;
									Eq_3 stackArg20 = <invalid>;
									Eq_3 stackArg24 = <invalid>;
									Eq_3 stackArg28 = <invalid>;
									Eq_3 stackArg32 = <invalid>;
									Eq_3 stackArg36 = <invalid>;
									Eq_3 stackArg40 = <invalid>;
									Eq_3 stackArg44 = <invalid>;
									Eq_3 stackArg48 = <invalid>;
									Eq_3 stackArg52 = <invalid>;
									Eq_3 stackArg56 = <invalid>;
									word32 edx_667;
									esp_237->dw001C = fn00734BB0(stackArg4, stackArg8, stackArg12, stackArg16, stackArg20, stackArg24, stackArg28, stackArg32, stackArg36, stackArg40, stackArg44, stackArg48, stackArg52, stackArg56, out edx_667);
									esp_107 = (struct Eq_127742 *) ((const char *) &esp_237->t0000 + 4);
								}
							}
						}
					}
				}
				ebx_113 = esp_107->t000C;
			}
			edi_304 = esp_107->t0010;
		}
		if (ebp_270 != 0x00)
		{
			word32 v23_312 = (word32) *ebp_270 - 1;
			*ebp_270 = v23_312;
			if (v23_312 == 0x00)
			{
				Eq_3 edx_316 = *((word32) ebp_270 + 4);
				Eq_3 eax_317 = *((word32) edx_316 + 24);
				esp_107->tFFFFFFFC = ebp_270;
				word32 esp_330;
				eax_317();
				esp_107 = esp_330 + 0x04;
			}
		}
	}
	Eq_3 eax_340 = esp_107->t0014;
	if (eax_340 != 0x00)
	{
		word32 v17_344 = (word32) *eax_340 - 1;
		*eax_340 = v17_344;
		if (v17_344 == 0x00)
		{
			Eq_3 ecx_348 = *((word32) eax_340 + 4);
			Eq_3 edx_349 = *((word32) ecx_348 + 24);
			esp_107->tFFFFFFFC = eax_340;
			word32 esp_357;
			edx_349();
			esp_107 = esp_357 + 0x04;
		}
	}
	if (edi_304 != 0x00)
	{
		word32 v18_370 = (word32) *edi_304 - 1;
		*edi_304 = v18_370;
		if (v18_370 == 0x00)
		{
			Eq_3 eax_374 = *((word32) edi_304 + 4);
			Eq_3 ecx_375 = *((word32) eax_374 + 24);
			esp_107->tFFFFFFFC = edi_304;
			word32 esp_383;
			ecx_375();
			esp_107 = esp_383 + 0x04;
		}
	}
	Eq_3 eax_393 = esp_107->t001C;
	if (eax_393 != 0x00)
	{
		word32 v19_397 = (word32) *eax_393 - 1;
		*eax_393 = v19_397;
		if (v19_397 == 0x00)
		{
			Eq_3 edx_401 = *((word32) eax_393 + 4);
			esp_107->tFFFFFFFC = eax_393;
			word32 esp_410;
			(*((word32) edx_401 + 24))();
			esp_107 = esp_410 + 0x04;
		}
	}
	Eq_3 eax_420 = esp_107->t0020;
	if (eax_420 != 0x00)
	{
		word32 v20_424 = (word32) *eax_420 - 1;
		*eax_420 = v20_424;
		if (v20_424 == 0x00)
		{
			Eq_3 ecx_428 = *((word32) eax_420 + 4);
			Eq_3 edx_429 = *((word32) ecx_428 + 24);
			esp_107->tFFFFFFFC = eax_420;
			word32 esp_437;
			edx_429();
			esp_107 = esp_437 + 0x04;
		}
	}
	if (ebx_113 != 0x00)
	{
		word32 v21_450 = (word32) *ebx_113 - 1;
		*ebx_113 = v21_450;
		if (v21_450 == 0x00)
		{
			Eq_3 eax_454 = *((word32) ebx_113 + 4);
			Eq_3 ecx_455 = *((word32) eax_454 + 24);
			esp_107->tFFFFFFFC = ebx_113;
			word32 esp_463;
			ecx_455();
			esp_107 = esp_463 + 0x04;
		}
	}
	Eq_3 eax_473 = esp_107->t0024;
	if (eax_473 != 0x00)
	{
		word32 v22_477 = (word32) *eax_473 - 1;
		*eax_473 = v22_477;
		if (v22_477 == 0x00)
		{
			Eq_3 edx_481 = *((word32) eax_473 + 4);
			esp_107->tFFFFFFFC = eax_473;
			(*((word32) edx_481 + 24))();
		}
	}
	return;
}

// 00728E40: Register Eq_3 fn00728E40(Register Eq_3 eax, Register Eq_3 ecx, Stack Eq_3 dwArg04, Stack Eq_3 dwArg08)
// Called from:
//      fn0072A5D0
//      fn0072B360
//      fn0072C160
//      fn0072C510
//      fn0072E660
Eq_3 fn00728E40(Eq_3 eax, Eq_3 ecx, Eq_3 dwArg04, Eq_3 dwArg08)
{
	word32 ecx_391;
	word32 edx_392;
	Eq_3 eax_22 = fn00723860(0xE0, out ecx_391, out edx_392);
	if (eax_22 == 0x00)
	{
		word32 ecx_393;
		word32 edx_394;
		fn006E1210(out ecx_393, out edx_394);
		return 0x00;
	}
	memset(eax_22, 0x00, 0xE0);
	*((word32) eax_22 + 32) = null;
	struct Eq_128334 * eax_49 = fn00747580(*((word32) ecx + 4), dwArg04);
	*eax_22 = eax_49;
	if (eax_49 != null)
	{
		*eax = (word32) *eax + 1;
		struct Eq_128334 * edx_61 = *eax_22;
		*((word32) eax_22 + 4) = eax;
		Eq_3 eax_67 = fn00726260(edx_61->t0014);
		struct Eq_128334 * ecx_72 = *eax_22;
		*((word32) eax_22 + 16) = eax_67;
		Eq_3 eax_84 = fn00726340(ecx_72->t000C, 0x00);
		*((word32) eax_22 + 20) = eax_84;
		if (*((word32) eax_22 + 16) != 0x00 && eax_84 != 0x00)
		{
			Eq_3 eax_114 = fn00726340(*((word32) *eax_22 + 0x0C), fn006FCF20(eax_84));
			*((word32) eax_22 + 24) = eax_114;
			if (eax_114 != 0x00)
			{
				((word32) eax_22 + 36)->u0 = 0x00;
				((word32) eax_22 + 44)->u0 = 0x00;
				*((word32) eax_22 + 48) = 0x00;
				*((word32) eax_22 + 212) = dwArg08;
				((word32) eax_22 + 0x00D8)->u0 = 0x00;
				*((word32) eax_22 + 220) = 0x00;
				word32 ecx_395;
				word32 edx_396;
				Eq_3 eax_131 = fn006FDCC0(out ecx_395, out edx_396);
				*((word32) eax_22 + 8) = eax_131;
				if (eax_131 != 0x00)
				{
					word32 ecx_397;
					word32 edx_398;
					Eq_3 eax_140 = fn006FDCC0(out ecx_397, out edx_398);
					*((word32) eax_22 + 0x0C) = eax_140;
					if (eax_140 != 0x00)
					{
						((word32) eax_22 + 28)->u0 = 0x00;
						Eq_3 eax_149 = *((word32) ecx + 24);
						if (eax_149 == 0x00)
						{
l00728F7B:
							*((word32) ecx + 20) = (word32) *((word32) ecx + 20) + 1;
							*((word32) ecx + 24) = eax_22;
							return fn00727380(ecx) == 0x00;
						}
						Eq_3 eax_157 = fn0072E920(eax_149, dwArg04);
						if (eax_157 != 0x00)
						{
							word32 ecx_399;
							word32 edx_400;
							int32 eax_172 = fn006F2A10(*((word32) ecx + 28), dwArg04, out ecx_399, out edx_400);
							if (eax_172 >= 0x00)
							{
								word32 v16_218 = (word32) *eax_157 - 1;
								*eax_157 = v16_218;
								if (v16_218 == 0x00)
								{
									Eq_3 ecx_222 = *((word32) eax_157 + 4);
									(*((word32) ecx_222 + 24))();
								}
								Eq_3 eax_237 = *((word32) *((word32) ecx + 24) + 28);
								*((word32) eax_22 + 28) = eax_237;
								if (eax_237 != 0x00)
									*eax_237 = (word32) *eax_237 + 1;
								goto l00728F7B;
							}
							word32 v18_181 = (word32) *eax_157 - 1;
							*eax_157 = v18_181;
							if (v18_181 == 0x00)
							{
								Eq_3 ecx_185 = *((word32) eax_157 + 4);
								(*((word32) ecx_185 + 24))();
							}
						}
					}
				}
			}
		}
	}
	fn00727170(eax_22);
	return 0x00;
}

// 00728FB0: Register Eq_3 fn00728FB0()
// Called from:
//      fn0072B360
//      fn0072BDC0
//      fn0072D830
//      fn0072D920
//      fn0072DD60
Eq_3 fn00728FB0()
{
	word32 ecx_58;
	Eq_3 eax_9 = fn007276E0(dwArg0C, eax, out ecx_58);
	if (eax_9 < 0x00)
		return 0x00;
	word32 ecx_59;
	return fn00727810(dwArg04, dwArg08, eax_9, out ecx_59);
}

// 00728FE0: Register Eq_3 fn00728FE0(Register Eq_3 ebx, Stack Eq_3 dwArg08)
// Called from:
//      fn0072A940
//      fn0072AC20
//      fn0072B360
Eq_3 fn00728FE0(Eq_3 ebx, Eq_3 dwArg08)
{
	word32 edx_137;
	Eq_3 eax_19 = fn00726150(*((word32) *((word32) ebx + 24) + 28), eax, out edx_137);
	if (eax_19 == 0x00)
		return eax_19;
	word32 ecx_138;
	Eq_3 eax_37 = fn007276E0(eax_19, dwArg08, out ecx_138);
	word32 v13_41 = (word32) *eax_19 - 1;
	*eax_19 = v13_41;
	if (v13_41 == 0x00)
	{
		Eq_3 ecx_46 = *((word32) eax_19 + 4);
		(*((word32) ecx_46 + 24))();
	}
	if (eax_37 < 0x00)
		return 0x00;
	word32 ecx_139;
	return fn00727810(ebx, dwArg04, eax_37, out ecx_139);
}

// 00729040: Register Eq_3 fn00729040(Register Eq_3 eax, Register (ptr16 Eq_7) es, Register (ptr16 Eq_8) ds, Stack Eq_3 dwArg04, Register out ptr32 ecxOut)
// Called from:
//      fn0072A5D0
//      fn0072B360
//      fn0072C160
//      fn0072C510
Eq_3 fn00729040(Eq_3 eax, struct Eq_7 * es, struct Eq_8 * ds, Eq_3 dwArg04, ptr32 & ecxOut)
{
	Eq_3 edi_11 = dwArg04;
	Eq_3 eax_15 = *((word32) *((word32) dwArg04 + 40) + 8);
	if (eax_15 != 0x00)
	{
		ptr32 ecx_286;
		struct Eq_128648 * esp_25 = fp - 0x20;
		if (eax_15 > 0x00)
		{
			do
			{
				struct Eq_128733 * esp_115;
				Eq_3 edx_111;
				Eq_3 eax_109;
				word32 esp_139;
				Eq_3 edi_35 = *((word32) *((word32) edi_11 + 40) + esp_25->ptr0010);
				word32 eax_42 = fn00727910(edi_35, ebx, ebp, eax, edi_35, es, ds);
				esp_25->dw001C = eax_42;
				if (eax_42 == 0x05)
				{
					Eq_3 ebp_101 = *((word32) *((word32) eax + 24) + 20);
					esp_25->dwFFFFFFFC = (word32) *((word32) edi_35 + 4);
					esp_25->dwFFFFFFF8 = (word32) edi_35;
					esp_25->dwFFFFFFF4 = 0x02;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_3 stackArg4 = <invalid>;
					struct Eq_128758 * esp_108 = esp_25 - 0x0C;
					word32 ecx_625;
					word32 esi_626;
					eax_109 = fn006DFF80(stackArg4, out ecx_625, out edx_111, out esi_626);
					esp_115 = (struct Eq_128733 *) ((const char *) &esp_108->t0008 + 4);
					if (eax_109 == 0x00)
					{
						ebx.u0 = ~0x00;
						goto l00729165;
					}
					esp_108->t0008 = eax_109;
					esp_108->t0004 = ebp_101;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_3 stackArg4 = <invalid>;
					word32 ecx_628;
					eax_109 = fn006FBCC0(stackArg4, dwArg04, out ecx_628, out edx_111);
					word32 v16_130 = (word32) *eax_109 - 1;
					*eax_109 = v16_130;
					esp_115 = (struct Eq_128733 *) ((const char *) &esp_108->t0008 + 4);
					ebp = eax_109;
					if (v16_130 != 0x00)
						goto l00729154;
					Eq_3 ecx_135 = *((word32) eax_109 + 4);
					Eq_3 edx_136 = *((word32) ecx_135 + 24);
					esp_108->t0008 = eax_109;
					edx_136();
					goto l00729151;
				}
				Eq_3 ebp_52 = *((word32) *((word32) eax + 24) + 24);
				esp_25->dwFFFFFFFC = (word32) *((word32) edi_35 + 4);
				esp_25->dwFFFFFFF8 = (word32) edi_35;
				esp_25->dwFFFFFFF4 = 0x02;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_3 stackArg4 = <invalid>;
				struct Eq_128720 * esp_59 = esp_25 - 0x0C;
				word32 esi_623;
				word32 ecx_622;
				eax_109 = fn006DFF80(stackArg4, out ecx_622, out edx_111, out esi_623);
				esp_115 = (struct Eq_128733 *) ((const char *) &esp_59->t0008 + 4);
				if (eax_109 == 0x00)
				{
					ebx.u0 = ~0x00;
					goto l00729165;
				}
				esp_59->t0008 = eax_109;
				esp_59->t0004 = ebp_52;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_3 stackArg4 = <invalid>;
				word32 ecx_633;
				eax_109 = fn006FBCC0(stackArg4, dwArg04, out ecx_633, out edx_111);
				word32 v17_81 = (word32) *eax_109 - 1;
				*eax_109 = v17_81;
				esp_115 = (struct Eq_128733 *) ((const char *) &esp_59->t0008 + 4);
				ebp = eax_109;
				if (v17_81 == 0x00)
				{
					Eq_3 edx_86 = *((word32) eax_109 + 4);
					Eq_3 eax_87 = *((word32) edx_86 + 24);
					esp_59->t0008 = eax_109;
					eax_87();
l00729151:
					esp_115 = esp_139 + 0x04;
				}
l00729154:
				if (ebp == 0x00)
				{
					ebx.u0 = ~0x00;
					goto l00729165;
				}
				ebx = *((word32) ebp + 8);
				if (ebx == ~0x00)
				{
l00729165:
					ebp = esp_115[3];
					struct Eq_128803 * esp_171 = esp_115 - 4;
					esp_171->t0000 = *((word32) ebp + 40);
					Eq_3 edi_212;
					word32 edx_629;
					Eq_3 eax_210 = fn006DDDB0(eax_109, edx_111, ebx, eax, edi_35, es, ds, esp_171->t0000, out edx_629, out edi_212);
					Eq_128822 edx_221 = *((word32) ebp + 52);
					Eq_3 ecx_222 = *((word32) eax + 24);
					esp_171->ptr0004 = (word32) eax_210 + 20;
					Eq_3 eax_227 = esp_171->t0024;
					esp_171->t0000 = (word32) edx_221.dw0000 + 20;
					Eq_3 edx_231 = *((word32) ecx_222 + 4);
					esp_171->dwFFFFFFFC = ~0x00;
					esp_171->tFFFFFFF8 = eax_227;
					esp_171->ptrFFFFFFF4 = (word32) edx_231 + 20;
					esp_171->tFFFFFFF0 = edi_212;
					word32 edi_631;
					word32 edx_630;
					esp_171->ptrFFFFFFF4 = (word32) fn006DDDB0(eax_227, (word32) edx_231 + 20, ebx, eax, edi_212, es, ds, esp_171->tFFFFFFF0, out edx_630, out edi_631) + 20;
					esp_171->tFFFFFFF0.u0 = 0x008DA794;
					printf(esp_171->tFFFFFFF0, esp_171->ptrFFFFFFF4, esp_171->tFFFFFFF8, esp_171->dwFFFFFFFC, esp_171->t0000, esp_171->ptr0004, esp_171->ptr0008);
					esp_171->tFFFFFFEC.u0 = 0x008DA77C;
					fn006E86F0(esp_171->tFFFFFFEC);
					esp_115 = (struct Eq_128733 *) ((const char *) &esp_171->ptr0008 + 4);
				}
				struct Eq_128926 * esp_271 = esp_115 - 4;
				esp_271->t0000 = ebx;
				esp_271->dwFFFFFFFC = 0x87;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_125083 stackArg4 = <invalid>;
				esp_25 = (struct Eq_128648 *) ((const char *) &esp_271->t0000 + 4);
				if (fn00727810(eax, stackArg4, dwArg04, out ecx_286) == 0x00)
					goto l00729223;
				word32 eax_294 = esp_271->dw0018;
				esp_271->dw0014 += 0x04;
				edi_11 = esp_271->t0028;
				esp_271->dw0018 = eax_294 + 0x01;
			} while (eax_294 + 0x01 < esp_271->t001C);
			eax_15 = esp_271->t001C;
		}
		struct Eq_128681 * esp_304 = esp_25 - 4;
		esp_304->t0000 = eax_15;
		esp_304->dwFFFFFFFC = 0x66;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_125083 stackArg4 = <invalid>;
		if (fn00727810(eax, stackArg4, dwArg04, out ecx_286) != 0x00)
		{
			esp_304->t0000 = *((word32) *((word32) eax + 24) + 8);
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg4 = <invalid>;
			Eq_3 eax_331 = fn007276E0(edi_11, stackArg4, out ecx_286);
			if (eax_331 >= 0x00)
			{
				esp_304->t0000 = eax_331;
				esp_304->dwFFFFFFFC = 100;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_125083 stackArg4 = <invalid>;
				if (fn00727810(eax, stackArg4, dwArg04, out ecx_286) != 0x00)
				{
					esp_304->t0000 = esp_304->t002C;
					esp_304->dwFFFFFFFC = 0x86;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_125083 stackArg4 = <invalid>;
					ptr32 ecx_363;
					Eq_3 eax_377 = fn00727810(eax, stackArg4, dwArg04, out ecx_363) == 0x00;
					ecxOut = ecx_363;
					return eax_377;
				}
			}
		}
l00729223:
		ecxOut = ecx_286;
		return 0x00;
	}
	else
	{
		ptr32 ecx_402;
		if (fn007276E0(dwArg04, *((word32) *((word32) eax + 24) + 8), out ecx_402) < 0x00 || fn00727810(eax, 100, dwArg04, out ecx_402) == 0x00)
		{
			ecxOut = ecx_402;
			return 0x00;
		}
		else
		{
			ptr32 ecx_433;
			Eq_3 eax_443 = fn00727810(eax, 0x84, dwArg04, out ecx_433) == 0x00;
			ecxOut = ecx_433;
			return eax_443;
		}
	}
}

// 00729300: Register Eq_3 fn00729300(Register Eq_3 eax, Stack Eq_3 dwArg04)
// Called from:
//      fn0072D920
Eq_3 fn00729300(Eq_3 eax, Eq_3 dwArg04)
{
	Eq_3 ebx_46;
	Eq_3 esi_18 = *((word32) eax + 24);
	word32 edx_524;
	word32 ecx_523;
	Eq_3 eax_21 = fn00723860(0x20, out ecx_523, out edx_524);
	if (eax_21 == 0x00)
	{
		word32 edx_526;
		word32 ecx_525;
		fn006E1210(out ecx_525, out edx_526);
		ebx_46.u0 = 0x00;
	}
	else
	{
		eax_21->u0 = 0x00;
		((word32) eax_21 + 4)->u0 = 0x00;
		((word32) eax_21 + 8)->u0 = 0x00;
		((word32) eax_21 + 0x0C)->u0 = 0x00;
		((word32) eax_21 + 16)->u0 = 0x00;
		((word32) eax_21 + 20)->u0 = 0x00;
		((word32) eax_21 + 24)->u0 = 0x00;
		((word32) eax_21 + 28)->u0 = 0x00;
		*eax_21 = *((word32) esi_18 + 36);
		*((word32) esi_18 + 36) = eax_21;
		ebx_46 = eax_21;
	}
	Eq_3 esi_58 = *((word32) eax + 24);
	word32 ecx_527;
	word32 edx_528;
	Eq_3 eax_101 = fn00723860(0x20, out ecx_527, out edx_528);
	if (eax_101 == 0x00)
	{
		word32 ecx_529;
		word32 edx_530;
		fn006E1210(out ecx_529, out edx_530);
		eax_101.u0 = 0x00;
	}
	else
	{
		eax_101->u0 = 0x00;
		((word32) eax_101 + 4)->u0 = 0x00;
		((word32) eax_101 + 8)->u0 = 0x00;
		((word32) eax_101 + 0x0C)->u0 = 0x00;
		((word32) eax_101 + 16)->u0 = 0x00;
		((word32) eax_101 + 20)->u0 = 0x00;
		((word32) eax_101 + 24)->u0 = 0x00;
		((word32) eax_101 + 28)->u0 = 0x00;
		*eax_101 = *((word32) esi_58 + 36);
		*((word32) esi_58 + 36) = eax_101;
	}
	if (ebx_46 == 0x00 || (eax_101 == 0x00 || fn00727880(eax, 122, eax_101, 0x00) == 0x00))
		return 0x00;
	*((word32) *((word32) *((word32) eax + 24) + 40) + 16) = ebx_46;
	*((word32) *((word32) eax + 24) + 40) = ebx_46;
	if (fn00728310(eax, 0x02, ebx_46) == 0x00)
		return 0x00;
	Eq_3 ebp_155 = *((word32) dwArg04 + 4);
	int32 ebx_156 = 0x00;
	word32 * esi_159 = (word32) ebp_155 + 4;
	while (true)
	{
		int32 eax_165;
		if (ebp_155 == 0x00)
			eax_165 = 0x00;
		else
			eax_165 = (int32) *ebp_155;
		if (ebx_156 >= eax_165)
			break;
		if (fn0072D920(eax, *esi_159) == 0x00)
			return 0x00;
		++ebx_156;
		++esi_159;
	}
	word32 ecx_531;
	int32 eax_186 = fn00727420(*((word32) *((word32) eax + 24) + 40), out ecx_531);
	if (eax_186 < 0x00)
		return 0x00;
	Eq_3 eax_196 = *((word32) *((word32) *((word32) eax + 24) + 40) + 0x0C);
	*((word32) eax_196 + eax_186 * 0x14) &= ~0x04;
	(word32) eax_196 + eax_186 * 0x14 + 0x04 = (ptr32) 0x57;
	Eq_3 edx_204 = *((word32) eax + 24);
	if (*((word32) edx_204 + 220) == 0x00)
	{
		*((word32) edx_204 + 220) = 0x01;
		Eq_3 eax_209 = *((word32) eax + 24);
		*((word32) *((word32) *((word32) eax_209 + 40) + 0x0C) + (eax_186 * 0x14 + 16)) = *((word32) eax_209 + 0x00D8);
	}
	Eq_3 eax_216 = *((word32) eax + 24);
	*((word32) eax_216 + 48) = (word32) *((word32) eax_216 + 48) - 1;
	word32 ecx_532;
	Eq_3 eax_232 = fn007276E0(0x00A163B8, *((word32) *((word32) eax + 24) + 8), out ecx_532);
	if (eax_232 < 0x00)
		return 0x00;
	word32 ecx_533;
	if (fn00727810(eax, 100, eax_232, out ecx_533) == 0x00)
		return 0x00;
	*((word32) *((word32) *((word32) eax + 24) + 40) + 16) = eax_101;
	*((word32) *((word32) eax + 24) + 40) = eax_101;
	if (fn00728310(eax, 0x03, eax_101) == 0x00)
		return 0x00;
	Eq_3 ebp_277 = *((word32) dwArg04 + 8);
	int32 ebx_278 = 0x00;
	word32 * esi_281 = (word32) ebp_277 + 4;
	while (true)
	{
		int32 eax_287;
		if (ebp_277 == 0x00)
			eax_287 = 0x00;
		else
			eax_287 = (int32) *ebp_277;
		if (ebx_278 >= eax_287)
			break;
		if (fn0072D920(eax, *esi_281) == 0x00)
			return 0x00;
		++ebx_278;
		++esi_281;
	}
	if (fn00727670(eax, 88) == 0x00)
		return 0x00;
	Eq_3 edi_319 = *((word32) eax + 24);
	*((word32) edi_319 + 48) = (word32) *((word32) edi_319 + 48) - 1;
	return 0x01;
}

// 00729510: Register Eq_3 fn00729510(Register Eq_3 ebx, Stack Eq_3 dwArg04, Stack Eq_3 dwArg08)
// Called from:
//      fn00729810
//      fn0072A520
//      fn0072B360
//      fn0072B830
//      fn0072C510
//      fn0072DD60
Eq_3 fn00729510(Eq_3 ebx, Eq_3 dwArg04, Eq_3 dwArg08)
{
	Eq_3 eax_8 = *((word32) ebx + 24);
	if (dwArg08 == 0x02 || (dwArg08 == 0x05 || dwArg08 == 0x03))
	{
		byte * esi_27 = (word32) dwArg04 + 20;
		byte * edi_28 = &g_b8DA718;
		word32 ecx_29 = 0x0A;
		bool v16_177 = false;
		while (ecx_29 != 0x00)
		{
			v16_177 = *esi_251 != *edi_252;
			esi_27 = esi_251 + 1;
			edi_28 = edi_252 + 1;
			--ecx_29;
			esi_251 = esi_27;
			edi_252 = edi_28;
			if (*esi_251 == *edi_252)
				break;
		}
		if (!v16_177)
			return fn00728360(ebx, 0x008DA884);
	}
	word32 edx_249;
	Eq_3 eax_74 = fn00726150(*((word32) eax_8 + 28), dwArg04, out edx_249);
	if (eax_74 == 0x00)
		return eax_74;
	ui32 esi_113 = 0x03;
	word32 edx_250;
	Eq_3 ecx_101;
	Eq_3 eax_102 = fn007475E0(**((word32) ebx + 24), out ecx_101, out edx_250);
	if (eax_102 <= 0x05)
	{
		switch ((word32) eax_102)
		{
		case 0x01:
			ecx_101 = **((word32) ebx + 24);
			if (*((word32) ecx_101 + 28) == 0x00)
				esi_113 = 0x00;
			break;
		case 0x02:
			goto l007295D9;
		case 0x03:
			struct Eq_129547 * eax_119 = **((word32) ebx + 24);
			if (eax_119->dw001C == 0x00 && eax_119->dw0020 == 0x00)
			{
l007295D9:
				esi_113 = 0x01;
			}
			break;
		case 0x04:
			esi_113 = 0x02;
			break;
		case 0x05:
			ecx_101 = *((word32) ebx + 24);
			esi_113 = 0x02;
			break;
		}
	}
	Eq_3 eax_149;
	(*((const char *) g_a7297A8 + esi_113 * 0x04))();
	return eax_149;
}

<anonymous> * g_a7297A8[] = // 007297A8
	{
	};
// 00729810: Register word32 fn00729810(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Stack Eq_3 dwArg0C, Stack ui32 dwArg10, Stack Eq_3 dwArg14)
// Called from:
//      fn00729810
//      fn00729D20
word32 fn00729810(Eq_3 dwArg04, Eq_3 dwArg08, Eq_3 dwArg0C, ui32 dwArg10, Eq_3 dwArg14)
{
	Eq_3 dwLoc14_732;
	Eq_3 esi_16 = *((word32) dwArg04 + 24);
	word32 ecx_1076;
	word32 edx_1077;
	Eq_3 eax_22 = fn00723860(0x20, out ecx_1076, out edx_1077);
	if (eax_22 == 0x00)
	{
		word32 ecx_1078;
		word32 edx_1079;
		fn006E1210(out ecx_1078, out edx_1079);
		dwLoc14_732.u0 = 0x00;
	}
	else
	{
		eax_22->u0 = 0x00;
		((word32) eax_22 + 4)->u0 = 0x00;
		((word32) eax_22 + 8)->u0 = 0x00;
		((word32) eax_22 + 0x0C)->u0 = 0x00;
		((word32) eax_22 + 16)->u0 = 0x00;
		((word32) eax_22 + 20)->u0 = 0x00;
		((word32) eax_22 + 24)->u0 = 0x00;
		((word32) eax_22 + 28)->u0 = 0x00;
		*eax_22 = *((word32) esi_16 + 36);
		*((word32) esi_16 + 36) = eax_22;
		dwLoc14_732 = eax_22;
	}
	Eq_3 dwLoc10_788;
	Eq_3 esi_57 = *((word32) dwArg04 + 24);
	word32 ecx_1080;
	word32 edx_1081;
	Eq_3 eax_61 = fn00723860(0x20, out ecx_1080, out edx_1081);
	if (eax_61 == 0x00)
	{
		word32 edx_1083;
		word32 ecx_1082;
		fn006E1210(out ecx_1082, out edx_1083);
		dwLoc10_788.u0 = 0x00;
	}
	else
	{
		eax_61->u0 = 0x00;
		((word32) eax_61 + 4)->u0 = 0x00;
		((word32) eax_61 + 8)->u0 = 0x00;
		((word32) eax_61 + 0x0C)->u0 = 0x00;
		((word32) eax_61 + 16)->u0 = 0x00;
		((word32) eax_61 + 20)->u0 = 0x00;
		((word32) eax_61 + 24)->u0 = 0x00;
		((word32) eax_61 + 28)->u0 = 0x00;
		*eax_61 = *((word32) esi_57 + 36);
		*((word32) esi_57 + 36) = eax_61;
		dwLoc10_788 = eax_61;
	}
	Eq_3 dwLoc0C_1069;
	Eq_3 ebx_127;
	Eq_3 esi_98 = *((word32) dwArg04 + 24);
	word32 edx_1085;
	word32 ecx_1084;
	Eq_3 eax_102 = fn00723860(0x20, out ecx_1084, out edx_1085);
	if (eax_102 == 0x00)
	{
		word32 edx_1087;
		word32 ecx_1086;
		fn006E1210(out ecx_1086, out edx_1087);
		ebx_127.u0 = 0x00;
		dwLoc0C_1069.u0 = 0x00;
	}
	else
	{
		eax_102->u0 = 0x00;
		((word32) eax_102 + 4)->u0 = 0x00;
		((word32) eax_102 + 8)->u0 = 0x00;
		((word32) eax_102 + 0x0C)->u0 = 0x00;
		((word32) eax_102 + 16)->u0 = 0x00;
		((word32) eax_102 + 20)->u0 = 0x00;
		((word32) eax_102 + 24)->u0 = 0x00;
		((word32) eax_102 + 28)->u0 = 0x00;
		*eax_102 = *((word32) esi_98 + 36);
		*((word32) esi_98 + 36) = eax_102;
		ebx_127 = eax_102;
		dwLoc0C_1069 = eax_102;
	}
	Eq_3 dwLoc08_798;
	Eq_3 edi_172;
	Eq_3 esi_143 = *((word32) dwArg04 + 24);
	word32 edx_1089;
	word32 ecx_1088;
	Eq_3 eax_147 = fn00723860(0x20, out ecx_1088, out edx_1089);
	if (eax_147 == 0x00)
	{
		word32 edx_1091;
		word32 ecx_1090;
		fn006E1210(out ecx_1090, out edx_1091);
		edi_172.u0 = 0x00;
		dwLoc08_798.u0 = 0x00;
	}
	else
	{
		eax_147->u0 = 0x00;
		((word32) eax_147 + 4)->u0 = 0x00;
		((word32) eax_147 + 8)->u0 = 0x00;
		((word32) eax_147 + 0x0C)->u0 = 0x00;
		((word32) eax_147 + 16)->u0 = 0x00;
		((word32) eax_147 + 20)->u0 = 0x00;
		((word32) eax_147 + 24)->u0 = 0x00;
		((word32) eax_147 + 28)->u0 = 0x00;
		*eax_147 = *((word32) esi_143 + 36);
		*((word32) esi_143 + 36) = eax_147;
		edi_172 = eax_147;
		dwLoc08_798 = eax_147;
	}
	if (dwLoc14_732 == 0x00 || (dwLoc10_788 == 0x00 || (ebx_127 == 0x00 || edi_172 == 0x00)))
		return 0x00;
	Eq_3 esi_202 = *((word32) dwArg0C + (dwArg10 * 0x04 + 4));
	if (fn0072B360(dwArg04, dwArg04) == 0x00 || fn00727670(dwArg04, 0x44) == 0x00)
		return 0x00;
	*((word32) *((word32) *((word32) dwArg04 + 24) + 40) + 16) = dwLoc14_732;
	*((word32) *((word32) dwArg04 + 24) + 40) = dwLoc14_732;
	if (fn00727880(dwArg04, 0x5D, dwArg04, 0x00) == 0x00 || (fn007273D0(dwArg04) == 0x00 || fn0072B360(dwArg04, dwArg04) == 0x00))
		return 0x00;
	*((word32) esi_202 + 8) != 0x00;
	Eq_3 esi_287 = 0x00;
	if (dwArg04 > 0x00)
	{
		do
		{
			if (fn0072B360(dwArg04, dwArg04) == 0x00 || (fn00727880(dwArg04, 111, dwArg04, 0x00) == 0x00 || (fn007273D0(dwArg04) == 0x00 || fn00727670(dwArg04, 0x01) == 0x00)))
				return 0x00;
			esi_287 = (word32) esi_287 + 1;
		} while (esi_287 < dwArg04);
	}
	Eq_3 eax_364;
	Eq_3 ebx_360 = dwArg0C;
	if (dwArg0C == 0x00)
		eax_364.u0 = 0x00;
	else
		eax_364 = *dwArg0C;
	if (dwArg10 + 0x01 < eax_364 && fn00729810(dwArg04, dwArg04, dwArg0C, dwArg10 + 0x01, dwArg14) == 0x00)
		return 0x00;
	if (dwArg0C != 0x00)
		ebx_360 = *dwArg0C;
	if (dwArg10 + 0x01 >= ebx_360)
	{
		if (fn00729510(dwArg04, dwArg08, dwArg04) == 0x00 || (fn0072B360(dwArg04, dwArg04) == 0x00 || fn00727670(dwArg04, 0x12) == 0x00))
			return 0x00;
		*((word32) *((word32) *((word32) dwArg04 + 24) + 40) + 16) = dwLoc10_788;
		*((word32) *((word32) dwArg04 + 24) + 40) = dwLoc10_788;
	}
	Eq_3 edi_471 = 0x00;
	if (dwArg04 > 0x00)
	{
		do
		{
			word32 ecx_1092;
			if (fn00727810(dwArg04, 110, dwArg04, out ecx_1092) == 0x00)
				return 0x00;
			if (edi_471 == 0x00)
			{
				*((word32) *((word32) *((word32) dwArg04 + 24) + 40) + 16) = dwLoc0C_1069;
				*((word32) *((word32) dwArg04 + 24) + 40) = dwLoc0C_1069;
			}
			if (fn00727670(dwArg04, 0x01) == 0x00)
				return 0x00;
			edi_471 = (word32) edi_471 + 1;
		} while (edi_471 < dwArg04);
	}
	if (fn00727880(dwArg04, 113, dwArg04, 0x01) == 0x00)
		return 0x00;
	*((word32) *((word32) *((word32) dwArg04 + 24) + 40) + 16) = dwLoc08_798;
	*((word32) *((word32) dwArg04 + 24) + 40) = dwLoc08_798;
	if (dwArg10 != 0x00)
		return 0x01;
	Eq_3 eax_565 = *((word32) dwArg04 + 24);
	byte * esi_569 = (word32) dwArg08 + 20;
	byte * edi_570 = &g_b8DA718;
	word32 ecx_571 = 0x0A;
	bool v19_722 = false;
	while (ecx_571 != 0x00)
	{
		v19_722 = *esi_1096 != *edi_1097;
		esi_569 = esi_1096 + 1;
		edi_570 = edi_1097 + 1;
		--ecx_571;
		esi_1096 = esi_569;
		edi_1097 = edi_570;
		if (*esi_1096 == *edi_1097)
			break;
	}
	if (v19_722)
	{
		word32 edx_1093;
		if (fn00726150(*((word32) eax_565 + 28), dwArg04, out edx_1093) == 0x00)
			return 0x00;
		ui32 edi_628 = 0x03;
		word32 ecx_1094;
		word32 edx_1095;
		Eq_3 eax_630 = fn007475E0(**((word32) dwArg04 + 24), out ecx_1094, out edx_1095);
		if (eax_630 <= 0x05)
		{
			switch ((word32) eax_630)
			{
			case 0x01:
				if (*((word32) **((word32) dwArg04 + 24) + 28) == 0x00)
					edi_628 = 0x00;
				break;
			case 0x02:
				goto l00729C2C;
			case 0x03:
				struct Eq_130117 * eax_648 = **((word32) dwArg04 + 24);
				if (eax_648->dw001C == 0x00 && eax_648->dw0020 == 0x00)
				{
l00729C2C:
					edi_628 = 0x01;
				}
				break;
			case 0x04:
				edi_628 = 0x02;
				break;
			case 0x05:
				edi_628 = 0x02;
				break;
			}
		}
		word32 eax_675;
		(*((const char *) g_a729D04 + edi_628 * 0x04))();
		return eax_675;
	}
	else
	{
		Eq_3 eax_684 = fn00728360(dwArg04, 0x008DA884);
		if (eax_684 == 0x00)
			return 0x00;
		return 0x01;
	}
}

<anonymous> * g_a729D04[] = // 00729D04
	{
	};
// 00729D20: Register Eq_3 fn00729D20(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08)
// Called from:
//      fn0072B360
Eq_3 fn00729D20(Eq_3 dwArg04, Eq_3 dwArg08)
{
	if (g_tA6DBF0 == 0x00)
	{
		word32 ecx_436;
		word32 edx_437;
		Eq_3 eax_19 = fn006F1A70(out ecx_436, out edx_437);
		g_tA6DBF0 = eax_19;
		if (eax_19 == 0x00)
			return eax_19;
	}
	Eq_3 eax_39 = fn007272E0(ebx, dwArg04, esi, edi, es, ds, dwArg04);
	if (eax_39 == 0x00)
		return 0x00;
	word32 ecx_438;
	if (fn00727810(dwArg04, 0x67, dwArg04, out ecx_438) == 0x00)
		return 0x00;
	Eq_3 eax_72 = fn00727670(dwArg04, 0x04);
	if (eax_72 == 0x00)
		return eax_72;
	Eq_3 eax_80 = *((word32) dwArg04 + 24);
	byte * esi_86 = (word32) eax_39 + 20;
	byte * edi_87 = &g_b8DA718;
	word32 ecx_88 = 0x0A;
	bool v17_295 = false;
	while (ecx_88 != 0x00)
	{
		v17_295 = *esi_442 != *edi_443;
		esi_86 = esi_442 + 1;
		edi_87 = edi_443 + 1;
		--ecx_88;
		esi_442 = esi_86;
		edi_443 = edi_87;
		if (*esi_442 == *edi_443)
			break;
	}
	Eq_3 esi_208;
	if (!v17_295)
	{
		Eq_3 eax_195 = fn00728360(dwArg04, 0x008DA884);
		if (eax_195 != 0x00)
		{
			esi_208 = fn00729810(dwArg04, dwArg04, dwArg08, 0x00, *((word32) dwArg08 + 4));
l00729F0B:
			word32 v15_236 = (word32) *eax_39 - 1;
			*eax_39 = v15_236;
			if (v15_236 == 0x00)
			{
				struct Eq_130302 * eax_240 = *((word32) eax_39 + 4);
				eax_240->ptr0018();
			}
			return esi_208;
		}
	}
	else
	{
		word32 edx_439;
		if (fn00726150(*((word32) eax_80 + 28), dwArg04, out edx_439) != 0x00)
		{
			ui32 edi_140 = 0x03;
			word32 ecx_440;
			word32 edx_441;
			Eq_3 eax_142 = fn007475E0(**((word32) dwArg04 + 24), out ecx_440, out edx_441);
			if (eax_142 <= 0x05)
			{
				switch ((word32) eax_142)
				{
				case 0x01:
					if (*((word32) **((word32) dwArg04 + 24) + 28) == 0x00)
						edi_140 = 0x00;
					break;
				case 0x02:
					goto l00729E53;
				case 0x03:
					struct Eq_130270 * eax_158 = **((word32) dwArg04 + 24);
					if (eax_158->dw001C == 0x00 && eax_158->dw0020 == 0x00)
					{
l00729E53:
						edi_140 = 0x01;
					}
					break;
				case 0x04:
					edi_140 = 0x02;
					break;
				case 0x05:
					edi_140 = 0x02;
					break;
				}
			}
			Eq_3 eax_185;
			(*((const char *) g_a729F3C + edi_140 * 0x04))();
			return eax_185;
		}
	}
	esi_208.u0 = 0x00;
	goto l00729F0B;
}

<anonymous> * g_a729F3C[] = // 00729F3C
	{
	};
// 00729F50: Register word32 fn00729F50(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Stack Eq_3 dwArg0C)
// Called from:
//      fn00729F50
//      fn0072B360
word32 fn00729F50(Eq_3 dwArg04, Eq_3 dwArg08, Eq_3 dwArg0C)
{
	Eq_3 dwLoc10_706;
	Eq_3 ebx_305;
	Eq_3 esi_19 = *((word32) dwArg04 + 24);
	word32 ecx_1026;
	word32 edx_1027;
	Eq_3 eax_22 = fn00723860(0x20, out ecx_1026, out edx_1027);
	if (eax_22 == 0x00)
	{
		word32 ecx_1028;
		word32 edx_1029;
		fn006E1210(out ecx_1028, out edx_1029);
		ebx_305.u0 = 0x00;
		dwLoc10_706.u0 = 0x00;
	}
	else
	{
		eax_22->u0 = 0x00;
		((word32) eax_22 + 4)->u0 = 0x00;
		((word32) eax_22 + 8)->u0 = 0x00;
		((word32) eax_22 + 0x0C)->u0 = 0x00;
		((word32) eax_22 + 16)->u0 = 0x00;
		((word32) eax_22 + 20)->u0 = 0x00;
		((word32) eax_22 + 24)->u0 = 0x00;
		((word32) eax_22 + 28)->u0 = 0x00;
		*eax_22 = *((word32) esi_19 + 36);
		*((word32) esi_19 + 36) = eax_22;
		dwLoc10_706 = eax_22;
		ebx_305 = eax_22;
	}
	Eq_3 dwLoc08_753;
	Eq_3 esi_61 = *((word32) dwArg04 + 24);
	word32 ecx_1030;
	word32 edx_1031;
	Eq_3 eax_65 = fn00723860(0x20, out ecx_1030, out edx_1031);
	if (eax_65 == 0x00)
	{
		word32 edx_1033;
		word32 ecx_1032;
		fn006E1210(out ecx_1032, out edx_1033);
		dwLoc08_753.u0 = 0x00;
	}
	else
	{
		eax_65->u0 = 0x00;
		((word32) eax_65 + 4)->u0 = 0x00;
		((word32) eax_65 + 8)->u0 = 0x00;
		((word32) eax_65 + 0x0C)->u0 = 0x00;
		((word32) eax_65 + 16)->u0 = 0x00;
		((word32) eax_65 + 20)->u0 = 0x00;
		((word32) eax_65 + 24)->u0 = 0x00;
		((word32) eax_65 + 28)->u0 = 0x00;
		*eax_65 = *((word32) esi_61 + 36);
		*((word32) esi_61 + 36) = eax_65;
		dwLoc08_753 = eax_65;
	}
	Eq_3 dwLoc14_758;
	Eq_3 esi_102 = *((word32) dwArg04 + 24);
	word32 edx_1035;
	word32 ecx_1034;
	Eq_3 eax_106 = fn00723860(0x20, out ecx_1034, out edx_1035);
	if (eax_106 == 0x00)
	{
		word32 edx_1037;
		word32 ecx_1036;
		fn006E1210(out ecx_1036, out edx_1037);
		dwLoc14_758.u0 = 0x00;
	}
	else
	{
		eax_106->u0 = 0x00;
		((word32) eax_106 + 4)->u0 = 0x00;
		((word32) eax_106 + 8)->u0 = 0x00;
		((word32) eax_106 + 0x0C)->u0 = 0x00;
		((word32) eax_106 + 16)->u0 = 0x00;
		((word32) eax_106 + 20)->u0 = 0x00;
		((word32) eax_106 + 24)->u0 = 0x00;
		((word32) eax_106 + 28)->u0 = 0x00;
		*eax_106 = *((word32) esi_102 + 36);
		*((word32) esi_102 + 36) = eax_106;
		dwLoc14_758 = eax_106;
	}
	Eq_3 dwLoc0C_763;
	Eq_3 esi_143 = *((word32) dwArg04 + 24);
	word32 edx_1039;
	word32 ecx_1038;
	Eq_3 eax_147 = fn00723860(0x20, out ecx_1038, out edx_1039);
	if (eax_147 == 0x00)
	{
		word32 ecx_1040;
		word32 edx_1041;
		fn006E1210(out ecx_1040, out edx_1041);
		dwLoc0C_763.u0 = 0x00;
	}
	else
	{
		eax_147->u0 = 0x00;
		((word32) eax_147 + 4)->u0 = 0x00;
		((word32) eax_147 + 8)->u0 = 0x00;
		((word32) eax_147 + 0x0C)->u0 = 0x00;
		((word32) eax_147 + 16)->u0 = 0x00;
		((word32) eax_147 + 20)->u0 = 0x00;
		((word32) eax_147 + 24)->u0 = 0x00;
		((word32) eax_147 + 28)->u0 = 0x00;
		*eax_147 = *((word32) esi_143 + 36);
		*((word32) esi_143 + 36) = eax_147;
		dwLoc0C_763 = eax_147;
	}
	Eq_3 esi_184 = *((word32) dwArg04 + 24);
	word32 ecx_1042;
	word32 edx_1043;
	Eq_3 eax_188 = fn00723860(0x20, out ecx_1042, out edx_1043);
	if (eax_188 == 0x00)
	{
		word32 ecx_1044;
		word32 edx_1045;
		fn006E1210(out ecx_1044, out edx_1045);
		eax_188.u0 = 0x00;
	}
	else
	{
		eax_188->u0 = 0x00;
		((word32) eax_188 + 4)->u0 = 0x00;
		((word32) eax_188 + 8)->u0 = 0x00;
		((word32) eax_188 + 0x0C)->u0 = 0x00;
		((word32) eax_188 + 16)->u0 = 0x00;
		((word32) eax_188 + 20)->u0 = 0x00;
		((word32) eax_188 + 24)->u0 = 0x00;
		((word32) eax_188 + 28)->u0 = 0x00;
		*eax_188 = *((word32) esi_184 + 36);
		*((word32) esi_184 + 36) = eax_188;
	}
	if (ebx_305 == 0x00 || (dwLoc08_753 == 0x00 || (dwLoc14_758 == 0x00 || (dwLoc0C_763 == 0x00 || eax_188 == 0x00))))
		return 0x00;
	Eq_3 ebp_241 = *((word32) dwArg08 + (dwArg0C * 0x04 + 4));
	if (fn00727880(dwArg04, 0x78, dwArg04, 0x00) == 0x00 || fn00728310(dwArg04, 0x00, dwArg04) == 0x00)
		return 0x00;
	if (dwArg0C == 0x00)
	{
		*((word32) *((word32) dwArg04 + 24) + 32) = (struct Eq_121100 *) 0x01;
		word32 ecx_1046;
		if (fn00727810(dwArg04, 0x7C, dwArg04, out ecx_1046) == 0x00)
			return 0x00;
	}
	else
	{
		if (fn0072B360(dwArg04, dwArg04) == 0x00 || fn00727670(dwArg04, 0x44) == 0x00)
			return 0x00;
		ebx_305 = dwLoc10_706;
	}
	*((word32) *((word32) *((word32) dwArg04 + 24) + 40) + 16) = ebx_305;
	*((word32) *((word32) dwArg04 + 24) + 40) = ebx_305;
	Eq_3 esi_329 = 0x00;
	if (fn00727880(dwArg04, 0x5D, dwArg04, 0x00) == 0x00 || (fn007273D0(dwArg04) == 0x00 || fn0072B360(dwArg04, dwArg04) == 0x00))
		return 0x00;
	*((word32) ebp_241 + 8) != 0x00;
	if (dwArg04 > 0x00)
	{
		do
		{
			if (fn0072B360(dwArg04, dwArg04) == 0x00 || (fn00727880(dwArg04, 111, dwArg04, 0x00) == 0x00 || (fn007273D0(dwArg04) == 0x00 || fn00727670(dwArg04, 0x01) == 0x00)))
				return 0x00;
			esi_329 = (word32) esi_329 + 1;
		} while (esi_329 < dwArg04);
	}
	int32 eax_460;
	if (dwArg08 == 0x00)
		eax_460 = 0x00;
	else
		eax_460 = (int32) *dwArg08;
	if ((word32) dwArg0C + 1 < eax_460 && fn00729F50(dwArg04, dwArg04, (word32) dwArg0C + 1) == 0x00)
		return 0x00;
	int32 eax_502;
	if (dwArg08 == 0x00)
		eax_502 = 0x00;
	else
		eax_502 = (int32) *dwArg08;
	if ((word32) dwArg0C + 1 >= eax_502)
	{
		if (fn0072B360(dwArg04, dwArg04) == 0x00 || (fn00727670(dwArg04, 0x56) == 0x00 || fn00727670(dwArg04, 0x01) == 0x00))
			return 0x00;
		*((word32) *((word32) *((word32) dwArg04 + 24) + 40) + 16) = dwLoc08_753;
		*((word32) *((word32) dwArg04 + 24) + 40) = dwLoc08_753;
	}
	Eq_3 esi_562 = 0x00;
	if (dwArg04 > 0x00)
	{
		do
		{
			word32 ecx_1047;
			if (fn00727810(dwArg04, 110, dwArg04, out ecx_1047) == 0x00)
				return 0x00;
			if (esi_562 == 0x00)
			{
				*((word32) *((word32) *((word32) dwArg04 + 24) + 40) + 16) = dwLoc14_758;
				*((word32) *((word32) dwArg04 + 24) + 40) = dwLoc14_758;
			}
			if (fn00727670(dwArg04, 0x01) == 0x00)
				return 0x00;
			esi_562 = (word32) esi_562 + 1;
		} while (esi_562 < dwArg04);
	}
	if (fn00727880(dwArg04, 113, dwArg04, 0x01) == 0x00)
		return 0x00;
	*((word32) *((word32) *((word32) dwArg04 + 24) + 40) + 16) = dwLoc0C_763;
	*((word32) *((word32) dwArg04 + 24) + 40) = dwLoc0C_763;
	if (fn00727670(dwArg04, 0x57) == 0x00)
		return 0x00;
	Eq_3 eax_665 = *((word32) dwArg04 + 24);
	*((word32) eax_665 + 48) = (word32) *((word32) eax_665 + 48) - 1;
	*((word32) *((word32) *((word32) dwArg04 + 24) + 40) + 16) = eax_188;
	*((word32) *((word32) dwArg04 + 24) + 40) = eax_188;
	return 0x01;
}

// 0072A350: Register word32 fn0072A350(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08)
// Called from:
//      fn0072A5D0
//      fn0072B360
//      fn0072C160
//      fn0072C510
//      fn0072E660
word32 fn0072A350(Eq_3 dwArg04, Eq_3 dwArg08)
{
	word32 dwLoc24_395 = 0x00;
	if ((*((word32) *((word32) *((word32) dwArg04 + 24) + 40) + 20) & 0x02) == 0x00)
	{
		if (fn007273D0(dwArg04) == 0x00)
			return 0x00;
		if (dwArg08 != 0x00)
		{
			word32 ecx_632;
			if (fn007276E0(0x00A163B8, *((word32) *((word32) dwArg04 + 24) + 8), out ecx_632) < 0x00)
				return 0x00;
			word32 ecx_633;
			if (fn00727810(dwArg04, 100, dwArg04, out ecx_633) == 0x00)
				return 0x00;
		}
		if (fn00727670(dwArg04, 0x53) == 0x00)
			return 0x00;
	}
	Eq_3 ecx_81 = *((word32) dwArg04 + 24);
	Eq_3 eax_82 = *((word32) ecx_81 + 36);
	uint32 edi_141 = 0x00;
	Eq_3 ebx_102 = 0x00;
	while (eax_82 != 0x00)
	{
		ebx_102 = eax_82;
		eax_82 = *eax_82;
		++edi_141;
	}
	if (*((word32) ecx_81 + 212) != 0x00)
	{
l0072A404:
		if (fn00728650(fp - 0x20, edi_141, *((word32) *((word32) dwArg04 + 24) + 212)) != 0x00)
		{
			Eq_3 ebp_169 = fn007284C0(ebx_102, fp - 0x20);
			fn007289A0(fp - 0x20, ebp_169);
			int32 eax_189 = dwLoc18 + ~0x00;
			int32 dwLoc28_479 = dwLoc18 + ~0x00;
			if (dwLoc18 >= ~0x00)
			{
				do
				{
					struct Eq_131008 * esi_197 = *((word32) dwLoc14 + eax_189 * 0x04);
					int32 ebx_198 = 0x00;
					if (esi_197->dw0004 > 0x00)
					{
						word32 ebp_201 = 0x00;
						do
						{
							if (fn007288B0(fp - 0x20, esi_197->dw000C + ebp_201) == 0x00)
								goto l0072A4C3;
							++ebx_198;
							ebp_201 += 0x14;
						} while (ebx_198 < esi_197->dw0004);
						ebp_169 = dwArg04;
						eax_189 = dwLoc28_479;
					}
					--eax_189;
					dwLoc28_479 = eax_189;
				} while (eax_189 >= 0x00);
			}
			word32 ecx_630;
			word32 edx_631;
			if (fn006EC4F0(fp - 0x10, dwArg04, out ecx_630, out edx_631) >= 0x00)
			{
				word32 edx_635;
				word32 ecx_634;
				if (fn006EC4F0(fp - 0x20, dwArg04, out ecx_634, out edx_635) >= 0x00)
					dwLoc24_395 = fn00728BE0(ebp_169);
			}
		}
l0072A4C3:
		struct Eq_130974 * esp_301 = fp - 0x34;
		if (dwLoc20 != null)
		{
			dwLoc20->dw0000 += ~0x00;
			if (dwLoc20->dw0000 == 0x00)
			{
				struct Eq_131102 * edx_308 = dwLoc20->ptr0004;
				word32 esp_316;
				edx_308->ptr0018();
				esp_301 = esp_316 + 0x04;
			}
		}
		struct Eq_131083 * eax_326 = esp_301->ptr0024;
		if (eax_326 != null)
		{
			eax_326->dw0000 += ~0x00;
			struct Eq_131083 * eax_332 = esp_301->ptr0024;
			if (eax_332->dw0000 == 0x00)
			{
				struct Eq_131131 * ecx_335 = eax_332->ptr0004;
				<anonymous> * edx_336 = ecx_335->ptr0018;
				esp_301->ptrFFFFFFFC = eax_332;
				edx_336();
			}
		}
		if (dwLoc14 != 0x00)
		{
			word32 ecx_636;
			word32 edx_637;
			fn007239C0(dwLoc14, out ecx_636, out edx_637);
		}
		return dwLoc24_395;
	}
	else
	{
		if (ebx_102 != 0x00)
		{
			Eq_3 eax_106 = *((word32) ebx_102 + 0x0C);
			if (eax_106 != 0x00)
			{
				*((word32) ecx_81 + 212) = *((word32) eax_106 + 16);
				goto l0072A404;
			}
		}
		((word32) ecx_81 + 212)->u0 = 0x01;
		goto l0072A404;
	}
}

// 0072A520: void fn0072A520(Register Eq_3 eax, Stack Eq_3 dwArg04)
// Called from:
//      fn0072A5D0
//      fn0072C160
void fn0072A520(Eq_3 eax, Eq_3 dwArg04)
{
	int32 dwLoc04_177;
	int32 * eax_16 = *dwArg04;
	struct Eq_131155 * esp_125 = fp - 20;
	struct Eq_53824 * edi_145 = null;
	if (eax_16 == null)
		dwLoc04_177 = 0x00;
	else
		dwLoc04_177 = *eax_16;
	if (dwLoc04_177 > 0x00)
	{
		do
		{
			word32 * ebp_39 = *((word32) *esp_125[6] + (edi_145 * 0x04 + 4));
			if (*ebp_39 == 0x13)
			{
				struct Eq_131192 * esp_42 = esp_125 - 4;
				esp_42->ptr0000 = edi_145;
				esp_42->ptrFFFFFFFC = &g_t8DA8A0;
				struct Eq_53824 * eax_52 = fn006F2070();
				if (eax_52 != null)
				{
					esp_42->ptr0000 = (struct Eq_53824 *) 0x01;
					esp_42->ptrFFFFFFFC = eax_52;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_3 stackArg4 = <invalid>;
					Eq_3 eax_67 = fn00729510(eax, stackArg4, dwArg04);
					ptr32 esp_105 = (const char *) &esp_42->ptr0000 + 4;
					if (eax_67 != 0x00)
					{
						word32 v14_91 = eax_52->dw0000 + ~0x00;
						eax_52->dw0000 = v14_91;
						if (v14_91 == 0x00)
						{
							struct Eq_131261 * ecx_95 = eax_52->ptr0004;
							<anonymous> * edx_96 = ecx_95->ptr0018;
							esp_42->ptr0000 = eax_52;
							word32 esp_99;
							word32 edx_102;
							edx_96();
							esp_105 = esp_99 + 0x04;
						}
						struct Eq_131245 * esp_108 = esp_105 - 4;
						esp_108->ptr0000 = ebp_39;
						esp_108->tFFFFFFFC = eax;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_3 stackArg4 = <invalid>;
						esp_125 = (struct Eq_131155 *) ((const char *) &esp_108->ptr0000 + 4);
						if (fn0072B360(stackArg4, dwArg04) != 0x00)
							goto l0072A597;
					}
					else
					{
						word32 v16_75 = eax_52->dw0000 + ~0x00;
						eax_52->dw0000 = v16_75;
						if (v16_75 == 0x00)
						{
							struct Eq_131261 * eax_79 = eax_52->ptr0004;
							<anonymous> * ecx_80 = eax_79->ptr0018;
							esp_42->ptr0000 = eax_52;
							word32 edx_86;
							ecx_80();
						}
					}
				}
				return;
			}
l0072A597:
			edi_145 = (struct Eq_53824 *) ((const char *) &edi_145->dw0000 + 1);
		} while (edi_145 < esp_125[4]);
	}
}

// 0072A5D0: Register Eq_3 fn0072A5D0(Register Eq_3 eax, Stack Eq_3 dwArg04)
// Called from:
//      fn0072B360
Eq_3 fn0072A5D0(Eq_3 eax, Eq_3 dwArg04)
{
	Eq_3 ebp_14 = *((word32) dwArg04 + 4);
	Eq_3 eax_20 = g_tA6DBE4;
	if (eax_20 == 0x00)
	{
		word32 edx_458;
		word32 ecx_457;
		eax_20 = fn006F1A70(out ecx_457, out edx_458);
		g_tA6DBE4 = eax_20;
		if (eax_20 == 0x00)
			return eax_20;
	}
	Eq_3 ebx_44 = *((word32) ebp_14 + 0x0C);
	if (ebx_44 != 0x00)
	{
		int32 ebp_314 = 0x00;
		while (true)
		{
			int32 eax_57;
			if (ebx_44 == 0x00)
				eax_57 = 0x00;
			else
				eax_57 = (int32) *ebx_44;
			if (ebp_314 >= eax_57)
				break;
			if (fn0072B360(eax, dwArg04) == 0x00)
				return 0x00;
			++ebp_314;
		}
		eax_20 = g_tA6DBE4;
	}
	if (fn00728E40(eax_20, eax, dwArg04, dwArg04) == 0x00)
		return 0x00;
	fn0072A520(eax, ebp_14);
	struct Eq_121100 * eax_114 = *ebp_14;
	if (eax_114 != null)
		eax_114 = eax_114->ptr0000;
	*((word32) *((word32) eax + 24) + 32) = eax_114;
	if (fn0072B360(eax, dwArg04) != 0x00)
	{
		word32 ecx_459;
		int32 eax_150 = fn00727420(*((word32) *((word32) eax + 24) + 40), out ecx_459);
		if (eax_150 >= 0x00)
		{
			Eq_3 edx_172 = *((word32) *((word32) eax + 24) + 40);
			Eq_3 eax_174 = *((word32) edx_172 + 0x0C);
			*((word32) eax_174 + eax_150 * 0x14) &= ~0x04;
			(word32) eax_174 + eax_150 * 0x14 + 0x04 = (ptr32) 0x53;
			*((word32) edx_172 + 20) |= 0x02;
			Eq_3 eax_185 = *((word32) eax + 24);
			if (*((word32) eax_185 + 220) == 0x00)
			{
				*((word32) eax_185 + 220) = 0x01;
				Eq_3 eax_190 = *((word32) eax + 24);
				*((word32) *((word32) *((word32) eax_190 + 40) + 0x0C) + (eax_150 * 0x14 + 16)) = *((word32) eax_190 + 0x00D8);
			}
			Eq_3 eax_209 = fn0072A350(eax, dwArg04);
			fn00727290(eax);
			if (eax_209 == 0x00)
				return 0x00;
			*((word32) ebp_14 + 0x0C) != 0x00;
			word32 ecx_462;
			word32 eax_245 = fn00729040(eax, es, ds, eax_209, out ecx_462);
			word32 v17_250 = (word32) *eax_209 - 1;
			*eax_209 = v17_250;
			if (v17_250 == 0x00)
			{
				Eq_3 ecx_254 = *((word32) eax_209 + 4);
				(*((word32) ecx_254 + 24))();
			}
			return 0x01;
		}
	}
	fn00727290(eax);
	return 0x00;
}

// 0072A740: Register Eq_3 fn0072A740(Register Eq_3 eax, Register Eq_3 ebx)
// Called from:
//      fn0072A940
Eq_3 fn0072A740(Eq_3 eax, Eq_3 ebx)
{
	const char * eax_23 = strchr((word32) eax + 20, 0x2E);
	struct Eq_131487 * esp_129 = fp - 0x10;
	if (eax_23 != null)
	{
		Eq_3 esi_152 = eax_23 + 1;
		esp_129 = fp - 0x10;
		do
		{
			Eq_3 eax_52;
			struct Eq_131527 * esp_31 = esp_129 - 4;
			esp_31->t0000.u0 = 0x2E;
			esp_31->tFFFFFFFC = esi_152;
			const char * eax_36 = strchr(esp_31->tFFFFFFFC, esp_31->t0000);
			if (eax_36 != null)
				eax_52 = eax_36 - esi_152;
			else
			{
				Eq_3 eax_42 = esi_152;
				Eq_131521 edx_43 = (word32) esi_152 + 1;
				do
				{
					eax_42 = (word32) eax_413 + 1;
					eax_413 = eax_42;
				} while (*eax_413 != 0x00);
				eax_52 = eax_42 - edx_43;
			}
			esp_31->t0000 = eax_52;
			esp_31->tFFFFFFFC = esi_152;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg4 = <invalid>;
			Eq_3 stackArg8 = <invalid>;
			word32 edx_405;
			word32 ecx_404;
			Eq_3 eax_80 = fn006EC9B0(stackArg4, stackArg8, out ecx_404, out edx_405);
			if (eax_80 == 0x00)
				return ~0x00;
			word32 ecx_410;
			Eq_3 eax_110 = fn007276E0(eax_80, *((word32) *((word32) ebx + 24) + 0x0C), out ecx_410);
			if (eax_110 < 0x00)
				return 0x00;
			esp_129 = fp - 0x10;
			word32 ecx_124;
			if (fn00727810(ebx, 0x69, eax_110, out ecx_124) == 0x00)
				return 0x00;
			word32 v15_133 = (word32) *eax_80 - 1;
			*eax_80 = v15_133;
			if (v15_133 == 0x00)
			{
				Eq_3 edx_137 = *((word32) eax_80 + 4);
				Eq_3 eax_138 = *((word32) edx_137 + 24);
				word32 esp_141;
				eax_138();
				esp_129 = esp_141 + 0x04;
			}
			esi_152 = eax_36 + 1;
		} while (eax_36 != null);
	}
	Eq_3 eax_159 = *((word32) ebx + 24);
	Eq_3 edx_163 = esp_129->t0014;
	esp_129->t000C = *((word32) eax_159 + 0x0C);
	byte * edi_165 = &g_b8DA718;
	byte * esi_166 = (word32) edx_163 + 20;
	word32 ecx_167 = 0x0A;
	bool v21_313 = false;
	while (ecx_167 != 0x00)
	{
		v21_313 = *esi_414 != *edi_415;
		esi_166 = esi_414 + 1;
		edi_165 = edi_415 + 1;
		--ecx_167;
		esi_414 = esi_166;
		edi_415 = edi_165;
		if (*esi_414 == *edi_415)
			break;
	}
	if (v21_313)
	{
		struct Eq_131569 * esp_185 = esp_129 - 4;
		esp_185->t0000 = edx_163;
		esp_185->tFFFFFFFC = *((word32) eax_159 + 28);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_3 stackArg4 = <invalid>;
		Eq_3 stackArg8 = <invalid>;
		word32 edx_408;
		Eq_3 eax_207 = fn00726150(stackArg4, stackArg8, out edx_408);
		if (eax_207 == 0x00)
			return 0x00;
		Eq_3 ecx_230 = **((word32) ebx + 24);
		esp_185->t0000 = eax_207;
		esp_185->tFFFFFFFC = ecx_230;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_3 stackArg4 = <invalid>;
		word32 edx_412;
		Eq_3 ecx_240;
		Eq_3 eax_241 = fn007475E0(stackArg4, out ecx_240, out edx_412);
		ui32 edi_238 = 0x03;
		Eq_3 eax_245 = (word32) eax_241 - 1;
		if (eax_241 <= 0x05)
		{
			switch ((word32) eax_241)
			{
			case 0x01:
				eax_245 = *((word32) ebx + 24);
				ecx_240 = *eax_245;
				if (*((word32) ecx_240 + 28) == 0x00)
					edi_238 = 0x00;
				break;
			case 0x02:
				goto l0072A88C;
			case 0x03:
				eax_245 = **((word32) ebx + 24);
				if (*((word32) eax_245 + 28) == 0x00 && *((word32) eax_245 + 32) == null)
				{
l0072A88C:
					edi_238 = 0x01;
				}
				break;
			case 0x04:
				eax_245 = *((word32) *((word32) ebx + 24) + 24);
				esp_185->t0010 = eax_245;
				edi_238 = 0x02;
				break;
			case 0x05:
				ecx_240 = *((word32) ebx + 24);
				esp_185->t0010 = *((word32) ecx_240 + 20);
				edi_238 = 0x02;
				break;
			}
		}
		Eq_3 eax_290;
		(*((const char *) g_a72A930 + edi_238 * 0x04))();
		return eax_290;
	}
	else
	{
		esp_129->t0014.u0 = 0x008DA884;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_3 stackArg4 = <invalid>;
		return fn00728360(ebx, stackArg4);
	}
}

<anonymous> * g_a72A930[] = // 0072A930
	{
	};
// 0072A940: Register Eq_3 fn0072A940(Register Eq_3 eax, Stack Eq_3 dwArg04)
// Called from:
//      fn0072D920
Eq_3 fn0072A940(Eq_3 eax, Eq_3 dwArg04)
{
	int32 dwLoc0C_438;
	struct Eq_131761 * eax_11 = *((word32) dwArg04 + 4);
	int32 ebp_15 = 0x00;
	struct Eq_131767 * esp_20 = fp - 0x24;
	if (eax_11 == null)
		dwLoc0C_438 = 0x00;
	else
		dwLoc0C_438 = eax_11->dw0000;
	if (dwLoc0C_438 > 0x00)
	{
		do
		{
			struct Eq_131780 * esp_48;
			struct Eq_131781 * edi_38 = *((word32) ((word32) esp_20[40].dwFFFFFFFC + 8)->dwFFFFFFFC + (ebp_15 * 0x04 + 8));
			Eq_3 eax_40 = *((word32) eax + 0x0C);
			if (eax_40 != 0x00 && (*eax_40 & 0x4000) != 0x00)
			{
				esp_48 = esp_20 - 4;
				esp_48->t0000.u0 = 0x00;
			}
			else
			{
				esp_48 = esp_20 - 4;
				esp_48->t0000.u0 = ~0x00;
			}
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg4 = <invalid>;
			word32 edx_576;
			word32 ecx_575;
			Eq_3 eax_68 = fn007050A0(stackArg4, out ecx_575, out edx_576);
			if (eax_68 == 0x00)
				return 0x00;
			esp_48->t0000 = *((word32) *((word32) eax + 24) + 8);
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg4 = <invalid>;
			word32 ecx_578;
			Eq_3 eax_85 = fn007276E0(eax_68, stackArg4, out ecx_578);
			if (eax_85 < 0x00)
				return 0x00;
			esp_48->t0000 = eax_85;
			esp_48->dwFFFFFFFC = 100;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			struct Eq_131853 * esp_99 = esp_48 - 4;
			Eq_125083 stackArg4 = <invalid>;
			struct Eq_131767 * esp_105 = (const char *) &esp_99->t0004 + 4;
			word32 ecx_580;
			if (fn00727810(eax, stackArg4, dwArg04, out ecx_580) == 0x00)
				return 0x00;
			word32 v15_109 = (word32) *eax_68 - 1;
			*eax_68 = v15_109;
			if (v15_109 == 0x00)
			{
				struct Eq_131761 * edx_113 = *((word32) eax_68 + 4);
				<anonymous> * eax_114 = edx_113->ptr0018;
				esp_99->t0004 = eax_68;
				word32 esp_117;
				word32 ecx_119;
				eax_114();
				esp_105 = esp_117 + 0x04;
			}
			struct Eq_131877 * esp_130 = esp_105 - 4;
			esp_130->t0000 = *((word32) *((word32) eax + 24) + 8);
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg4 = <invalid>;
			word32 ecx_582;
			Eq_3 eax_138 = fn007276E0(0x00A163B8, stackArg4, out ecx_582);
			if (eax_138 < 0x00)
				return 0x00;
			esp_130->t0000 = eax_138;
			esp_130->tFFFFFFFC.u0 = 100;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_125083 stackArg4 = <invalid>;
			word32 ecx_584;
			if (fn00727810(eax, stackArg4, dwArg04, out ecx_584) == 0x00)
				return 0x00;
			esp_130->t0000 = *((word32) *((word32) eax + 24) + 0x0C);
			esp_130->tFFFFFFFC.u0 = 0x6B;
			if (fn00728FE0(eax, dwArg04) == 0x00)
				return 0x00;
			Eq_3 eax_179 = edi_38->t0004;
			if (eax_179 != 0x00)
			{
				esp_130->t0000 = eax_179;
				esp_20 = (struct Eq_131767 *) ((const char *) &esp_130->t0000 + 4);
				if (fn0072A740(edi_38->t0000, eax) == 0x00)
					return 0x00;
				goto l0072ABD9;
			}
			Eq_3 ebp_183 = edi_38->t0000;
			esp_130->t0000.u0 = 0x2E;
			esp_130->tFFFFFFFC = (word32) ebp_183 + 20;
			esp_130->t0014 = ebp_183;
			const char * eax_190 = strchr(esp_130->tFFFFFFFC, esp_130->t0000);
			esp_130->ptr0024 = eax_190;
			if (eax_190 != null)
			{
				esp_130->t0000 = eax_190 - ((word32) ebp_183 + 20);
				esp_130->tFFFFFFFC = (word32) ebp_183 + 20;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_3 stackArg4 = <invalid>;
				word32 ecx_586;
				word32 edx_587;
				Eq_3 eax_203 = fn006EC9B0(stackArg4, dwArg04, out ecx_586, out edx_587);
				esp_130->t0014 = eax_203;
				ebp_183 = eax_203;
			}
			Eq_3 eax_214 = *((word32) eax + 24);
			esp_105[20] = (struct Eq_131767) *((word32) eax_214 + 0x0C);
			byte * edi_218 = &g_b8DA718;
			byte * esi_220 = (word32) ebp_183 + 20;
			word32 ecx_221 = 0x0A;
			bool v19_429 = false;
			while (ecx_221 != 0x00)
			{
				v19_429 = *esi_594 != *edi_595;
				esi_220 = esi_594 + 1;
				edi_218 = edi_595 + 1;
				--ecx_221;
				esi_594 = esi_220;
				edi_595 = edi_218;
				if (*esi_594 == *edi_595)
					break;
			}
			Eq_3 esi_262;
			Eq_3 eax_257;
			if (!v19_429)
			{
				esp_105->dwFFFFFFFC = 0x008DA884;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_3 stackArg4 = <invalid>;
				eax_257 = fn00728360(eax, stackArg4);
				esi_262 = eax_257;
			}
			else
			{
				Eq_3 eax_240 = *((word32) eax_214 + 28);
				struct Eq_132072 * esp_243 = esp_105 - 4;
				esp_243->t0000 = ebp_183;
				esp_243->tFFFFFFFC = eax_240;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_3 stackArg4 = <invalid>;
				word32 edx_589;
				eax_257 = fn00726150(stackArg4, dwArg04, out edx_589);
				esi_262 = eax_257;
				if (eax_257 != 0x00)
				{
					Eq_3 edx_268 = **((word32) eax + 24);
					esp_243->t0000 = eax_257;
					esp_243->tFFFFFFFC = edx_268;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_3 stackArg4 = <invalid>;
					word32 ecx_592;
					word32 edx_593;
					Eq_3 eax_278 = fn007475E0(stackArg4, out ecx_592, out edx_593);
					ui32 edi_276 = 0x03;
					Eq_3 eax_283 = (word32) eax_278 - 1;
					if (eax_278 <= 0x05)
					{
						switch ((word32) eax_278)
						{
						case 0x01:
							if (*((word32) **((word32) eax + 24) + 28) == 0x00)
								edi_276 = 0x00;
							break;
						case 0x02:
							goto l0072AB1B;
						case 0x03:
							eax_283 = **((word32) eax + 24);
							if (*((word32) eax_283 + 28) == 0x00 && *((word32) eax_283 + 32) == null)
							{
l0072AB1B:
								edi_276 = 0x01;
							}
							break;
						case 0x04:
							eax_283 = *((word32) eax + 24);
							esp_243->t0018 = *((word32) eax_283 + 24);
							edi_276 = 0x02;
							break;
						case 0x05:
							eax_283 = *((word32) *((word32) eax + 24) + 20);
							esp_243->t0018 = eax_283;
							edi_276 = 0x02;
							break;
						}
					}
					Eq_3 eax_325;
					word32 ecx_326;
					word32 edx_327;
					(*((const char *) g_a72AC0C + edi_276 * 0x04))();
					return eax_325;
				}
			}
			esp_20 = esp_105;
			if (esp_105[32] != 0x00)
			{
				word32 v16_347 = (word32) *ebp_183 - 1;
				*ebp_183 = v16_347;
				if (v16_347 == 0x00)
				{
					struct Eq_132108 * ecx_351 = *((word32) ebp_183 + 4);
					<anonymous> * edx_352 = ecx_351->ptr0018;
					esp_105->dwFFFFFFFC = (word32) ebp_183;
					word32 esp_360;
					word32 edx_363;
					edx_352();
					esp_20 = esp_360 + 0x04;
				}
			}
			if (esi_262 == 0x00)
				return 0x00;
			ebp_15 = (int32) esp_20[28];
l0072ABD9:
			++ebp_15;
			esp_20[28] = (struct Eq_131767) ebp_15;
		} while (ebp_15 < esp_20[24]);
	}
	return 0x01;
}

<anonymous> * g_a72AC0C[] = // 0072AC0C
	{
	};
// 0072AC20: Register Eq_3 fn0072AC20(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08)
// Called from:
//      fn0072D920
Eq_3 fn0072AC20(Eq_3 dwArg04, Eq_3 dwArg08)
{
	Eq_3 edi_25;
	Eq_3 eax_9 = *((word32) dwArg08 + 8);
	if (eax_9 == 0x00)
		edi_25.u0 = 0x00;
	else
		edi_25 = *eax_9;
	word32 ecx_918;
	word32 edx_919;
	Eq_3 eax_39 = fn006DFD20(edi_25, out ecx_918, out edx_919);
	if (eax_39 == 0x00)
		return 0x00;
	if (*((word32) dwArg08 + 0x0C) == 0x00)
	{
		Eq_3 ecx_54 = *((word32) dwArg04 + 0x0C);
		if (ecx_54 != 0x00 && (*ecx_54 & 0x4000) == 0x00)
		{
l0072AC74:
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg4 = <invalid>;
			word32 ecx_921;
			word32 edx_922;
			Eq_3 eax_79 = fn007050A0(stackArg4, out ecx_921, out edx_922);
			struct Eq_132266 * esp_597 = fp - 0x20;
			if (eax_79 != 0x00)
			{
				Eq_3 eax_106 = 0x00;
				if (edi_25 > 0x00)
				{
					word32 * esi_104 = (word32) eax_39 + 0x0C;
					do
					{
						Eq_3 ecx_99 = *((word32) *((word32) dwArg08 + 8) + (eax_106 * 0x04 + 4));
						word32 * edx_100 = *ecx_99;
						++*edx_100;
						*esi_104 = (word32) *ecx_99;
						eax_106 = (word32) eax_106 + 1;
						++esi_104;
					} while (eax_106 < edi_25);
				}
				if (*((word32) dwArg08 + 20) > *((word32) (*((word32) dwArg04 + 8)) + 4))
				{
					byte * esi_123 = (word32) *((word32) dwArg08 + 4) + 20;
					byte * edi_124 = &g_b8DA8F0;
					word32 ecx_125 = 11;
					bool v25_678 = false;
					while (ecx_125 != 0x00)
					{
						v25_678 = *esi_937 != *edi_938;
						esi_123 = esi_937 + 1;
						edi_124 = edi_938 + 1;
						--ecx_125;
						esi_937 = esi_123;
						edi_938 = edi_124;
						if (*esi_937 == *edi_938)
							break;
					}
					if (!v25_678)
					{
						word32 v15_582 = (word32) *eax_79 - 1;
						*eax_79 = v15_582;
						if (v15_582 == 0x00)
						{
							struct Eq_132413 * eax_586 = *((word32) eax_79 + 4);
							word32 esp_591;
							eax_586->ptr0018();
							esp_597 = esp_591 + 0x04;
						}
						struct Eq_132398 * eax_601 = esp_597->ptr0014;
						word32 v19_602 = eax_601->dw0000 + ~0x00;
						eax_601->dw0000 = v19_602;
						if (v19_602 == 0x00)
						{
							struct Eq_132481 * edx_606 = eax_601->ptr0004;
							esp_597->ptrFFFFFFFC = eax_601;
							word32 esp_615;
							edx_606->ptr0018();
							esp_597 = esp_615 + 0x04;
						}
						esp_597->ptrFFFFFFFC = &g_t8DA8B0;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_3 stackArg4 = <invalid>;
						return fn00728360(dwArg04, stackArg4);
					}
				}
				word32 ecx_923;
				if (fn007276E0(eax_79, *((word32) *((word32) dwArg04 + 24) + 8), out ecx_923) < 0x00)
					return 0x00;
				ptr32 esp_191 = fp - 0x20;
				word32 ecx_924;
				if (fn00727810(dwArg04, 100, dwArg04, out ecx_924) == 0x00)
					return 0x00;
				word32 v18_195 = (word32) *eax_79 - 1;
				*eax_79 = v18_195;
				if (v18_195 == 0x00)
				{
					struct Eq_132413 * edx_199 = *((word32) eax_79 + 4);
					word32 esp_203;
					edx_199->ptr0018();
					esp_191 = esp_203 + 0x04;
				}
				struct Eq_132444 * esp_216 = esp_191 - 4;
				esp_216->t0000 = *((word32) *((word32) dwArg04 + 24) + 8);
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_3 stackArg4 = <invalid>;
				word32 ecx_926;
				Eq_3 eax_224 = fn007276E0(eax_39, stackArg4, out ecx_926);
				if (eax_224 < 0x00)
					return 0x00;
				esp_216->t0000 = eax_224;
				esp_216->dwFFFFFFFC = 100;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_125083 stackArg4 = <invalid>;
				struct Eq_132502 * esp_244 = (const char *) &esp_216->t0000 + 4;
				word32 ecx_929;
				if (fn00727810(dwArg04, stackArg4, dwArg04, out ecx_929) == 0x00)
					return 0x00;
				word32 v20_248 = (word32) *eax_39 - 1;
				*eax_39 = v20_248;
				if (v20_248 == 0x00)
				{
					struct Eq_132287 * edx_252 = *((word32) eax_39 + 4);
					<anonymous> * eax_253 = edx_252->ptr0018;
					esp_216->t0000 = eax_39;
					word32 esp_256;
					eax_253();
					esp_244 = esp_256 + 0x04;
				}
				struct Eq_132522 * esp_271 = esp_244 - 4;
				esp_271->t0000 = *((word32) *((word32) dwArg04 + 24) + 0x0C);
				esp_271->dwFFFFFFFC = 0x6B;
				if (fn00728FE0(dwArg04, dwArg04) == 0x00)
					return 0x00;
				esp_271->dw0020 = 0x00;
				ui32 eax_289 = 0x00;
				if (esp_271->dw0014 > 0x00)
				{
					do
					{
						struct Eq_132580 * esi_300 = esp_244->ptr0028->ptr0008->a0004[eax_289].t0000;
						if (eax_289 == 0x00 && *((word32) esi_300->t0000 + 20) == 0x2A)
							return fn00727670(dwArg04, 0x54) == 0x00;
						struct Eq_132594 * esp_337 = esp_244 - 4;
						esp_337->t0000 = *((word32) *((word32) dwArg04 + 24) + 0x0C);
						esp_337->tFFFFFFFC.u0 = 0x6C;
						if (fn00728FE0(dwArg04, dwArg04) == 0x00)
							return 0x00;
						Eq_3 eax_356 = *((word32) dwArg04 + 24);
						Eq_3 edx_354 = esi_300->t0000;
						Eq_3 esi_355 = esi_300->t0004;
						Eq_3 ecx_357 = *((word32) eax_356 + 0x0C);
						if (esi_355 != 0x00)
							edx_354 = esi_355;
						esp_337->t001C = ecx_357;
						byte * edi_365 = &g_b8DA718;
						byte * esi_367 = (word32) edx_354 + 20;
						word32 ecx_368 = 0x0A;
						bool v29_682 = false;
						while (ecx_368 != 0x00)
						{
							v29_682 = *esi_939 != *edi_940;
							esi_367 = esi_939 + 1;
							edi_365 = edi_940 + 1;
							--ecx_368;
							esi_939 = esi_367;
							edi_940 = edi_365;
							if (*esi_939 == *edi_940)
								break;
						}
						if (v29_682)
						{
							esp_337->t0000 = edx_354;
							esp_337->tFFFFFFFC = *((word32) eax_356 + 28);
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							Eq_3 stackArg4 = <invalid>;
							word32 edx_932;
							Eq_3 eax_407 = fn00726150(stackArg4, dwArg04, out edx_932);
							if (eax_407 != 0x00)
							{
								Eq_3 ecx_418 = **((word32) dwArg04 + 24);
								esp_337->t0000 = eax_407;
								esp_337->tFFFFFFFC = ecx_418;
								// Failed to bind call argument.
								// Please report this issue at https://github.com/uxmal/reko
								Eq_3 stackArg4 = <invalid>;
								ui32 edi_426 = 0x03;
								word32 edx_936;
								word32 ecx_935;
								Eq_3 eax_428 = fn007475E0(stackArg4, out ecx_935, out edx_936);
								if (eax_428 <= 0x05)
								{
									switch ((word32) eax_428)
									{
									case 0x01:
										if (*((word32) **((word32) dwArg04 + 24) + 28) == 0x00)
											edi_426 = 0x00;
										break;
									case 0x02:
										goto l0072AEDE;
									case 0x03:
										Eq_3 eax_446 = **((word32) dwArg04 + 24);
										if (*((word32) eax_446 + 28) == 0x00 && *((word32) eax_446 + 32) == null)
										{
l0072AEDE:
											edi_426 = 0x01;
										}
										break;
									case 0x04:
										esp_337->t001C = *((word32) *((word32) dwArg04 + 24) + 24);
										edi_426 = 0x02;
										break;
									case 0x05:
										esp_337->t001C = *((word32) *((word32) dwArg04 + 24) + 20);
										edi_426 = 0x02;
										break;
									}
								}
								Eq_3 eax_473;
								(*((const char *) g_a72B02C + edi_426 * 0x04))();
								return eax_473;
							}
l0072AF90:
							struct Eq_132762 * eax_494 = esp_244->ptr0014;
							word32 v23_495 = eax_494->dw0000 + ~0x00;
							eax_494->dw0000 = v23_495;
							if (v23_495 != 0x00)
								return 0x00;
							struct Eq_132874 * ecx_499 = eax_494->ptr0004;
							<anonymous> * edx_500 = ecx_499->ptr0018;
							esp_244->ptrFFFFFFFC = eax_494;
							edx_500();
							return 0x00;
						}
						esp_337->t0000.u0 = 0x008DA884;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_3 stackArg4 = <invalid>;
						Eq_3 eax_482 = fn00728360(dwArg04, stackArg4);
						if (eax_482 == 0x00)
							goto l0072AF90;
						word32 eax_526 = esp_337->dw0020;
						esp_337->dw0020 = eax_526 + 0x01;
						eax_289 = eax_526 + 0x01;
					} while (eax_526 + 0x01 < esp_337->dw0014);
				}
				word32 ecx_930;
				int32 eax_540 = fn00727420(*((word32) *((word32) dwArg04 + 24) + 40), out ecx_930);
				if (eax_540 < 0x00)
					return 0x00;
				Eq_3 eax_551 = *((word32) *((word32) *((word32) dwArg04 + 24) + 40) + 0x0C);
				*((word32) eax_551 + eax_540 * 0x14) &= ~0x04;
				(word32) eax_551 + eax_540 * 0x14 + 0x04 = (ptr32) 0x01;
				Eq_3 edx_559 = *((word32) dwArg04 + 24);
				if (*((word32) edx_559 + 220) == 0x00)
				{
					*((word32) edx_559 + 220) = 0x01;
					Eq_3 ebp_564 = *((word32) dwArg04 + 24);
					*((word32) *((word32) *((word32) ebp_564 + 40) + 0x0C) + (eax_540 * 0x14 + 16)) = *((word32) ebp_564 + 0x00D8);
				}
				return 0x01;
			}
			else
			{
				word32 v13_649 = (word32) *eax_39 - 1;
				*eax_39 = v13_649;
				if (v13_649 == 0x00)
				{
					struct Eq_132287 * ecx_653 = *((word32) eax_39 + 4);
					ecx_653->ptr0018();
				}
				return 0x00;
			}
		}
	}
	goto l0072AC74;
}

<anonymous> * g_a72B02C[] = // 0072B02C
	{
	};
// 0072B040: Register Eq_3 fn0072B040(Register Eq_3 edi, Stack Eq_3 dwArg04)
// Called from:
//      fn0072B360
Eq_3 fn0072B040(Eq_3 edi, Eq_3 dwArg04)
{
	int32 ebp_15 = 0x00;
	uint32 dwLoc08_409 = 0x00;
	Eq_3 eax_23 = fn0072B360(edi, *((word32) dwArg04 + 4));
	if (eax_23 == 0x00)
		return eax_23;
	Eq_3 ebx_35 = *((word32) dwArg04 + 8);
	while (true)
	{
		int32 eax_50;
		if (ebx_35 == 0x00)
			eax_50 = 0x00;
		else
			eax_50 = (int32) *ebx_35;
		if (ebp_15 >= eax_50)
			break;
		if (fn0072B360(edi, dwArg04) == 0x00)
			return 0x00;
		++ebp_15;
	}
	Eq_3 eax_63 = *((word32) dwArg04 + 0x0C);
	if (eax_63 != 0x00)
	{
		Eq_3 dwLoc10_485 = 0x00;
		union Eq_3 ** dwLoc0C_486 = (word32) eax_63 + 4;
		while (true)
		{
			Eq_3 eax_72 = eax_63;
			if (eax_63 != 0x00)
				eax_72 = *eax_63;
			if (dwLoc10_485 >= eax_72)
				break;
			word32 ecx_592;
			Eq_3 eax_290 = fn007276E0(**dwLoc0C_486, *((word32) *((word32) edi + 24) + 8), out ecx_592);
			if (eax_290 < 0x00)
				return 0x00;
			word32 ecx_593;
			int32 eax_303 = fn00727420(*((word32) *((word32) edi + 24) + 40), out ecx_593);
			if (eax_303 < 0x00)
				return 0x00;
			Eq_3 eax_314 = *((word32) *((word32) *((word32) edi + 24) + 40) + 0x0C);
			*((word32) eax_314 + eax_303 * 0x14) |= 0x04;
			struct Eq_132997 * eax_320 = (word32) eax_314 + eax_303 * 0x14;
			eax_320->b0004 = 100;
			eax_320->t0008 = eax_290;
			Eq_3 eax_323 = *((word32) edi + 24);
			if (*((word32) eax_323 + 220) == 0x00)
			{
				*((word32) eax_323 + 220) = 0x01;
				Eq_3 eax_328 = *((word32) edi + 24);
				*((word32) *((word32) *((word32) eax_328 + 40) + 0x0C) + (eax_303 * 0x14 + 16)) = *((word32) eax_328 + 0x00D8);
			}
			if (fn0072B360(edi, dwArg04) == 0x00)
				return 0x00;
			dwLoc10_485 = (word32) dwLoc10_485 + 1;
			dwLoc0C_486 = (union Eq_3 **) ((const char *) dwLoc0C_486 + 4);
		}
		*((word32) dwArg04 + 0x0C) == 0x00;
	}
	if (*((word32) dwArg04 + 16) != 0x00)
	{
		if (fn0072B360(edi, dwArg04) == 0x00)
			return 0x00;
		dwLoc08_409 = 0x01;
	}
	uint32 eax_150;
	if (*((word32) dwArg04 + 20) != 0x00)
	{
		if (fn0072B360(edi, dwArg04) == 0x00)
			return 0x00;
		eax_150 = dwLoc08_409 | 0x02;
	}
	else
		eax_150 = dwLoc08_409;
	if (eax_150 <= 0x03)
	{
		switch (eax_150)
		{
		case 0x00:
			word32 ecx_594;
			Eq_3 eax_254 = fn00727810(edi, 131, dwArg04, out ecx_594);
			if (eax_254 == 0x00)
				return eax_254;
			break;
		case 0x01:
			word32 ecx_595;
			Eq_3 eax_230 = fn00727810(edi, 0x8C, dwArg04, out ecx_595);
			if (eax_230 == 0x00)
				return eax_230;
			break;
		case 0x02:
			word32 ecx_596;
			Eq_3 eax_206 = fn00727810(edi, 141, dwArg04, out ecx_596);
			if (eax_206 == 0x00)
				return eax_206;
			break;
		case 0x03:
			word32 ecx_597;
			if (fn00727810(edi, 0x8E, dwArg04, out ecx_597) == 0x00)
				return 0x00;
			break;
		}
	}
	return 0x01;
}

// 0072B360: Register Eq_3 fn0072B360(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08)
// Called from:
//      fn007279E0
//      fn00727D50
//      fn00727EF0
//      fn00727F90
//      fn00728030
//      fn00729810
//      fn00729F50
//      fn0072A520
//      fn0072A5D0
//      fn0072B040
//      fn0072B360
//      fn0072B830
//      fn0072BB20
//      fn0072BBE0
//      fn0072BD40
//      fn0072BDC0
//      fn0072BF10
//      fn0072C110
//      fn0072C160
//      fn0072C510
//      fn0072CA10
//      fn0072CC90
//      fn0072CEE0
//      fn0072D130
//      fn0072D3D0
//      fn0072D830
//      fn0072D920
//      fn0072DD60
//      fn0072E660
Eq_3 fn0072B360(Eq_3 dwArg04, Eq_3 dwArg08)
{
	Eq_3 eax_14 = *((word32) dwArg08 + 24);
	Eq_3 ecx_19 = *((word32) dwArg04 + 24);
	Eq_3 ebp_20 = 0x00;
	if (eax_14 > *((word32) ecx_19 + 0x00D8))
	{
		*((word32) ecx_19 + 0x00D8) = eax_14;
		*((word32) *((word32) dwArg04 + 24) + 220) = 0x00;
	}
	up32 eax_29 = *dwArg08;
	if (eax_29 > 0x13)
		return 0x01;
	Eq_3 eax_136;
	Eq_3 ebx_445;
	Eq_3 eax_917;
	switch (eax_29)
	{
	case 0x01:
		return fn00727D50(dwArg08, dwArg04);
	case 0x02:
		if (fn0072B360(dwArg04, *((word32) dwArg08 + 4)) != 0x00 && fn0072B360(dwArg04, dwArg04) != 0x00)
		{
			eax_917 = fn00727B60(*((word32) dwArg08 + 8), dwArg04);
			goto l0072B3DC;
		}
		break;
	case 0x03:
		if (fn0072B360(dwArg04, *((word32) dwArg08 + 8)) != 0x00)
		{
			eax_917 = fn00727B20(*((word32) dwArg08 + 4));
l0072B3DC:
			ebx_445 = eax_917;
			goto l0072B3DE;
		}
		break;
	case 0x04:
		return fn0072A5D0(dwArg04, dwArg08);
	case 0x05:
		return fn007279E0(dwArg04, dwArg08);
	case 0x06:
		word32 ecx_1424;
		if (fn00727810(dwArg04, 0x68, 0x00, out ecx_1424) != 0x00)
		{
			*((word32) dwArg08 + 8) != 0x00;
			if (dwArg04 > 0x00)
			{
				do
				{
					if (fn00727670(dwArg04, 0x04) == 0x00 || (fn0072B360(dwArg04, dwArg04) == 0x00 || (fn00727670(dwArg04, 0x02) == 0x00 || (fn0072B360(dwArg04, dwArg04) == 0x00 || fn00727670(dwArg04, 0x3C) == 0x00))))
						return 0x00;
					ebp_20 = (word32) ebp_20 + 1;
				} while (ebp_20 < dwArg04);
			}
			return 0x01;
		}
		break;
	case 0x07:
		return fn00729D20(dwArg04, dwArg08);
	case 0x08:
		word32 ebx_572 = *((word32) *((word32) *((word32) dwArg08 + 8) + 4) + 4);
		if (g_tA6DBE8 == 0x00)
		{
			word32 edx_1431;
			word32 ecx_1430;
			Eq_3 eax_577 = fn006ECAC0(9283836, out ecx_1430, out edx_1431);
			g_tA6DBE8 = eax_577;
			if (eax_577 == 0x00)
				return 0x00;
		}
		if (fn00728E40(eax, dwArg04, dwArg08, dwArg04) != 0x00)
		{
			fn00729F50(dwArg04, dwArg04, dwArg08);
			Eq_3 eax_631 = fn0072A350(dwArg04, dwArg04);
			fn00727290(dwArg04);
			if (eax_631 != 0x00)
			{
				word32 ecx_1434;
				fn00729040(dwArg04, es, ds, eax_631, out ecx_1434);
				word32 v16_660 = (word32) *eax_631 - 1;
				*eax_631 = v16_660;
				ptr32 esp_659 = fp - 0x0C;
				if (v16_660 == 0x00)
				{
					struct Eq_133454 * edx_664 = *((word32) eax_631 + 4);
					word32 esp_668;
					edx_664->ptr0018();
					esp_659 = esp_668 + 0x04;
				}
				struct Eq_133440 * esp_677 = esp_659 - 4;
				esp_677->dw0000 = ebx_572;
				esp_677->tFFFFFFFC = dwArg04;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_3 stackArg4 = <invalid>;
				if (fn0072B360(stackArg4, dwArg04) != 0x00 && fn00727670(dwArg04, 0x44) != 0x00)
				{
					esp_677->dw0000 = 0x01;
					esp_677->tFFFFFFFC.u0 = 131;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_125083 stackArg4 = <invalid>;
					word32 ecx_1437;
					return fn00727810(dwArg04, stackArg4, dwArg04, out ecx_1437) == 0x00;
				}
			}
		}
		return 0x00;
	case 0x09:
		if (*((word32) **((word32) dwArg04 + 24) + 28) != 0x00)
			return fn00728360(dwArg04, 9283928);
		Eq_3 esi_487 = *((word32) dwArg08 + 4);
		if (esi_487 != 0x00)
		{
			Eq_3 eax_512 = fn0072B360(dwArg04, esi_487);
			if (eax_512 == 0x00)
				return eax_512;
			goto l0072B550;
		}
		if (fn00728FB0() != 0x00)
		{
l0072B550:
			ebx_445.u0 = 0x56;
			goto l0072B3DE;
		}
		break;
	case 0x0A:
		return fn00728030(dwArg04, dwArg08);
	case 11:
		return fn0072B040(dwArg04, dwArg08);
	case 0x0C:
		if (fn0072B360(dwArg04, *((word32) dwArg08 + 4)) != 0x00)
		{
			ebx_445.u0 = 0x0D;
l0072B3DE:
			eax_136 = fn00727670(dwArg04, ebx_445);
			goto l0072B3E5;
		}
		break;
	case 0x0D:
		eax_136 = fn00728FB0();
		goto l0072B3E5;
	case 0x0E:
		eax_136 = fn00728FB0();
		goto l0072B3E5;
	case 0x0F:
		if (*((word32) dwArg08 + 0x0C) == 0x05 || fn0072B360(dwArg04, *((word32) dwArg08 + 4)) != 0x00)
		{
			Eq_3 eax_282 = *((word32) dwArg08 + 0x0C);
			if (eax_282 > 0x05)
			{
				word32 edx_1428;
				word32 ecx_1427;
				fn006E0F80(g_tA18720, dwArg04, out ecx_1427, out edx_1428);
				return 0x00;
			}
			switch ((word32) eax_282)
			{
			case 0x01:
				break;
			case 0x02:
				goto l0072B63F;
			case 0x03:
				eax_136 = fn00728FE0(dwArg04, dwArg04);
				goto l0072B3E5;
			case 0x04:
				if (fn00727670(dwArg04, 0x04) == 0x00)
					return 0x00;
				break;
			case 0x05:
				if (fn00727670(dwArg04, 0x02) == 0x00)
					return 0x00;
l0072B63F:
				eax_136 = fn00728FE0(dwArg04, dwArg04);
				goto l0072B3E5;
			}
			eax_136 = fn00728FE0(dwArg04, dwArg04);
l0072B3E5:
			if (eax_136 != 0x00)
				return 0x01;
		}
		break;
	case 0x10:
		Eq_3 eax_101 = *((word32) dwArg08 + 0x0C);
		if (eax_101 > 0x05)
		{
			word32 edx_1426;
			word32 ecx_1425;
			fn006E0F80(g_tA18720, 9283848, out ecx_1425, out edx_1426);
			return 0x00;
		}
		switch ((word32) eax_101)
		{
		case 0x01:
			if (fn0072B360(dwArg04, *((word32) dwArg08 + 4)) != 0x00)
			{
				eax_136 = fn0072BDC0(dwArg04, dwArg04, dwArg08);
				goto l0072B3E5;
			}
			break;
		case 0x02:
			if (fn0072B360(dwArg04, *((word32) dwArg08 + 4)) != 0x00)
			{
				eax_136 = fn0072BDC0(dwArg04, dwArg04, dwArg08);
				goto l0072B3E5;
			}
			break;
		case 0x03:
			if (fn0072B360(dwArg04, *((word32) dwArg08 + 4)) != 0x00)
			{
				eax_136 = fn0072BDC0(dwArg04, dwArg04, dwArg08);
				goto l0072B3E5;
			}
			break;
		case 0x04:
			if (fn0072B360(dwArg04, *((word32) dwArg08 + 4)) != 0x00)
			{
				eax_136 = fn0072BDC0(dwArg04, dwArg04, dwArg08);
				goto l0072B3E5;
			}
			break;
		case 0x05:
			eax_136 = fn0072BDC0(dwArg04, *((word32) dwArg08 + 8), 0x05);
			goto l0072B3E5;
		}
		break;
	case 0x11:
		return fn00729510(dwArg04, *((word32) dwArg08 + 4), *((word32) dwArg08 + 8));
	case 0x12:
		return fn00727EF0(dwArg08);
	case 0x13:
		return fn00727F90(dwArg08);
	}
	return 0x00;
}

// 0072B830: Register Eq_3 fn0072B830(Register Eq_3 eax, Stack Eq_3 dwArg04)
// Called from:
//      fn0072D920
Eq_3 fn0072B830(Eq_3 eax, Eq_3 dwArg04)
{
	struct Eq_133502 * esi_22 = *((word32) eax + 4);
	word32 ecx_23 = esi_22->dw0000;
	if (ecx_23 == 0x0F)
	{
		word32 edx_627;
		Eq_3 eax_47 = fn00743D80(esi_22->t0004, esi_22->t0008, 0x04, esi_22->t0018, esi_22->t001C, out edx_627);
		if (eax_47 == 0x00 || (fn0072B360(dwArg04, dwArg04) == 0x00 || (fn0072B360(dwArg04, dwArg04) == 0x00 || fn00727670(dwArg04, fn00727C90(*((word32) eax + 8), dwArg04)) == 0x00)))
			return 0x00;
		((word32) eax_47 + 0x0C)->u0 = 0x05;
		if (fn0072B360(dwArg04, dwArg04) == 0x00)
			return 0x00;
		return 0x01;
	}
	else if (ecx_23 == 0x10)
	{
		word32 edx_628;
		Eq_3 eax_144 = fn00743E30(esi_22->t0004, esi_22->t0008, 0x04, esi_22->t0018, esi_22->t001C, out edx_628);
		if (eax_144 != 0x00 && (fn0072B360(dwArg04, dwArg04) != 0x00 && (fn0072B360(dwArg04, dwArg04) != 0x00 && fn00727670(dwArg04, fn00727C90(*((word32) eax + 8), dwArg04)) != 0x00)))
		{
			((word32) eax_144 + 0x0C)->u0 = 0x05;
			if (fn0072B360(dwArg04, dwArg04) != 0x00)
				return 0x01;
		}
		return 0x00;
	}
	else if (ecx_23 == 0x11)
	{
		if (fn00729510(dwArg04, esi_22->t0004, 0x01) == 0x00 || (fn0072B360(dwArg04, dwArg04) == 0x00 || fn00727670(dwArg04, fn00727C90(*((word32) eax + 8), dwArg04)) == 0x00))
			return 0x00;
		Eq_3 edx_288 = *((word32) dwArg04 + 24);
		byte * edi_292 = &g_b8DA718;
		byte * esi_293 = (word32) esi_22->t0004 + 20;
		word32 ecx_294 = 0x0A;
		bool v16_470 = false;
		while (ecx_294 != 0x00)
		{
			v16_470 = *esi_633 != *edi_634;
			esi_293 = esi_633 + 1;
			edi_292 = edi_634 + 1;
			--ecx_294;
			esi_633 = esi_293;
			edi_634 = edi_292;
			if (*esi_633 == *edi_634)
				break;
		}
		if (!v16_470)
			return fn00728360(dwArg04, 0x008DA884);
		word32 edx_631;
		if (fn00726150(*((word32) edx_288 + 28), dwArg04, out edx_631) == 0x00)
			return 0x00;
		word32 edx_632;
		Eq_3 ecx_368;
		Eq_3 eax_369 = fn007475E0(**((word32) dwArg04 + 24), out ecx_368, out edx_632);
		ui32 edi_366 = 0x03;
		Eq_3 eax_373 = (word32) eax_369 - 1;
		if (eax_369 <= 0x05)
		{
			switch ((word32) eax_369)
			{
			case 0x01:
				eax_373 = *((word32) dwArg04 + 24);
				ecx_368 = *eax_373;
				if (*((word32) ecx_368 + 28) == 0x00)
					edi_366 = 0x00;
				break;
			case 0x02:
				goto l0072B96F;
			case 0x03:
				eax_373 = **((word32) dwArg04 + 24);
				if (*((word32) eax_373 + 28) == 0x00 && *((word32) eax_373 + 32) == null)
				{
l0072B96F:
					edi_366 = 0x01;
				}
				break;
			case 0x04:
				eax_373 = *((word32) *((word32) dwArg04 + 24) + 24);
				edi_366 = 0x02;
				break;
			case 0x05:
				ecx_368 = *((word32) dwArg04 + 24);
				edi_366 = 0x02;
				break;
			}
		}
		Eq_3 eax_418;
		(*((const char *) g_a72BB10 + edi_366 * 0x04))();
		return eax_418;
	}
	else
	{
		word32 ecx_629;
		word32 edx_630;
		fn006E15D0(g_tA18720, 9283956, out ecx_629, out edx_630);
		return 0x00;
	}
}

<anonymous> * g_a72BB10[] = // 0072BB10
	{
	};
// 0072BB20: Register Eq_133772 fn0072BB20(Register Eq_3 esi, Register Eq_3 edi)
// Called from:
//      fn0072BD40
//      fn0072BDC0
Eq_133772 fn0072BB20(Eq_3 esi, Eq_3 edi)
{
	Eq_3 eax_6 = *((word32) edi + 4);
	Eq_3 ebx_119 = 0x02;
	if (eax_6 != 0x00)
	{
		if (fn0072B360(esi, eax_6) == 0x00)
			return 0x00;
	}
	else
	{
		word32 ecx_227;
		Eq_3 eax_21 = fn007276E0(0x00A163B8, *((word32) *((word32) esi + 24) + 8), out ecx_227);
		if (eax_21 < 0x00)
			return 0x00;
		word32 ecx_228;
		if (fn00727810(esi, 100, eax_21, out ecx_228) == 0x00)
			return 0x00;
	}
	Eq_3 eax_58 = *((word32) edi + 8);
	if (eax_58 != 0x00)
	{
		if (fn0072B360(esi, eax_58) == 0x00)
			return 0x00;
	}
	else
	{
		word32 ecx_229;
		Eq_3 eax_72 = fn007276E0(0x00A163B8, *((word32) *((word32) esi + 24) + 8), out ecx_229);
		if (eax_72 < 0x00)
			return 0x00;
		word32 ecx_231;
		if (fn00727810(esi, 100, eax_72, out ecx_231) == 0x00)
			return 0x00;
	}
	Eq_3 eax_109 = *((word32) edi + 0x0C);
	if (eax_109 != 0x00)
	{
		ebx_119.u0 = 0x03;
		if (fn0072B360(esi, eax_109) == 0x00)
			return 0x00;
	}
	word32 ecx_230;
	return fn00727810(esi, 133, ebx_119, out ecx_230) == 0x00;
}

// 0072BBE0: Register Eq_3 fn0072BBE0(Register Eq_3 eax, Stack Eq_3 dwArg08)
// Called from:
//      fn0072BDC0
Eq_3 fn0072BBE0(Eq_3 eax, Eq_3 dwArg08)
{
	Eq_3 eax_23 = *((word32) eax + 4);
	word32 esi_24 = 0x00;
	word32 dwLoc04_293 = 0x00;
	if (eax_23 != 0x00)
	{
		esi_24 = 0x01;
		dwLoc04_293 = 0x01;
		if (dwArg08 != 0x05 && fn0072B360(dwArg04, eax_23) == 0x00)
			return 0x00;
	}
	if (*((word32) eax + 8) != 0x00)
	{
		dwLoc04_293 += 0x02;
		++esi_24;
		if (dwArg08 != 0x05 && fn0072B360(dwArg04, dwArg04) == 0x00)
			return 0x00;
	}
	Eq_3 ebx_106;
	if (dwArg08 == 0x04)
	{
		if (esi_24 != 0x00)
		{
			word32 esi_143 = esi_24 - 0x01;
			if (esi_143 != 0x00)
			{
				if (esi_143 == 0x01)
				{
					word32 ecx_404;
					Eq_3 eax_182 = fn00727810(dwArg04, 99, dwArg04, out ecx_404);
					if (eax_182 == 0x00)
						return eax_182;
				}
			}
			else
			{
				word32 ecx_403;
				Eq_3 eax_154 = fn00727810(dwArg04, 99, dwArg04, out ecx_403);
				if (eax_154 == 0x00)
					return eax_154;
			}
l0072BCCF:
			if (dwArg08 > 0x05)
			{
				word32 edx_406;
				word32 ecx_405;
				fn006E0F80(g_tA18720, dwArg04, out ecx_405, out edx_406);
				return 0x00;
			}
			else
			{
				word32 eax_229;
				switch (dwArg08)
				{
				case 0x01:
				case 0x04:
					eax_229 = 0x1E;
					break;
				case 0x02:
				case 0x05:
					eax_229 = 0x28;
					break;
				case 0x03:
					eax_229 = 0x32;
					break;
				}
				return fn00727670(dwArg04, dwLoc04_293 + eax_229) == 0x00;
			}
		}
		ebx_106.u0 = 0x04;
	}
	else
	{
		if (dwArg08 != 0x05)
			goto l0072BCCF;
		if (esi_24 == 0x00)
		{
			if (fn00727670(dwArg04, 0x02) == 0x00)
				return 0x00;
			goto l0072BCCF;
		}
		word32 esi_103 = esi_24 - 0x01;
		if (esi_103 != 0x00)
		{
			if (esi_103 != 0x01)
				goto l0072BCCF;
			ebx_106 = dwArg08;
		}
		else
			ebx_106.u0 = 0x03;
	}
	Eq_3 eax_126 = fn00727670(dwArg04, ebx_106);
	if (eax_126 == 0x00)
		return eax_126;
	goto l0072BCCF;
}

// 0072BD40: Register Eq_3 fn0072BD40(Register Eq_3 eax, Register Eq_3 ecx)
// Called from:
//      fn0072BDC0
Eq_3 fn0072BD40(Eq_3 eax, Eq_3 ecx)
{
	word32 eax_12 = *eax;
	if (eax_12 == 0x01)
	{
		word32 ecx_167;
		Eq_3 eax_24 = fn007276E0(10640184, *((word32) *((word32) ecx + 24) + 8), out ecx_167);
		if (eax_24 < 0x00)
			return 0x00;
		word32 ecx_170;
		if (fn00727810(ecx, 100, eax_24, out ecx_170) == 0x00)
			return 0x00;
		return 0x01;
	}
	else
	{
		if (eax_12 == 0x02)
			return fn0072BB20(ecx, eax);
		if (eax_12 == 0x04)
		{
			Eq_3 eax_70 = fn0072B360(ecx, *((word32) eax + 4));
			if (eax_70 != 0x00)
				return 0x01;
			return eax_70;
		}
		else
		{
			word32 edx_169;
			word32 ecx_168;
			fn006E0F80(g_tA18720, 0x008DA9C4, out ecx_168, out edx_169);
			return 0x00;
		}
	}
}

// 0072BDC0: Register Eq_3 fn0072BDC0(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Stack Eq_3 dwArg0C)
// Called from:
//      fn0072B360
Eq_3 fn0072BDC0(Eq_3 dwArg04, Eq_3 dwArg08, Eq_3 dwArg0C)
{
	up32 ecx_17 = *dwArg08;
	if (ecx_17 > 0x04)
	{
		word32 ecx_357;
		word32 edx_358;
		fn006E15D0(g_tA18720, 0x008DA9EC, out ecx_357, out edx_358);
		return 0x00;
	}
	else
	{
		switch (ecx_17)
		{
		case 0x01:
			if (dwArg0C != 0x05)
			{
				Eq_3 eax_197 = fn00728FB0();
				if (eax_197 == 0x00)
					return eax_197;
			}
			break;
		case 0x02:
			if (*((word32) dwArg08 + 0x0C) == 0x00)
				return fn0072BBE0(dwArg08, dwArg0C);
			if (dwArg0C != 0x05)
			{
				Eq_3 eax_146 = fn0072BB20(dwArg04, dwArg08);
				if (eax_146 == 0x00)
					return eax_146;
			}
			break;
		case 0x03:
			if (dwArg0C != 0x05)
			{
				int32 esi_70;
				Eq_3 eax_66 = *((word32) dwArg08 + 4);
				if (eax_66 == 0x00)
					esi_70 = 0x00;
				else
					esi_70 = (int32) *eax_66;
				int32 ebx_74 = 0x00;
				if (esi_70 > 0x00)
				{
					do
					{
						if (fn0072BD40(*((word32) *((word32) dwArg08 + 4) + (ebx_74 * 0x04 + 4)), dwArg04) == 0x00)
							return 0x00;
						++ebx_74;
					} while (ebx_74 < esi_70);
				}
				word32 ecx_359;
				if (fn00727810(dwArg04, 0x66, dwArg04, out ecx_359) == 0x00)
					return 0x00;
			}
			break;
		case 0x04:
			if (dwArg0C == 0x05)
				return fn00728420(dwArg0C);
			Eq_3 eax_47 = fn0072B360(dwArg04, *((word32) dwArg08 + 4));
			if (eax_47 != 0x00)
				return fn00728420(dwArg0C);
			return eax_47;
		}
		return fn00728420(dwArg0C);
	}
}

// 0072BF10: Register word32 fn0072BF10(Register Eq_3 ebx, Stack Eq_3 dwArg04)
// Called from:
//      fn0072C510
//      fn0072E660
word32 fn0072BF10(Eq_3 ebx, Eq_3 dwArg04)
{
	int32 edi_12 = 0x00;
	if (dwArg04 == 0x00 || *dwArg04 == 0x00)
		return 0x01;
	struct Eq_134130 * eax_18 = *((word32) dwArg04 + 4);
	if (eax_18->dw0000 == 0x14)
	{
		Eq_3 eax_24 = eax_18->t0004;
		if ((uint32) (int8) (*eax_24 == 0x0E) != 0x00 && g_dwA6DBF4 < 0x02)
		{
			if (fn0072B360(ebx, eax_24) == 0x00)
				return 0x00;
			Eq_3 eax_52 = *((word32) ebx + 24);
			byte * edi_56 = &g_b8DA718;
			byte * esi_57 = (word32) g_tA6DBD8 + 20;
			word32 ecx_58 = 0x0A;
			bool v19_244 = false;
			while (ecx_58 != 0x00)
			{
				v19_244 = *esi_346 != *edi_347;
				esi_57 = esi_346 + 1;
				edi_56 = edi_347 + 1;
				--ecx_58;
				esi_346 = esi_57;
				edi_347 = edi_56;
				if (*esi_346 == *edi_347)
					break;
			}
			if (v19_244)
			{
				word32 edx_343;
				if (fn00726150(*((word32) eax_52 + 28), dwArg04, out edx_343) == 0x00)
					return 0x00;
				ui32 edi_113 = 0x03;
				word32 ecx_344;
				word32 edx_345;
				Eq_3 eax_115 = fn007475E0(**((word32) ebx + 24), out ecx_344, out edx_345);
				if (eax_115 <= 0x05)
				{
					switch ((word32) eax_115)
					{
					case 0x01:
						if (*((word32) **((word32) ebx + 24) + 28) == 0x00)
							edi_113 = 0x00;
						break;
					case 0x02:
						goto l0072C028;
					case 0x03:
						struct Eq_134265 * eax_133 = **((word32) ebx + 24);
						if (eax_133->dw001C == 0x00 && eax_133->dw0020 == 0x00)
						{
l0072C028:
							edi_113 = 0x01;
						}
						break;
					case 0x04:
						edi_113 = 0x02;
						break;
					case 0x05:
						edi_113 = 0x02;
						break;
					}
				}
				word32 eax_160;
				word32 ecx_161;
				word32 edx_162;
				(*((const char *) g_a72C0FC + edi_113 * 0x04))();
				return eax_160;
			}
			Eq_3 eax_169 = fn00728360(ebx, 0x008DA884);
			if (eax_169 == 0x00)
				return 0x00;
			edi_12 = 0x01;
		}
	}
	for (; edi_12 < *dwArg04; ++edi_12)
	{
		if (fn0072D920(ebx, dwArg04) == 0x00)
			return 0x00;
	}
	return 0x01;
}

<anonymous> * g_a72C0FC[] = // 0072C0FC
	{
	};
// 0072C110: Register word32 fn0072C110(Register Eq_3 ebx)
// Called from:
//      fn0072C160
word32 fn0072C110(Eq_3 ebx)
{
	if (ebx == 0x00)
		return 0x01;
	int32 esi_18;
	for (esi_18 = 0x00; esi_18 < *ebx; ++esi_18)
	{
		if (fn0072B360(dwArg04, dwArg04) == 0x00)
			return 0x00;
	}
	return 0x01;
}

// 0072C160: Register Eq_3 fn0072C160(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08)
// Called from:
//      fn0072D920
Eq_3 fn0072C160(Eq_3 dwArg04, Eq_3 dwArg08)
{
	Eq_3 edi_18 = *((word32) dwArg08 + 8);
	Eq_3 dwLoc0C_600 = 0x00A163B8;
	Eq_3 eax_27 = fn0072C110(*((word32) dwArg08 + 16));
	if (eax_27 == 0x00)
		return eax_27;
	Eq_3 esi_39 = *((word32) edi_18 + 0x0C);
	if (esi_39 != 0x00)
	{
		int32 edi_43 = 0x00;
		while (true)
		{
			int32 eax_52;
			if (esi_39 == 0x00)
				eax_52 = 0x00;
			else
				eax_52 = (int32) *esi_39;
			if (edi_43 >= eax_52)
				break;
			if (fn0072B360(dwArg04, dwArg04) == 0x00)
				return 0x00;
			++edi_43;
		}
	}
	if (fn00728E40(*((word32) dwArg08 + 4), dwArg04, dwArg08, dwArg04) == 0x00)
		return 0x00;
	Eq_134345 esi_105;
	struct Eq_134346 * eax_95 = *((word32) *((word32) dwArg08 + 0x0C) + 4);
	if (eax_95->dw0000 != 0x14)
		esi_105.u0 = 0x00;
	else
	{
		struct Eq_134358 * eax_98 = eax_95->ptr0004;
		Eq_134345 edx_104 = (uint32) (int8) (eax_98->dw0000 == 0x0E);
		esi_105 = edx_104;
		if (edx_104 != 0x00 && g_dwA6DBF4 < 0x02)
			dwLoc0C_600 = eax_98->t0004;
	}
	word32 ecx_805;
	if (fn007276E0(dwLoc0C_600, *((word32) *((word32) dwArg04 + 24) + 8), out ecx_805) < 0x00)
	{
l0072C2E3:
		fn00727290(dwArg04);
		return 0x00;
	}
	else
	{
		fn0072A520(dwArg04, edi_18);
		struct Eq_132212 * eax_147 = *edi_18;
		if (eax_147 != null)
			eax_147 = eax_147->ptr0000;
		Eq_134345 ebx_163;
		*((word32) *((word32) dwArg04 + 24) + 32) = eax_147;
		Eq_3 eax_159 = *((word32) dwArg08 + 0x0C);
		if (eax_159 == 0x00)
			ebx_163.u0 = 0x00;
		else
			ebx_163 = *eax_159;
		while (esi_105 < ebx_163)
		{
			if (fn0072D920(dwArg04, dwArg04) == 0x00)
				goto l0072C2E3;
			esi_105 = (word32) esi_105.u0 + 1;
		}
		Eq_3 eax_229 = fn0072A350(dwArg04, dwArg04);
		Eq_3 esi_234 = *((word32) dwArg04 + 24);
		*((word32) dwArg04 + 20) = (word32) *((word32) dwArg04 + 20) - 1;
		fn00727170(esi_234);
		Eq_3 eax_247 = *((word32) dwArg04 + 28);
		Eq_3 esi_248 = *((word32) eax_247 + 8);
		if (esi_248 >= 0x01)
		{
			word32 edx_806;
			Eq_3 eax_258 = fn0072E9C0(*((word32) *((word32) eax_247 + 0x0C) + (esi_248 - 0x01) * 0x04), out edx_806);
			Eq_3 edx_263 = *((word32) dwArg04 + 28);
			*((word32) dwArg04 + 24) = eax_258;
			word32 edx_808;
			word32 ecx_807;
			if (fn00703390(edx_263, dwArg04, out ecx_807, out edx_808) < 0x00)
				fn006E86F0(9283148);
		}
		else
			((word32) dwArg04 + 24)->u0 = 0x00;
		if (eax_229 == 0x00)
			return 0x00;
		*((word32) edi_18 + 0x0C) == 0x00;
		word32 ecx_811;
		fn00729040(dwArg04, es, ds, eax_229, out ecx_811);
		word32 v18_322 = (word32) *eax_229 - 1;
		*eax_229 = v18_322;
		struct Eq_134521 * esp_321 = fp - 0x1C;
		if (v18_322 == 0x00)
		{
			struct Eq_134529 * eax_326 = *((word32) eax_229 + 4);
			word32 esp_330;
			eax_326->ptr0018();
			esp_321 = esp_330 + 0x04;
		}
		struct Eq_134527 * edi_338 = null;
		while (true)
		{
			struct Eq_134527 * eax_346 = esp_321->ptr0018;
			if (eax_346 != null)
				eax_346 = eax_346->ptr0000;
			Eq_3 edx_358 = *((word32) dwArg04 + 24);
			if (edi_338 >= eax_346)
				break;
			word32 ecx_812;
			int32 eax_501 = fn00727420(*((word32) edx_358 + 40), out ecx_812);
			if (eax_501 < 0x00)
				return 0x00;
			Eq_3 eax_512 = *((word32) *((word32) *((word32) dwArg04 + 24) + 40) + 0x0C);
			*((word32) eax_512 + eax_501 * 0x14) |= 0x04;
			struct Eq_134597 * eax_518 = (word32) eax_512 + eax_501 * 0x14;
			eax_518->b0004 = 131;
			eax_518->dw0008 = 0x01;
			Eq_3 eax_523 = *((word32) dwArg04 + 24);
			if (*((word32) eax_523 + 220) == 0x00)
			{
				*((word32) eax_523 + 220) = 0x01;
				Eq_3 eax_527 = *((word32) dwArg04 + 24);
				*((word32) *((word32) *((word32) eax_527 + 40) + 0x0C) + (eax_501 * 0x14 + 16)) = *((word32) eax_527 + 0x00D8);
			}
			edi_338 = (struct Eq_134527 *) ((const char *) &edi_338->ptr0000 + 1);
		}
		Eq_3 eax_362 = *((word32) esp_321->t0024 + 4);
		esp_321->t0024 = *((word32) edx_358 + 0x0C);
		byte * edi_365 = &g_b8DA718;
		byte * esi_366 = (word32) eax_362 + 20;
		word32 ecx_367 = 0x0A;
		bool v27_590 = false;
		while (ecx_367 != 0x00)
		{
			v27_590 = *esi_819 != *edi_820;
			esi_366 = esi_819 + 1;
			edi_365 = edi_820 + 1;
			--ecx_367;
			esi_819 = esi_366;
			edi_820 = edi_365;
			if (*esi_819 == *edi_820)
				break;
		}
		if (v27_590)
		{
			Eq_3 edx_386 = *((word32) edx_358 + 28);
			struct Eq_134668 * esp_389 = esp_321 - 4;
			esp_389->t0000 = eax_362;
			esp_389->tFFFFFFFC = edx_386;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg4 = <invalid>;
			word32 edx_814;
			Eq_3 eax_406 = fn00726150(stackArg4, dwArg04, out edx_814);
			if (eax_406 == 0x00)
				return 0x00;
			Eq_3 ecx_417 = **((word32) dwArg04 + 24);
			esp_389->t0000 = eax_406;
			esp_389->tFFFFFFFC = ecx_417;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg4 = <invalid>;
			ui32 edi_425 = 0x03;
			word32 ecx_817;
			word32 edx_818;
			Eq_3 eax_427 = fn007475E0(stackArg4, out ecx_817, out edx_818);
			if (eax_427 <= 0x05)
			{
				switch ((word32) eax_427)
				{
				case 0x01:
					if (*((word32) **((word32) dwArg04 + 24) + 28) == 0x00)
						edi_425 = 0x00;
					break;
				case 0x02:
					goto l0072C44D;
				case 0x03:
					struct Eq_134741 * eax_445 = **((word32) dwArg04 + 24);
					if (eax_445->dw001C == 0x00 && eax_445->dw0020 == 0x00)
					{
l0072C44D:
						edi_425 = 0x01;
					}
					break;
				case 0x04:
					esp_389->t0028 = *((word32) *((word32) dwArg04 + 24) + 24);
					edi_425 = 0x02;
					break;
				case 0x05:
					esp_389->t0028 = *((word32) *((word32) dwArg04 + 24) + 20);
					edi_425 = 0x02;
					break;
				}
			}
			Eq_3 eax_472;
			(*((const char *) g_a72C4F8 + edi_425 * 0x04))();
			return eax_472;
		}
		else
		{
			esp_321->dwFFFFFFFC = 0x008DA884;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg4 = <invalid>;
			return fn00728360(dwArg04, stackArg4);
		}
	}
}

<anonymous> * g_a72C4F8[] = // 0072C4F8
	{
	};
// 0072C510: Register word32 fn0072C510(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08)
// Called from:
//      fn0072D920
word32 fn0072C510(Eq_3 dwArg04, Eq_3 dwArg08)
{
	word32 ecx_962;
	if (fn007276E0(*((word32) dwArg08 + 4), *((word32) *((word32) dwArg04 + 24) + 8), out ecx_962) < 0x00)
		return 0x00;
	word32 ecx_963;
	if (fn00727810(dwArg04, 100, dwArg04, out ecx_963) == 0x00)
		return 0x00;
	Eq_3 esi_51 = *((word32) dwArg08 + 8);
	if (esi_51 != 0x00 && *esi_51 > 0x00)
	{
		int32 ebx_106 = 0x00;
		while (true)
		{
			int32 eax_68;
			if (esi_51 == 0x00)
				eax_68 = 0x00;
			else
				eax_68 = (int32) *esi_51;
			if (ebx_106 >= eax_68)
				break;
			if (fn0072B360(dwArg04, dwArg04) == 0x00)
				return 0x00;
			++ebx_106;
		}
	}
	word32 ecx_964;
	if (fn00727810(dwArg04, 0x66, dwArg04, out ecx_964) == 0x00 || fn00728E40(*((word32) dwArg08 + 4), dwArg04, dwArg08, dwArg04) == 0x00)
		return 0x00;
	*((word32) *((word32) dwArg04 + 24) + 28) = *((word32) dwArg08 + 4);
	Eq_3 eax_156 = *((word32) *((word32) dwArg04 + 24) + 28);
	*eax_156 = (word32) *eax_156 + 1;
	word32 ecx_965;
	word32 edx_966;
	Eq_3 eax_164 = fn006F1A70(out ecx_965, out edx_966);
	if (eax_164 != 0x00)
	{
		struct Eq_134874 * esp_184 = fp - 0x14;
		if (fn00729510(dwArg04, eax_164, dwArg04) == 0x00)
		{
			word32 v21_188 = (word32) *eax_164 - 1;
			*eax_164 = v21_188;
			if (v21_188 == 0x00)
			{
				struct Eq_134923 * eax_192 = *((word32) eax_164 + 4);
				<anonymous> * ecx_193 = eax_192->ptr0018;
				ecx_193();
			}
			goto l0072C9AD;
		}
		word32 v16_204 = (word32) *eax_164 - 1;
		*eax_164 = v16_204;
		if (v16_204 == 0x00)
		{
			struct Eq_134923 * eax_208 = *((word32) eax_164 + 4);
			<anonymous> * ecx_209 = eax_208->ptr0018;
			word32 esp_212;
			ecx_209();
			esp_184 = esp_212 + 0x04;
		}
		struct Eq_134904 * esp_221 = esp_184 - 4;
		esp_221->t0000.u0 = 9209240;
		word32 edx_968;
		word32 ecx_967;
		Eq_3 eax_231 = fn006F1A70(out ecx_967, out edx_968);
		esp_221->t0014 = eax_231;
		if (eax_231 != 0x00)
		{
			Eq_3 eax_241 = *((word32) dwArg04 + 24);
			byte * esi_243 = (word32) esp_221->t0014 + 20;
			byte * edi_244 = &g_b8DA718;
			word32 ecx_245 = 0x0A;
			bool v23_737 = false;
			while (ecx_245 != 0x00)
			{
				v23_737 = *esi_986 != *edi_987;
				esi_243 = esi_986 + 1;
				edi_244 = edi_987 + 1;
				--ecx_245;
				esi_986 = esi_243;
				edi_987 = edi_244;
				if (*esi_986 == *edi_987)
					break;
			}
			if (!v23_737)
			{
				esp_221->t0000.u0 = 0x008DA884;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_3 stackArg4 = <invalid>;
				Eq_3 eax_356 = fn00728360(dwArg04, stackArg4);
				struct Eq_135011 * esp_360 = (const char *) &esp_221->t0000 + 4;
				if (eax_356 != 0x00)
				{
					Eq_3 eax_409 = esp_221->t0014;
					word32 v17_410 = (word32) *eax_409 - 1;
					*eax_409 = v17_410;
					if (v17_410 == 0x00)
					{
						struct Eq_135064 * ecx_414 = *((word32) eax_409 + 4);
						<anonymous> * edx_415 = ecx_414->ptr0018;
						esp_221->t0000 = eax_409;
						word32 esp_418;
						edx_415();
						esp_360 = esp_418 + 0x04;
					}
					struct Eq_135046 * esp_430 = esp_360 - 4;
					esp_430->t0000 = esp_360->ptr001C->t000C;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_3 stackArg4 = <invalid>;
					if (fn0072BF10(dwArg04, stackArg4) != 0x00 && (fn00727670(dwArg04, 0x52) != 0x00 && fn00727670(dwArg04, 0x53) != 0x00))
					{
						esp_430->t0000.u0 = 0x01;
						esp_430->tFFFFFFFC = dwArg04;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_3 stackArg4 = <invalid>;
						Eq_3 eax_489 = fn0072A350(stackArg4, dwArg04);
						fn00727290(dwArg04);
						if (eax_489 == 0x00)
							return 0x00;
						esp_430->t0000.u0 = 0x00;
						esp_430->tFFFFFFFC = eax_489;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_3 stackArg4 = <invalid>;
						word32 ecx_512;
						fn00729040(dwArg04, es, ds, stackArg4, out ecx_512);
						word32 v19_518 = (word32) *eax_489 - 1;
						*eax_489 = v19_518;
						ptr32 esp_517 = (const char *) &esp_430->t0000 + 4;
						if (v19_518 == 0x00)
						{
							struct Eq_135217 * edx_522 = *((word32) eax_489 + 4);
							<anonymous> * eax_523 = edx_522->ptr0018;
							esp_430->t0000 = eax_489;
							word32 esp_526;
							eax_523();
							esp_517 = esp_526 + 0x04;
						}
						struct Eq_135199 * esp_535 = esp_517 - 4;
						esp_535->t0000.u0 = 0x00;
						esp_535->tFFFFFFFC.u0 = 131;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_125083 stackArg4 = <invalid>;
						word32 ecx_980;
						if (fn00727810(dwArg04, stackArg4, dwArg04, out ecx_980) == 0x00 || fn00727670(dwArg04, 0x59) == 0x00)
							return 0x00;
						Eq_3 edx_569 = *((word32) dwArg04 + 24);
						Eq_3 eax_568 = *((word32) esp_535->t0020 + 4);
						esp_535->t0020 = *((word32) edx_569 + 0x0C);
						byte * edi_572 = &g_b8DA718;
						byte * esi_573 = (word32) eax_568 + 20;
						word32 ecx_574 = 0x0A;
						bool v27_741 = false;
						while (ecx_574 != 0x00)
						{
							v27_741 = *esi_988 != *edi_989;
							esi_573 = esi_988 + 1;
							edi_572 = edi_989 + 1;
							--ecx_574;
							esi_988 = esi_573;
							edi_989 = edi_572;
							if (*esi_988 == *edi_989)
								break;
						}
						if (v27_741)
						{
							Eq_3 edx_593 = *((word32) edx_569 + 28);
							esp_535->t0000 = eax_568;
							esp_535->tFFFFFFFC = edx_593;
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							Eq_3 stackArg4 = <invalid>;
							word32 edx_982;
							Eq_3 eax_613 = fn00726150(stackArg4, dwArg04, out edx_982);
							if (eax_613 == 0x00)
								return 0x00;
							Eq_3 ecx_623 = **((word32) dwArg04 + 24);
							esp_535->t0000 = eax_613;
							esp_535->tFFFFFFFC = ecx_623;
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							Eq_3 stackArg4 = <invalid>;
							ui32 edi_631 = 0x03;
							word32 edx_985;
							Eq_3 ecx_633;
							Eq_3 eax_634 = fn007475E0(stackArg4, out ecx_633, out edx_985);
							if (eax_634 <= 0x05)
							{
								switch ((word32) eax_634)
								{
								case 0x01:
									ecx_633 = **((word32) dwArg04 + 24);
									if (*((word32) ecx_633 + 28) == 0x00)
										edi_631 = 0x00;
									break;
								case 0x02:
									goto l0072C8E2;
								case 0x03:
									struct Eq_135372 * eax_651 = **((word32) dwArg04 + 24);
									if (eax_651->dw001C == 0x00 && eax_651->dw0020 == 0x00)
									{
l0072C8E2:
										edi_631 = 0x01;
									}
									break;
								case 0x04:
									esp_535->t0020 = *((word32) *((word32) dwArg04 + 24) + 24);
									edi_631 = 0x02;
									break;
								case 0x05:
									ecx_633 = *((word32) dwArg04 + 24);
									esp_535->t0020 = *((word32) ecx_633 + 20);
									edi_631 = 0x02;
									break;
								}
							}
							word32 eax_681;
							(*((const char *) g_a72C9F4 + edi_631 * 0x04))();
							return eax_681;
						}
						else
						{
							esp_535->t0000.u0 = 0x008DA884;
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							Eq_3 stackArg4 = <invalid>;
							Eq_3 eax_690 = fn00728360(dwArg04, stackArg4);
							if (eax_690 == 0x00)
								return 0x00;
							return 0x01;
						}
					}
					goto l0072C9AD;
				}
			}
			else
			{
				Eq_3 edx_267 = *((word32) eax_241 + 28);
				esp_221->t0000 = esp_221->t0014;
				esp_221->tFFFFFFFC = edx_267;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_3 stackArg4 = <invalid>;
				word32 edx_970;
				Eq_3 eax_282 = fn00726150(stackArg4, dwArg04, out edx_970);
				if (eax_282 != 0x00)
				{
					Eq_3 ecx_292 = **((word32) dwArg04 + 24);
					esp_221->t0000 = eax_282;
					esp_221->tFFFFFFFC = ecx_292;
					esp_221->dw001C = 0x00;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_3 stackArg4 = <invalid>;
					ui32 edi_298 = 0x03;
					word32 edx_974;
					Eq_3 ecx_300;
					Eq_3 eax_301 = fn007475E0(stackArg4, out ecx_300, out edx_974);
					if (eax_301 <= 0x05)
					{
						switch ((word32) eax_301)
						{
						case 0x01:
							ecx_300 = *((word32) dwArg04 + 24);
							if (*((word32) *ecx_300 + 28) == 0x00)
								edi_298 = 0x00;
							break;
						case 0x02:
							goto l0072C6DE;
						case 0x03:
							struct Eq_135126 * eax_316 = **((word32) dwArg04 + 24);
							if (eax_316->dw001C == 0x00 && eax_316->dw0020 == 0x00)
							{
l0072C6DE:
								edi_298 = 0x01;
							}
							break;
						case 0x04:
							edi_298 = 0x02;
							break;
						case 0x05:
							edi_298 = 0x02;
							break;
						}
					}
					word32 eax_346;
					(*((const char *) g_a72C9D0 + edi_298 * 0x04))();
					return eax_346;
				}
			}
			struct Eq_135016 * eax_367 = esp_184->ptr0010;
			word32 v20_368 = eax_367->dw0000 + ~0x00;
			eax_367->dw0000 = v20_368;
			if (v20_368 == 0x00)
			{
				struct Eq_135231 * ecx_372 = eax_367->ptr0004;
				<anonymous> * edx_373 = ecx_372->ptr0018;
				esp_184->ptrFFFFFFFC = eax_367;
				edx_373();
				fn00727290(dwArg04);
				return 0x00;
			}
			goto l0072C9AD;
		}
	}
l0072C9AD:
	fn00727290(dwArg04);
	return 0x00;
}

<anonymous> * g_a72C9D0[] = // 0072C9D0
	{
	};
<anonymous> * g_a72C9F4[] = // 0072C9F4
	{
	};
// 0072CA10: Register Eq_3 fn0072CA10(Register Eq_3 eax, Stack Eq_3 dwArg04)
// Called from:
//      fn0072D920
Eq_3 fn0072CA10(Eq_3 eax, Eq_3 dwArg04)
{
	int32 dwLoc04_363;
	Eq_3 eax_17 = *((word32) dwArg04 + 8);
	int32 ebp_18 = 0x00;
	if (eax_17 == 0x00)
		dwLoc04_363 = 0x00;
	else
		dwLoc04_363 = (int32) *eax_17;
	Eq_3 eax_26 = *((word32) dwArg04 + 4);
	word32 dwLoc08_365 = 0x00;
	if (eax_26 != 0x00)
	{
		Eq_3 eax_39 = fn0072B360(eax, eax_26);
		if (eax_39 == 0x00)
			return eax_39;
		dwLoc08_365 = 0x01;
	}
	if (dwLoc04_363 > 0x00)
	{
		do
		{
			if (dwLoc08_365 != 0x00)
			{
				word32 ecx_493;
				int32 eax_119 = fn00727420(*((word32) *((word32) eax + 24) + 40), out ecx_493);
				if (eax_119 < 0x00)
					return 0x00;
				Eq_3 eax_130 = *((word32) *((word32) *((word32) eax + 24) + 40) + 0x0C);
				*((word32) eax_130 + eax_119 * 0x14) &= ~0x04;
				(word32) eax_130 + eax_119 * 0x14 + 0x04 = (ptr32) 0x04;
				Eq_3 eax_138 = *((word32) eax + 24);
				if (*((word32) eax_138 + 220) == 0x00)
				{
					*((word32) eax_138 + 220) = 0x01;
					Eq_3 eax_143 = *((word32) eax + 24);
					*((word32) *((word32) *((word32) eax_143 + 40) + 0x0C) + (eax_119 * 0x14 + 16)) = *((word32) eax_143 + 0x00D8);
				}
				if (fn0072B360(eax, dwArg04) == 0x00)
					return 0x00;
				word32 ecx_496;
				int32 eax_172 = fn00727420(*((word32) *((word32) eax + 24) + 40), out ecx_496);
				if (eax_172 < 0x00)
					return 0x00;
				Eq_3 eax_183 = *((word32) *((word32) *((word32) eax + 24) + 40) + 0x0C);
				*((word32) eax_183 + eax_172 * 0x14) &= ~0x04;
				(word32) eax_183 + eax_172 * 0x14 + 0x04 = (ptr32) 0x02;
				Eq_3 edx_191 = *((word32) eax + 24);
				if (*((word32) edx_191 + 220) == 0x00)
				{
					*((word32) edx_191 + 220) = 0x01;
					Eq_3 eax_196 = *((word32) eax + 24);
					*((word32) *((word32) *((word32) eax_196 + 40) + 0x0C) + (eax_172 * 0x14 + 16)) = *((word32) eax_196 + 0x00D8);
				}
				if (fn00727670(eax, 0x49) == 0x00)
					return 0x00;
			}
			else
			{
				if (fn0072B360(eax, dwArg04) == 0x00)
					return 0x00;
				word32 ecx_498;
				int32 eax_87 = fn00727420(*((word32) *((word32) eax + 24) + 40), out ecx_498);
				if (eax_87 < 0x00)
					return 0x00;
				Eq_3 eax_98 = *((word32) *((word32) *((word32) eax + 24) + 40) + 0x0C);
				*((word32) eax_98 + eax_87 * 0x14) &= ~0x04;
				(word32) eax_98 + eax_87 * 0x14 + 0x04 = (ptr32) 0x47;
				Eq_3 edx_106 = *((word32) eax + 24);
				if (*((word32) edx_106 + 220) == 0x00)
				{
					*((word32) edx_106 + 220) = 0x01;
					Eq_3 eax_111 = *((word32) eax + 24);
					*((word32) *((word32) *((word32) eax_111 + 40) + 0x0C) + (eax_87 * 0x14 + 16)) = *((word32) eax_111 + 0x00D8);
				}
			}
			++ebp_18;
		} while (ebp_18 < dwLoc04_363);
	}
	int32 ecx_258;
	struct Eq_135451 * eax_259;
	if (*((word32) dwArg04 + 0x0C) != 0x00)
	{
		if (dwLoc08_365 != 0x00)
		{
			word32 ecx_495;
			int32 eax_290 = fn00727420(*((word32) *((word32) eax + 24) + 40), out ecx_495);
			if (eax_290 < 0x00)
				return 0x00;
			eax_259 = (word32) *((word32) *((word32) *((word32) eax + 24) + 40) + 0x0C) + eax_290 * 0x14;
			eax_259->b0004 = 0x4A;
			ecx_258 = eax_290 * 0x14;
		}
		else
		{
			word32 ecx_494;
			int32 eax_267 = fn00727420(*((word32) *((word32) eax + 24) + 40), out ecx_494);
			if (eax_267 < 0x00)
				return 0x00;
			eax_259 = (word32) *((word32) *((word32) *((word32) eax + 24) + 40) + 0x0C) + eax_267 * 0x14;
			eax_259->b0004 = 0x48;
			ecx_258 = eax_267 * 0x14;
		}
	}
	else
	{
		if (dwLoc08_365 == 0x00)
			return 0x01;
		word32 ecx_497;
		int32 eax_245 = fn00727420(*((word32) *((word32) eax + 24) + 40), out ecx_497);
		if (eax_245 < 0x00)
			return 0x00;
		eax_259 = (word32) *((word32) *((word32) *((word32) eax + 24) + 40) + 0x0C) + eax_245 * 0x14;
		eax_259->b0004 = 0x01;
		ecx_258 = eax_245 * 0x14;
	}
	eax_259->dw0000 &= ~0x04;
	Eq_3 edx_313 = *((word32) eax + 24);
	if (*((word32) edx_313 + 220) == 0x00)
	{
		*((word32) edx_313 + 220) = 0x01;
		Eq_3 edi_318 = *((word32) eax + 24);
		(word32) *((word32) *((word32) edi_318 + 40) + 0x0C) + 16 + ecx_258 = (union Eq_3 *) *((word32) edi_318 + 0x00D8);
	}
	return 0x01;
}

// 0072CC90: Register word32 fn0072CC90(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08)
// Called from:
//      fn0072D920
word32 fn0072CC90(Eq_3 dwArg04, Eq_3 dwArg08)
{
	Eq_3 esi_17 = *((word32) dwArg04 + 24);
	word32 ecx_620;
	word32 edx_621;
	Eq_3 eax_20 = fn00723860(0x20, out ecx_620, out edx_621);
	if (eax_20 != 0x00)
	{
		eax_20->u0 = 0x00;
		*((word32) eax_20 + 4) = 0x00;
		((word32) eax_20 + 8)->u0 = 0x00;
		((word32) eax_20 + 0x0C)->u0 = 0x00;
		((word32) eax_20 + 16)->u0 = 0x00;
		((word32) eax_20 + 20)->u0 = 0x00;
		((word32) eax_20 + 24)->u0 = 0x00;
		((word32) eax_20 + 28)->u0 = 0x00;
		*eax_20 = *((word32) esi_17 + 36);
		*((word32) esi_17 + 36) = eax_20;
		Eq_3 edi_50 = *((word32) dwArg04 + 24);
		word32 edx_623;
		word32 ecx_622;
		Eq_3 eax_53 = fn00723860(0x20, out ecx_622, out edx_623);
		if (eax_53 != 0x00)
		{
			eax_53->u0 = 0x00;
			*((word32) eax_53 + 4) = 0x00;
			((word32) eax_53 + 8)->u0 = 0x00;
			((word32) eax_53 + 0x0C)->u0 = 0x00;
			((word32) eax_53 + 16)->u0 = 0x00;
			((word32) eax_53 + 20)->u0 = 0x00;
			((word32) eax_53 + 24)->u0 = 0x00;
			((word32) eax_53 + 28)->u0 = 0x00;
			*eax_53 = *((word32) edi_50 + 36);
			*((word32) edi_50 + 36) = eax_53;
			word32 eax_81 = fn007282B0(*((word32) dwArg08 + 4));
			if (eax_81 == 0x00)
			{
				Eq_3 eax_330 = *((word32) dwArg08 + 0x0C);
				if (eax_330 != 0x00)
				{
					Eq_3 edi_335 = 0x00;
					while (true)
					{
						Eq_3 eax_339 = eax_330;
						if (eax_330 != 0x00)
							eax_339 = *eax_330;
						if (edi_335 >= eax_339)
							break;
						if (fn0072D920(dwArg04, eax_330) == 0x00)
							return 0x00;
						edi_335 = (word32) edi_335 + 1;
					}
				}
			}
			else if (eax_81 == 0x01)
			{
				Eq_3 ebp_276 = *((word32) dwArg08 + 8);
				int32 edi_277 = 0x00;
				while (true)
				{
					int32 eax_287;
					if (ebp_276 == 0x00)
						eax_287 = 0x00;
					else
						eax_287 = (int32) *ebp_276;
					if (edi_277 >= eax_287)
						break;
					if (fn0072D920(dwArg04, dwArg04) == 0x00)
						return 0x00;
					++edi_277;
				}
			}
			else
			{
				if (fn0072B360(dwArg04, *((word32) dwArg08 + 4)) == 0x00 || (fn00727880(dwArg04, 111, dwArg04, dwArg08) == 0x00 || fn00727670(dwArg04, 0x01) == 0x00))
					return 0x00;
				Eq_3 ebp_136 = *((word32) dwArg08 + 8);
				int32 ebx_137 = 0x00;
				while (true)
				{
					int32 eax_146;
					if (ebp_136 == 0x00)
						eax_146 = 0x00;
					else
						eax_146 = (int32) *ebp_136;
					if (ebx_137 >= eax_146)
						break;
					if (fn0072D920(dwArg04, dwArg04) == 0x00)
						return 0x00;
					++ebx_137;
				}
				if (fn00727880(dwArg04, 110, dwArg04, dwArg08) == 0x00)
					return 0x00;
				*((word32) *((word32) *((word32) dwArg04 + 24) + 40) + 16) = eax_53;
				*((word32) *((word32) dwArg04 + 24) + 40) = eax_53;
				if (fn00727670(dwArg04, 0x01) == 0x00)
					return 0x00;
				Eq_3 ebx_201 = *((word32) dwArg08 + 0x0C);
				if (ebx_201 != 0x00)
				{
					int32 edi_205 = 0x00;
					while (true)
					{
						int32 eax_214;
						if (ebx_201 == 0x00)
							eax_214 = 0x00;
						else
							eax_214 = (int32) *ebx_201;
						if (edi_205 >= eax_214)
							break;
						if (fn0072D920(dwArg04, dwArg04) == 0x00)
							return 0x00;
						++edi_205;
					}
				}
			}
			*((word32) *((word32) *((word32) dwArg04 + 24) + 40) + 16) = eax_20;
			*((word32) *((word32) dwArg04 + 24) + 40) = eax_20;
			return 0x01;
		}
		else
		{
			word32 ecx_626;
			word32 edx_627;
			fn006E1210(out ecx_626, out edx_627);
			return 0x00;
		}
	}
	else
	{
		word32 edx_625;
		word32 ecx_624;
		fn006E1210(out ecx_624, out edx_625);
		return 0x00;
	}
}

// 0072CEE0: Register word32 fn0072CEE0(Register Eq_3 esi, Stack Eq_3 dwArg04)
// Called from:
//      fn0072D920
word32 fn0072CEE0(Eq_3 esi, Eq_3 dwArg04)
{
	Eq_3 dwLoc08_427;
	Eq_3 ebp_42;
	Eq_3 edi_13 = *((word32) esi + 24);
	word32 edx_558;
	word32 ecx_557;
	Eq_3 eax_16 = fn00723860(0x20, out ecx_557, out edx_558);
	if (eax_16 == 0x00)
	{
		word32 edx_560;
		word32 ecx_559;
		fn006E1210(out ecx_559, out edx_560);
		ebp_42.u0 = 0x00;
		dwLoc08_427.u0 = 0x00;
	}
	else
	{
		eax_16->u0 = 0x00;
		*((word32) eax_16 + 4) = 0x00;
		((word32) eax_16 + 8)->u0 = 0x00;
		((word32) eax_16 + 0x0C)->u0 = 0x00;
		((word32) eax_16 + 16)->u0 = 0x00;
		((word32) eax_16 + 20)->u0 = 0x00;
		((word32) eax_16 + 24)->u0 = 0x00;
		((word32) eax_16 + 28)->u0 = 0x00;
		*eax_16 = *((word32) edi_13 + 36);
		*((word32) edi_13 + 36) = eax_16;
		dwLoc08_427 = eax_16;
		ebp_42 = eax_16;
	}
	Eq_3 dwLoc0C_465;
	Eq_3 edi_55 = *((word32) esi + 24);
	word32 edx_562;
	word32 ecx_561;
	Eq_3 eax_59 = fn00723860(0x20, out ecx_561, out edx_562);
	if (eax_59 == 0x00)
	{
		word32 edx_564;
		word32 ecx_563;
		fn006E1210(out ecx_563, out edx_564);
		dwLoc0C_465.u0 = 0x00;
	}
	else
	{
		eax_59->u0 = 0x00;
		*((word32) eax_59 + 4) = 0x00;
		((word32) eax_59 + 8)->u0 = 0x00;
		((word32) eax_59 + 0x0C)->u0 = 0x00;
		((word32) eax_59 + 16)->u0 = 0x00;
		((word32) eax_59 + 20)->u0 = 0x00;
		((word32) eax_59 + 24)->u0 = 0x00;
		((word32) eax_59 + 28)->u0 = 0x00;
		*eax_59 = *((word32) edi_55 + 36);
		*((word32) edi_55 + 36) = eax_59;
		dwLoc0C_465 = eax_59;
	}
	Eq_3 edi_96 = *((word32) esi + 24);
	word32 edx_566;
	word32 ecx_565;
	Eq_3 eax_100 = fn00723860(0x20, out ecx_565, out edx_566);
	if (eax_100 == 0x00)
	{
		word32 ecx_567;
		word32 edx_568;
		fn006E1210(out ecx_567, out edx_568);
		eax_100.u0 = 0x00;
	}
	else
	{
		eax_100->u0 = 0x00;
		*((word32) eax_100 + 4) = 0x00;
		((word32) eax_100 + 8)->u0 = 0x00;
		((word32) eax_100 + 0x0C)->u0 = 0x00;
		((word32) eax_100 + 16)->u0 = 0x00;
		((word32) eax_100 + 20)->u0 = 0x00;
		((word32) eax_100 + 24)->u0 = 0x00;
		((word32) eax_100 + 28)->u0 = 0x00;
		*eax_100 = *((word32) edi_96 + 36);
		*((word32) edi_96 + 36) = eax_100;
	}
	if (ebp_42 == 0x00 || (eax_100 == 0x00 || (dwLoc0C_465 == 0x00 || (fn00727880(esi, 0x78, eax_100, 0x00) == 0x00 || (fn00728310(esi, 0x00, ebp_42) == 0x00 || fn0072B360(esi, *((word32) dwArg04 + 8)) == 0x00)))))
		return 0x00;
	if (fn00727670(esi, 0x44) == 0x00)
		return 0x00;
	*((word32) *((word32) *((word32) esi + 24) + 40) + 16) = ebp_42;
	*((word32) *((word32) esi + 24) + 40) = ebp_42;
	*((word32) *((word32) esi + 24) + 220) = 0x00;
	if (fn00727880(esi, 0x5D, dwLoc0C_465, 0x00) == 0x00 || fn0072B360(esi, *((word32) dwArg04 + 4)) == 0x00)
		return 0x00;
	Eq_3 ebp_256 = *((word32) dwArg04 + 0x0C);
	int32 ebx_257 = 0x00;
	word32 * edi_260 = (word32) ebp_256 + 4;
	while (true)
	{
		int32 eax_266;
		if (ebp_256 == 0x00)
			eax_266 = 0x00;
		else
			eax_266 = (int32) *ebp_256;
		if (ebx_257 >= eax_266)
			break;
		if (fn0072D920(esi, *edi_260) == 0x00)
			return 0x00;
		++ebx_257;
		++edi_260;
	}
	if (fn00727880(esi, 113, dwLoc08_427, 0x01) == 0x00)
		return 0x00;
	*((word32) *((word32) *((word32) esi + 24) + 40) + 16) = dwLoc0C_465;
	*((word32) *((word32) esi + 24) + 40) = dwLoc0C_465;
	if (fn00727670(esi, 0x57) == 0x00)
		return 0x00;
	Eq_3 eax_320 = *((word32) esi + 24);
	*((word32) eax_320 + 48) = (word32) *((word32) eax_320 + 48) - 1;
	Eq_3 ebx_324 = *((word32) dwArg04 + 16);
	int32 ebp_325 = 0x00;
	word32 * edi_328 = (word32) ebx_324 + 4;
	while (true)
	{
		int32 eax_334;
		if (ebx_324 == 0x00)
			eax_334 = 0x00;
		else
			eax_334 = (int32) *ebx_324;
		if (ebp_325 >= eax_334)
			break;
		if (fn0072D920(esi, *edi_328) == 0x00)
			return 0x00;
		++ebp_325;
		++edi_328;
	}
	*((word32) *((word32) *((word32) esi + 24) + 40) + 16) = eax_100;
	*((word32) *((word32) esi + 24) + 40) = eax_100;
	return 0x01;
}

// 0072D130: Register word32 fn0072D130(Register Eq_3 esi, Stack Eq_3 dwArg04)
// Called from:
//      fn0072D920
word32 fn0072D130(Eq_3 esi, Eq_3 dwArg04)
{
	int32 ebp_16 = 0x00;
	Eq_3 dwLoc10_488 = 0x00;
	word32 eax_20 = fn007282B0(*((word32) dwArg04 + 4));
	if (eax_20 != 0x00)
	{
		Eq_3 dwLoc14_491;
		Eq_3 edi_32 = *((word32) esi + 24);
		word32 ecx_676;
		word32 edx_677;
		Eq_3 eax_35 = fn00723860(0x20, out ecx_676, out edx_677);
		if (eax_35 == 0x00)
		{
			word32 edx_679;
			word32 ecx_678;
			fn006E1210(out ecx_678, out edx_679);
			dwLoc14_491.u0 = 0x00;
		}
		else
		{
			eax_35->u0 = 0x00;
			*((word32) eax_35 + 4) = 0x00;
			((word32) eax_35 + 8)->u0 = 0x00;
			((word32) eax_35 + 0x0C)->u0 = 0x00;
			((word32) eax_35 + 16)->u0 = 0x00;
			((word32) eax_35 + 20)->u0 = 0x00;
			((word32) eax_35 + 24)->u0 = 0x00;
			((word32) eax_35 + 28)->u0 = 0x00;
			*eax_35 = *((word32) edi_32 + 36);
			*((word32) edi_32 + 36) = eax_35;
			dwLoc14_491 = eax_35;
		}
		Eq_3 dwLoc0C_543;
		Eq_3 edi_108;
		Eq_3 edi_69 = *((word32) esi + 24);
		word32 edx_681;
		word32 ecx_680;
		Eq_3 eax_73 = fn00723860(0x20, out ecx_680, out edx_681);
		if (eax_73 == 0x00)
		{
			word32 ecx_682;
			word32 edx_683;
			fn006E1210(out ecx_682, out edx_683);
			edi_108.u0 = 0x00;
			dwLoc0C_543.u0 = 0x00;
		}
		else
		{
			eax_73->u0 = 0x00;
			*((word32) eax_73 + 4) = 0x00;
			((word32) eax_73 + 8)->u0 = 0x00;
			((word32) eax_73 + 0x0C)->u0 = 0x00;
			((word32) eax_73 + 16)->u0 = 0x00;
			((word32) eax_73 + 20)->u0 = 0x00;
			((word32) eax_73 + 24)->u0 = 0x00;
			((word32) eax_73 + 28)->u0 = 0x00;
			*eax_73 = *((word32) edi_69 + 36);
			*((word32) edi_69 + 36) = eax_73;
			dwLoc0C_543 = eax_73;
			edi_108 = eax_73;
		}
		if (eax_20 == ~0x00)
		{
			Eq_3 eax_123 = fn00727340(esi);
			dwLoc10_488 = eax_123;
			if (eax_123 == 0x00)
				return 0x00;
		}
		if (dwLoc14_491 == 0x00 || edi_108 == 0x00)
			return 0x00;
		Eq_3 dwLoc04_553;
		if (*((word32) dwArg04 + 0x0C) != 0x00)
		{
			Eq_3 eax_148 = fn00727340(esi);
			dwLoc04_553 = eax_148;
			if (eax_148 == 0x00)
				return 0x00;
		}
		else
			dwLoc04_553.u0 = 0x00;
		if (fn00727880(esi, 0x78, dwArg04, 0x00) == 0x00)
			return 0x00;
		*((word32) *((word32) *((word32) esi + 24) + 40) + 16) = dwLoc14_491;
		*((word32) *((word32) esi + 24) + 40) = dwLoc14_491;
		if (fn00728310(esi, 0x00, dwArg04) == 0x00)
			return 0x00;
		if (eax_20 == ~0x00)
		{
			*((word32) *((word32) esi + 24) + 220) = 0x00;
			if (fn0072B360(esi, dwArg04) == 0x00 || (fn00727880(esi, 111, dwArg04, 0x00) == 0x00 || fn00727670(esi, 0x01) == 0x00))
				return 0x00;
		}
		Eq_3 ebp_250 = *((word32) dwArg04 + 8);
		int32 ebx_251 = 0x00;
		while (true)
		{
			int32 eax_260;
			if (ebp_250 == 0x00)
				eax_260 = 0x00;
			else
				eax_260 = (int32) *ebp_250;
			if (ebx_251 >= eax_260)
				break;
			if (fn0072D920(esi, dwArg04) == 0x00)
				return 0x00;
			++ebx_251;
		}
		if (fn00727880(esi, 113, dwArg04, 0x01) == 0x00)
			return 0x00;
		if (eax_20 == ~0x00)
		{
			*((word32) *((word32) *((word32) esi + 24) + 40) + 16) = dwLoc10_488;
			*((word32) *((word32) esi + 24) + 40) = dwLoc10_488;
			if (fn00727670(esi, 0x01) == 0x00 || fn00727670(esi, 0x57) == 0x00)
				return 0x00;
		}
		Eq_3 eax_330 = *((word32) esi + 24);
		*((word32) eax_330 + 48) = (word32) *((word32) eax_330 + 48) - 1;
		if (dwLoc04_553 != 0x00)
		{
			Eq_3 ebp_338 = *((word32) dwArg04 + 0x0C);
			int32 ebx_339 = 0x00;
			while (true)
			{
				int32 eax_348;
				if (ebp_338 == 0x00)
					eax_348 = 0x00;
				else
					eax_348 = (int32) *ebp_338;
				if (ebx_339 >= eax_348)
					break;
				if (fn0072D920(esi, dwArg04) == 0x00)
					return 0x00;
				++ebx_339;
			}
		}
		*((word32) *((word32) *((word32) esi + 24) + 40) + 16) = dwLoc0C_543;
		*((word32) *((word32) esi + 24) + 40) = dwLoc0C_543;
		return 0x01;
	}
	else
	{
		Eq_3 ebx_412 = *((word32) dwArg04 + 0x0C);
		if (ebx_412 != 0x00)
		{
			while (true)
			{
				int32 eax_421;
				if (ebx_412 == 0x00)
					eax_421 = 0x00;
				else
					eax_421 = (int32) *ebx_412;
				if (ebp_16 >= eax_421)
					break;
				if (fn0072D920(esi, dwArg04) == 0x00)
					return 0x00;
				++ebp_16;
			}
		}
		return 0x01;
	}
}

// 0072D3D0: Register Eq_3 fn0072D3D0(Register Eq_3 esi, Stack Eq_3 dwArg04)
// Called from:
//      fn0072D920
Eq_3 fn0072D3D0(Eq_3 esi, Eq_3 dwArg04)
{
	Eq_3 ebx_44;
	Eq_3 edi_16 = *((word32) esi + 24);
	word32 edx_984;
	word32 ecx_983;
	Eq_3 eax_19 = fn00723860(0x20, out ecx_983, out edx_984);
	if (eax_19 == 0x00)
	{
		word32 edx_986;
		word32 ecx_985;
		fn006E1210(out ecx_985, out edx_986);
		ebx_44.u0 = 0x00;
	}
	else
	{
		eax_19->u0 = 0x00;
		*((word32) eax_19 + 4) = 0x00;
		((word32) eax_19 + 8)->u0 = 0x00;
		((word32) eax_19 + 0x0C)->u0 = 0x00;
		((word32) eax_19 + 16)->u0 = 0x00;
		((word32) eax_19 + 20)->u0 = 0x00;
		((word32) eax_19 + 24)->u0 = 0x00;
		((word32) eax_19 + 28)->u0 = 0x00;
		*eax_19 = *((word32) edi_16 + 36);
		*((word32) edi_16 + 36) = eax_19;
		ebx_44 = eax_19;
	}
	Eq_3 dwLoc18_766;
	Eq_3 ebp_133;
	Eq_3 edi_56 = *((word32) esi + 24);
	word32 edx_988;
	word32 ecx_987;
	Eq_3 eax_60 = fn00723860(0x20, out ecx_987, out edx_988);
	if (eax_60 == 0x00)
	{
		word32 edx_990;
		word32 ecx_989;
		fn006E1210(out ecx_989, out edx_990);
		ebp_133.u0 = 0x00;
		dwLoc18_766.u0 = 0x00;
	}
	else
	{
		eax_60->u0 = 0x00;
		*((word32) eax_60 + 4) = 0x00;
		((word32) eax_60 + 8)->u0 = 0x00;
		((word32) eax_60 + 0x0C)->u0 = 0x00;
		((word32) eax_60 + 16)->u0 = 0x00;
		((word32) eax_60 + 20)->u0 = 0x00;
		((word32) eax_60 + 24)->u0 = 0x00;
		((word32) eax_60 + 28)->u0 = 0x00;
		*eax_60 = *((word32) edi_56 + 36);
		*((word32) edi_56 + 36) = eax_60;
		dwLoc18_766 = eax_60;
		ebp_133 = eax_60;
	}
	Eq_3 dwLoc10_771;
	Eq_3 edi_102 = *((word32) esi + 24);
	word32 edx_992;
	word32 ecx_991;
	Eq_3 eax_106 = fn00723860(0x20, out ecx_991, out edx_992);
	if (eax_106 == 0x00)
	{
		word32 ecx_993;
		word32 edx_994;
		fn006E1210(out ecx_993, out edx_994);
		dwLoc10_771.u0 = 0x00;
	}
	else
	{
		eax_106->u0 = 0x00;
		*((word32) eax_106 + 4) = 0x00;
		((word32) eax_106 + 8)->u0 = 0x00;
		((word32) eax_106 + 0x0C)->u0 = 0x00;
		((word32) eax_106 + 16)->u0 = 0x00;
		((word32) eax_106 + 20)->u0 = 0x00;
		((word32) eax_106 + 24)->u0 = 0x00;
		((word32) eax_106 + 28)->u0 = 0x00;
		*eax_106 = *((word32) edi_102 + 36);
		*((word32) edi_102 + 36) = eax_106;
		dwLoc10_771 = eax_106;
	}
	Eq_3 dwLoc0C_776;
	Eq_3 edi_144 = *((word32) esi + 24);
	word32 ecx_995;
	word32 edx_996;
	Eq_3 eax_148 = fn00723860(0x20, out ecx_995, out edx_996);
	if (eax_148 == 0x00)
	{
		word32 ecx_997;
		word32 edx_998;
		fn006E1210(out ecx_997, out edx_998);
		dwLoc0C_776.u0 = 0x00;
	}
	else
	{
		eax_148->u0 = 0x00;
		*((word32) eax_148 + 4) = 0x00;
		((word32) eax_148 + 8)->u0 = 0x00;
		((word32) eax_148 + 0x0C)->u0 = 0x00;
		((word32) eax_148 + 16)->u0 = 0x00;
		((word32) eax_148 + 20)->u0 = 0x00;
		((word32) eax_148 + 24)->u0 = 0x00;
		((word32) eax_148 + 28)->u0 = 0x00;
		*eax_148 = *((word32) edi_144 + 36);
		*((word32) edi_144 + 36) = eax_148;
		dwLoc0C_776 = eax_148;
	}
	if (ebx_44 == 0x00 || (ebp_133 == 0x00 || (dwLoc10_771 == 0x00 || (dwLoc0C_776 == 0x00 || fn00727880(esi, 121, ebp_133, 0x00) == 0x00))))
		return 0x00;
	*((word32) *((word32) *((word32) esi + 24) + 40) + 16) = ebx_44;
	*((word32) *((word32) esi + 24) + 40) = ebx_44;
	if (fn00728310(esi, 0x01, ebx_44) == 0x00)
		return 0x00;
	int32 * ebp_239 = *((word32) dwArg04 + 4);
	int32 ebx_240 = 0x00;
	word32 * edi_243 = ebp_239 + 1;
	while (true)
	{
		int32 eax_249;
		if (ebp_239 == null)
			eax_249 = 0x00;
		else
			eax_249 = *ebp_239;
		if (ebx_240 >= eax_249)
			break;
		if (fn0072D920(esi, *edi_243) == 0x00)
			return 0x00;
		++ebx_240;
		++edi_243;
	}
	if (fn00727670(esi, 0x57) == 0x00)
		return 0x00;
	Eq_3 eax_279 = *((word32) esi + 24);
	*((word32) eax_279 + 48) = (word32) *((word32) eax_279 + 48) - 1;
	if (fn00727880(esi, 110, dwLoc10_771, 0x00) == 0x00)
		return 0x00;
	Eq_3 dwLoc14_808;
	Eq_3 eax_302 = *((word32) dwArg04 + 8);
	if (eax_302 == 0x00)
		dwLoc14_808 = eax_302;
	else
		dwLoc14_808 = *eax_302;
	*((word32) *((word32) *((word32) esi + 24) + 40) + 16) = dwLoc18_766;
	*((word32) *((word32) esi + 24) + 40) = dwLoc18_766;
	Eq_137163 eax_318 = 0x00;
	Eq_137163 dwLoc08_814 = 0x01;
	if (dwLoc14_808 > 0x00)
	{
		while (true)
		{
			struct Eq_137169 * edi_327 = *((word32) *((word32) dwArg04 + 8) + (eax_318 * 0x04 + 4));
			if (edi_327->t0000 == 0x00 && eax_318 < dwLoc14_808 + ~0x00)
				break;
			*((word32) *((word32) esi + 24) + 220) = 0x00;
			*((word32) *((word32) esi + 24) + 0x00D8) = edi_327->t000C;
			Eq_3 eax_369 = fn00727340(esi);
			if (eax_369 == 0x00)
				return 0x00;
			if (edi_327->t0000 != 0x00)
			{
				if (fn00727670(esi, 0x04) == 0x00 || fn0072B360(esi, edi_327->t0000) == 0x00)
					return 0x00;
				word32 ecx_999;
				if (fn00727810(esi, 0x6A, 0x0A, out ecx_999) == 0x00 || (fn00727880(esi, 111, eax_369, 0x00) == 0x00 || fn00727670(esi, 0x01) == 0x00))
					return 0x00;
			}
			if (fn00727670(esi, 0x01) == 0x00)
				return 0x00;
			Eq_3 eax_473;
			Eq_3 eax_467 = edi_327->t0004;
			if (eax_467 != 0x00)
				eax_473 = fn0072B360(esi, eax_467);
			else
				eax_473 = fn00727670(esi, 0x01);
			if (eax_473 == 0x00 || fn00727670(esi, 0x01) == 0x00)
				return 0x00;
			int32 * ebp_511 = edi_327->ptr0008;
			word32 * edi_515 = ebp_511 + 1;
			int32 ebx_516 = 0x00;
			while (true)
			{
				int32 eax_522;
				if (ebp_511 == null)
					eax_522 = 0x00;
				else
					eax_522 = *ebp_511;
				if (ebx_516 >= eax_522)
					break;
				if (fn0072D920(esi, *edi_515) == 0x00)
					return 0x00;
				++ebx_516;
				++edi_515;
			}
			if (fn00727880(esi, 110, dwLoc0C_776, 0x00) == 0x00)
				return 0x00;
			*((word32) *((word32) *((word32) esi + 24) + 40) + 16) = eax_369;
			*((word32) *((word32) esi + 24) + 40) = eax_369;
			if (edi_327->t0000 != 0x00 && fn00727670(esi, 0x01) == 0x00)
				return 0x00;
			dwLoc08_814 = (word32) dwLoc08_814 + 1;
			if (dwLoc08_814 >= dwLoc14_808)
				goto l0072D5E7;
			eax_318 = dwLoc08_814;
		}
		return fn00728360(eax, 0x008DAA2C);
	}
	else
	{
l0072D5E7:
		if (fn00727670(esi, 88) == 0x00)
			return 0x00;
		*((word32) *((word32) *((word32) esi + 24) + 40) + 16) = dwLoc10_771;
		*((word32) *((word32) esi + 24) + 40) = dwLoc10_771;
		Eq_3 ebx_635 = *((word32) dwArg04 + 0x0C);
		int32 ebp_636 = 0x00;
		word32 * edi_639 = (word32) ebx_635 + 4;
		while (true)
		{
			int32 eax_645;
			if (ebx_635 == 0x00)
				eax_645 = 0x00;
			else
				eax_645 = (int32) *ebx_635;
			if (ebp_636 >= eax_645)
				break;
			if (fn0072D920(esi, *edi_639) == 0x00)
				return 0x00;
			++ebp_636;
			++edi_639;
		}
		*((word32) *((word32) *((word32) esi + 24) + 40) + 16) = dwLoc0C_776;
		*((word32) *((word32) esi + 24) + 40) = dwLoc0C_776;
		return 0x01;
	}
}

// 0072D830: Register Eq_137398 fn0072D830(Register Eq_3 esi, Stack Eq_3 dwArg04)
// Called from:
//      fn0072D920
Eq_137398 fn0072D830(Eq_3 esi, Eq_3 dwArg04)
{
	if (g_dwA6DBF4 != 0x00)
		return 0x01;
	if (g_tA6DBF8 == 0x00)
	{
		word32 edx_298;
		word32 ecx_297;
		Eq_3 eax_16 = fn006ECAC0(0x008D33B8, out ecx_297, out edx_298);
		g_tA6DBF8 = eax_16;
		if (eax_16 == 0x00)
			return 0x00;
	}
	if (fn0072B360(esi, dwArg04) == 0x00)
		return 0x00;
	Eq_3 eax_53 = fn00727340(esi);
	if (eax_53 == 0x00 || fn00727880(esi, 0x70, dwArg04, 0x00) == 0x00)
		return 0x00;
	if (fn00727670(esi, 0x01) == 0x00 || (fn00728FB0() == 0x00 || *((word32) dwArg04 + 8) != 0x00 && fn0072B360(esi, dwArg04) == 0x00))
		return 0x00;
	word32 ecx_299;
	if (fn00727810(esi, 0x82, dwArg04, out ecx_299) == 0x00)
		return 0x00;
	*((word32) *((word32) *((word32) esi + 24) + 40) + 16) = eax_53;
	*((word32) *((word32) esi + 24) + 40) = eax_53;
	return fn00727670(esi, 0x01) == 0x00;
}

// 0072D920: Register Eq_3 fn0072D920(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08)
// Called from:
//      fn00729300
//      fn0072BF10
//      fn0072C160
//      fn0072CC90
//      fn0072CEE0
//      fn0072D130
//      fn0072D3D0
//      fn0072DD60
//      fn0072E660
Eq_3 fn0072D920(Eq_3 dwArg04, Eq_3 dwArg08)
{
	*((word32) *((word32) dwArg04 + 24) + 0x00D8) = *((word32) dwArg08 + 20);
	*((word32) *((word32) dwArg04 + 24) + 220) = 0x00;
	Eq_3 edx_22 = 0x00;
	up32 eax_24 = *dwArg08;
	if (eax_24 > 0x17)
		return 0x01;
	Eq_3 ebx_191;
	switch (eax_24)
	{
	case 0x01:
		return fn0072C160(dwArg04, dwArg08);
	case 0x02:
		return fn0072C510(dwArg04, dwArg08);
	case 0x03:
		if (*((word32) **((word32) dwArg04 + 24) + 28) != 0x00)
			return fn00728360(dwArg04, 0x008DAA64);
		Eq_3 edi_813 = *((word32) dwArg08 + 4);
		if (edi_813 == 0x00)
		{
			if (fn00728FB0() == 0x00)
				return 0x00;
l0072D9C7:
			ebx_191.u0 = 0x53;
			goto l0072D9CC;
		}
		if (fn0072B360(dwArg04, edi_813) != 0x00)
			goto l0072D9C7;
		break;
	case 0x04:
		Eq_3 ebp_761 = *((word32) dwArg08 + 4);
		int32 edi_762 = 0x00;
		while (true)
		{
			int32 eax_772;
			if (ebp_761 == 0x00)
				eax_772 = 0x00;
			else
				eax_772 = (int32) *ebp_761;
			if (edi_762 >= eax_772)
				break;
			if (fn0072B360(dwArg04, dwArg04) == 0x00)
				return 0x00;
			++edi_762;
		}
		return 0x01;
	case 0x05:
		Eq_3 eax_680 = *((word32) dwArg08 + 4);
		if (eax_680 != 0x00)
			edx_22 = *eax_680;
		if (fn0072B360(dwArg04, *((word32) dwArg08 + 8)) != 0x00)
		{
			Eq_3 ebp_708 = 0x00;
			if (edx_22 > 0x00)
			{
				Eq_3 ebx_711 = edx_22;
				do
				{
					if (ebp_708 < ebx_711 - 0x01)
					{
						if (fn00727670(dwArg04, 0x04) == 0x00)
							return 0x00;
						ebx_711 = edx_22;
					}
					if (fn0072B360(dwArg04, edx_22) == 0x00)
						return 0x00;
					ebp_708 = (word32) ebp_708 + 1;
				} while (ebp_708 < ebx_711);
			}
			return 0x01;
		}
		break;
	case 0x06:
		return fn0072B830(dwArg08, dwArg04);
	case 0x07:
		return fn0072CA10(dwArg04, dwArg08);
	case 0x08:
		return fn0072CEE0(dwArg04, dwArg08);
	case 0x09:
		return fn0072D130(dwArg04, dwArg08);
	case 0x0A:
		return fn0072CC90(dwArg04, dwArg08);
	case 11:
		return fn0072DD60(dwArg04, dwArg08);
	case 0x0C:
		Eq_3 ecx_479 = *((word32) dwArg08 + 4);
		if (ecx_479 == 0x00 || fn0072B360(dwArg04, ecx_479) != 0x00 && (*((word32) dwArg08 + 8) == 0x00 || fn0072B360(dwArg04, dwArg04) != 0x00 && (*((word32) dwArg08 + 0x0C) == 0x00 || fn0072B360(dwArg04, dwArg04) != 0x00)))
		{
			word32 ecx_1383;
			Eq_3 eax_549 = fn00727810(dwArg04, 0x82, dwArg04, out ecx_1383);
			if (eax_549 != 0x00)
				return 0x01;
			return eax_549;
		}
		break;
	case 0x0D:
		return fn0072D3D0(dwArg04, dwArg08);
	case 0x0E:
		return fn00729300(dwArg04, dwArg08);
	case 0x0F:
		return fn0072D830(dwArg04, dwArg08);
	case 0x10:
		return fn0072A940(dwArg04, dwArg08);
	case 0x11:
		return fn0072AC20(dwArg04, dwArg08);
	case 0x12:
		if (fn0072B360(dwArg04, *((word32) dwArg08 + 4)) != 0x00)
		{
			if (*((word32) dwArg08 + 8) != 0x00)
			{
				if (fn0072B360(dwArg04, dwArg04) != 0x00)
				{
					if (*((word32) dwArg08 + 0x0C) != 0x00)
					{
						Eq_3 eax_367 = fn0072B360(dwArg04, dwArg04);
						if (eax_367 == 0x00)
							return eax_367;
					}
					else
					{
						Eq_3 eax_346 = fn00727670(dwArg04, 0x04);
						if (eax_346 == 0x00)
							return eax_346;
					}
l0072DC37:
					ebx_191.u0 = 0x55;
					goto l0072D9CC;
				}
			}
			else if (fn00728FB0() != 0x00 && fn00727670(dwArg04, 0x04) != 0x00)
				goto l0072DC37;
		}
		break;
	case 0x13:
	case 0x15:
		return 0x01;
	case 0x14:
		if (*((word32) dwArg04 + 16) != 0x00 && *((word32) dwArg04 + 20) <= 0x01)
		{
			if (fn0072B360(dwArg04, *((word32) dwArg08 + 4)) != 0x00)
			{
				ebx_191.u0 = 0x46;
				goto l0072D9CC;
			}
		}
		else
		{
			Eq_3 edi_235 = *((word32) dwArg08 + 4);
			word32 eax_236 = *edi_235;
			if (eax_236 == 0x0E || eax_236 == 0x0D)
				return 0x01;
			if (fn0072B360(dwArg04, edi_235) != 0x00)
			{
				ebx_191.u0 = 0x01;
l0072D9CC:
				if (fn00727670(dwArg04, ebx_191) != 0x00)
					return 0x01;
				return 0x00;
			}
		}
		break;
	case 22:
		Eq_3 edx_179 = *((word32) dwArg04 + 24);
		Eq_3 ecx_180 = *((word32) edx_179 + 48);
		Eq_3 eax_181 = 0x00;
		if (ecx_180 > 0x00)
		{
			struct Eq_137620 * edx_184 = (word32) edx_179 + 52;
			do
			{
				if (edx_184->dw0000 == 0x00)
				{
					ebx_191.u0 = 0x50;
					goto l0072D9CC;
				}
				eax_181 = (word32) eax_181 + 1;
				++edx_184;
			} while (eax_181 < ecx_180);
		}
		return fn00728360(dwArg04, 0x008DAA4C);
	case 0x17:
		Eq_3 edi_39 = *((word32) dwArg04 + 24);
		if (*((word32) edi_39 + 48) == 0x00)
			return fn00728360(eax, 9282972);
		Eq_3 ecx_43 = *((word32) edi_39 + 48);
		up32 edx_44 = *((word32) edi_39 + (ecx_43 * 0x08 + 44));
		if (edx_44 <= 0x03)
		{
			switch (edx_44)
			{
			case 0x00:
				break;
			case 0x01:
			case 0x02:
				int32 ecx_51 = ecx_43 - 0x02;
				if (ecx_43 >= 0x02)
				{
					struct Eq_137718 * edx_55 = (word32) edi_39 + 52 + (ecx_43 - 0x02) * 0x08;
					do
					{
						word32 esi_58 = edx_55->dw0000;
						if (esi_58 == 0x00)
							break;
						if (esi_58 == 0x03)
							return fn00728360(eax, 9283004);
						--ecx_51;
						edx_55 -= 0x08;
					} while (ecx_51 >= 0x00);
				}
				if (ecx_51 == ~0x00)
					return fn00728360(eax, 9282972);
				break;
			case 0x03:
				return fn00728360(eax, 9283004);
			}
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_125083 stackArg4 = <invalid>;
			Eq_3 stackArg8 = <invalid>;
			Eq_3 stackArg12 = <invalid>;
			Eq_3 eax_146 = fn00727880(eax, stackArg4, stackArg8, stackArg12);
			if (eax_146 == 0x00)
				return eax_146;
		}
		return 0x01;
	}
	return 0x00;
}

// 0072DD60: Register word32 fn0072DD60(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08)
// Called from:
//      fn0072D920
word32 fn0072DD60(Eq_3 dwArg04, Eq_3 dwArg08)
{
	Eq_3 dwLoc14_1108 = 0x00;
	if (g_tA6DBEC == 0x00)
	{
		word32 ecx_1489;
		word32 edx_1490;
		Eq_3 eax_12 = fn006F1A70(out ecx_1489, out edx_1490);
		g_tA6DBEC = eax_12;
		if (eax_12 == 0x00)
			return 0x00;
	}
	if (g_tA6DBDC == 0x00)
	{
		word32 ecx_1493;
		word32 edx_1494;
		Eq_3 eax_30 = fn006F1A70(out ecx_1493, out edx_1494);
		g_tA6DBDC = eax_30;
		if (eax_30 == 0x00)
			return 0x00;
	}
	Eq_3 dwLoc04_1183;
	Eq_3 edi_129;
	Eq_3 esi_52 = *((word32) dwArg04 + 24);
	word32 edx_1492;
	word32 ecx_1491;
	Eq_3 eax_60 = fn00723860(0x20, out ecx_1491, out edx_1492);
	if (eax_60 == 0x00)
	{
		word32 ecx_1495;
		word32 edx_1496;
		fn006E1210(out ecx_1495, out edx_1496);
		edi_129.u0 = 0x00;
		dwLoc04_1183.u0 = 0x00;
	}
	else
	{
		eax_60->u0 = 0x00;
		*((word32) eax_60 + 4) = 0x00;
		((word32) eax_60 + 8)->u0 = 0x00;
		((word32) eax_60 + 0x0C)->u0 = 0x00;
		((word32) eax_60 + 16)->u0 = 0x00;
		((word32) eax_60 + 20)->u0 = 0x00;
		((word32) eax_60 + 24)->u0 = 0x00;
		((word32) eax_60 + 28)->u0 = 0x00;
		*eax_60 = *((word32) esi_52 + 36);
		*((word32) esi_52 + 36) = eax_60;
		edi_129 = eax_60;
		dwLoc04_1183 = eax_60;
	}
	Eq_3 esi_100 = *((word32) dwArg04 + 24);
	word32 edx_1498;
	word32 ecx_1497;
	Eq_3 eax_104 = fn00723860(0x20, out ecx_1497, out edx_1498);
	if (eax_104 == 0x00)
	{
		word32 ecx_1499;
		word32 edx_1500;
		fn006E1210(out ecx_1499, out edx_1500);
		eax_104.u0 = 0x00;
	}
	else
	{
		eax_104->u0 = 0x00;
		*((word32) eax_104 + 4) = 0x00;
		((word32) eax_104 + 8)->u0 = 0x00;
		((word32) eax_104 + 0x0C)->u0 = 0x00;
		((word32) eax_104 + 16)->u0 = 0x00;
		((word32) eax_104 + 20)->u0 = 0x00;
		((word32) eax_104 + 24)->u0 = 0x00;
		((word32) eax_104 + 28)->u0 = 0x00;
		*eax_104 = *((word32) esi_100 + 36);
		*((word32) esi_100 + 36) = eax_104;
	}
	if (edi_129 == 0x00 || eax_104 == 0x00)
		return 0x00;
	Eq_3 eax_156 = fn007272E0(ebx, dwArg04, esi_100, edi_129, es, ds, dwArg04);
	if (eax_156 == 0x00)
		return 0x00;
	fn00740DF0(*((word32) dwArg04 + 36), eax_156);
	if (*((word32) dwArg08 + 8) != 0x00)
	{
		Eq_3 eax_184 = fn007272E0(ebx, dwArg04, dwArg08, edi_129, es, ds, dwArg04);
		dwLoc14_1108 = eax_184;
		if (eax_184 == 0x00)
			return 0x00;
		fn00740DF0(*((word32) dwArg04 + 36), eax_184);
	}
	if (fn0072B360(dwArg04, *((word32) dwArg08 + 4)) == 0x00)
		return 0x00;
	if (fn00727670(dwArg04, 0x04) == 0x00 || fn00728FB0() == 0x00)
		return 0x00;
	Eq_3 eax_277 = *((word32) dwArg04 + 24);
	byte * esi_281 = (word32) eax_156 + 20;
	byte * edi_282 = &g_b8DA718;
	word32 ecx_283 = 0x0A;
	bool v21_1092 = false;
	while (ecx_283 != 0x00)
	{
		v21_1092 = *esi_1516 != *edi_1517;
		esi_281 = esi_1516 + 1;
		edi_282 = edi_1517 + 1;
		--ecx_283;
		esi_1516 = esi_281;
		edi_1517 = edi_282;
		if (*esi_1516 == *edi_1517)
			break;
	}
	if (v21_1092)
	{
		word32 edx_1503;
		if (fn00726150(*((word32) eax_277 + 28), eax_156, out edx_1503) == 0x00)
			return 0x00;
		ui32 edi_339 = 0x03;
		word32 ecx_1506;
		word32 edx_1507;
		Eq_3 eax_341 = fn007475E0(**((word32) dwArg04 + 24), out ecx_1506, out edx_1507);
		if (eax_341 <= 0x05)
		{
			switch ((word32) eax_341)
			{
			case 0x01:
				if (*((word32) **((word32) dwArg04 + 24) + 28) == 0x00)
					edi_339 = 0x00;
				break;
			case 0x02:
				goto l0072DF90;
			case 0x03:
				struct Eq_138230 * eax_359 = **((word32) dwArg04 + 24);
				if (eax_359->dw001C == 0x00 && eax_359->dw0020 == 0x00)
				{
l0072DF90:
					edi_339 = 0x01;
				}
				break;
			case 0x04:
				edi_339 = 0x02;
				break;
			case 0x05:
				edi_339 = 0x02;
				break;
			}
		}
		word32 eax_386;
		(*((const char *) g_a72E5DC + edi_339 * 0x04))();
		return eax_386;
	}
	else
	{
		Eq_3 eax_395 = fn00728360(dwArg04, 0x008DA884);
		if (eax_395 == 0x00 || fn00728FB0() == 0x00)
			return 0x00;
		word32 ecx_1504;
		if (fn00727810(dwArg04, 131, 0x00, out ecx_1504) == 0x00)
			return 0x00;
		if (*((word32) dwArg08 + 8) != 0x00)
		{
			Eq_3 eax_453 = *((word32) dwArg04 + 24);
			byte * edi_457 = &g_b8DA718;
			byte * esi_458 = (word32) dwLoc14_1108 + 20;
			word32 ecx_459 = 0x0A;
			bool v25_1096 = false;
			while (ecx_459 != 0x00)
			{
				v25_1096 = *esi_1518 != *edi_1519;
				esi_458 = esi_1518 + 1;
				edi_457 = edi_1519 + 1;
				--ecx_459;
				esi_1518 = esi_458;
				edi_1519 = edi_457;
				if (*esi_1518 == *edi_1519)
					break;
			}
			if (v25_1096)
			{
				word32 edx_1505;
				if (fn00726150(*((word32) eax_453 + 28), dwLoc14_1108, out edx_1505) == 0x00)
					return 0x00;
				ui32 edi_514 = 0x03;
				word32 edx_1515;
				word32 ecx_1514;
				Eq_3 eax_516 = fn007475E0(**((word32) dwArg04 + 24), out ecx_1514, out edx_1515);
				if (eax_516 <= 0x05)
				{
					switch ((word32) eax_516)
					{
					case 0x01:
						if (*((word32) **((word32) dwArg04 + 24) + 28) == 0x00)
							edi_514 = 0x00;
						break;
					case 0x02:
						goto l0072E114;
					case 0x03:
						struct Eq_138642 * eax_534 = **((word32) dwArg04 + 24);
						if (eax_534->dw001C == 0x00 && eax_534->dw0020 == 0x00)
						{
l0072E114:
							edi_514 = 0x01;
						}
						break;
					case 0x04:
						edi_514 = 0x02;
						break;
					case 0x05:
						edi_514 = 0x02;
						break;
					}
				}
				word32 eax_561;
				(*((const char *) g_a72E600 + edi_514 * 0x04))();
				return eax_561;
			}
			Eq_3 eax_570 = fn00728360(dwArg04, 0x008DA884);
			if (eax_570 == 0x00)
				return 0x00;
		}
		else if (fn00727670(dwArg04, 0x01) == 0x00)
			return 0x00;
		if (fn00727880(dwArg04, 122, eax_104, 0x00) == 0x00)
			return 0x00;
		*((word32) *((word32) *((word32) dwArg04 + 24) + 40) + 16) = dwLoc04_1183;
		*((word32) *((word32) dwArg04 + 24) + 40) = dwLoc04_1183;
		if (fn00728310(dwArg04, 0x02, dwLoc04_1183) == 0x00)
			return 0x00;
		if (*((word32) dwArg08 + 8) != 0x00)
		{
			if (fn00729510(dwArg04, dwLoc14_1108, 0x01) == 0x00)
				return 0x00;
			Eq_3 eax_645 = *((word32) dwArg04 + 24);
			byte * esi_649 = (word32) dwLoc14_1108 + 20;
			byte * edi_650 = &g_b8DA718;
			word32 ecx_651 = 0x0A;
			bool v29_1100 = false;
			while (ecx_651 != 0x00)
			{
				v29_1100 = *esi_1520 != *edi_1521;
				esi_649 = esi_1520 + 1;
				edi_650 = edi_1521 + 1;
				--ecx_651;
				esi_1520 = esi_649;
				edi_1521 = edi_650;
				if (*esi_1520 == *edi_1521)
					break;
			}
			if (v29_1100)
			{
				word32 edx_1508;
				if (fn00726150(*((word32) eax_645 + 28), dwLoc14_1108, out edx_1508) == 0x00)
					return 0x00;
				ui32 edi_707 = 0x03;
				word32 edx_1510;
				word32 ecx_1509;
				Eq_3 eax_709 = fn007475E0(**((word32) dwArg04 + 24), out ecx_1509, out edx_1510);
				if (eax_709 <= 0x05)
				{
					switch ((word32) eax_709)
					{
					case 0x01:
						if (*((word32) **((word32) dwArg04 + 24) + 28) == 0x00)
							edi_707 = 0x00;
						break;
					case 0x02:
						goto l0072E2BE;
					case 0x03:
						struct Eq_138396 * eax_727 = **((word32) dwArg04 + 24);
						if (eax_727->dw001C == 0x00 && eax_727->dw0020 == 0x00)
						{
l0072E2BE:
							edi_707 = 0x01;
						}
						break;
					case 0x04:
						edi_707 = 0x02;
						break;
					case 0x05:
						edi_707 = 0x02;
						break;
					}
				}
				word32 eax_754;
				(*((const char *) g_a72E624 + edi_707 * 0x04))();
				return eax_754;
			}
			Eq_3 eax_763 = fn00728360(dwArg04, 0x008DA884);
			if (eax_763 == 0x00 || fn0072B360(dwArg04, *((word32) dwArg08 + 8)) == 0x00)
				return 0x00;
		}
		Eq_3 ebx_792 = *((word32) dwArg08 + 0x0C);
		int32 edi_1070 = 0x00;
		word32 * esi_1071 = (word32) ebx_792 + 4;
		while (true)
		{
			int32 eax_802;
			if (ebx_792 == 0x00)
				eax_802 = 0x00;
			else
				eax_802 = (int32) *ebx_792;
			if (edi_1070 >= eax_802)
				break;
			if (fn0072D920(dwArg04, *esi_1071) == 0x00)
				return 0x00;
			++edi_1070;
			++esi_1071;
		}
		if (fn00727670(dwArg04, 0x57) == 0x00)
			return 0x00;
		Eq_3 eax_831 = *((word32) dwArg04 + 24);
		*((word32) eax_831 + 48) = (word32) *((word32) eax_831 + 48) - 1;
		if (fn00728FB0() == 0x00)
			return 0x00;
		*((word32) *((word32) *((word32) dwArg04 + 24) + 40) + 16) = eax_104;
		*((word32) *((word32) dwArg04 + 24) + 40) = eax_104;
		if (fn00728310(dwArg04, 0x03, eax_104) == 0x00 || fn00729510(dwArg04, eax_156, 0x01) == 0x00)
			return 0x00;
		Eq_3 eax_890 = *((word32) dwArg04 + 24);
		byte * esi_894 = (word32) eax_156 + 20;
		byte * edi_895 = &g_b8DA718;
		word32 ecx_896 = 0x0A;
		bool v33_1104 = false;
		while (ecx_896 != 0x00)
		{
			v33_1104 = *esi_1522 != *edi_1523;
			esi_894 = esi_1522 + 1;
			edi_895 = edi_1523 + 1;
			--ecx_896;
			esi_1522 = esi_894;
			edi_1523 = edi_895;
			if (*esi_1522 == *edi_1523)
				break;
		}
		if (v33_1104)
		{
			word32 edx_1511;
			if (fn00726150(*((word32) eax_890 + 28), eax_156, out edx_1511) == 0x00)
				return 0x00;
			ui32 edi_952 = 0x03;
			word32 ecx_1512;
			word32 edx_1513;
			Eq_3 eax_954 = fn007475E0(**((word32) dwArg04 + 24), out ecx_1512, out edx_1513);
			if (eax_954 <= 0x05)
			{
				switch ((word32) eax_954)
				{
				case 0x01:
					if (*((word32) **((word32) dwArg04 + 24) + 28) == 0x00)
						edi_952 = 0x00;
					break;
				case 0x02:
					goto l0072E4C8;
				case 0x03:
					struct Eq_138586 * eax_972 = **((word32) dwArg04 + 24);
					if (eax_972->dw001C == 0x00 && eax_972->dw0020 == 0x00)
					{
l0072E4C8:
						edi_952 = 0x01;
					}
					break;
				case 0x04:
					edi_952 = 0x02;
					break;
				case 0x05:
					edi_952 = 0x02;
					break;
				}
			}
			word32 eax_999;
			(*((const char *) g_a72E648 + edi_952 * 0x04))();
			return eax_999;
		}
		else
		{
			Eq_3 eax_1008 = fn00728360(dwArg04, 0x008DA884);
			if (eax_1008 == 0x00 || (fn00727670(dwArg04, 0x51) == 0x00 || fn00727670(dwArg04, 88) == 0x00))
				return 0x00;
			Eq_3 ebp_1040 = *((word32) dwArg04 + 24);
			*((word32) ebp_1040 + 48) = (word32) *((word32) ebp_1040 + 48) - 1;
			return 0x01;
		}
	}
}

<anonymous> * g_a72E5DC[] = // 0072E5DC
	{
	};
<anonymous> * g_a72E600[] = // 0072E600
	{
	};
<anonymous> * g_a72E624[] = // 0072E624
	{
	};
<anonymous> * g_a72E648[] = // 0072E648
	{
	};
// 0072E660: Register Eq_3 fn0072E660(Register Eq_3 eax, Register Eq_3 ecx)
// Called from:
//      fn0072E790
Eq_3 fn0072E660(Eq_3 eax, Eq_3 ecx)
{
	Eq_3 eax_18 = g_tA6DBE0;
	int32 ebp_150 = 0x00;
	Eq_3 dwLoc04_271 = 0x01;
	if (eax_18 == 0x00)
	{
		word32 edx_367;
		word32 ecx_366;
		eax_18 = fn006ECAC0(0x008DAAE0, out ecx_366, out edx_367);
		g_tA6DBE0 = eax_18;
		if (eax_18 == 0x00)
			return 0x00;
	}
	if (fn00728E40(eax_18, ecx, eax, 0x00) == 0x00)
		return 0x00;
	up32 ecx_62 = *eax;
	if (ecx_62 > 0x04)
	{
		word32 edx_369;
		word32 ecx_368;
		fn006E15D0(g_tA18720, 9284248, out ecx_368, out edx_369);
		return 0x00;
	}
	else
	{
		switch (ecx_62)
		{
		case 0x01:
			if (fn0072BF10(ecx, *((word32) eax + 4)) != 0x00)
				goto l0072E723;
			break;
		case 0x02:
			((word32) ecx + 16)->u0 = 0x01;
			Eq_3 esi_138 = *((word32) eax + 4);
			word32 * ebx_139 = (word32) esi_138 + 4;
			while (true)
			{
				int32 eax_145;
				if (esi_138 == 0x00)
					eax_145 = 0x00;
				else
					eax_145 = (int32) *esi_138;
				if (ebp_150 >= eax_145)
					break;
				if (fn0072D920(ecx, *ebx_139) == 0x00)
					goto l0072E6D2;
				++ebp_150;
				++ebx_139;
			}
			goto l0072E723;
		case 0x03:
			if (fn0072B360(ecx, *((word32) eax + 4)) != 0x00)
			{
				dwLoc04_271.u0 = 0x00;
l0072E723:
				Eq_3 eax_214 = fn0072A350(ecx, dwLoc04_271);
				fn00727290(ecx);
				return eax_214;
			}
			break;
		case 0x04:
			word32 edx_371;
			word32 ecx_370;
			fn006E0F80(g_tA18720, 9284288, out ecx_370, out edx_371);
			return 0x00;
		}
l0072E6D2:
		fn00727290(ecx);
		return 0x00;
	}
}

// 0072E790: Register word32 fn0072E790(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Stack (ptr32 ui32) dwArg0C, Stack Eq_3 dwArg10)
// Called from:
//      fn006E83E0
//      fn006F67C0
word32 fn0072E790(Eq_3 dwArg04, Eq_3 dwArg08, ui32 * dwArg0C, Eq_3 dwArg10)
{
	word32 ebp_130 = 0x00;
	if (g_tA6DBD8 == 0x00)
	{
		word32 ecx_374;
		word32 edx_375;
		Eq_3 eax_14 = fn006F1A70(out ecx_374, out edx_375);
		g_tA6DBD8 = eax_14;
		if (eax_14 == 0x00)
			return 0x00;
	}
	Eq_3 dwLoc24_280 = 0x00;
	word32 edx_373;
	Eq_3 eax_43 = fn006F2650(0x00, out edx_373);
	if (eax_43 == 0x00)
		return 0x00;
	Eq_3 eax_71 = fn00752DC0();
	if (eax_71 != 0x00)
	{
		ui32 * edx_81 = dwArg0C;
		if (dwArg0C == null)
			edx_81 = fp - 44;
		ui32 ecx_91 = *eax_71 | *edx_81;
		*eax_71 = ecx_91;
		*edx_81 = ecx_91;
		Eq_3 eax_111 = fn00749820(dwArg04, dwArg08, eax_71);
		dwLoc24_280 = eax_111;
		if (eax_111 == 0x00)
		{
			if (fn006E0FC0() == 0x00)
			{
				word32 ecx_376;
				word32 edx_377;
				fn006E0F80(g_tA18720, 9284332, out ecx_376, out edx_377);
			}
		}
		else
			ebp_130 = fn0072E660(dwArg04, fp - 0x28);
	}
	if (dwLoc24_280 != 0x00)
		fn00747530(dwLoc24_280);
	if (eax_71 != 0x00)
	{
		word32 ecx_378;
		word32 edx_379;
		fn007239C0(eax_71, out ecx_378, out edx_379);
	}
	*eax_43 = (word32) *eax_43 - 1;
	if (*eax_43 == 0x00)
	{
		struct Eq_138879 * ecx_199 = *((word32) eax_43 + 4);
		ecx_199->ptr0018();
	}
	return ebp_130;
}

// 0072E920: Register word32 fn0072E920(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08)
// Called from:
//      fn006E54A0
//      fn00728E40
word32 fn0072E920(Eq_3 dwArg04, Eq_3 dwArg08)
{
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_3 stackArg8 = <invalid>;
	word32 edx_56;
	word32 ecx_55;
	word32 edx_58;
	struct Eq_138891 * eax_22 = fn006DDD30(fn00723860(g_tA253C0, out ecx_55, out edx_56), stackArg8, out edx_58);
	if (eax_22 == null)
		return;
	eax_22->t0008 = dwArg04;
	eax_22->t0010 = dwArg08;
	eax_22->t000C.u0 = 0x00;
	return;
}

// 0072E9C0: Register Eq_3 fn0072E9C0(Stack Eq_3 dwArg04, Register out Eq_540 edxOut)
// Called from:
//      fn006E5530
//      fn00718F10
//      fn00727290
//      fn0072C160
Eq_3 fn0072E9C0(Eq_3 dwArg04, union Eq_540 & edxOut)
{
	if (dwArg04 != 0x00)
	{
		if (*((word32) dwArg04 + 4) == 0x00A253B0)
		{
			Eq_3 eax_45 = *((word32) dwArg04 + 8);
			edxOut.u0 = <invalid>;
			return eax_45;
		}
		word32 ecx_76;
		word32 edx_77;
		fn006E0F80(g_tA16B7C, 9284464, out ecx_76, out edx_77);
	}
	if (fn006E0FC0() == 0x00)
	{
		word32 ecx_78;
		word32 edx_79;
		fn006E0F80(g_tA16B7C, dwArg04, out ecx_78, out edx_79);
	}
	edxOut.u0 = <invalid>;
	return 0x00;
}

// 0072EC10: Register word32 fn0072EC10(Register out ptr32 edxOut, Register out Eq_540 ebxOut, Register out Eq_540 ebpOut, Register out Eq_540 esiOut, Register out Eq_540 ediOut)
// Called from:
//      fn006DDEB0
//      fn006DEEA0
//      fn006E1260
//      fn0072FB30
//      fn007556D0
word32 fn0072EC10(ptr32 & edxOut, union Eq_540 & ebxOut, union Eq_540 & ebpOut, union Eq_540 & esiOut, union Eq_540 & ediOut)
{
	if (g_dwA6DCCC != 0x00 && fn0074F680() == g_dwA6DC00)
	{
		g_dwA6DCCC = 0x00;
		fn007075C0() != 0x00;
		int32 edi_145;
		for (edi_145 = 0x01; edi_145 < 0x17; ++edi_145)
		{
			ptr32 edx_139;
			if (g_aA6DC10[edi_145] != 0x00)
			{
				word32 esi_252;
				Eq_3 eax_61 = fn006EA200(out edx, out esi_252);
				g_aA6DC10[edi_145] = (struct Eq_179817) 0x00;
				if (eax_61 == 0x00)
				{
l0072ECC4:
					edxOut = edx;
					ebxOut.u0 = <invalid>;
					ebpOut.u0 = <invalid>;
					esiOut.u0 = <invalid>;
					ediOut.u0 = <invalid>;
					return ~0x00;
				}
				word32 edi_255;
				word32 esi_254;
				word32 ecx_253;
				Eq_3 eax_80 = fn00707680(g_aA6DC14[edi_145], eax_61, 0x00, out ecx_253, out edx, out esi_254, out edi_255);
				word32 v13_86 = (word32) *eax_61 - 1;
				*eax_61 = v13_86;
				struct Eq_139012 * esp_101 = fp - 0x10;
				if (v13_86 == 0x00)
				{
					struct Eq_139020 * edx_91 = *((word32) eax_61 + 4);
					word32 esp_95;
					word32 ecx_97;
					edx_91->ptr0018();
					esp_101 = esp_95 + 0x04;
				}
				if (eax_80 == 0x00)
					goto l0072ECC4;
				word32 v16_124 = (word32) *eax_80 - 1;
				*eax_80 = v16_124;
				if (v16_124 == 0x00)
				{
					struct Eq_139050 * ecx_128 = *((word32) eax_80 + 4);
					<anonymous> * edx_129 = ecx_128->ptr0018;
					esp_101->tFFFFFFFC = eax_80;
					edx_129();
					edx = edx_139;
				}
			}
		}
		edxOut = edx;
		ebxOut.u0 = <invalid>;
		ebpOut.u0 = <invalid>;
		esiOut.u0 = <invalid>;
		ediOut.u0 = <invalid>;
		return 0x00;
	}
	else
	{
		edxOut = edx;
		ebxOut.u0 = <invalid>;
		ebpOut.u0 = <invalid>;
		esiOut.u0 = <invalid>;
		ediOut.u0 = <invalid>;
		return 0x00;
	}
}

// 0072ECF0: void fn0072ECF0()
// Called from:
//      fn006E8910
void fn0072ECF0()
{
	signal(0x02, g_ptrA6DCD0);
	struct Eq_139069 * ecx_106 = g_ptrA6DC08;
	g_ptrA6DCD0 = null;
	int32 edi_23;
	struct Eq_139077 * esp_24 = fp - 0x0C;
	for (edi_23 = 0x01; edi_23 < 0x17; ++edi_23)
	{
		struct Eq_139069 * esi_30 = g_aA6DC14[edi_23];
		g_aA6DC10[edi_23] = (struct Eq_179817) 0x00;
		g_aA6DC14[edi_23] = (struct Eq_179818) 0x00;
		if (edi_23 != 0x02)
		{
			if (esi_30 == null)
				goto l0072EBA3;
			if (esi_30 != &g_dwA163B8 && (esi_30 != ecx_106 && esi_30 != g_ptrA6DCC8))
			{
				struct Eq_139096 * esp_45 = esp_24 - 4;
				esp_45->ptr0000 = null;
				esp_45->dwFFFFFFFC = edi_23;
				signal(esp_45->dwFFFFFFFC, esp_45->ptr0000);
				ecx_106 = g_ptrA6DC08;
			}
		}
		if (esi_30 != null)
		{
			word32 v12_58 = esi_30->dw0000 + ~0x00;
			esi_30->dw0000 = v12_58;
			if (v12_58 == 0x00)
			{
				struct Eq_139127 * ecx_62 = esi_30->ptr0004;
				<anonymous> * edx_63 = ecx_62->ptr0018;
				esp_24->ptrFFFFFFFC = esi_30;
				word32 esp_70;
				word32 edx_73;
				edx_63();
				ecx_106 = g_ptrA6DC08;
				esp_24 = esp_70 + 0x04;
			}
		}
l0072EBA3:
	}
	struct Eq_139069 * eax_84 = g_ptrA6DC0C;
	struct Eq_139163 * esp_107 = (const char *) &esp_24->ptrFFFFFFFC + 8;
	if (eax_84 != null)
	{
		word32 v15_91 = eax_84->dw0000 + ~0x00;
		eax_84->dw0000 = v15_91;
		if (v15_91 == 0x00)
		{
			struct Eq_139127 * ecx_95 = eax_84->ptr0004;
			<anonymous> * edx_96 = ecx_95->ptr0018;
			esp_107->ptrFFFFFFFC = eax_84;
			word32 esp_100;
			word32 edx_103;
			edx_96();
			ecx_106 = g_ptrA6DC08;
			esp_107 = esp_100 + 0x04;
		}
	}
	g_ptrA6DC0C = null;
	if (ecx_106 != null)
	{
		word32 v16_116 = ecx_106->dw0000 + ~0x00;
		ecx_106->dw0000 = v16_116;
		if (v16_116 == 0x00)
		{
			struct Eq_139127 * eax_120 = ecx_106->ptr0004;
			esp_107->ptrFFFFFFFC = ecx_106;
			word32 esp_128;
			word32 edx_131;
			eax_120->ptr0018();
			esp_107 = esp_128 + 0x04;
		}
	}
	struct Eq_139069 * eax_137 = g_ptrA6DCC8;
	g_ptrA6DC08 = null;
	if (eax_137 != null)
	{
		word32 v17_142 = eax_137->dw0000 + ~0x00;
		eax_137->dw0000 = v17_142;
		if (v17_142 == 0x00)
		{
			struct Eq_139127 * edx_146 = eax_137->ptr0004;
			esp_107->ptrFFFFFFFC = eax_137;
			edx_146->ptr0018();
		}
	}
	g_ptrA6DCC8 = null;
}

// 0072ED00: Register word32 fn0072ED00()
// Called from:
//      fn007556D0
word32 fn0072ED00()
{
	if (g_dwA6DC20 == 0x00 || fn0074F680() != g_dwA6DC00)
		return 0x00;
	g_dwA6DC20 = 0x00;
	return 0x01;
}

// 0072F1E0: Register word32 fn0072F1E0(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Stack Eq_3 dwArg0C)
// Called from:
//      fn00707E00
//      fn00707F70
//      fn00708DC0
word32 fn0072F1E0(Eq_3 dwArg04, Eq_3 dwArg08, Eq_3 dwArg0C)
{
	word32 ecx_94;
	word32 edx_95;
	Eq_3 eax_7 = fn006DDD80(&g_tA25D30, out ecx_94, out edx_95);
	if (eax_7 == 0x00)
		return;
	Eq_3 esi_20 = dwArg0C;
	if (dwArg0C == 0x00)
		esi_20.u0 = 0x00A163B8;
	*esi_20 = (word32) *esi_20 + 1;
	Eq_3 edx_27 = dwArg04;
	if (dwArg04 == 0x00)
		edx_27.u0 = 0x00A163B8;
	*edx_27 = (word32) *edx_27 + 1;
	Eq_3 ecx_37 = dwArg08;
	if (dwArg08 == 0x00)
		ecx_37.u0 = 0x00A163B8;
	*ecx_37 = (word32) *ecx_37 + 1;
	*((word32) eax_7 + 16) = esi_20;
	*((word32) eax_7 + 8) = edx_27;
	*((word32) eax_7 + 0x0C) = ecx_37;
	return;
}

// 0072F230: Register Eq_3 fn0072F230(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08)
// Called from:
//      fn00703210
//      fn00703420
Eq_3 fn0072F230(Eq_3 dwArg04, Eq_3 dwArg08)
{
	word32 edx_224;
	word32 ecx_223;
	Eq_3 eax_12 = fn00705120(dwArg04, out ecx_223, out edx_224);
	if (eax_12 == 0x00)
		return eax_12;
	word32 ecx_225;
	word32 edx_226;
	Eq_3 eax_29 = fn00705120(dwArg08, out ecx_225, out edx_226);
	if (eax_29 != 0x00)
	{
		Eq_3 ebx_65;
		word32 edx_228;
		word32 ecx_227;
		Eq_3 eax_45 = fn006DDD80(&g_tA25D30, out ecx_227, out edx_228);
		struct Eq_139357 * esp_51 = fp - 0x08;
		if (eax_45 == 0x00)
			ebx_65.u0 = 0x00;
		else
		{
			++g_dwA163B8;
			*eax_12 = (word32) *eax_12 + 1;
			*eax_29 = (word32) *eax_29 + 1;
			((word32) eax_45 + 16)->u0 = 0x00A163B8;
			*((word32) eax_45 + 8) = eax_12;
			*((word32) eax_45 + 0x0C) = eax_29;
			ebx_65 = eax_45;
		}
		word32 v17_71 = (word32) *eax_12 - 1;
		*eax_12 = v17_71;
		if (v17_71 == 0x00)
		{
			struct Eq_59705 * ecx_75 = *((word32) eax_12 + 4);
			word32 esp_83;
			ecx_75->ptr0018();
			esp_51 = esp_83 + 0x04;
		}
		word32 v18_93 = (word32) *eax_29 - 1;
		*eax_29 = v18_93;
		if (v18_93 == 0x00)
		{
			struct Eq_59705 * eax_97 = *((word32) eax_29 + 4);
			<anonymous> * ecx_98 = eax_97->ptr0018;
			esp_51->tFFFFFFFC = eax_29;
			ecx_98();
		}
		return ebx_65;
	}
	else
	{
		word32 v11_123 = (word32) *eax_12 - 1;
		*eax_12 = v11_123;
		if (v11_123 == 0x00)
		{
			struct Eq_59705 * edx_127 = *((word32) eax_12 + 4);
			edx_127->ptr0018();
		}
		return 0x00;
	}
}

// 0072F770: Register Eq_3 fn0072F770(Register Eq_3 ebx, Register Eq_3 edi)
// Called from:
//      fn0072F7F0
Eq_3 fn0072F770(Eq_3 ebx, Eq_3 edi)
{
	if ((ebx == 0x00 || *((word32) ebx + 4) == 10640960) && (edi != 0x00 && *((word32) edi + 4) == 0x00A2B8D8))
	{
		word32 ecx_148;
		word32 edx_149;
		Eq_3 eax_47 = fn006FEF30(&g_tA25E40, out ecx_148, out edx_149);
		if (eax_47 != 0x00)
		{
			if (ebx != 0x00)
				*ebx = (word32) *ebx + 1;
			*((word32) eax_47 + 8) = ebx;
			*edi = (word32) *edi + 1;
			*((word32) eax_47 + 0x0C) = edi;
			*((word32) eax_47 + 16) = *((word32) edi + 60);
			*((word32) eax_47 + 20) = fn00735550(*((word32) edi + 16), *((word32) edi + 60));
			word32 edx_150;
			fn006FEE30(eax_47, out edx_150);
		}
		return eax_47;
	}
	else
	{
		word32 edx_147;
		fn006E1DC0(out edx_147);
		return 0x00;
	}
}

// 0072F7F0: void fn0072F7F0(Stack Eq_3 dwArg04)
// Called from:
//      fn00708DC0
void fn0072F7F0(Eq_3 dwArg04)
{
	Eq_3 esi_10 = g_tA6D67C;
	Eq_3 ebx_11 = *((word32) esi_10 + 48);
	Eq_3 eax_17 = fn0072F770(ebx_11, dwArg04);
	if (eax_17 == 0x00)
		return;
	*((word32) esi_10 + 48) = eax_17;
	if (ebx_11 != 0x00)
	{
		word32 v10_28 = (word32) *ebx_11 - 1;
		*ebx_11 = v10_28;
		if (v10_28 == 0x00)
		{
			struct Eq_139564 * eax_32 = *((word32) ebx_11 + 4);
			eax_32->ptr0018();
		}
	}
}

// 0072F830: Register word32 fn0072F830(Register Eq_3 ecx, Register Eq_3 edx, Register Eq_3 ebx, Register Eq_3 ebp, Register Eq_3 esi, Register Eq_3 edi, Register (ptr16 Eq_7) es, Register (ptr16 Eq_8) ds, Stack Eq_3 dwArg04, Stack Eq_3 dwArg0C, Register out Eq_3 edxOut)
// Called from:
//      fn0072FB30
word32 fn0072F830(Eq_3 ecx, Eq_3 edx, Eq_3 ebx, Eq_3 ebp, Eq_3 esi, Eq_3 edi, struct Eq_7 * es, struct Eq_8 * ds, Eq_3 dwArg04, Eq_3 dwArg0C, union Eq_3 & edxOut)
{
	ui32 eax_7 = g_tA14188 ^ fp - 2292;
	if (ecx == 0x00 || dwArg0C == 0x00)
	{
		word32 ecx_948;
		word32 eax_55 = fn00694B8E(~0x00, eax_7 ^ fp - 2292, edx, ebx, ebp, esi, edi, es, ds, esi, out ecx_948);
		edxOut = edx;
		return eax_55;
	}
	word32 ebx_950;
	word32 ebp_951;
	word32 edx_949;
	Eq_3 eax_75 = fn00659040(ebx, ebp, ecx, edi, es, ds, ecx, 9074500, out edx_949, out ebx_950, out ebp_951);
	Eq_3 ebp_375 = eax_75;
	Eq_3 dwLoc08F4_689 = eax_75;
	if (eax_75 == 0x00)
	{
		Eq_3 ebx_102;
		const char * eax_96 = strrchr(ecx, 0x5C);
		if (eax_96 == null)
			ebx_102 = ecx;
		else
			ebx_102 = eax_96 + 1;
		word32 edx_954;
		word32 ecx_953;
		Eq_3 eax_108 = fn00715DD0(out ecx_953, out edx_954);
		if (eax_108 != 0x00)
		{
			Eq_3 eax_121 = *((word32) eax_108 + 4);
			if (eax_121 != 0x00A1BAF0)
			{
				word32 ecx_959;
				word32 edx_960;
				if (fn006D5670(eax_121, 0x00A1BAF0, out ecx_959, out edx_960) == 0x00)
					goto l0072F9FE;
			}
			word32 edx_958;
			word32 ecx_957;
			Eq_3 eax_143 = fn006F2750(eax_108, out ecx_957, out edx_958);
			Eq_3 eax_153 = ebx_102;
			const char * edx_156 = (word32) ebx_102 + 1;
			do
			{
				eax_153 = (word32) eax_974 + 1;
				eax_974 = eax_153;
			} while (*eax_974 != 0x00);
			Eq_139725 eax_165 = eax_153 - edx_156;
			Eq_3 ebp_166 = 0x00;
			if (eax_143 > 0x00)
			{
				do
				{
					word32 ecx_961;
					word32 edx_962;
					Eq_3 eax_178 = fn006F2790(eax_108, ebp_166, out ecx_961, out edx_962);
					if (eax_178 == 0x00)
					{
						word32 ecx_964;
						word32 edx_965;
						fn006E1160(out ecx_964, out edx_965);
						break;
					}
					Eq_3 eax_199 = *((word32) eax_178 + 4);
					if (eax_199 != 0x00A1B450)
					{
						word32 ecx_966;
						word32 edx_967;
						if (fn006D5670(eax_199, 0x00A1B450, out ecx_966, out edx_967) != 0x00)
							goto l0072F94B;
					}
					else
					{
l0072F94B:
						if ((word32) eax_165 + ((word32) (*((word32) eax_178 + 8)) + 1) < 0x0100)
						{
							word32 ecx_968;
							word32 edx_969;
							struct Eq_139797 * esi_230;
							Eq_3 eax_227 = fn006ECC50(eax_178, out ecx_968, out edx_969, out esi_230);
							byte * edx_237 = fp - 0x08D8;
							do
							{
								byte cl_240 = *eax_227;
								*edx_237 = cl_240;
								eax_227 = (word32) eax_227 + 1;
								++edx_237;
							} while (cl_240 != 0x00);
							byte * eax_249 = fp - 0x08D8;
							do
							{
								eax_249 = eax_975 + 1;
								eax_975 = eax_249;
							} while (*eax_975 != 0x00);
							if (eax_249 - (fp - (struct Eq_139831 *) 2263) == esi_230)
							{
								if (esi_230 > null && Mem242[(fp - 2265) + esi_230:byte] != 0x5C)
								{
									Mem271[fp - 0x08D8 + esi_230:byte] = 0x5C;
									++esi_230;
								}
								Eq_3 esi_280 = esi_230 - ebx_102;
								Eq_3 eax_282 = ebx_102;
								word32 edx_284 = fp - 0x08D8 + esi_280;
								do
								{
									Eq_139847 cl_287 = *eax_282;
									Mem289[edx_284 + eax_282:byte] = cl_287;
									++eax_282;
								} while (cl_287 != 0x00);
								word32 edx_970;
								Eq_3 eax_347 = fn00659040(ebx_102, ebp_166, esi_280, eax_178, es, ds, fp - (struct Eq_139870 *) 0x08D8, 9074500, out edx_970, out ebx_102, out ebp_166);
								dwLoc08F4_689 = eax_347;
								if (eax_347 != 0x00)
									break;
							}
						}
					}
					ebp_166 = (word32) ebp_166 + 1;
				} while (ebp_166 < eax_143);
			}
			ebp_375 = dwLoc08F4_689;
		}
	}
l0072F9FE:
	fn00724FE0(fp - 2004, 2000, &g_b8DAD60);
	int32 edi_411;
	word32 esi_952;
	Eq_3 edx_412;
	Eq_3 eax_414 = fn00731D30(fp - 2004, dwArg04, out edx_412, out esi_952, out edi_411);
	Eq_3 esi_424 = eax_414;
	if (ebp_375 == 0x00)
	{
l0072FAF4:
		word32 ecx_955;
		word32 eax_623 = fn00694B8E(esi_424, eax_7 ^ fp - 2292, edx_412, ebx, ebp, esi, edi, es, ds, esi, out ecx_955);
		edxOut = edx_412;
		return eax_623;
	}
	if (eax_414 == 0x00)
	{
		if (edi_411 > 0x00)
		{
			int32 esi_432 = edi_411;
			do
			{
				do
				{
					word32 edx_956;
				} while (fn00731F90(fp - 2004, 2000, ebp_375, null, out edx_956) != 0x00 && (false && true));
				--esi_432;
			} while (esi_432 != 0x00);
		}
		else if (edi_411 != 0x00)
			goto l0072FAEA;
		byte * edi_469 = fp - 2004;
		while (true)
		{
			byte al_472 = *edi_469;
			if (al_472 != 0x20 && (al_472 != 0x09 && al_472 != 0x0C))
				break;
			++edi_469;
		}
		word32 esi_963;
		Eq_3 edi_486;
		Eq_3 eax_489 = fn00731D30(9256696, dwArg04, out edx_412, out esi_963, out edi_486);
		esi_424 = eax_489;
		if (eax_489 == 0x00)
		{
			Eq_3 edi_504;
			word32 esi_971;
			Eq_3 eax_507 = fn00731D30(edi_486, dwArg04, out edx_412, out esi_971, out edi_504);
			esi_424 = eax_507;
			if (eax_507 == 0x00 && strchr(edi_504, 0x0A) == null)
			{
				word32 esi_972;
				word32 edi_973;
				esi_424 = fn00731D30(0x008A6DE8, dwArg04, out edx_412, out esi_972, out edi_973);
			}
		}
	}
l0072FAEA:
	fclose(ebp_375);
	goto l0072FAF4;
}

// 0072FB30: Register Eq_3 fn0072FB30(Register Eq_3 eax, Register Eq_3 ebx, Register (ptr16 Eq_7) es, Register (ptr16 Eq_8) ds, Stack Eq_3 dwArg04, Register out ptr32 edxOut)
// Called from:
//      fn0072FBB0
Eq_3 fn0072FB30(Eq_3 eax, Eq_3 ebx, struct Eq_7 * es, struct Eq_8 * ds, Eq_3 dwArg04, ptr32 & edxOut)
{
	Eq_3 ebp_104 = dwArg04;
	Eq_3 esi_109 = eax;
	Eq_3 eax_103 = 0x00;
	Eq_3 edi_107 = 0x00;
	Eq_3 ecx_20 = eax;
	if (eax != 0x00)
	{
		do
		{
			ecx_20 = *((word32) ecx_20 + 8);
			edi_107 = (word32) edi_107 + 1;
		} while (ecx_20 != 0x00);
		do
		{
			Eq_3 esi_65;
			if (edi_107 <= ebp_104)
			{
				struct Eq_139934 * esi_45;
				Eq_3 edx_64;
				word32 ecx_232;
				word32 ecx_234;
				word32 edx_233;
				eax_103 = fn0072F830(fn006ECC50(esi_45->ptr000C->ptr0010->t0030, out ecx_234, out edx_64, out esi_65), edx_64, ebx, ebp_104, esi_65, edi_107, es, ds, ebx, fn006ECC50(*((word32) *((word32) *((word32) esi_109 + 0x0C) + 16) + 52), out ecx_232, out edx_233, out esi_45), out edx);
				esi_109 = esi_65;
			}
			esi_109 = *((word32) esi_109 + 8);
			--edi_107;
			if (eax_103 == 0x00)
				eax_103 = fn0072EC10(out edx, out ebx, out ebp_104, out esi_109, out edi_107);
		} while (esi_109 != 0x00 && eax_103 == 0x00);
	}
	edxOut = edx;
	return eax_103;
}

// 0072FBB0: Register Eq_3 fn0072FBB0(Register (ptr16 Eq_7) es, Register (ptr16 Eq_8) ds, Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Register out ptr32 edxOut)
// Called from:
//      fn006E8060
Eq_3 fn0072FBB0(struct Eq_7 * es, struct Eq_8 * ds, Eq_3 dwArg04, Eq_3 dwArg08, ptr32 & edxOut)
{
	if (dwArg04 == 0x00)
	{
		edxOut = edx;
		return 0x00;
	}
	if (*((word32) dwArg04 + 4) != 10640960)
	{
		ptr32 edx_152;
		fn006E1DC0(out edx_152);
		edxOut = edx_152;
		return ~0x00;
	}
	word32 ecx_240;
	word32 edx_241;
	Eq_3 eax_22 = fn00715DD0(out ecx_240, out edx_241);
	if (eax_22 != 0x00)
	{
		Eq_3 eax_34 = *((word32) eax_22 + 4);
		if (eax_34 == 10610664)
		{
l0072FC15:
			ptr32 edx_59;
			word32 ecx_243;
			word32 esi_244;
			word32 edi_245;
			if (fn007051A0(1000, eax_22, out ecx_243, out edx_59, out esi_244, out edi_245) <= 0x00)
			{
				edxOut = edx_59;
				return 0x00;
			}
			goto l0072FC2A;
		}
		word32 ecx_246;
		word32 edx_247;
		if (fn006D5670(eax_34, 10610664, out ecx_246, out edx_247) != 0x00)
			goto l0072FC15;
	}
l0072FC2A:
	Eq_3 edi_82;
	word32 esi_242;
	ptr32 edx_120;
	Eq_3 eax_117 = fn00731D30(0x008DAD88, dwArg08, out edx_120, out esi_242, out edi_82);
	if (eax_117 == 0x00)
		eax_117 = fn0072FB30(dwArg04, dwArg08, es, ds, edi_82, out edx_120);
	edxOut = edx_120;
	return eax_117;
}

// 0072FC60: Register Eq_3 fn0072FC60(Stack Eq_3 dwArg04, Register out (ptr32 Eq_109320) ecxOut, Register out ptr32 edxOut)
// Called from:
//      fn0070BCC0
//      fn00715DF0
//      fn00716A00
Eq_3 fn0072FC60(Eq_3 dwArg04, struct Eq_109320 & ecxOut, ptr32 & edxOut)
{
	if (dwArg04 != 0x00)
	{
		Eq_3 eax_11 = *((word32) dwArg04 + 4);
		if (eax_11 == 0x00A26EF0 || fn006D5670(eax_11, 0x00A26EF0, out ecx, out edx) != 0x00)
		{
			Eq_3 eax_38 = *((word32) dwArg04 + 8);
			ecxOut = ecx;
			edxOut = edx;
			return eax_38;
		}
	}
	ecxOut = ecx;
	edxOut = edx;
	return 0x00;
}

// 0072FC90: Register Eq_3 fn0072FC90(Stack Eq_3 dwArg04)
// Called from:
//      fn0070BCC0
Eq_3 fn0072FC90(Eq_3 dwArg04)
{
	if (dwArg04 == 0x00)
		return 0x00;
	Eq_3 eax_11 = *((word32) dwArg04 + 4);
	if (eax_11 != 0x00A26EF0)
	{
		word32 ecx_78;
		word32 edx_79;
		if (fn006D5670(eax_11, 0x00A26EF0, out ecx_78, out edx_79) == 0x00)
			return 0x00;
	}
	return *((word32) dwArg04 + 0x0C);
}

