// sho_text_002F.c
// Generated by decompiling sho.exe
// using Reko decompiler version 0.10.0.0.

#include "sho.h"

// 006F1A70: Register word32 fn006F1A70(Register out ptr32 ecxOut, Register out ptr32 edxOut)
// Called from:
//      fn006D9ED0
//      fn006DF760
//      fn006DF800
//      fn006F6D50
//      fn006F6EA0
//      fn006F9120
//      fn006FE400
//      fn00725010
//      fn00729D20
//      fn0072A5D0
//      fn0072C510
//      fn0072DD60
//      fn0072E790
//      fn0073B810
//      fn0073C100
//      fn0073C280
//      fn0073C520
//      fn0073C870
//      fn0073CAE0
//      fn0073CE00
//      fn0073E050
//      fn0073E390
//      fn0073FAF0
//      fn0073FC30
//      fn00740060
//      fn00748090
//      fn00748310
//      fn00748810
//      fn00748D30
//      fn00749820
//      fn00752CA0
word32 fn006F1A70(ptr32 & ecxOut, ptr32 & edxOut)
{
	word32 ecx_60;
	word32 edx_61;
	if (fn006ECAC0(dwArg04, out ecx_60, out edx_61) == 0x00)
		return;
	word32 edx_62;
	fn006EC890(fp - 0x04, out edx_62);
	return;
}

// 006F1AA0: Register Eq_3 fn006F1AA0(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08)
// Called from:
//      fn006E15D0
//      fn006F2070
Eq_3 fn006F1AA0(Eq_3 dwArg04, Eq_3 dwArg08)
{
	Eq_3 edi_250;
	Eq_3 esi_136 = dwArg04;
	Eq_3 edi_100 = 0x00;
	if (*dwArg04 != 0x00)
	{
		struct Eq_69610 * ebp_102 = (word32) dwArg08 - 4;
		do
		{
			if (*esi_136 == 0x25)
			{
				do
				{
					byte al_33 = *((word32) esi_136 + 1);
					esi_136 = (word32) esi_136 + 1;
				} while (al_33 != 0x00 && (al_33 != 0x25 && isalpha((word32) al_33) == 0x00));
				byte al_51 = *esi_136;
				if (al_51 == 0x6C || al_51 == 122)
				{
					byte al_58 = *((word32) esi_136 + 1);
					if (al_58 == 100 || al_58 == 117)
						esi_136 = (word32) esi_136 + 1;
				}
				Eq_69644 eax_69 = (int32) *esi_136;
				if (eax_69 > 0x78)
				{
l006F1B4F:
					Eq_3 eax_118 = esi_136;
					struct Eq_69717 * edx_119 = (word32) esi_136 + 1;
					do
					{
						eax_118 = (word32) eax_1523 + 1;
						eax_1523 = eax_118;
					} while (*eax_1523 != 0x00);
					edi_100 = (word32) edi_100 + (eax_118 - edx_119);
					break;
				}
				switch ((word32) eax_69)
				{
				case 0x25:
					goto l006F1B1A;
				case 0x26:
				case 0x27:
				case 0x28:
				case 0x29:
				case 0x2A:
				case 0x2B:
				case 44:
				case 0x2D:
				case 0x2E:
				case 0x2F:
				case 0x30:
				case 0x31:
				case 0x32:
				case 0x33:
				case 0x34:
				case 0x35:
				case 0x36:
				case 55:
				case 0x38:
				case 0x39:
				case 0x3A:
				case 0x3B:
				case 0x3C:
				case 0x3D:
				case 0x3E:
				case 0x3F:
				case 0x40:
				case 0x41:
				case 66:
				case 0x43:
				case 0x44:
				case 0x45:
				case 0x46:
				case 0x47:
				case 0x48:
				case 0x49:
				case 0x4A:
				case 0x4B:
				case 0x4C:
				case 77:
				case 0x4E:
				case 0x4F:
				case 0x50:
				case 0x51:
				case 0x52:
				case 0x53:
				case 0x54:
				case 0x55:
				case 0x56:
				case 0x57:
				case 88:
				case 0x59:
				case 0x5A:
				case 0x5B:
				case 0x5C:
				case 0x5D:
				case 0x5E:
				case 0x5F:
				case 0x60:
				case 0x61:
				case 0x62:
				case 101:
				case 0x66:
				case 0x67:
				case 0x68:
				case 0x6A:
				case 0x6B:
				case 0x6C:
				case 0x6D:
				case 110:
				case 111:
				case 113:
				case 114:
				case 116:
				case 118:
				case 0x77:
					goto l006F1B4F;
				case 99:
					++ebp_102;
					goto l006F1B1A;
				case 100:
				case 0x69:
				case 117:
				case 0x78:
					++ebp_102;
					edi_100 = (word32) edi_100 + 20;
					break;
				case 0x70:
					++ebp_102;
					edi_100 = (word32) edi_100 + 19;
					break;
				case 115:
					byte * eax_80 = ebp_102[1];
					++ebp_102;
					eax_84 = eax_80;
					do
					{
						byte * eax_84;
						eax_84 = eax_1522 + 1;
						eax_1522 = eax_84;
					} while (*eax_1522 != 0x00);
					edi_100 = (word32) edi_100 + (eax_84 - (eax_80 + 1));
					break;
				}
			}
			else
			{
l006F1B1A:
				edi_100 = (word32) edi_100 + 1;
			}
			esi_136 = (word32) esi_136 + 1;
		} while (*esi_136 != 0x00);
		if (edi_100 != 0x00)
		{
l006F1B79:
			word32 ecx_1511;
			word32 edx_1512;
			Eq_3 eax_176 = fn00723860((word32) edi_100 + 24, out ecx_1511, out edx_1512);
			if (eax_176 == 0x00)
			{
				word32 ecx_1513;
				word32 edx_1514;
				edi_250 = fn006E1210(out ecx_1513, out edx_1514);
			}
			else
			{
				*((word32) eax_176 + 8) = edi_100;
				((word32) eax_176 + 4)->u0 = 0x00A1B450;
				*eax_176 = 0x01;
				((word32) eax_176 + 0x0C)->u0 = ~0x00;
				((word32) eax_176 + 16)->u0 = 0x00;
				*((word32) edi_100 + ((word32) eax_176 + 20)) = 0x00;
				if (edi_100 == 0x00)
				{
					word32 edx_1518;
					fn006EC890(fp - 0x10, out edx_1518);
					*eax_176 = (word32) *eax_176 + 1;
					g_tA6C63C = eax_176;
				}
				edi_250 = eax_176;
			}
l006F1BE0:
			if (edi_250 == 0x00)
				return 0x00;
			Eq_3 esi_291;
			Eq_3 eax_272 = *((word32) edi_250 + 4);
			if (eax_272 != 0x00A1B450)
			{
				word32 edx_1516;
				word32 ecx_1515;
				if (fn006D5670(eax_272, 0x00A1B450, out ecx_1515, out edx_1516) == 0x00)
				{
					word32 edx_1517;
					esi_291 = ~(0x00 - (fn006EA420(edi_250, dwArg04, dwArg08, out edx_1517) == 0x00)) & dwLoc08;
l006F1C32:
					Eq_3 edi_860;
					struct Eq_69762 * esp_323 = fp - 0x20;
					Eq_3 ebp_327 = dwArg04;
					edi_860 = edi_250;
					if (*dwArg04 != 0x00)
					{
						struct Eq_69829 * ebx_331 = (word32) dwArg08 - 4;
						do
						{
							byte al_335 = *ebp_327;
							if (al_335 == 0x25)
							{
								Eq_3 eax_340 = (word32) *((word32) ebp_327 + 1);
								esp_323[6] = (struct Eq_69762) ebp_327;
								struct Eq_69856 * esp_345 = esp_323 - 4;
								esp_345->t0000 = eax_340;
								esp_345->dw0028 = 0x00;
								esp_345->dw002C = 0x00;
								ebp_327 = (word32) ebp_327 + 1;
								Eq_3 edi_344 = 0x00;
								if (isdigit(esp_345->t0000) != 0x00)
								{
									edi_344.u0 = 0x00;
									do
									{
										int32 edx_357 = (int32) *ebp_327;
										union Eq_3 * esp_363 = esp_323 - 4;
										*esp_363 = (word32) *((word32) ebp_327 + 1);
										ebp_327 = (word32) ebp_327 + 1;
										edi_344 = edx_357 - 0x30 + edi_344 * 0x0A;
									} while (isdigit(*esp_363) != 0x00);
								}
								if (*ebp_327 == 0x2E)
								{
									union Eq_3 * esp_378 = esp_323 - 4;
									*esp_378 = (word32) *((word32) ebp_327 + 1);
									ebp_327 = (word32) ebp_327 + 1;
									edi_344.u0 = 0x00;
									if (isdigit(*esp_378) != 0x00)
									{
										do
										{
											int32 eax_389 = (int32) *ebp_327;
											union Eq_3 * esp_395 = esp_323 - 4;
											*esp_395 = (word32) *((word32) ebp_327 + 1);
											ebp_327 = (word32) ebp_327 + 1;
											edi_344 = eax_389 - 0x30 + edi_344 * 0x0A;
										} while (isdigit(*esp_395) != 0x00);
									}
								}
								byte al_405 = *ebp_327;
								if (al_405 != 0x00)
								{
									while (al_405 != 0x25)
									{
										union Eq_3 * esp_414 = esp_323 - 4;
										*esp_414 = (word32) al_405;
										if (isalpha(*esp_414) != 0x00)
											break;
										al_405 = (byte) *((word32) ebp_327 + 1);
										ebp_327 = (word32) ebp_327 + 1;
										if (al_405 == 0x00)
											break;
									}
								}
								word32 edx_441;
								if (*ebp_327 == 0x6C)
								{
									byte al_432 = *((word32) ebp_327 + 1);
									if (al_432 != 100 && al_432 != 117)
										goto l006F1D21;
									edx_441 = 0x01;
									ebp_327 = (word32) ebp_327 + 1;
								}
								else
								{
l006F1D21:
									edx_441 = (word32) esp_323[9];
								}
								word32 ecx_461;
								if (*ebp_327 == 122)
								{
									byte al_452 = *((word32) ebp_327 + 1);
									if (al_452 != 100 && al_452 != 117)
										goto l006F1D40;
									ecx_461 = 0x01;
									ebp_327 = (word32) ebp_327 + 1;
								}
								else
								{
l006F1D40:
									ecx_461 = (word32) esp_323[0x0A];
								}
								struct Eq_70036 * eax_470 = (int32) *ebp_327;
								if (eax_470 > (struct Eq_70036 *) 0x78)
								{
l006F1F38:
									struct Eq_70043 * eax_793 = esp_323[6];
									struct Eq_70047 * edx_796 = esi_291 - eax_793;
									do
									{
										byte cl_800 = eax_793->b0000;
										Mem802[edx_796 + eax_793:byte] = cl_800;
										++eax_793;
									} while (cl_800 != 0x00);
									Eq_3 eax_808 = esi_291;
									Eq_70522 edx_809 = (word32) esi_291 + 1;
									do
									{
										eax_808 = (word32) eax_1531 + 1;
										eax_1531 = eax_808;
									} while (*eax_1531 != 0x00);
									esi_291 += eax_808 - edx_809;
									break;
								}
								switch ((word32) eax_470->b6F1FEF)
								{
								case 0x00:
									*esi_291 = 0x25;
									goto l006F1F26;
								case 0x01:
								case 0x02:
								case 0x03:
								case 0x04:
								case 0x05:
								case 0x06:
								case 0x07:
								case 0x08:
								case 0x09:
								case 0x0A:
								case 11:
								case 0x0C:
								case 0x0D:
								case 0x0E:
								case 0x0F:
								case 0x10:
								case 0x11:
								case 0x12:
								case 0x13:
								case 0x14:
								case 0x15:
								case 22:
								case 0x17:
								case 0x18:
								case 0x19:
								case 0x1A:
								case 0x1B:
								case 0x1C:
								case 0x1D:
								case 0x1E:
								case 0x1F:
								case 0x20:
								case 33:
								case 0x22:
								case 0x23:
								case 0x24:
								case 0x25:
								case 0x26:
								case 0x27:
								case 0x28:
								case 0x29:
								case 0x2A:
								case 0x2B:
								case 44:
								case 0x2D:
								case 0x2E:
								case 0x2F:
								case 0x30:
								case 0x31:
								case 0x32:
								case 0x33:
								case 0x34:
								case 0x35:
								case 0x36:
								case 55:
								case 0x38:
								case 0x39:
								case 0x3A:
								case 0x3B:
								case 0x3C:
								case 0x3D:
								case 0x40:
								case 0x41:
								case 66:
								case 0x43:
								case 0x45:
								case 0x46:
								case 0x47:
								case 0x48:
								case 0x49:
								case 0x4A:
								case 0x4C:
								case 77:
								case 0x4F:
								case 0x51:
								case 0x52:
									goto l006F1F38;
								case 0x3E:
									*esi_291 = ebx_331[1];
									++ebx_331;
									goto l006F1F26;
								case 0x3F:
									word32 * esp_758;
									++ebx_331;
									if (edx_441 != 0x00)
									{
										struct Eq_70342 * esp_761 = esp_323 - 4;
										esp_761->t0000.u0 = ebx_331->b0000;
										esp_761->dwFFFFFFFC = 9260980;
										esp_758 = esp_761 - 4;
									}
									else
									{
										word32 * esp_752;
										if (ecx_461 != 0x00)
										{
											esp_752 = esp_323 - 4;
											*esp_752 = (word32) ebx_331->b0000;
										}
										else
										{
											esp_752 = esp_323 - 4;
											*esp_752 = (word32) ebx_331->b0000;
										}
										esp_758 = esp_752 - 4;
										*esp_758 = 0x008A8F48;
									}
									struct Eq_70357 * esp_766 = esp_758 - 4;
									esp_766->t0000 = esi_291;
									sprintf(esp_766->t0000, esp_766->t0004, esp_766->dw0008);
									Eq_3 eax_771 = esi_291;
									esp_323 = (struct Eq_69762 *) (&esp_766->dw0008 + 1);
									word32 edx_774 = esi_291 + 0x01;
									do
									{
										eax_771 = (word32) eax_1530 + 1;
										eax_1530 = eax_771;
									} while (*eax_1530 != 0x00);
									esi_291 += eax_771 - edx_774;
									break;
								case 0x44:
									struct Eq_70070 * esp_721 = esp_323 - 4;
									esp_721->t0000 = ebx_331[1];
									esp_721->tFFFFFFFC.u0 = 9260968;
									esp_721->tFFFFFFF8 = esi_291;
									sprintf(esp_721->tFFFFFFF8, esp_721->tFFFFFFFC, esp_721->t0000);
									++ebx_331;
									Eq_3 eax_728 = esi_291;
									esp_323 = (struct Eq_69762 *) ((const char *) &esp_721->t0000 + 4);
									word32 edx_731 = esi_291 + 0x01;
									do
									{
										eax_728 = (word32) eax_1529 + 1;
										eax_1529 = eax_728;
									} while (*eax_1529 != 0x00);
									esi_291 += eax_728 - edx_731;
									break;
								case 0x4B:
									struct Eq_70107 * esp_660 = esp_323 - 4;
									esp_660->t0000 = ebx_331[1];
									esp_660->tFFFFFFFC.u0 = 9260964;
									esp_660->tFFFFFFF8 = esi_291;
									sprintf(esp_660->tFFFFFFF8, esp_660->tFFFFFFFC, esp_660->t0000);
									++ebx_331;
									byte al_667 = *((word32) esi_291 + 1);
									if (al_667 != 88)
									{
										if (al_667 == 0x78)
											goto l006F1F04;
										Eq_3 eax_673 = esi_291;
										word32 edx_674 = esi_291 + 0x01;
										do
										{
											eax_673 = (word32) eax_1527 + 1;
											eax_1527 = eax_673;
										} while (*eax_1527 != 0x00);
										Mem688[esp_660 + 0x00:word32] = eax_673 - edx_674 + 0x01;
										esp_660->tFFFFFFFC = esi_291;
										Mem694[esp_660 + -8:word32] = esi_291 + 0x02;
										memmove(esp_660->tFFFFFFF8, esp_660->tFFFFFFFC, esp_660->t0000);
										*esi_291 = 0x30;
									}
									*((word32) esi_291 + 1) = 0x78;
l006F1F04:
									Eq_3 eax_702 = esi_291;
									word32 edx_703 = esi_291 + 0x01;
									do
									{
										eax_702 = (word32) eax_1528 + 1;
										eax_1528 = eax_702;
									} while (*eax_1528 != 0x00);
									esi_291 += eax_702 - edx_703;
									break;
								case 0x4E:
									Eq_3 ecx_576 = ebx_331[1];
									esp_323[9] = (struct Eq_69762) (ebx_331 + 1);
									Eq_3 eax_579 = ecx_576;
									do
									{
										eax_579 = (word32) eax_1526 + 1;
										eax_1526 = eax_579;
									} while (*eax_1526 != 0x00);
									Eq_3 eax_590 = eax_579 - ((word32) ecx_576 + 1);
									Eq_3 ebx_604 = eax_590;
									if (edi_344 > 0x00 && eax_590 > edi_344)
										ebx_604 = edi_344;
									if (ebx_604 >= 0x10)
									{
										struct Eq_70439 * esp_647 = esp_323 - 4;
										esp_647->t0000 = ebx_604;
										esp_647->tFFFFFFFC = ecx_576;
										esp_647->tFFFFFFF8 = esi_291;
										memcpy(esp_647->tFFFFFFF8, esp_647->tFFFFFFFC, esp_647->t0000);
										esp_323 = (struct Eq_69762 *) ((const char *) &esp_647->t0000 + 4);
										esi_291 += ebx_604;
										ebx_331 = esp_647->ptr0028;
									}
									else
									{
										if (ebx_604 > 0x00)
										{
											Eq_3 eax_617 = esi_291;
											Eq_70495 ecx_620 = ecx_576 - esi_291;
											Eq_3 edi_622 = ebx_604;
											do
											{
												Mem628[eax_617 + 0x00:byte] = Mem626[ecx_620 + eax_617:byte];
												eax_617 = (word32) eax_617 + 1;
												--edi_622;
											} while (edi_622 != 0x00);
										}
										esi_291 += ebx_604;
										ebx_331 = (struct Eq_69829 *) esp_323[9];
									}
									break;
								case 0x50:
									word32 * esp_547;
									++ebx_331;
									if (edx_441 != 0x00)
									{
										struct Eq_70226 * esp_550 = esp_323 - 4;
										esp_550->t0000.u0 = ebx_331->b0000;
										esp_550->dwFFFFFFFC = 9260976;
										esp_547 = esp_550 - 4;
									}
									else
									{
										word32 * esp_541;
										if (ecx_461 != 0x00)
										{
											esp_541 = esp_323 - 4;
											*esp_541 = (word32) ebx_331->b0000;
										}
										else
										{
											esp_541 = esp_323 - 4;
											*esp_541 = (word32) ebx_331->b0000;
										}
										esp_547 = esp_541 - 4;
										*esp_547 = 9260972;
									}
									struct Eq_70241 * esp_555 = esp_547 - 4;
									esp_555->t0000 = esi_291;
									sprintf(esp_555->t0000, esp_555->t0004, esp_555->dw0008);
									Eq_3 eax_560 = esi_291;
									esp_323 = (struct Eq_69762 *) (&esp_555->dw0008 + 1);
									word32 edx_563 = esi_291 + 0x01;
									do
									{
										eax_560 = (word32) eax_1525 + 1;
										eax_1525 = eax_560;
									} while (*eax_1525 != 0x00);
									esi_291 += eax_560 - edx_563;
									break;
								case 0x53:
									struct Eq_70159 * esp_492 = esp_323 - 4;
									esp_492->t0000 = ebx_331[1];
									esp_492->tFFFFFFFC.u0 = 0x008A8538;
									esp_492->tFFFFFFF8 = esi_291;
									sprintf(esp_492->tFFFFFFF8, esp_492->tFFFFFFFC, esp_492->t0000);
									++ebx_331;
									Eq_3 eax_511 = esi_291;
									esp_323 = (struct Eq_69762 *) ((const char *) &esp_492->t0000 + 4);
									word32 edx_514 = esi_291 + 0x01;
									do
									{
										eax_511 = (word32) eax_1524 + 1;
										eax_1524 = eax_511;
									} while (*eax_1524 != 0x00);
									esi_291 += eax_511 - edx_514;
									break;
								}
							}
							else
							{
								*esi_291 = al_335;
l006F1F26:
								esi_291 = (word32) esi_291 + 1;
							}
							ebp_327 = (word32) ebp_327 + 1;
						} while (*ebp_327 != 0x00);
						edi_860 = esp_323[4];
					}
					struct Eq_69807 * esp_872 = esp_323 - 4;
					esp_872->dw0000 = esi_291 - edi_860 - 0x14;
					esp_872->ptrFFFFFFFC = esp_323 + 5;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_3 stackArg4 = <invalid>;
					word32 edx_1521;
					word32 ecx_1520;
					fn006EC4F0(stackArg4, dwArg04, out ecx_1520, out edx_1521);
					return edi_250;
				}
			}
			esi_291 = (word32) edi_250 + 20;
			goto l006F1C32;
		}
	}
	Eq_3 eax_153 = g_tA6C63C;
	if (eax_153 != 0x00)
	{
		*eax_153 = (word32) *eax_153 + 1;
		edi_250 = eax_153;
		goto l006F1BE0;
	}
	goto l006F1B79;
}

// 006F2070: Register Eq_3 fn006F2070()
// Called from:
//      fn006DDEB0
//      fn00708C10
//      fn0072A520
//      fn007483C0
Eq_3 fn006F2070()
{
	return fn006F1AA0(dwArg04, fp + 0x08);
}

// 006F2090: Register Eq_3 fn006F2090(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Stack ui32 dwArg14, Register out Eq_70556 edxOut)
// Called from:
//      fn0073D450
Eq_3 fn006F2090(Eq_3 dwArg04, Eq_3 dwArg08, ui32 dwArg14, union Eq_70556 & edxOut)
{
	Eq_3 dwLoc0C_771;
	if (dwArg14 != 0x00)
		dwLoc0C_771 = dwArg08 * 0x04;
	else
		dwLoc0C_771 = dwArg08;
	Eq_3 eax_24;
	Eq_3 edi_20 = dwLoc0C_771;
	if (dwLoc0C_771 == 0x00)
	{
		eax_24 = g_tA6C63C;
		if (eax_24 != 0x00)
			goto l006F211A;
	}
	word32 ecx_1135;
	eax_24 = fn00723860((word32) dwLoc0C_771 + 24, out ecx_1135, out edx);
	if (eax_24 == 0x00)
	{
		word32 ecx_1136;
		eax_24 = fn006E1210(out ecx_1136, out edx);
l006F211D:
		if (eax_24 != 0x00)
		{
			word32 esi_1138;
			word32 ecx_1137;
			Eq_70556 edx_115;
			Eq_3 eax_113 = fn006ECC50(eax_24, out ecx_1137, out edx_115, out esi_1138);
			Eq_3 ebp_118 = dwArg04;
			word32 esi_119 = dwArg08 + dwArg04;
			struct Eq_70641 * esp_120 = fp - 0x28;
			Eq_3 ebx_123 = eax_113;
			if (dwArg04 < esi_119)
			{
				do
				{
					struct Eq_70641 * esp_234;
					Eq_3 edx_131;
					if (*ebp_118 == 0x5C)
					{
						Eq_3 ebp_132 = (word32) ebp_118 + 1;
						if (ebp_132 != esi_119)
						{
							struct Eq_70676 * eax_141 = (int32) *ebp_132;
							ebp_118 = (word32) ebp_132 + 1;
							if (eax_141 <= (struct Eq_70676 *) 0x78)
							{
								switch ((word32) eax_141->b6F24D6)
								{
								case 0x00:
									break;
								case 0x01:
								case 0x02:
								case 0x03:
								case 0x04:
								case 0x05:
								case 0x06:
								case 0x07:
								case 0x08:
								case 0x09:
								case 0x0A:
								case 11:
								case 0x0C:
								case 0x0D:
								case 0x0E:
								case 0x0F:
								case 0x10:
								case 0x11:
								case 0x12:
								case 0x13:
								case 0x14:
								case 0x15:
								case 22:
								case 0x17:
								case 0x19:
								case 0x1A:
								case 0x1B:
								case 0x1C:
								case 0x1E:
								case 0x1F:
								case 0x20:
								case 33:
								case 0x22:
								case 0x23:
								case 0x24:
								case 0x25:
								case 0x2E:
								case 0x2F:
								case 0x30:
								case 0x31:
								case 0x32:
								case 0x33:
								case 0x34:
								case 0x35:
								case 0x36:
								case 55:
								case 0x38:
								case 0x39:
								case 0x3A:
								case 0x3B:
								case 0x3C:
								case 0x3D:
								case 0x3E:
								case 0x3F:
								case 0x40:
								case 0x41:
								case 66:
								case 0x43:
								case 0x44:
								case 0x45:
								case 0x46:
								case 0x47:
								case 0x48:
								case 0x49:
								case 0x4A:
								case 0x4B:
								case 0x4C:
								case 77:
								case 0x4E:
								case 0x4F:
								case 0x50:
								case 0x51:
								case 0x53:
								case 0x54:
								case 0x55:
								case 0x56:
								case 0x59:
								case 0x5A:
								case 0x5B:
								case 0x5D:
								case 0x5E:
								case 0x5F:
								case 0x60:
								case 0x61:
								case 0x62:
								case 99:
								case 101:
								case 0x66:
								case 0x67:
								case 0x69:
								case 0x6B:
								case 0x6D:
									goto l006F235D;
								case 0x18:
									*ebx_123 = 0x22;
									ebx_123 = (word32) ebx_123 + 1;
									break;
								case 0x1D:
									*ebx_123 = 0x27;
									ebx_123 = (word32) ebx_123 + 1;
									break;
								case 0x26:
								case 0x27:
								case 0x28:
								case 0x29:
								case 0x2A:
								case 0x2B:
								case 44:
								case 0x2D:
									int32 eax_409 = (int32) *ebp_132;
									byte al_433 = (byte) (eax_409 - 0x30);
									if ((word32) ebp_132 + 1 < esi_119)
									{
										ci8 cl_414 = *((word32) ebp_132 + 1);
										if (cl_414 >= 0x30 && cl_414 <= 55)
										{
											int32 eax_422 = (int32) cl_414 - 0x30 + (eax_409 - 0x30) * 0x08;
											ebp_118 = (word32) ebp_132 + 2;
											al_433 = (byte) eax_422;
											if ((word32) ebp_132 + 2 < esi_119)
											{
												ci8 cl_424 = *((word32) ebp_132 + 2);
												if (cl_424 >= 0x30 && cl_424 <= 55)
												{
													edx_115.u0 = (int32) cl_424;
													al_433 = (byte) (edx_115 - 0x30 + eax_422 * 0x08);
													ebp_118 = (word32) ebp_132 + 3;
												}
											}
										}
									}
									*ebx_123 = al_433;
									ebx_123 = (word32) ebx_123 + 1;
									break;
								case 0x52:
									*ebx_123 = 0x5C;
									ebx_123 = (word32) ebx_123 + 1;
									break;
								case 0x57:
									*ebx_123 = 0x07;
									ebx_123 = (word32) ebx_123 + 1;
									break;
								case 88:
									*ebx_123 = 0x08;
									ebx_123 = (word32) ebx_123 + 1;
									break;
								case 0x5C:
									*ebx_123 = 0x0C;
									ebx_123 = (word32) ebx_123 + 1;
									break;
								case 100:
									*ebx_123 = 0x0A;
									ebx_123 = (word32) ebx_123 + 1;
									break;
								case 0x68:
									*ebx_123 = 0x0D;
									ebx_123 = (word32) ebx_123 + 1;
									break;
								case 0x6A:
									*ebx_123 = 0x09;
									ebx_123 = (word32) ebx_123 + 1;
									break;
								case 0x6C:
									*ebx_123 = 11;
									ebx_123 = (word32) ebx_123 + 1;
									break;
								case 110:
									if ((word32) ebp_132 + 2 >= esi_119)
									{
l006F22E8:
										edx_131 = esp_120[0x0D];
										if (edx_131 != 0x00)
										{
											byte * edi_173 = &g_b8D1DC8;
											Eq_3 esi_174 = edx_131;
											word32 ecx_175 = 0x07;
											bool v26_755 = true;
											while (ecx_175 != 0x00)
											{
												v26_755 = *esi_1147 == *edi_1148;
												esi_174 = (word32) esi_1147 + 1;
												edi_173 = edi_1148 + 1;
												--ecx_175;
												esi_1147 = esi_174;
												edi_1148 = edi_173;
												if (*esi_1147 == *edi_1148)
													break;
											}
											if (!v26_755)
											{
												byte * edi_236 = &g_b8D46D8;
												Eq_3 esi_239 = edx_131;
												word32 ecx_240 = 0x08;
												bool v30_759 = false;
												while (ecx_240 != 0x00)
												{
													v30_759 = *esi_1149 != *edi_1150;
													esi_239 = (word32) esi_1149 + 1;
													edi_236 = edi_1150 + 1;
													--ecx_240;
													esi_1149 = esi_239;
													edi_1150 = edi_236;
													if (*esi_1149 == *edi_1150)
														break;
												}
												if (!v30_759)
												{
													*ebx_123 = 0x3F;
													ebx_123 = (word32) ebx_123 + 1;
												}
												else
												{
													byte * edi_256 = &g_b8B056C;
													Eq_3 esi_259 = edx_131;
													word32 ecx_260 = 0x07;
													bool v34_763 = true;
													while (ecx_260 != 0x00)
													{
														v34_763 = *esi_1151 == *edi_1152;
														esi_259 = (word32) esi_1151 + 1;
														edi_256 = edi_1152 + 1;
														--ecx_260;
														esi_1151 = esi_259;
														edi_1152 = edi_256;
														if (*esi_1151 == *edi_1152)
															break;
													}
													if (!v34_763)
													{
														Eq_3 ecx_277 = g_tA17E2C;
														struct Eq_71099 * esp_282 = esp_120 - 4;
														esp_282->t0000 = edx_131;
														esp_282->dwFFFFFFFC = 0x008D4FE4;
														esp_282->tFFFFFFF8 = ecx_277;
														// Failed to bind call argument.
														// Please report this issue at https://github.com/uxmal/reko
														Eq_3 stackArg4 = <invalid>;
														word32 ecx_1140;
														fn006E15D0(stackArg4, dwArg04, out ecx_1140, out edx_115);
														esp_234 = (struct Eq_70641 *) ((const char *) &esp_282->t0000 + 4);
														goto l006F2489;
													}
												}
												esi_119 = esp_120[4];
												*ebx_123 = 0x5C;
												ebx_123 = (word32) ebx_123 + 1;
												ebp_118 = ebp_132;
												goto l006F2370;
											}
										}
										Eq_3 edx_193 = g_tA17E2C;
										struct Eq_70910 * esp_197 = esp_120 - 4;
										esp_197->dw0000 = 0x008D4FB8;
										esp_197->tFFFFFFFC = edx_193;
										goto l006F2481;
									}
									union Eq_3 * esp_152 = esp_120 - 4;
									*esp_152 = (word32) *((word32) ebp_132 + 1);
									if (isxdigit(*esp_152) == 0x00)
										goto l006F22E8;
									*esp_152 = (word32) *((word32) ebp_132 + 2);
									if (isxdigit(*esp_152) == 0x00)
										goto l006F22E8;
									ui32 edi_339;
									Eq_3 esi_324 = (word32) *((word32) ebp_132 + 1);
									*esp_152 = (union Eq_3 *) esi_324;
									if (isdigit(*esp_152) != 0x00)
										edi_339 = esi_324 - 0x30;
									else
									{
										*esp_152 = (union Eq_3 *) esi_324;
										edi_339 = esi_324 - 0x57;
										if (islower(*esp_152) == 0x00)
											edi_339 = esi_324 - 55;
									}
									Eq_3 esi_345 = (word32) *((word32) ebp_132 + 2);
									struct Eq_70844 * esp_347 = esp_120 - 4;
									esp_347->t0000 = esi_345;
									ui32 edi_350 = edi_339 << 0x04;
									ebp_118 = (word32) ebp_132 + 3;
									esp_120 = (struct Eq_70641 *) ((const char *) &esp_347->t0000 + 4);
									if (isdigit(esp_347->t0000) != 0x00)
									{
										esi_119 = esp_347->t0014;
										*ebx_123 = (byte) ((word32) esi_345 + (edi_350 - 0x30));
										ebx_123 = (word32) ebx_123 + 1;
									}
									else
									{
										esp_347->t0000 = esi_345;
										esp_120 = (struct Eq_70641 *) ((const char *) &esp_347->t0000 + 4);
										byte al_369 = (byte) ((word32) esi_345 + (edi_350 - 0x57));
										if (islower(esp_347->t0000) == 0x00)
											al_369 = (byte) ((word32) esi_345 + (edi_350 - 55));
										esi_119 = esp_347->t0014;
										*ebx_123 = al_369;
										ebx_123 = (word32) ebx_123 + 1;
									}
									break;
								}
								goto l006F2438;
							}
l006F235D:
							edx_131 = esp_120[0x0D];
							*ebx_123 = 0x5C;
							ebx_123 = (word32) ebx_123 + 1;
							ebp_118 = ebp_132;
							goto l006F2370;
						}
						Eq_3 eax_136 = g_tA17E2C;
						struct Eq_70666 * esp_137 = esp_120 - 4;
						esp_137->dw0000 = 0x008D4FCC;
						esp_137->tFFFFFFFC = eax_136;
l006F2481:
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_3 stackArg4 = <invalid>;
						word32 ecx_1144;
						fn006E0F80(stackArg4, dwArg04, out ecx_1144, out edx_115);
						esp_234 = esp_120;
l006F2489:
						struct Eq_71120 * eax_578 = esp_234[5];
						word32 v17_579 = eax_578->dw0000 + ~0x00;
						eax_578->dw0000 = v17_579;
						if (v17_579 == 0x00)
						{
							struct Eq_71136 * ecx_583 = eax_578->ptr0004;
							<anonymous> * edx_584 = ecx_583->ptr0018;
							esp_234->dwFFFFFFFC = eax_578;
							edx_584();
						}
						edxOut = edx_115;
						return 0x00;
					}
					edx_131 = esp_120[0x0D];
l006F2370:
					word24 edx_24_8_895 = SLICE(edx_131, word24, 8);
					int32 edi_459 = esp_120[0x0F];
					if (edi_459 != 0x00 && (*ebp_118 & 0x80) != 0x00)
					{
						esp_120[6] = (struct Eq_70641) ebp_118;
						Eq_3 eax_479 = ebp_118;
						if (ebp_118 < esi_119)
						{
							while ((*eax_479 & 0x80) != 0x00)
							{
								eax_479 = (word32) eax_479 + 1;
								if (eax_479 >= esi_119)
									break;
							}
							esp_120[6] = (struct Eq_70641) eax_479;
						}
						struct Eq_71027 * esp_496 = esp_120 - 4;
						esp_496->t0000 = edx_131;
						esp_496->dwFFFFFFFC = eax_479 - ebp_118;
						esp_496->tFFFFFFF8 = ebp_118;
						Eq_3 eax_528 = fn0071FC80(out edx_115);
						esp_234 = (struct Eq_70641 *) ((const char *) &esp_496->t0000 + 4);
						if (eax_528 == 0x00)
							goto l006F2489;
						esp_496->t0000 = esp_496->t0038;
						esp_496->dwFFFFFFFC = edi_459;
						esp_496->tFFFFFFF8 = eax_528;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_3 stackArg4 = <invalid>;
						word32 ecx_1142;
						Eq_3 eax_546 = fn0071FB20(stackArg4, dwArg04, dwArg08, out ecx_1142, out edx_115);
						word32 v18_552 = (word32) *eax_528 - 1;
						*eax_528 = v18_552;
						esp_234 = (struct Eq_70641 *) ((const char *) &esp_496->t0000 + 4);
						if (v18_552 == 0x00)
						{
							Eq_3 edx_557 = *((word32) eax_528 + 4);
							struct Eq_58241 * eax_558 = *((word32) edx_557 + 24);
							esp_496->t0000 = eax_528;
							word32 esp_561;
							word32 ecx_563;
							eax_558();
							esp_234 = esp_561 + 0x04;
						}
						word24 edx_24_8_900 = SLICE(edx_115, word24, 8);
						if (eax_546 == 0x00)
							goto l006F2489;
						Eq_3 ebp_617 = *((word32) eax_546 + 8);
						if (ebp_617 >= 0x10)
						{
							struct Eq_71206 * esp_639 = esp_234 - 4;
							esp_639->t0000 = ebp_617;
							Mem642[esp_639 + -4:word32] = eax_546 + 0x14;
							esp_639->tFFFFFFF8 = ebx_123;
							memcpy(esp_639->tFFFFFFF8, esp_639->tFFFFFFFC, esp_639->t0000);
						}
						else if (ebp_617 > 0x00)
						{
							Eq_3 eax_625 = ebx_123;
							word32 esi_626 = eax_546 + 0x14 - ebx_123;
							Eq_3 ecx_628 = ebp_617;
							do
							{
								byte dl_632 = *((word32) eax_625 + esi_626);
								*eax_625 = dl_632;
								eax_625 = (word32) eax_625 + 1;
								--ecx_628;
								edx_115 = SEQ(edx_24_8_900, dl_632);
							} while (ecx_628 != 0x00);
						}
						Eq_70556 edx_672;
						word32 v22_656 = (word32) *eax_546 - 1;
						*eax_546 = v22_656;
						esp_120 = esp_234;
						ebx_123 += ebp_617;
						if (v22_656 == 0x00)
						{
							Eq_3 eax_660 = *((word32) eax_546 + 4);
							struct Eq_58241 * ecx_661 = *((word32) eax_660 + 24);
							esp_234->dwFFFFFFFC = (word32) eax_546;
							word32 esp_669;
							word32 ecx_671;
							ecx_661();
							esp_120 = esp_669 + 0x04;
							edx_115 = edx_672;
						}
						ebp_118 = esp_120[6];
						esi_119 = esp_120[4];
					}
					else
					{
						byte dl_469 = *ebp_118;
						*ebx_123 = dl_469;
						ebx_123 = (word32) ebx_123 + 1;
						ebp_118 = (word32) ebp_118 + 1;
						edx_115 = SEQ(edx_24_8_895, dl_469);
					}
l006F2438:
				} while (ebp_118 < esi_119);
				edi_20 = esp_120[7];
				eax_113 = esp_120[9];
			}
			Eq_3 ebx_700 = ebx_123 - eax_113;
			if (ebx_700 < edi_20)
			{
				struct Eq_71336 * esp_706 = esp_120 - 4;
				esp_706->t0000 = ebx_700;
				esp_706->ptrFFFFFFFC = esp_120 + 8;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_3 stackArg4 = <invalid>;
				word32 ecx_1146;
				fn006EC4F0(stackArg4, dwArg04, out ecx_1146, out edx_115);
			}
			edxOut = edx_115;
			return eax_24;
		}
		else
		{
			edxOut = edx;
			return eax_24;
		}
	}
	*((word32) eax_24 + 8) = dwLoc0C_771;
	((word32) eax_24 + 4)->u0 = 0x00A1B450;
	*eax_24 = 0x01;
	((word32) eax_24 + 0x0C)->u0 = ~0x00;
	((word32) eax_24 + 16)->u0 = 0x00;
	*((word32) dwLoc0C_771 + ((word32) eax_24 + 20)) = 0x00;
	if (dwLoc0C_771 != 0x00)
		goto l006F211D;
	fn006EC890(fp - 0x10, out edx);
	g_tA6C63C = eax_24;
l006F211A:
	*eax_24 = (word32) *eax_24 + 1;
	goto l006F211D;
}

// 006F2590: Register word32 fn006F2590(Register Eq_3 ebx, Register Eq_3 esi, Register out Eq_3 ecxOut)
// Called from:
//      fn006F29C0
//      fn006F31C0
//      fn006F3930
word32 fn006F2590(Eq_3 ebx, Eq_3 esi, union Eq_3 & ecxOut)
{
	Eq_3 eax_6 = *((word32) ebx + 16);
	if (eax_6 < esi || esi < eax_6 >> 0x01)
	{
		uint32 eax_34 = ((uint32) (int8) (esi >= 0x09) - 0x01 & ~0x02) + 0x06 + (esi >> 0x03);
		if (eax_34 <= ~0x00 - esi)
		{
			Eq_3 edi_38 = (word32) esi + eax_34;
			if (esi == 0x00)
				edi_38.u0 = 0x00;
			Eq_3 ecx_50 = *((word32) ebx + 0x0C);
			if (edi_38 <= 0x3FFFFFFF)
			{
				Eq_3 eax_52 = edi_38 * 0x04;
				if (eax_52 == 0x00)
					eax_52.u0 = 0x01;
				Eq_3 eax_65 = realloc(ecx_50, eax_52);
				if (eax_65 != 0x00)
				{
					*((word32) ebx + 0x0C) = eax_65;
					*((word32) ebx + 16) = edi_38;
					*((word32) ebx + 8) = esi;
					ecxOut = ecx_50;
					return 0x00;
				}
			}
		}
		Eq_3 ecx_95;
		word32 edx_138;
		fn006E1210(out ecx_95, out edx_138);
		ecxOut = ecx_95;
		return ~0x00;
	}
	else
	{
		*((word32) ebx + 8) = esi;
		ecxOut = ecx;
		return 0x00;
	}
}

// 006F2610: void fn006F2610()
// Called from:
//      fn006E8910
void fn006F2610()
{
	ui32 eax_10 = g_dwA6CB80;
	if (eax_10 != 0x00)
	{
		union Eq_3 * esp_15 = fp;
		do
		{
			ui32 eax_11 = eax_10 - 0x01;
			g_dwA6CB80 = eax_11;
			union Eq_3 * esp_16 = esp_15 - 4;
			*esp_16 = (union Eq_3 *) *((const char *) &g_ptrA6CA40 + eax_11 * 0x04);
			fn006FEFD0(*esp_16);
			eax_10 = g_dwA6CB80;
			esp_15 = esp_16;
		} while (eax_10 != 0x00);
	}
}

// 006F2650: Register Eq_3 fn006F2650(Stack Eq_3 dwArg04, Register out Eq_3 edxOut)
// Called from:
//      fn006E54A0
//      fn006E9B00
//      fn006F2EA0
//      fn006FE2A0
//      fn007035C0
//      fn00708DC0
//      fn0072E790
//      fn007367D0
//      fn007373A0
//      fn00737410
//      fn00740CC0
//      fn00747330
//      fn00748670
//      fn0074E980
Eq_3 fn006F2650(Eq_3 dwArg04, union Eq_3 & edxOut)
{
	if (dwArg04 >= 0x00)
	{
		if (dwArg04 <= 0x3FFFFFFF)
		{
			Eq_3 esi_32;
			ui32 eax_17 = g_dwA6CB80;
			if (eax_17 != 0x00)
			{
				esi_32 = *((const char *) g_aA6CA3C + eax_17 * 0x04);
				g_dwA6CB80 = eax_17 - 0x01;
				*esi_32 = 0x01;
			}
			else
			{
				Eq_3 edx_28;
				word32 ecx_254;
				Eq_3 eax_27 = fn006FEF30(&g_tA1BAF0, out ecx_254, out edx_28);
				esi_32 = eax_27;
				if (eax_27 == 0x00)
				{
					edxOut = edx_28;
					return eax_27;
				}
			}
			if (dwArg04 <= 0x00)
				((word32) esi_32 + 0x0C)->u0 = 0x00;
			else
			{
				Eq_3 eax_54 = dwArg04 * 0x04;
				if (dwArg04 * 0x04 == 0x00)
					eax_54.u0 = 0x01;
				Eq_3 eax_62 = malloc(eax_54);
				*((word32) esi_32 + 0x0C) = eax_62;
				if (eax_62 == 0x00)
				{
					word32 v15_80 = (word32) *esi_32 - 1;
					*esi_32 = v15_80;
					if (v15_80 == 0x00)
					{
						Eq_3 eax_84 = *((word32) esi_32 + 4);
						(*((word32) eax_84 + 24))();
					}
					Eq_3 edx_110;
					word32 ecx_255;
					Eq_3 eax_109 = fn006E1210(out ecx_255, out edx_110);
					edxOut = edx_110;
					return eax_109;
				}
				memset(eax_62, 0x00, dwArg04 * 0x04);
			}
			*((word32) esi_32 + 8) = dwArg04;
			*((word32) esi_32 + 16) = dwArg04;
			Eq_3 edi_120 = esi_32 - 0x10;
			if (*((word32) esi_32 - 8) != ~0x01)
				fn006E86F0(0x008D0E04);
			*((word32) edi_120 + 8) = ~0x02;
			Eq_3 edx_134 = g_tA1D558;
			*edi_120 = edx_134;
			Eq_3 eax_137 = *((word32) g_tA1D558 + 4);
			*((word32) edi_120 + 4) = eax_137;
			*eax_137 = edi_120;
			*((word32) g_tA1D558 + 4) = edi_120;
			edxOut = edx_134;
			return esi_32;
		}
		else
		{
			Eq_3 edx_157;
			word32 ecx_253;
			Eq_3 eax_156 = fn006E1210(out ecx_253, out edx_157);
			edxOut = edx_157;
			return eax_156;
		}
	}
	else
	{
		Eq_3 edx_167;
		fn006E1DC0(out edx_167);
		edxOut = edx_167;
		return 0x00;
	}
}

// 006F2750: Register Eq_3 fn006F2750(Stack Eq_3 dwArg04, Register out Eq_3 ecxOut, Register out ptr32 edxOut)
// Called from:
//      fn006F6AF0
//      fn006F7890
//      fn00726260
//      fn0072F830
//      fn0074EB10
Eq_3 fn006F2750(Eq_3 dwArg04, union Eq_3 & ecxOut, ptr32 & edxOut)
{
	Eq_3 eax_8 = *((word32) dwArg04 + 4);
	if (eax_8 == 0x00A1BAF0 || fn006D5670(eax_8, 0x00A1BAF0, out ecx, out edx) != 0x00)
	{
		Eq_3 eax_28 = *((word32) dwArg04 + 8);
		ecxOut = ecx;
		edxOut = edx;
		return eax_28;
	}
	else
	{
		ptr32 edx_40;
		ecxOut = fn006E1DC0(out edx_40);
		edxOut = edx_40;
		return ~0x00;
	}
}

// 006F2790: Register word32 fn006F2790(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Register out Eq_3 ecxOut, Register out ptr32 edxOut)
// Called from:
//      fn006F6AF0
//      fn006F7890
//      fn0072F830
//      fn0074EB10
word32 fn006F2790(Eq_3 dwArg04, Eq_3 dwArg08, union Eq_3 & ecxOut, ptr32 & edxOut)
{
	Eq_3 eax_8 = *((word32) dwArg04 + 4);
	if (eax_8 != 0x00A1BAF0)
	{
		word32 ecx_142;
		if (fn006D5670(eax_8, 0x00A1BAF0, out ecx_142, out edx) == 0x00)
		{
			ptr32 edx_87;
			ecxOut = fn006E1DC0(out edx_87);
			edxOut = edx_87;
			return 0x00;
		}
	}
	if (dwArg08 < 0x00 || dwArg08 >= *((word32) dwArg04 + 8))
	{
		Eq_3 eax_36 = g_tA6CB84;
		if (eax_36 == 0x00)
		{
			word32 ecx_143;
			word32 edx_144;
			eax_36 = fn006ECAC0(0x008D5090, out ecx_143, out edx_144);
			g_tA6CB84 = eax_36;
		}
		Eq_3 ecx_64;
		ptr32 edx_65;
		fn006E0E90(g_tA17CA4, eax_36, out ecx_64, out edx_65);
		ecxOut = ecx_64;
		edxOut = edx_65;
		return 0x00;
	}
	else
	{
		Eq_3 ecx_76 = *((word32) dwArg04 + 0x0C);
		word32 eax_77 = *((word32) ecx_76 + dwArg08 * 0x04);
		ecxOut = ecx_76;
		edxOut = edx;
		return eax_77;
	}
}

// 006F29C0: Register Eq_3 fn006F29C0(Register Eq_3 eax, Stack Eq_3 dwArg04, Register out Eq_3 ecxOut, Register out Eq_540 edxOut)
// Called from:
//      fn006F2A10
//      fn006F3930
Eq_3 fn006F29C0(Eq_3 eax, Eq_3 dwArg04, union Eq_3 & ecxOut, union Eq_540 & edxOut)
{
	Eq_3 ecx_25;
	Eq_3 edi_16 = *((word32) eax + 8);
	if (edi_16 == 0x7FFFFFFF)
	{
		word32 edx_106;
		fn006E0F80(g_tA18598, 0x008D50CC, out ecx_25, out edx_106);
	}
	else if (fn006F2590(eax, (word32) edi_16 + 1, out ecx_25) != ~0x00)
	{
		*dwArg04 = (word32) *dwArg04 + 1;
		Eq_3 ecx_34 = *((word32) eax + 0x0C);
		*((word32) ecx_34 + edi_16 * 0x04) = dwArg04;
		ecxOut = ecx_34;
		edxOut.u0 = <invalid>;
		return 0x00;
	}
	ecxOut = ecx_25;
	edxOut.u0 = <invalid>;
	return ~0x00;
}

// 006F2A10: Register int32 fn006F2A10(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Register out Eq_3 ecxOut, Register out (ptr32 Eq_59919) edxOut)
// Called from:
//      fn006E54A0
//      fn006FE2A0
//      fn006FE380
//      fn00708DC0
//      fn007264A0
//      fn00726570
//      fn00726760
//      fn00726930
//      fn00728E40
//      fn007367D0
//      fn00740DF0
//      fn00748090
//      fn00748190
int32 fn006F2A10(Eq_3 dwArg04, Eq_3 dwArg08, union Eq_3 & ecxOut, struct Eq_59919 & edxOut)
{
	Eq_3 eax_8 = *((word32) dwArg04 + 4);
	if (eax_8 != 0x00A1BAF0)
	{
		word32 ecx_103;
		word32 edx_104;
		if (fn006D5670(eax_8, 0x00A1BAF0, out ecx_103, out edx_104) == 0x00)
		{
l006F2A46:
			struct Eq_59919 * edx_45;
			ecxOut = fn006E1DC0(out edx_45);
			edxOut = edx_45;
			return ~0x00;
		}
	}
	if (dwArg08 != 0x00)
	{
		Eq_3 ecx_59;
		struct Eq_59919 * edx_60;
		int32 eax_57 = fn006F29C0(dwArg04, dwArg08, out ecx_59, out edx_60);
		ecxOut = ecx_59;
		edxOut = edx_60;
		return eax_57;
	}
	goto l006F2A46;
}

// 006F2EA0: Register word32 fn006F2EA0(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Stack Eq_3 dwArg0C)
// Called from:
//      fn006F31C0
word32 fn006F2EA0(Eq_3 dwArg04, Eq_3 dwArg08, Eq_3 dwArg0C)
{
	Eq_3 esi_11 = dwArg08;
	if (dwArg08 < 0x00)
		esi_11.u0 = 0x00;
	else
	{
		Eq_3 eax_18 = *((word32) dwArg04 + 8);
		if (dwArg08 > eax_18)
			esi_11 = eax_18;
	}
	Eq_3 eax_27 = dwArg0C;
	if (dwArg0C < esi_11)
		eax_27 = esi_11;
	else
	{
		Eq_3 ecx_32 = *((word32) dwArg04 + 8);
		if (dwArg0C > ecx_32)
			eax_27 = ecx_32;
	}
	Eq_3 eax_39 = eax_27 - esi_11;
	Eq_3 edi_41 = eax_39;
	word32 edx_149;
	Eq_3 eax_49 = fn006F2650(eax_39, out edx_149);
	if (eax_49 == 0x00)
		return;
	Eq_3 edx_61 = *((word32) eax_49 + 0x0C);
	word32 esi_62 = (word32) *((word32) dwArg04 + 0x0C) + esi_11 * 0x04;
	if (eax_39 > 0x00)
	{
		ptr32 esi_63 = esi_62 - edx_61;
		do
		{
			word32 * ecx_68 = *((word32) edx_61 + esi_63);
			++*ecx_68;
			*edx_61 = ecx_68;
			edx_61 = (word32) edx_61 + 4;
			--edi_41;
		} while (edi_41 != 0x00);
	}
	return;
}

// 006F3150: void fn006F3150(Stack Eq_3 dwArg04)
// Called from:
//      fn006F31C0
void fn006F3150(Eq_3 dwArg04)
{
	Eq_3 edi_9 = *((word32) dwArg04 + 0x0C);
	if (edi_9 != 0x00)
	{
		Eq_3 esi_16 = *((word32) dwArg04 + 8);
		((word32) dwArg04 + 8)->u0 = 0x00;
		((word32) dwArg04 + 0x0C)->u0 = 0x00;
		((word32) dwArg04 + 16)->u0 = 0x00;
		struct Eq_71856 * esp_13 = fp - 8;
		int32 esi_17 = esi_16 - 0x01;
		if (esi_16 >= 0x01)
		{
			do
			{
				if (*((word32) edi_9 + esi_17 * 0x04) != null)
				{
					struct Eq_71879 * eax_30 = *((word32) edi_9 + esi_17 * 0x04);
					eax_30->dw0000 += ~0x00;
					struct Eq_71879 * eax_33 = *((word32) edi_9 + esi_17 * 0x04);
					if (eax_33->dw0000 == 0x00)
					{
						struct Eq_71900 * ecx_36 = eax_33->ptr0004;
						<anonymous> * edx_37 = ecx_36->ptr0018;
						esp_13->ptrFFFFFFFC = eax_33;
						word32 esp_43;
						word32 edx_46;
						edx_37();
						esp_13 = esp_43 + 0x04;
					}
				}
				--esi_17;
			} while (esi_17 >= 0x00);
		}
		union Eq_3 * esp_57 = esp_13 - 4;
		*esp_57 = (union Eq_3 *) edi_9;
		free(*esp_57);
	}
}

// 006F31C0: void fn006F31C0(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Stack Eq_3 dwArg0C, Stack Eq_3 dwArg10)
// Called from:
//      fn006F31C0
//      fn006F34B0
void fn006F31C0(Eq_3 dwArg04, Eq_3 dwArg08, Eq_3 dwArg0C, Eq_3 dwArg10)
{
	Eq_3 dwLoc38_540 = fp - 0x20;
	struct Eq_71928 * edx_19 = null;
	union Eq_71930 * dwLoc30_543 = null;
	if (dwArg10 == 0x00)
	{
		dwArg10.u0 = 0x00;
		goto l006F32C6;
	}
	if (dwArg04 == dwArg10)
	{
		Eq_3 eax_109 = fn006F2EA0(dwArg10, 0x00, *((word64) dwArg10.u0 + 8));
		if (eax_109 == 0x00)
			return;
		fn006F31C0(dwArg04, dwArg04, dwArg0C, eax_109);
		word32 v15_135 = (word32) *eax_109 - 1;
		*eax_109 = v15_135;
		if (v15_135 == 0x00)
		{
			Eq_3 ecx_140 = *((word32) eax_109 + 4);
			(*((word32) ecx_140 + 24))();
		}
		return;
	}
	struct Eq_71928 * eax_35 = fn00704DA0(dwArg10);
	if (eax_35 == null)
		return;
	Eq_3 eax_45 = eax_35->t0004;
	if (eax_45 != 0x00A1BAF0)
	{
		word32 ecx_844;
		word32 edx_845;
		if (fn006D5670(eax_45, 0x00A1BAF0, out ecx_844, out edx_845) == 0x00)
		{
l006F3294:
			Eq_3 eax_72 = eax_35->t0004;
			if (eax_72 != 0x00A1BAF0)
			{
				word32 ecx_848;
				word32 edx_849;
				if (fn006D5670(eax_72, 0x00A1BAF0, out ecx_848, out edx_849) == 0x00)
				{
					edx_19 = eax_35;
					dwLoc30_543 = (union Eq_71930 *) &eax_35->ptr000C;
l006F32C6:
					Eq_3 ecx_180 = dwArg08;
					if (dwArg08 < 0x00)
					{
						dwArg08.u0 = 0x00;
						ecx_180.u0 = 0x00;
					}
					else
					{
						Eq_3 eax_191 = *((word32) dwArg04 + 8);
						if (dwArg08 > eax_191)
						{
							dwArg08 = eax_191;
							ecx_180 = eax_191;
						}
					}
					Eq_3 ebp_200 = dwArg0C;
					if (dwArg0C < ecx_180)
						ebp_200 = ecx_180;
					else
					{
						Eq_3 eax_205 = *((word32) dwArg04 + 8);
						if (dwArg0C > eax_205)
							ebp_200 = eax_205;
					}
					int32 eax_218 = ebp_200 - ecx_180;
					Eq_71993 edi_219 = dwArg10 - eax_218;
					if (Mem199[dwArg04 + 0x08:word32] + edi_219 == 0x00)
					{
						if (edx_19 != null)
						{
							word32 v16_496 = edx_19->dw0000 + ~0x00;
							edx_19->dw0000 = v16_496;
							if (v16_496 == 0x00)
							{
								Eq_3 eax_500 = edx_19->t0004;
								(*((word32) eax_500 + 24))();
							}
						}
						fn006F3150(dwArg04);
						return;
					}
					Eq_3 edi_370;
					struct Eq_72002 * esp_332;
					Eq_3 esi_224 = *((word32) dwArg04 + 0x0C);
					Eq_3 edx_225 = eax_218 * 0x04;
					if (eax_218 * 0x04 > 0x20)
					{
						if (eax_218 * 0x04 == 0x00)
							edx_225.u0 = 0x01;
						Eq_3 eax_236 = malloc(edx_225);
						dwLoc38_540 = eax_236;
						if (eax_236 == 0x00)
						{
							word32 ecx_846;
							word32 edx_847;
							fn006E1210(out ecx_846, out edx_847);
							goto l006F3362;
						}
						ecx_180 = dwArg08;
					}
					memcpy(dwLoc38_540, (word32) esi_224 + ecx_180 * 0x04, eax_218 * 0x04);
					if (edi_219 < 0x00)
					{
						memmove(esi_224 + (edi_219 + ebp_200) * 0x04, esi_224 + ebp_200 * 0x04, (Mem258[dwArg04 + 0x08:word32] - ebp_200) * 0x04);
						word32 ecx_850;
						fn006F2590(dwArg04, Mem319[dwArg04 + 0x08:word32] + edi_219, out ecx_850);
						esi_224 = *((word32) dwArg04 + 0x0C);
					}
					else if (edi_219 > 0x00)
					{
						Eq_3 eax_268 = *((word32) dwArg04 + 8);
						word32 ecx_851;
						if (fn006F2590(dwArg04, eax_268 + edi_219, out ecx_851) < 0x00)
						{
l006F3362:
							esp_332 = fp - 0x48;
							edi_370 = dwLoc38_540;
							goto l006F3366;
						}
						esi_224 = *((word32) dwArg04 + 0x0C);
						memmove(esi_224 + (edi_219 + ebp_200) * 0x04, esi_224 + ebp_200 * 0x04, (eax_268 - ebp_200) * 0x04);
					}
					esp_332 = fp - 0x48;
					Eq_3 ecx_335 = 0x00;
					if (dwArg10 > 0x00)
					{
						word32 * esi_340 = (word32) esi_224 + dwArg08 * 0x04;
						do
						{
							word32 * eax_345 = *((const char *) dwLoc30_543 + ecx_335 * 0x04);
							if (eax_345 != null)
								++*eax_345;
							*esi_340 = eax_345;
							ecx_335 = (word32) ecx_335 + 1;
							++esi_340;
						} while (ecx_335 < dwArg10);
					}
					int32 esi_367 = eax_218 + ~0x00;
					if (eax_218 >= ~0x00)
					{
						do
						{
							edi_370 = esp_332[4];
							struct Eq_72226 * eax_381 = *((word32) edi_370 + esi_367 * 0x04);
							if (eax_381 != null)
							{
								eax_381->dw0000 += ~0x00;
								struct Eq_72226 * eax_387 = *((word32) edi_370 + esi_367 * 0x04);
								if (eax_387->dw0000 == 0x00)
								{
									struct Eq_72244 * ecx_390 = eax_387->ptr0004;
									<anonymous> * edx_391 = ecx_390->ptr0018;
									esp_332->dwFFFFFFFC = eax_387;
									word32 esp_397;
									edx_391();
									esp_332 = esp_397 + 0x04;
								}
							}
							--esi_367;
						} while (esi_367 >= 0x00);
						esp_332[8] = (struct Eq_72002) 0x00;
					}
					else
						edi_370 = dwLoc38_540;
l006F3366:
					if (edi_370 != esp_332 + 0x0A)
					{
						union Eq_3 * esp_426 = esp_332 - 4;
						*esp_426 = (union Eq_3 *) edi_370;
						free(*esp_426);
					}
					struct Eq_72081 * eax_433 = esp_332[5];
					if (eax_433 != null)
					{
						word32 v18_437 = eax_433->dw0000 + ~0x00;
						eax_433->dw0000 = v18_437;
						if (v18_437 == 0x00)
						{
							struct Eq_72123 * ecx_441 = eax_433->ptr0004;
							<anonymous> * edx_442 = ecx_441->ptr0018;
							esp_332->dwFFFFFFFC = eax_433;
							edx_442();
						}
					}
					return;
				}
			}
			dwLoc30_543 = eax_35->ptr000C;
			edx_19 = eax_35;
			goto l006F32C6;
		}
	}
	goto l006F3294;
}

// 006F34B0: void fn006F34B0(Stack Eq_3 dwArg04)
// Called from:
//      fn00740D60
void fn006F34B0(Eq_3 dwArg04)
{
	Eq_3 eax_8 = *((word32) dwArg04 + 4);
	if (eax_8 != 0x00A1BAF0)
	{
		word32 ecx_106;
		word32 edx_107;
		if (fn006D5670(eax_8, 0x00A1BAF0, out ecx_106, out edx_107) == 0x00)
		{
			word32 edx_108;
			fn006E1DC0(out edx_108);
			return;
		}
	}
	fn006F31C0(dwArg04, dwArg08, dwArg0C, dwArg10);
}

// 006F3930: Register word32 fn006F3930(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08)
// Called from:
//      fn007035C0
word32 fn006F3930(Eq_3 dwArg04, Eq_3 dwArg08)
{
	Eq_3 eax_15 = *((word32) dwArg08 + 4);
	if (eax_15 != 0x00A1BAF0 && (eax_15 != 0x00A16588 && dwArg04 != dwArg08))
	{
		word32 ecx_737;
		word32 edx_738;
		Eq_3 eax_212 = fn00704B00(dwArg08, out ecx_737, out edx_738);
		if (eax_212 == 0x00)
			return 0x00;
		struct Eq_72334 * esp_263;
		Eq_3 eax_228 = fn007040D0(eax_212, dwArg08);
		if (eax_228 < 0x00)
		{
			if (fn006E0FC0() != 0x00)
			{
				word32 ecx_741;
				word32 edx_742;
				if (fn006E1110(out ecx_741, out edx_742) == 0x00)
				{
					esp_263 = fp - 0x10;
					word32 ecx_743;
					word32 edx_744;
					if (fn006E1110(out ecx_743, out edx_744) == 0x00)
						goto l006F3755;
				}
			}
			word32 ecx_739;
			word32 edx_740;
			fn006E1160(out ecx_739, out edx_740);
			eax_228.u0 = 0x08;
		}
		Eq_3 ebp_279 = *((word32) dwArg04 + 8);
		word32 esi_281 = eax_228 + ebp_279;
		if (esi_281 >= ebp_279)
		{
			esp_263 = fp - 0x10;
			word32 ecx_748;
			if (fn006F2590(dwArg04, esi_281, out ecx_748) == ~0x00)
				goto l006F3755;
			*((word32) dwArg04 + 8) = ebp_279;
		}
		word32 esp_307;
		struct Eq_72490 * eax_308;
		fn00000000();
		struct Eq_72490 * esi_313 = eax_308;
		esp_263 = esp_307 + 0x04;
		if (eax_308 != null)
		{
			do
			{
				Eq_3 eax_320 = *((word32) dwArg04 + 8);
				if (eax_320 < *((word32) dwArg04 + 16))
				{
					*((word32) *((word32) dwArg04 + 0x0C) + eax_320 * 0x04) = esi_313;
					*((word32) dwArg04 + 8) = (word32) *((word32) dwArg04 + 8) + 1;
				}
				else
				{
					struct Eq_72490 ** esp_324 = esp_263 - 4;
					*esp_324 = (struct Eq_72490 **) esi_313;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_3 stackArg4 = <invalid>;
					word32 ecx_750;
					word32 edx_751;
					int32 eax_332 = fn006F29C0(dwArg04, stackArg4, out ecx_750, out edx_751);
					word32 v25_338 = esi_313->dw0000 + ~0x00;
					esi_313->dw0000 = v25_338;
					esp_263 = (struct Eq_72334 *) ((const char *) esp_324 + 4);
					if (v25_338 == 0x00)
					{
						struct Eq_72708 * edx_343 = esi_313[1];
						<anonymous> * eax_344 = edx_343->ptr0018;
						*esp_324 = (struct Eq_72490 **) esi_313;
						word32 esp_347;
						eax_344();
						esp_263 = esp_347 + 0x04;
					}
					if (eax_332 < 0x00)
						goto l006F3755;
				}
				struct Eq_72562 * esp_366 = esp_263 - 4;
				esp_366->t0000 = eax_212;
				word32 esp_377;
				struct Eq_72490 * eax_378;
				esp_366->ptr001C();
				esi_313 = eax_378;
				esp_263 = esp_377 + 0x04;
			} while (eax_378 != null);
		}
		if (fn006E0FC0() == 0x00)
		{
l006F380D:
			Eq_3 esi_421 = *((word32) dwArg04 + 8);
			if (esi_421 < *((word32) dwArg04 + 16))
			{
				word32 ecx_758;
				fn006F2590(dwArg04, esi_421, out ecx_758);
			}
			word32 v23_436 = (word32) *eax_212 - 1;
			*eax_212 = v23_436;
			if (v23_436 == 0x00)
			{
				Eq_3 edx_455 = *((word32) eax_212 + 4);
				struct Eq_58241 * eax_456 = *((word32) edx_455 + 24);
				esp_263->dwFFFFFFFC = (word32) eax_212;
				eax_456();
				++g_dwA163B8;
				return 0x00A163B8;
			}
			goto l006F3919;
		}
		union Eq_3 * esp_395 = esp_263 - 4;
		*esp_395 = (union Eq_3 *) g_tA16D00;
		esp_263 = (struct Eq_72334 *) ((const char *) esp_395 + 4);
		word32 edx_755;
		word32 ecx_754;
		if (fn006E1110(out ecx_754, out edx_755) != 0x00)
		{
			word32 edx_757;
			word32 ecx_756;
			fn006E1160(out ecx_756, out edx_757);
			goto l006F380D;
		}
l006F3755:
		word32 v15_485 = (word32) *eax_212 - 1;
		*eax_212 = v15_485;
		if (v15_485 != 0x00)
			return 0x00;
		Eq_3 ecx_503 = *((word32) eax_212 + 4);
		struct Eq_58241 * edx_504 = *((word32) ecx_503 + 24);
		esp_263->dwFFFFFFFC = (word32) eax_212;
		edx_504();
		return 0x00;
	}
	struct Eq_71928 * eax_36 = fn00704DA0(dwArg08);
	if (eax_36 == null)
		return 0x00;
	Eq_3 eax_46 = eax_36->t0004;
	if (eax_46 != 0x00A1BAF0)
	{
		word32 ecx_745;
		word32 edx_746;
		fn006D5670(eax_46, 0x00A1BAF0, out ecx_745, out edx_746);
	}
	int32 ebp_64 = eax_36->dw0008;
	if (ebp_64 == 0x00)
	{
		word32 v16_181 = eax_36->dw0000 + ~0x00;
		eax_36->dw0000 = v16_181;
		if (v16_181 == 0x00)
		{
			Eq_3 eax_185 = eax_36->t0004;
			(*((word32) eax_185 + 24))();
			++g_dwA163B8;
			return 0x00A163B8;
		}
		goto l006F3919;
	}
	word32 ecx_747;
	int32 eax_75 = fn006F2590(dwArg04, (word32) *((word32) dwArg04 + 8) + ebp_64, out ecx_747);
	if (eax_75 == ~0x00)
	{
		word32 v19_165 = eax_36->dw0000 + eax_75;
		eax_36->dw0000 = v19_165;
		if (v19_165 == 0x00)
		{
			Eq_3 edx_169 = eax_36->t0004;
			(*((word32) edx_169 + 24))();
		}
		return 0x00;
	}
	union Eq_71930 * edx_103;
	Eq_3 eax_82 = eax_36->t0004;
	if (eax_82 != 0x00A1BAF0)
	{
		edx_103 = (union Eq_71930 *) &eax_36->ptr000C;
		word32 ecx_752;
		word32 edx_753;
		if (fn006D5670(eax_82, 0x00A1BAF0, out ecx_752, out edx_753) == 0x00)
		{
l006F38E6:
			word32 * ecx_115 = (word32) *((word32) dwArg04 + 0x0C) + dwArg08 * 0x04;
			if (ebp_64 > 0x00)
			{
				int32 edx_117 = edx_103 - ecx_115;
				int32 esi_119 = ebp_64;
				do
				{
					word32 * eax_123 = ecx_115[edx_117];
					++*eax_123;
					*ecx_115 = eax_123;
					++ecx_115;
					--esi_119;
				} while (esi_119 != 0x00);
			}
			word32 v22_136 = eax_36->dw0000 + ~0x00;
			eax_36->dw0000 = v22_136;
			if (v22_136 == 0x00)
			{
				Eq_3 ecx_140 = eax_36->t0004;
				(*((word32) ecx_140 + 24))();
			}
l006F3919:
			++g_dwA163B8;
			return 0x00A163B8;
		}
	}
	edx_103 = eax_36->ptr000C;
	goto l006F38E6;
}

// 006F4F00: Register Eq_3 fn006F4F00(Stack Eq_3 dwArg04)
// Called from:
//      fn00704BA0
//      fn00728BE0
Eq_3 fn006F4F00(Eq_3 dwArg04)
{
	if (dwArg04 != 0x00)
	{
		Eq_3 eax_11 = *((word32) dwArg04 + 4);
		if (eax_11 == 0x00A1BAF0)
		{
l006F4F25:
			Eq_3 edi_58 = *((word32) dwArg04 + 8);
			word32 edx_189;
			word32 ecx_188;
			Eq_3 eax_63 = fn006DFD20(edi_58, out ecx_188, out edx_189);
			if (eax_63 == 0x00)
				return eax_63;
			memcpy((word32) eax_63 + 0x0C, *((word32) dwArg04 + 0x0C), edi_58 * 0x04);
			word32 * esi_83 = (word32) eax_63 + 0x0C;
			int32 edi_88 = edi_58 - 0x01;
			if (edi_58 >= 0x01)
			{
				do
				{
					word32 * eax_93 = *esi_83;
					++*eax_93;
					++esi_83;
					--edi_88;
				} while (edi_88 >= 0x00);
			}
			return eax_63;
		}
		word32 ecx_190;
		word32 edx_191;
		if (fn006D5670(eax_11, 0x00A1BAF0, out ecx_190, out edx_191) != 0x00)
			goto l006F4F25;
	}
	word32 edx_187;
	fn006E1DC0(out edx_187);
	return 0x00;
}

// 006F5C20: void fn006F5C20()
// Called from:
//      fn006E8910
void fn006F5C20()
{
	Eq_3 eax_5 = g_tA6CB88;
	if (eax_5 != 0x00)
	{
		word32 v7_9 = (word32) *eax_5 - 1;
		*eax_5 = v7_9;
		if (v7_9 == 0x00)
		{
			Eq_3 ecx_13 = *((word32) eax_5 + 4);
			word32 edx_20;
			(*((word32) ecx_13 + 24))();
		}
	}
	Eq_3 eax_26 = g_tA6CB8C;
	g_tA6CB88.u0 = 0x00;
	free(eax_26);
	g_tA6CB8C.u0 = 0x00;
}

// 006F5C60: void fn006F5C60()
// Called from:
//      fn006F9090
void fn006F5C60()
{
	word32 eax_7 = fn0074F680();
	if (eax_7 == ~0x00)
		return;
	Eq_3 eax_15 = g_tA6CB90;
	if (eax_15 == 0x00)
	{
		eax_15 = fn0074F6A0();
		g_tA6CB90 = eax_15;
		if (eax_15 == 0x00)
			return;
	}
	word32 ecx_30 = g_dwA1BDB8;
	if (ecx_30 == eax_7)
	{
		++g_dwA6CB94;
		return;
	}
	if (ecx_30 == ~0x00)
	{
		word32 ecx_158;
		eax_15 = fn0074F540(eax_15, 0x00, out ecx_158);
		if (eax_15 != 0x00)
		{
l006F5CCA:
			g_dwA1BDB8 = eax_7;
			g_dwA6CB94 = 0x01;
			return;
		}
	}
	fn00706BE0();
	word32 ecx_157;
	fn0074F540(g_tA6CB90, 0x01, out ecx_157);
	fn00706C20(eax_15);
	goto l006F5CCA;
}

// 006F5DA0: Register Eq_3 fn006F5DA0()
// Called from:
//      fn006F6EA0
//      fn006F82C0
//      fn0074F9E0
Eq_3 fn006F5DA0()
{
	Eq_3 esi_9 = *((word32) g_tA6D67C + 4);
	if (*((word32) esi_9 + 8) == 0x00)
		fn006E86F0(9262392);
	return *((word32) esi_9 + 8);
}

// 006F5DD0: Register word32 fn006F5DD0(Register out ptr32 esiOut, Register out ptr32 ediOut)
// Called from:
//      fn006E8910
word32 fn006F5DD0(ptr32 & esiOut, ptr32 & ediOut)
{
	Eq_3 eax_7 = *((word32) g_tA6D67C + 4);
	Eq_3 ebp_11 = *((word32) eax_7 + 8);
	if (ebp_11 == 0x00)
	{
l006F62AC:
		esiOut = esi;
		ediOut = edi;
		return ebx;
	}
	word32 edi_1403;
	word32 esi_1402;
	word32 edx_1401;
	word32 ecx_1400;
	Eq_3 eax_32 = fn006FD8B0(ebp_11, 9245772, out ecx_1400, out edx_1401, out esi_1402, out edi_1403);
	if (eax_32 != 0x00)
	{
		if (*((word32) eax_32 + 4) != 10622400)
		{
			word32 ecx_1410;
			word32 edx_1411;
			if (fn006D5670(*((word32) eax_32 + 4), 10622400, out ecx_1410, out edx_1411) == 0x00)
				goto l006F5E57;
		}
		word32 ecx_1408;
		word32 edx_1409;
		Eq_3 eax_67 = fn00717230(eax_32, out ecx_1408, out edx_1409);
		if (g_tA74AF0 != 0x00)
		{
			word32 edx_1415;
			fn00716B20(out edx_1415);
		}
		word32 ecx_1412;
		word32 esi_1414;
		word32 edx_1413;
		fn006FD8F0(eax_67, 0x008B460C, 0x00A163B8, out ecx_1412, out edx_1413, out esi_1414);
	}
l006F5E57:
	word32 esi_1406;
	word32 edx_1405;
	word32 ecx_1404;
	word32 edi_1407;
	Eq_3 eax_119 = fn006FD8B0(ebp_11, 9094548, out ecx_1404, out edx_1405, out esi_1406, out edi_1407);
	if (eax_119 != 0x00)
	{
		if (*((word32) eax_119 + 4) != 10622400)
		{
			word32 edx_1423;
			word32 ecx_1422;
			if (fn006D5670(*((word32) eax_119 + 4), 10622400, out ecx_1422, out edx_1423) == 0x00)
				goto l006F5F34;
		}
		word32 ecx_1420;
		word32 edx_1421;
		Eq_3 eax_156 = fn00717230(eax_119, out ecx_1420, out edx_1421);
		Eq_3 edi_166 = eax_156;
		word32 * esi_167 = g_aA1BDBC;
		if (g_aA1BDBC[0] != 0x00)
		{
			do
			{
				if (g_tA74AF0 != 0x00)
				{
					word32 edx_1432;
					fn00716B20(out edx_1432);
				}
				struct Eq_73110 * esi_202;
				word32 edx_1431;
				word32 ecx_1430;
				fn006FD8F0(eax_156, *esi_167, 0x00A163B8, out ecx_1430, out edx_1431, out esi_202);
				esi_167 = &esi_202->dw0004;
			} while (esi_202->dw0004 != 0x00);
		}
		struct Eq_73035 * esi_214 = &g_dwA1BDF8;
		if (g_dwA1BDF8 != 0x00)
		{
			do
			{
				if (g_tA74AF0 != 0x00)
				{
					word32 edx_1429;
					fn00716B20(out edx_1429);
				}
				union Eq_3 * esi_249;
				word32 ecx_1427;
				word32 edx_1428;
				Eq_3 eax_248 = fn006FD8B0(edi_166, esi_214->dw0004, out ecx_1427, out edx_1428, out esi_249, out edi_166);
				if (eax_248 == 0x00)
					eax_248.u0 = 0x00A163B8;
				struct Eq_73597 * esi_273;
				word32 edx_1472;
				word32 ecx_1471;
				fn006FD8F0(edi_166, *esi_249, eax_248, out ecx_1471, out edx_1472, out esi_273);
				esi_214 = (struct Eq_73035 *) &esi_273->dw0008;
			} while (esi_273->dw0008 != 0x00);
		}
	}
l006F5F34:
	word32 ecx_1416;
	word32 edi_1419;
	word32 esi_1418;
	word32 edx_1417;
	Eq_3 eax_300 = fn006FD8B0(ebp_11, 0x008CA56C, out ecx_1416, out edx_1417, out esi_1418, out edi_1419);
	if (eax_300 != 0x00)
	{
		if (*((word32) eax_300 + 4) != 10622400)
		{
			word32 ecx_1425;
			word32 edx_1426;
			if (fn006D5670(*((word32) eax_300 + 4), 10622400, out ecx_1425, out edx_1426) == 0x00)
				goto l006F5F97;
		}
		if (g_tA74AF0 != 0x00)
		{
			word32 edx_1476;
			fn00716B20(out edx_1476);
		}
		fn007173A0(eax_300);
		word32 ecx_1473;
		word32 edx_1474;
		word32 esi_1475;
		fn006FD8F0(ebp_11, 0x008CA56C, 0x00A163B8, out ecx_1473, out edx_1474, out esi_1475);
	}
l006F5F97:
	do
	{
		int32 ebx_395 = 0x00;
		word32 edx_1424;
		if (fn006FC050(ebp_11, fp - 0x08, fp - 0x0C, fp - 0x10, out edx_1424) == 0x00)
			break;
		do
		{
			if (*eax_300 == 0x01)
			{
				if (*((word32) dwLoc0C + 4) != 0x00A1B450)
				{
					word32 ecx_1435;
					word32 edx_1436;
					if (fn006D5670(*((word32) dwLoc0C + 4), 0x00A1B450, out ecx_1435, out edx_1436) != 0x00)
						goto l006F5FF7;
					goto l006F6076;
				}
l006F5FF7:
				if (*((word32) eax_300 + 4) != 10622400)
				{
					word32 ecx_1437;
					word32 edx_1438;
					if (fn006D5670(*((word32) eax_300 + 4), 10622400, out ecx_1437, out edx_1438) != 0x00)
						goto l006F6015;
				}
				else
				{
l006F6015:
					byte * edi_464 = &g_b8D144C;
					byte * esi_465 = (word32) dwLoc0C + 20;
					word32 ecx_466 = 0x0C;
					bool v19_1109 = true;
					while (ecx_466 != 0x00)
					{
						v19_1109 = *esi_1477 == *edi_1478;
						esi_465 = esi_1477 + 1;
						edi_464 = edi_1478 + 1;
						--ecx_466;
						esi_1477 = esi_465;
						edi_1478 = edi_464;
						if (*esi_1477 == *edi_1478)
							break;
					}
					if (!v19_1109)
					{
						byte * edi_482 = &g_b8AC594;
						byte * esi_485 = (word32) dwLoc0C + 20;
						word32 ecx_486 = 0x04;
						bool v23_1113 = true;
						while (ecx_486 != 0x00)
						{
							v23_1113 = *esi_1479 == *edi_1480;
							esi_485 = esi_1479 + 1;
							edi_482 = edi_1480 + 1;
							--ecx_486;
							esi_1479 = esi_485;
							edi_1480 = edi_482;
							if (*esi_1479 == *edi_1480)
								break;
						}
						if (!v23_1113)
						{
							if (g_tA74AF0 != 0x00)
							{
								word32 edx_1442;
								fn00716B20(out edx_1442);
							}
							fn007173A0(eax_300);
							word32 ebx_555;
							word32 ecx_1439;
							word32 edx_1440;
							word32 edi_1441;
							fn006FBD90(ebp_11, dwLoc0C, 0x00A163B8, out ecx_1439, out edx_1440, out ebx_555, out edi_1441);
							ebx_395 = ebx_555 + 0x01;
						}
					}
				}
			}
l006F6076:
			word32 edx_1434;
		} while (fn006FC050(ebp_11, fp - 0x08, fp - 0x0C, fp - 0x10, out edx_1434) != 0x00);
	} while (ebx_395 > 0x00);
	word32 edx_1433;
	if (fn006FC050(ebp_11, fp - 0x08, fp - 0x0C, fp - 0x10, out edx_1433) != 0x00)
	{
		do
		{
			if (*((word32) dwLoc0C + 4) != 0x00A1B450)
			{
				word32 ecx_1446;
				word32 edx_1447;
				if (fn006D5670(*((word32) dwLoc0C + 4), 0x00A1B450, out ecx_1446, out edx_1447) != 0x00)
					goto l006F60F6;
				goto l006F6176;
			}
l006F60F6:
			if (*((word32) eax_300 + 4) != 10622400)
			{
				word32 ecx_1449;
				word32 edx_1450;
				if (fn006D5670(*((word32) eax_300 + 4), 10622400, out ecx_1449, out edx_1450) != 0x00)
					goto l006F6118;
			}
			else
			{
l006F6118:
				byte * edi_675 = &g_b8D144C;
				byte * esi_676 = (word32) dwLoc0C + 20;
				word32 ecx_677 = 0x0C;
				bool v27_1117 = true;
				while (ecx_677 != 0x00)
				{
					v27_1117 = *esi_1481 == *edi_1482;
					esi_676 = esi_1481 + 1;
					edi_675 = edi_1482 + 1;
					--ecx_677;
					esi_1481 = esi_676;
					edi_1482 = edi_675;
					if (*esi_1481 == *edi_1482)
						break;
				}
				if (!v27_1117)
				{
					byte * edi_693 = &g_b8AC594;
					byte * esi_696 = (word32) dwLoc0C + 20;
					word32 ecx_697 = 0x04;
					bool v31_1121 = true;
					while (ecx_697 != 0x00)
					{
						v31_1121 = *esi_1483 == *edi_1484;
						esi_696 = esi_1483 + 1;
						edi_693 = edi_1484 + 1;
						--ecx_697;
						esi_1483 = esi_696;
						edi_1484 = edi_693;
						if (*esi_1483 == *edi_1484)
							break;
					}
					if (!v31_1121)
					{
						if (g_tA74AF0 != 0x00)
						{
							word32 edx_1455;
							fn00716B20(out edx_1455);
						}
						fn007173A0(eax_300);
						word32 ecx_1451;
						word32 edx_1452;
						word32 ebx_1453;
						word32 edi_1454;
						fn006FBD90(ebp_11, dwLoc0C, 0x00A163B8, out ecx_1451, out edx_1452, out ebx_1453, out edi_1454);
					}
				}
			}
l006F6176:
			word32 edx_1448;
		} while (fn006FC050(ebp_11, fp - 0x08, fp - 0x0C, fp - 0x10, out edx_1448) != 0x00);
	}
	Eq_3 edi_811;
	word32 edx_1444;
	word32 ecx_1443;
	word32 esi_1445;
	Eq_3 eax_813 = fn006FD8B0(ebp_11, 9094548, out ecx_1443, out edx_1444, out esi_1445, out edi_811);
	if (eax_813 != edi_811)
	{
		if (*((word32) eax_813 + 4) != 10622400)
		{
			word32 ecx_1459;
			word32 edx_1460;
			if (fn006D5670(*((word32) eax_813 + 4), 10622400, out ecx_1459, out edx_1460) == 0x00)
				goto l006F6202;
		}
		if (g_tA74AF0 != edi_811)
		{
			word32 edx_1464;
			fn00716B20(out edx_1464);
		}
		fn007173A0(eax_813);
		word32 esi_1463;
		word32 ecx_1461;
		word32 edx_1462;
		fn006FD8F0(ebp_11, 9094548, 0x00A163B8, out ecx_1461, out edx_1462, out esi_1463);
	}
l006F6202:
	word32 esi_1458;
	word32 ecx_1456;
	word32 edx_1457;
	Eq_3 edi_897;
	Eq_3 eax_899 = fn006FD8B0(ebp_11, 9245772, out ecx_1456, out edx_1457, out esi_1458, out edi_897);
	if (eax_899 != edi_897)
	{
		if (*((word32) eax_899 + 4) != 10622400)
		{
			word32 edx_1466;
			word32 ecx_1465;
			if (fn006D5670(*((word32) eax_899 + 4), 10622400, out ecx_1465, out edx_1466) == 0x00)
				goto l006F626C;
		}
		if (g_tA74AF0 != edi_897)
		{
			word32 edx_1470;
			fn00716B20(out edx_1470);
		}
		edi_897 = fn007173A0(eax_899);
		word32 ecx_1467;
		word32 edx_1468;
		word32 esi_1469;
		fn006FD8F0(ebp_11, 9245772, 0x00A163B8, out ecx_1467, out edx_1468, out esi_1469);
	}
l006F626C:
	struct Eq_73482 * ebp_981 = fn006FBF30(ebp_11);
	*((word32) eax_7 + 8) = edi_897;
	word32 v14_993 = ebp_981->dw0000 + ~0x00;
	ebp_981->dw0000 = v14_993;
	struct Eq_73499 * esp_1063 = fp - 0x20;
	if (v14_993 == 0x00)
	{
		struct Eq_73545 * ecx_997 = ebp_981->ptr0004;
		word32 esp_1057;
		word32 edx_1060;
		ecx_997->ptr0018();
		esp_1063 = esp_1057 + 0x04;
	}
	Eq_3 eax_1067 = *((word32) eax_7 + 20);
	if (eax_1067 != edi_897)
	{
		*((word32) eax_7 + 20) = edi_897;
		word32 v15_1072 = (word32) *eax_1067 - 1;
		*eax_1067 = v15_1072;
		if (v15_1072 == 0x00)
		{
			Eq_3 ecx_1076 = *((word32) eax_1067 + 4);
			struct Eq_58241 * edx_1077 = *((word32) ecx_1076 + 24);
			esp_1063->tFFFFFFFC = eax_1067;
			word32 esp_1084;
			word32 edx_1087;
			edx_1077();
			esp_1063 = esp_1084 + 0x04;
		}
	}
	struct Eq_73556 * esp_1095 = &esp_1063->ptr0000 + 1;
	edi = esp_1063->ptr0000;
	esi = esp_1095->ptr0000;
	ebx = esp_1095->dw0004;
	goto l006F62AC;
}

// 006F62D0: Register Eq_3 fn006F62D0(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Register out ptr32 edxOut)
// Called from:
//      fn006F8050
//      fn0074F9E0
Eq_3 fn006F62D0(Eq_3 dwArg04, Eq_3 dwArg08, ptr32 & edxOut)
{
	if (g_tA6CB88 == 0x00)
	{
		ptr32 edx_10;
		word32 ecx_259;
		Eq_3 eax_8 = fn006FDCC0(out ecx_259, out edx_10);
		g_tA6CB88 = eax_8;
		if (eax_8 == 0x00)
		{
			edxOut = edx_10;
			return eax_8;
		}
	}
	Eq_3 esi_24 = *((word32) g_tA6D67C + 4);
	if (*((word32) esi_24 + 8) == 0x00)
		fn006E86F0(9262392);
	ptr32 edx_110;
	word32 edi_263;
	word32 ecx_260;
	word32 edx_261;
	word32 esi_262;
	Eq_3 eax_53 = fn006FD8B0(*((word32) esi_24 + 8), dwArg04, out ecx_260, out edx_261, out esi_262, out edi_263);
	if (eax_53 != 0x00)
	{
		Eq_3 eax_63 = *((word32) eax_53 + 4);
		if (eax_63 == 10622400)
		{
l006F6338:
			word32 ecx_265;
			Eq_3 eax_108 = fn00717230(eax_53, out ecx_265, out edx_110);
			if (eax_108 != 0x00)
			{
				Eq_3 eax_120 = fn006FDE60(eax_108, out edx_110);
				if (eax_120 != 0x00)
				{
					word32 esi_269;
					word32 ecx_268;
					ptr32 edx_150;
					fn006FD8F0(g_tA6CB88, dwArg08, eax_120, out ecx_268, out edx_150, out esi_269);
					word32 v12_154 = (word32) *eax_120 - 1;
					*eax_120 = v12_154;
					if (v12_154 == 0x00)
					{
						Eq_3 eax_158 = *((word32) eax_120 + 4);
						(*((word32) eax_158 + 24))();
					}
					edxOut = edx_150;
					return eax_120;
				}
			}
l006F6394:
			edxOut = edx_110;
			return 0x00;
		}
		word32 edx_267;
		word32 ecx_266;
		if (fn006D5670(eax_63, 10622400, out ecx_266, out edx_267) != 0x00)
			goto l006F6338;
	}
	word32 ecx_264;
	fn006E15D0(g_tA18720, 9262600, out ecx_264, out edx_110);
	goto l006F6394;
}

// 006F63A0: Register Eq_3 fn006F63A0(Stack Eq_3 dwArg04, Register out ptr32 edxOut)
// Called from:
//      fn006F6490
//      fn006F6D50
//      fn006F7810
//      fn006F8960
Eq_3 fn006F63A0(Eq_3 dwArg04, ptr32 & edxOut)
{
	Eq_3 esi_12 = *((word32) g_tA6D67C + 4);
	if (*((word32) esi_12 + 8) == 0x00)
		fn006E86F0(9262392);
	Eq_3 edi_31 = *((word32) esi_12 + 8);
	word32 edi_230;
	word32 esi_229;
	word32 ecx_228;
	ptr32 edx_111;
	Eq_3 eax_38 = fn006FD8B0(edi_31, dwArg04, out ecx_228, out edx_111, out esi_229, out edi_230);
	Eq_3 esi_120 = eax_38;
	if (eax_38 != 0x00)
	{
		Eq_3 eax_48 = *((word32) eax_38 + 4);
		if (eax_48 == 10622400)
			goto l006F6437;
		word32 ecx_231;
		if (fn006D5670(eax_48, 10622400, out ecx_231, out edx_111) != 0x00)
		{
l006F6437:
			edxOut = edx_111;
			return esi_120;
		}
	}
	Eq_3 eax_74 = fn00717180(dwArg04, out edx_111);
	esi_120 = eax_74;
	if (eax_74 == 0x00)
	{
l006F6420:
		edxOut = edx_111;
		return 0x00;
	}
	word32 esi_233;
	word32 ecx_232;
	if (fn006FD8F0(edi_31, dwArg04, eax_74, out ecx_232, out edx_111, out esi_233) != 0x00)
	{
		word32 v11_126 = (word32) *eax_74 - 1;
		*eax_74 = v11_126;
		if (v11_126 == 0x00)
		{
			Eq_3 ecx_130 = *((word32) eax_74 + 4);
			(*((word32) ecx_130 + 24))();
		}
		goto l006F6420;
	}
	word32 v14_100 = (word32) *eax_74 - 1;
	*eax_74 = v14_100;
	if (v14_100 == 0x00)
	{
		Eq_3 eax_104 = *((word32) eax_74 + 4);
		(*((word32) eax_104 + 24))();
	}
	goto l006F6437;
}

// 006F6440: Register Eq_3 fn006F6440()
// Called from:
//      fn006F6490
Eq_3 fn006F6440()
{
	Eq_3 esi_9 = *((word32) g_tA6D67C + 4);
	if (*((word32) esi_9 + 8) == 0x00)
		fn006E86F0(9262392);
	Eq_3 esi_23 = *((word32) esi_9 + 8);
	word32 ecx_93;
	word32 edx_94;
	word32 esi_95;
	word32 edi_96;
	if (fn006FD8B0(esi_23, edi, out ecx_93, out edx_94, out esi_95, out edi_96) != 0x00 && fn006FD950(esi_23, edi) < 0x00)
		fn006E86F0(9262652);
	return <invalid>;
}

// 006F6490: Register Eq_3 fn006F6490(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Stack Eq_3 dwArg0C, Register out Eq_540 ecxOut, Register out (ptr32 Eq_73901) edxOut)
// Called from:
//      fn006F6730
//      fn006F68F0
//      fn006F6D50
Eq_3 fn006F6490(Eq_3 dwArg04, Eq_3 dwArg08, Eq_3 dwArg0C, union Eq_540 & ecxOut, FILE & edxOut)
{
	if (*((word32) *((word32) g_tA6D67C + 4) + 8) == 0x00)
		fn006E86F0(9262392);
	FILE * edx_38;
	Eq_3 eax_37 = fn006F63A0(dwArg04, out edx_38);
	if (eax_37 == 0x00)
	{
		ecxOut.u0 = <invalid>;
		edxOut = edx_38;
		return eax_37;
	}
	word32 edx_456;
	word32 ecx_455;
	Eq_3 eax_53 = fn00717230(eax_37, out ecx_455, out edx_456);
	word32 esi_459;
	word32 edi_460;
	word32 edx_458;
	word32 ecx_457;
	if (fn006FD8B0(eax_53, dwArg04, out ecx_457, out edx_458, out esi_459, out edi_460) == 0x00)
	{
		word32 ecx_461;
		word32 edx_462;
		word32 esi_463;
		if (fn006FD8F0(eax_53, dwArg04, fn00708800(), out ecx_461, out edx_462, out esi_463) != 0x00)
			goto l006F655D;
	}
	Eq_3 esi_119;
	if (dwArg0C != 0x00)
	{
		word32 edx_465;
		word32 ecx_464;
		Eq_3 eax_115 = fn006ECAC0(dwArg0C, out ecx_464, out edx_465);
		esi_119 = eax_115;
		if (eax_115 != 0x00)
		{
l006F6524:
			ptr32 esp_161 = fp - 0x14;
			word32 edx_466;
			word32 esi_467;
			word32 ecx_156;
			if (fn006FD8F0(eax_53, dwArg04, esi_119, out ecx_156, out edx_466, out esi_467) != 0x00)
			{
				word32 edx_470;
				fn006E1160(out ecx_156, out edx_470);
			}
			word32 v14_174 = (word32) *esi_119 - 1;
			*esi_119 = v14_174;
			if (v14_174 == 0x00)
			{
				Eq_3 edx_178 = *((word32) esi_119 + 4);
				word32 esp_188;
				(*((word32) edx_178 + 24))();
				esp_161 = esp_188 + 0x04;
			}
			struct Eq_74019 * esp_197 = esp_161 - 4;
			esp_197->t0000 = eax_53;
			esp_197->tFFFFFFFC = eax_53;
			esp_197->tFFFFFFF8 = dwArg08;
			word32 edx_471;
			Eq_3 eax_211 = fn0070BC90(out edx_471);
			struct Eq_74036 * esp_219 = (const char *) &esp_197->t0004 + 4;
			if (eax_211 != 0x00)
			{
				word32 v16_221 = (word32) *eax_211 - 1;
				*eax_211 = v16_221;
				if (v16_221 == 0x00)
				{
					Eq_3 ecx_225 = *((word32) eax_211 + 4);
					struct Eq_58241 * edx_226 = *((word32) ecx_225 + 24);
					esp_197->t0004 = eax_211;
					word32 esp_229;
					edx_226();
					esp_219 = esp_229 + 0x04;
				}
				word32 eax_239 = esp_219->dw000C;
				struct Eq_74066 * esp_240 = esp_219 - 4;
				esp_240->t0000 = dwArg04;
				esp_240->dwFFFFFFFC = eax_239;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_3 stackArg4 = <invalid>;
				FILE * edx_253;
				word32 ecx_473;
				word32 esi_474;
				word32 edi_475;
				Eq_3 eax_252 = fn006FD8B0(stackArg4, dwArg04, out ecx_473, out edx_253, out esi_474, out edi_475);
				if (eax_252 != 0x00)
				{
					*eax_252 = (word32) *eax_252 + 1;
					ecxOut.u0 = <invalid>;
					edxOut = edx_253;
					return eax_252;
				}
				else
				{
					FILE * edx_281;
					word32 ecx_476;
					fn006E15D0(g_tA16F8C, dwArg04, out ecx_476, out edx_281);
					ecxOut.u0 = <invalid>;
					edxOut = edx_281;
					return 0x00;
				}
			}
l006F655D:
			FILE * edx_306 = fn006F6440();
			ecxOut.u0 = <invalid>;
			edxOut = edx_306;
			return 0x00;
		}
		word32 ecx_468;
		word32 edx_469;
		fn006E1160(out ecx_468, out edx_469);
	}
	esi_119 = *((word32) dwArg08 + 48);
	*esi_119 = (word32) *esi_119 + 1;
	goto l006F6524;
}

// 006F65B0: Register Eq_3 fn006F65B0(Register Eq_3 edx, Stack Eq_3 dwArg04, Stack up32 dwArg08)
// Called from:
//      fn006F68F0
Eq_3 fn006F65B0(Eq_3 edx, Eq_3 dwArg04, up32 dwArg08)
{
	Eq_3 eax_12 = edx;
	do
	{
		eax_12 = (word32) eax_165 + 1;
		eax_165 = eax_12;
	} while (*eax_165 != 0x00);
	Eq_3 eax_26 = eax_12 - ((word32) edx + 1);
	Eq_3 ebx_27 = eax_26;
	if ((word32) eax_26 + 2 > dwArg08)
		return 0x00;
	if (eax_26 >= 0x04)
	{
		byte * edi_38 = &g_b8D54C0;
		byte * esi_40 = (word32) edx + (eax_26 - 0x04);
		word32 ecx_41 = 0x05;
		bool v17_108 = false;
		while (ecx_41 != 0x00)
		{
			v17_108 = *esi_166 != *edi_167;
			esi_40 = esi_166 + 1;
			edi_38 = edi_167 + 1;
			--ecx_41;
			esi_166 = esi_40;
			edi_167 = edi_38;
			if (*esi_166 == *edi_167)
				break;
		}
		if (!v17_108)
			ebx_27 = eax_26 - 0x01;
	}
	memcpy(dwArg04, edx, ebx_27);
	Mem92[ebx_27 + dwArg04:byte] = (0x00 - (Mem80[0x00A6DBF4<p32>:word32] == 0x00) & 0x0C) + 99;
	Mem93[ebx_27 + 0x01 + dwArg04:byte] = 0x00;
	return dwArg04;
}

// 006F6630: Register Eq_3 fn006F6630(Register Eq_3 ebx, Register Eq_3 ebp, Register Eq_3 esi, Register Eq_3 edi, Register (ptr16 Eq_7) es, Register (ptr16 Eq_8) ds, Stack ui32 dwArg08, Stack Eq_3 dwArg0C)
// Called from:
//      fn006F68F0
Eq_3 fn006F6630(Eq_3 ebx, Eq_3 ebp, Eq_3 esi, Eq_3 edi, struct Eq_7 * es, struct Eq_8 * ds, ui32 dwArg08, Eq_3 dwArg0C)
{
	word32 edx_254;
	word32 ebx_255;
	word32 ebp_256;
	Eq_3 eax_20 = fn00659040(ebx, ebp, esi, edi, es, ds, edi, 9074500, out edx_254, out ebx_255, out ebp_256);
	if (eax_20 == 0x00)
		return 0x00;
	if (fn00737370() == g_dwA1BDB0)
	{
		int64 edx_eax_57 = (int64) fn00737370();
		Eq_3 edx_62 = SLICE(edx_eax_57, word32, 32);
		if ((word32) edx_eax_57 != dwArg08 || edx_62 != dwArg0C)
		{
			if (g_tA74AF0 != 0x00)
			{
				word32 edx_258;
				fn00716B20(out edx_258);
			}
			fclose(eax_20);
			return 0x00;
		}
		else
		{
			if (g_tA74AF0 != 0x00)
			{
				word32 edx_259;
				fn00716B20(out edx_259);
			}
			return eax_20;
		}
	}
	else
	{
		if (g_tA74AF0 != 0x00)
		{
			word32 edx_257;
			fn00716B20(out edx_257);
		}
		fclose(eax_20);
		return 0x00;
	}
}

// 006F66E0: Register (ptr32 Eq_74265) fn006F66E0(Stack Eq_3 dwArg04, Register out ptr32 edxOut)
// Called from:
//      fn006F6730
//      fn006F68F0
struct Eq_74265 * fn006F66E0(Eq_3 dwArg04, ptr32 & edxOut)
{
	ptr32 edx_13;
	struct Eq_74265 * eax_11 = fn00737880(ebx, ebp, esi, edi, es, ds, out edx_13);
	if (eax_11 != null)
	{
		if (eax_11->ptr0004 == &g_tA27458)
		{
l006F6725:
			edxOut = edx_13;
			return eax_11;
		}
		word32 ecx_100;
		fn006E15D0(g_tA16F8C, 9262812, out ecx_100, out edx_13);
		word32 v11_38 = eax_11->dw0000 + ~0x00;
		eax_11->dw0000 = v11_38;
		if (v11_38 == 0x00)
		{
			struct Eq_74292 * eax_42 = eax_11->ptr0004;
			eax_42->ptr0018();
		}
	}
	eax_11 = null;
	goto l006F6725;
}

// 006F6730: Register Eq_3 fn006F6730(Register out ptr32 edxOut)
// Called from:
//      fn006F82C0
Eq_3 fn006F6730(ptr32 & edxOut)
{
	ptr32 edx_121;
	if (fn00737370() != g_dwA1BDB0)
	{
		word32 ecx_197;
		fn006E15D0(g_tA16F8C, 9262876, out ecx_197, out edx_121);
	}
	else
	{
		fn00737370();
		Eq_3 eax_39 = fn006F66E0(ecx, out edx_121);
		if (eax_39 != 0x00)
		{
			if (g_tA74AF0 != 0x00)
			{
				word32 edx_199;
				fn00716B20(out edx_199);
			}
			word32 ecx_198;
			ptr32 edx_154;
			Eq_3 eax_80 = fn006F6490(ebx, eax_39, ecx, out ecx_198, out edx_154);
			word32 v12_86 = (word32) *eax_39 - 1;
			*eax_39 = v12_86;
			if (v12_86 == 0x00)
			{
				Eq_3 ecx_91 = *((word32) eax_39 + 4);
				(*((word32) ecx_91 + 24))();
			}
			edxOut = edx_154;
			return eax_80;
		}
	}
	edxOut = edx_121;
	return 0x00;
}

// 006F67C0: Register Eq_3 fn006F67C0(Register out Eq_540 edxOut)
// Called from:
//      fn006F68F0
Eq_3 fn006F67C0(union Eq_540 & edxOut)
{
	Eq_3 ebx_10 = 0x00;
	Eq_3 eax_14 = fn00740CC0();
	if (eax_14 != 0x00)
	{
		Eq_3 eax_41 = fn006E8B50(0x00, null);
		if (eax_41 != 0x00)
			ebx_10 = fn0072E790(eax_41, edi, null, eax_14);
		fn00740D60(eax_14);
		edxOut.u0 = <invalid>;
		return ebx_10;
	}
	else
	{
		edxOut.u0 = <invalid>;
		return eax_14;
	}
}

// 006F6810: void fn006F6810(Register Eq_3 ebx, Register Eq_3 ebp, Register Eq_3 esi, Register Eq_3 edi, Register (ptr16 Eq_7) es, Register (ptr16 Eq_8) ds, Stack Eq_3 dwArg04)
// Called from:
//      fn006F68F0
void fn006F6810(Eq_3 ebx, Eq_3 ebp, Eq_3 esi, Eq_3 edi, struct Eq_7 * es, struct Eq_8 * ds, Eq_3 dwArg04)
{
	word32 ebx_22;
	word32 edx_334;
	word32 ebp_335;
	Eq_3 eax_20 = fn00659040(ebx, ebp, esi, edi, es, ds, ebx, 0x008A7F88, out edx_334, out ebx_22, out ebp_335);
	if (eax_20 != 0x00)
	{
		fn00736560();
		fn00736560();
		fn00736590(dwArg04, eax_20, 0x02);
		struct Eq_74436 * esp_79;
		word32 eax_80;
		MSVCR80.dll!fflush();
		word32 esp_104 = (const char *) &esp_79->t0024 + 4;
		if (eax_80 == 0x00)
		{
			esp_79->t0024 = eax_20;
			struct Eq_74459 * esp_91;
			int32 eax_92;
			MSVCR80.dll!ferror();
			esp_104 = &esp_91->dw0000 + 1;
			if (eax_92 == 0x00)
			{
				esp_91->dw0000 = eax_92;
				esp_91->tFFFFFFFC.u0 = 0x04;
				esp_91->tFFFFFFF8 = eax_20;
				fseek(esp_91->tFFFFFFF8, esp_91->tFFFFFFFC, esp_91->dw0000);
				word32 edx_160 = esp_91->dw0014;
				esp_91->dwFFFFFFF4 = 0x02;
				esp_91->tFFFFFFF0 = eax_20;
				esp_91->dwFFFFFFEC = edx_160;
				fn00736560();
				esp_91->tFFFFFFE8 = eax_20;
				struct Eq_74507 * esp_175;
				MSVCR80.dll!fflush();
				esp_175->tFFFFFFFC = eax_20;
				fclose(esp_175->tFFFFFFFC);
				if (g_tA74AF0 == 0x00)
					return;
				esp_175->dw0018 = ebx_22;
				esp_175->dw0014 = 9262924;
				word32 edx_337;
				fn00716B20(out edx_337);
				return;
			}
		}
		if (g_tA74AF0 != 0x00)
		{
			struct Eq_74549 * esp_105 = esp_104 - 4;
			esp_105->dw0000 = ebx_22;
			esp_105->dwFFFFFFFC = 9262904;
			word32 edx_338;
			fn00716B20(out edx_338);
		}
		struct Eq_74532 * esp_129 = esp_104 - 4;
		esp_129->t0000 = eax_20;
		int32 eax_132 = fclose(esp_129->t0000);
		esp_129->dwFFFFFFFC = ebx_22;
		unlink();
	}
	else
	{
		if (g_tA74AF0 == eax_20)
			return;
		word32 edx_336;
		fn00716B20(out edx_336);
	}
}

// 006F68F0: Register word32 fn006F68F0(Register Eq_3 ecx, Register Eq_3 ebx, Register Eq_3 ebp, Register Eq_3 esi, Register Eq_3 edi, Register (ptr16 Eq_7) es, Register (ptr16 Eq_8) ds, Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Register out Eq_3 edxOut)
// Called from:
//      fn006F82C0
word32 fn006F68F0(Eq_3 ecx, Eq_3 ebx, Eq_3 ebp, Eq_3 esi, Eq_3 edi, struct Eq_7 * es, struct Eq_8 * ds, Eq_3 dwArg04, Eq_3 dwArg08, union Eq_3 & edxOut)
{
	ui32 eax_7 = g_tA14188 ^ fp - 0x011C;
	Eq_3 edx_32;
	ui32 eax_30 = fn0074F9A0(dwArg08, out edx_32);
	if ((eax_30 & edx_32) == ~0x00)
	{
		Eq_3 edx_360;
		word32 ecx_532;
		fn006E15D0(g_tA175E0, 0x008D57B0, out ecx_532, out edx_360);
		word32 ecx_533;
		word32 eax_375 = fn00694B8E(0x00, eax_7 ^ fp - 0x011C, edx_360, ebx, ebp, esi, edi, es, ds, ebx, out ecx_533);
		edxOut = edx_360;
		return eax_375;
	}
	if (edx_32 != 0x00)
	{
		Eq_3 edx_325;
		word32 ecx_534;
		fn006E0F80(g_tA18598, 9262980, out ecx_534, out edx_325);
		word32 ecx_535;
		word32 eax_340 = fn00694B8E(0x00, eax_7 ^ fp - 0x011C, edx_325, ebx, ebp, esi, edi, es, ds, ebx, out ecx_535);
		edxOut = edx_325;
		return eax_340;
	}
	Eq_3 edx_101;
	Eq_3 eax_170;
	Eq_3 edi_104;
	Eq_3 eax_59 = fn006F65B0(ecx, fp - 0x0108, 0x0101);
	if (eax_59 != 0x00)
	{
		Eq_3 eax_78 = fn006F6630(edx_32, eax_59, ecx, eax_59, es, ds, eax_30, edx_32);
		if (eax_78 != 0x00)
		{
			word32 edx_536;
			Eq_3 eax_156 = fn006F66E0(eax_59, out edx_536);
			fclose(eax_78);
			edx_101 = eax_78;
			edi_104 = eax_156;
			if (eax_156 != 0x00)
			{
				if (g_tA74AF0 != 0x00)
				{
					word32 edx_537;
					fn00716B20(out edx_537);
				}
				goto l006F6A50;
			}
l006F6A1B:
			eax_170.u0 = 0x00;
			goto l006F6A74;
		}
	}
	Eq_3 eax_99 = fn006F67C0(out edx_101);
	edi_104 = eax_99;
	if (eax_99 != 0x00)
	{
		if (g_tA74AF0 != 0x00)
		{
			word32 edx_539;
			fn00716B20(out edx_539);
		}
		if (eax_59 != 0x00)
			fn006F6810(eax_59, eax_59, ecx, eax_99, es, ds, eax_99);
l006F6A50:
		word32 ecx_213;
		Eq_3 eax_212 = fn006F6490(dwArg04, dwArg04, dwArg08, out ecx_213, out edx_101);
		word32 v14_218 = (word32) *edi_104 - 1;
		*edi_104 = v14_218;
		if (v14_218 == 0x00)
		{
			struct Eq_74708 * edx_223 = *((word32) edi_104 + 4);
			edx_223->ptr0018();
		}
		eax_170 = eax_212;
l006F6A74:
		word32 ecx_538;
		word32 eax_307 = fn00694B8E(eax_170, eax_7 ^ fp - 0x011C, edx_101, ebx, ebp, esi, edi, es, ds, ebx, out ecx_538);
		edxOut = edx_101;
		return eax_307;
	}
	goto l006F6A1B;
}

// 006F6A90: Register uint32 fn006F6A90(Register Eq_74719 ebx)
// Called from:
//      fn006F7890
uint32 fn006F6A90(Eq_74719 ebx)
{
	struct Eq_74720 * edi_10 = g_ptrA1BDB4;
	ui32 esi_11 = 0x00;
	if (edi_10->dw0000 != null)
	{
		struct Eq_74727 * ecx_14 = edi_10->dw0000;
		do
		{
			Eq_74719 eax_16 = ebx;
			do
			{
				word32 eax_35;
				cu8 dl_19 = *eax_16;
				if (dl_19 != ecx_14->b0000)
				{
l006F6AC2:
					up32 eax_32 = 0x00 - (dl_19 < ecx_14->b0000);
					eax_35 = eax_32 - ~0x00 - (eax_32 < 0x00);
					goto l006F6AC7;
				}
				if (dl_19 == 0x00)
					break;
				byte dl_26 = *((word32) eax_16 + 1);
				if (dl_26 != ecx_14->b0001)
					goto l006F6AC2;
				eax_16 = (word32) eax_16 + 2;
				++ecx_14;
			} while (dl_26 != 0x00);
			eax_35 = 0x00;
l006F6AC7:
			if (eax_35 == 0x00)
			{
				uint32 eax_76 = (uint32) (int8) (*((const char *) &edi_10->t0004 + esi_11 * 0x08) != 0x00);
				return eax_76 - 0x01 + eax_76;
			}
			ecx_14 = (struct Eq_74727 *) *((const char *) &edi_10->t0008 + esi_11 * 0x08);
			++esi_11;
		} while (ecx_14 != null);
	}
	return 0x00;
}

// 006F6AF0: Register Eq_3 fn006F6AF0(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Register out ptr32 ecxOut, Register out Eq_74802 edxOut)
// Called from:
//      fn006F7890
Eq_3 fn006F6AF0(Eq_3 dwArg04, Eq_3 dwArg08, ptr32 & ecxOut, union Eq_74802 & edxOut)
{
	ptr32 ecx_13;
	Eq_74802 edx_14;
	Eq_3 eax_12 = fn006F2750(dwArg08, out ecx_13, out edx_14);
	if (eax_12 >= 0x00)
	{
		ptr32 ecx_108;
		Eq_74802 edx_109;
		Eq_3 eax_219 = fn006FBCC0(dwArg04, ebx, out ecx_108, out edx_109);
		if (eax_219 == 0x00)
		{
			ptr32 ecx_49;
			Eq_74802 edx_50;
			word32 ebx_376;
			word32 edi_377;
			if (fn006FBD90(dwArg04, ebx, dwArg08, out ecx_49, out edx_50, out ebx_376, out edi_377) != 0x00)
			{
				ecxOut = ecx_49;
				edxOut = edx_50;
				return 0x00;
			}
			Eq_3 esi_144;
			if (eax_12 > 0x00)
			{
				Eq_3 edi_123 = 0x00;
				do
				{
					Eq_3 eax_77 = fn006F2790(dwArg08, edi_123, out ecx_108, out edx_109);
					if (eax_77 == 0x00)
						goto l006F6BE3;
					word32 edx_381;
					word32 ecx_380;
					Eq_3 eax_93 = fn00703AF0(eax_77, out ecx_380, out edx_381);
					esi_144 = eax_93;
					if (eax_93 != 0x00)
						goto l006F6BBD;
					if (fn006E1110(out ecx_108, out edx_109) == 0x00)
						goto l006F6BE3;
					word32 edx_385;
					word32 ecx_384;
					fn006E1160(out ecx_384, out edx_385);
					edi_123 = (word32) edi_123 + 1;
				} while (edi_123 < eax_12);
			}
			word32 edx_379;
			word32 ecx_378;
			Eq_3 eax_139 = fn00703AF0(0x00A1C560, out ecx_378, out edx_379);
			esi_144 = eax_139;
			if (eax_139 == 0x00)
			{
				if (fn006E1110(out ecx_108, out edx_109) != 0x00)
				{
					ptr32 ecx_231;
					Eq_74802 edx_232;
					fn006E1160(out ecx_231, out edx_232);
					ecxOut = ecx_231;
					edxOut = edx_232;
					return 0x00A163B8;
				}
			}
			else
			{
l006F6BBD:
				word32 ebx_382;
				word32 edi_383;
				Eq_3 eax_164 = fn006FBD90(dwArg04, ebx, dwArg08, out ecx_108, out edx_109, out ebx_382, out edi_383);
				word32 v15_170 = (word32) *esi_144 - 1;
				*esi_144 = v15_170;
				if (v15_170 == 0x00)
				{
					Eq_3 edx_175 = *((word32) esi_144 + 4);
					(*((word32) edx_175 + 24))();
				}
				if (eax_164 != 0x00)
				{
l006F6BE3:
					ecxOut = ecx_108;
					edxOut = edx_109;
					return 0x00;
				}
			}
			eax_219 = esi_144;
		}
		ecxOut = ecx_108;
		edxOut = edx_109;
		return eax_219;
	}
	else
	{
		ecxOut = ecx_13;
		edxOut = edx_14;
		return 0x00;
	}
}

// 006F6BF0: Register word32 fn006F6BF0(Register Eq_3 ebx, Register out ptr32 ecxOut, Register out Eq_74934 edxOut)
// Called from:
//      fn006F7890
word32 fn006F6BF0(Eq_3 ebx, ptr32 & ecxOut, union Eq_74934 & edxOut)
{
	Eq_3 eax_10 = ebx;
	do
	{
		byte cl_9 = *eax_10;
		eax_10 = (word32) eax_10 + 1;
		ptr32 ecx_162 = SEQ(ecx_24_8, cl_9);
	} while (cl_9 != 0x00);
	ptr32 eax_15 = eax_10 - ((word32) ebx + 1);
	if (eax_15 < 0xF3)
	{
		*((word32) ebx + eax_15) = 0x5C;
		struct Eq_74956 * esi_37 = (word32) ebx + (eax_15 + 0x01);
		esi_37->t0000 = g_t8D57E0;
		esi_37->dw0004 = g_dw8D57E4;
		esi_37->dw0008 = g_dw8D57E8;
		ptr32 ecx_163;
		Eq_74934 edx_166;
		if (fn00656460(ebx, out ecx_163, out edx_166) < 0x00)
		{
			struct Eq_74956 * eax_56 = esi_37;
			do
			{
				eax_56 = (struct Eq_74956 *) ((const char *) &eax_195->t0000 + 1);
				eax_195 = eax_56;
			} while (eax_195->t0000 != 0x00);
			ptr32 edi_68 = eax_15 + 0x01 + (eax_56 - ((const char *) (&esi_37->t0000) + 1));
			byte * edx_136 = &g_b8D57DC;
			if (g_dwA6DBF4 == 0x00)
				edx_136 = &g_b8C4880;
			byte * ecx_76 = (word32) ebx + edi_68;
			do
			{
				byte al_79 = *edx_136;
				*ecx_76 = al_79;
				++edx_136;
				++ecx_76;
			} while (al_79 != 0x00);
			if (fn00656460(ebx, out ecx_163, out edx_166) < 0x00)
			{
				*((word32) ebx + eax_15) = 0x00;
				ecxOut = ecx_163;
				edxOut = edx_166;
				return 0x00;
			}
		}
		*((word32) ebx + eax_15) = 0x00;
		ecxOut = ecx_163;
		edxOut = edx_166;
		return 0x01;
	}
	else
	{
		ecxOut = ecx_162;
		edxOut = (word32) ebx + 1;
		return 0x00;
	}
}

// 006F6CA0: Register (ptr32 Eq_75037) fn006F6CA0(Register Eq_3 esi, Register out Eq_3 edxOut)
// Called from:
//      fn006F6D50
//      fn006F7890
struct Eq_75037 * fn006F6CA0(Eq_3 esi, union Eq_3 & edxOut)
{
	struct Eq_75037 * eax_5 = g_ptrA2EC98;
	struct Eq_75043 * ecx_16 = eax_5->dw0000;
	while (ecx_16 != null)
	{
		edx = esi;
		do
		{
			word32 ecx_34;
			cu8 bl_18 = ecx_16->b0000;
			if (bl_18 != *edx)
			{
l006F6CD2:
				up32 ecx_31 = 0x00 - (bl_18 < *edx);
				ecx_34 = ecx_31 - ~0x00 - (ecx_31 < 0x00);
				goto l006F6CD7;
			}
			if (bl_18 == 0x00)
				break;
			byte bl_25 = ecx_16->b0001;
			if (bl_25 != *((word32) edx + 1))
				goto l006F6CD2;
			++ecx_16;
			edx = (word32) edx + 2;
		} while (bl_25 != 0x00);
		ecx_34 = 0x00;
l006F6CD7:
		if (ecx_34 == 0x00)
			goto l006F6CE7;
		ecx_16 = (struct Eq_75043 *) eax_5[1];
		++eax_5;
	}
	eax_5 = null;
l006F6CE7:
	edxOut = edx;
	return eax_5;
}

// 006F6D50: Register (ptr32 Eq_75098) fn006F6D50(Stack Eq_3 dwArg04, Register out ptr32 edxOut)
// Called from:
//      fn006F82C0
struct Eq_75098 * fn006F6D50(Eq_3 dwArg04, ptr32 & edxOut)
{
	ptr32 edx_13;
	struct Eq_75098 * eax_11 = fn006F6CA0(dwArg04, out edx_13);
	if (eax_11 == null)
	{
		edxOut = edx_13;
		return eax_11;
	}
	if (eax_11->t0004 == 0x00)
	{
		ptr32 edx_318;
		word32 ecx_466;
		fn006E15D0(g_tA16F8C, 0x008D57EC, out ecx_466, out edx_318);
		edxOut = edx_318;
		return (struct Eq_75098 *) ~0x00;
	}
	uint32 ecx_36 = (uint32) (int8) (eax_11->dw0008 < 0x00);
	if (g_tA74AF0 != 0x00)
	{
		word32 edx_467;
		fn00716B20(out edx_467);
	}
	ptr32 edx_112;
	Eq_3 eax_92 = fn00737410(eax_11->t0004, dwArg04, out edx_112);
	struct Eq_75150 * esp_115 = fp - 0x10;
	if (eax_92 == 0x00)
	{
l006F6E68:
		edxOut = edx_112;
		return (struct Eq_75098 *) ~0x00;
	}
	if (*((word32) eax_92 + 4) != 10646616)
	{
		word32 ecx_468;
		fn006E15D0(g_tA16B7C, dwArg04, out ecx_468, out edx_112);
		esp_115 = fp - 0x10;
		goto l006F6E57;
	}
	if (ecx_36 == 0x00)
	{
l006F6E42:
		struct Eq_75201 * esp_177 = esp_115 - 4;
		esp_177->t0000.u0 = 0x008D5834;
		esp_177->tFFFFFFFC = eax_92;
		esp_177->tFFFFFFF8 = dwArg04;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_3 stackArg4 = <invalid>;
		Eq_3 stackArg12 = <invalid>;
		word32 ecx_471;
		Eq_3 eax_193 = fn006F6490(stackArg4, dwArg04, stackArg12, out ecx_471, out edx_112);
		esp_115 = (struct Eq_75150 *) ((const char *) &esp_177->t0000 + 4);
		if (eax_193 != 0x00)
		{
			word32 v18_203 = (word32) *eax_92 - 1;
			*eax_92 = v18_203;
			if (v18_203 == 0x00)
			{
				Eq_3 edx_207 = *((word32) eax_92 + 4);
				<anonymous> * eax_208 = *((word32) edx_207 + 24);
				esp_177->t0000 = eax_92;
				word32 esp_211;
				eax_208();
				esp_115 = esp_211 + 0x04;
			}
			word32 v19_221 = (word32) *eax_193 - 1;
			*eax_193 = v19_221;
			if (v19_221 == 0x00)
			{
				Eq_3 ecx_225 = *((word32) eax_193 + 4);
				<anonymous> * edx_226 = *((word32) ecx_225 + 24);
				esp_115->tFFFFFFFC = eax_193;
				edx_226();
			}
			edxOut = edx_112;
			return (struct Eq_75098 *) 0x01;
		}
		goto l006F6E57;
	}
	else
	{
		Eq_3 eax_110 = fn006F63A0(dwArg04, out edx_112);
		esp_115 = fp - 0x10;
		if (eax_110 != 0x00)
		{
			word32 edx_473;
			word32 ecx_472;
			Eq_3 eax_122 = fn00717230(eax_110, out ecx_472, out edx_473);
			word32 ecx_474;
			Eq_3 eax_131 = fn006F1A70(out ecx_474, out edx_112);
			esp_115 = fp - 0x10;
			if (eax_131 != 0x00)
			{
				word32 ecx_475;
				word32 esi_476;
				int32 eax_148 = fn006FD8F0(eax_122, dwArg04, eax_131, out ecx_475, out edx_112, out esi_476);
				word32 v17_154 = (word32) *eax_131 - 1;
				*eax_131 = v17_154;
				esp_115 = fp - 0x10;
				if (v17_154 == 0x00)
				{
					Eq_3 ecx_159 = *((word32) eax_131 + 4);
					word32 esp_163;
					(*((word32) ecx_159 + 24))();
					esp_115 = esp_163 + 0x04;
				}
				if (eax_148 == 0x00)
					goto l006F6E42;
			}
		}
l006F6E57:
		word32 v16_271 = (word32) *eax_92 - 1;
		*eax_92 = v16_271;
		if (v16_271 == 0x00)
		{
			Eq_3 eax_275 = *((word32) eax_92 + 4);
			<anonymous> * ecx_276 = *((word32) eax_275 + 24);
			esp_115->tFFFFFFFC = eax_92;
			ecx_276();
		}
		goto l006F6E68;
	}
}

// 006F6EA0: Register Eq_3 fn006F6EA0(Register Eq_3 eax, Register Eq_3 ebx, Stack (ptr32 int32) dwArg04, Stack (ptr32 charconst ) dwArg08, Register out ptr32 edxOut)
// Called from:
//      fn006F8EC0
Eq_3 fn006F6EA0(Eq_3 eax, Eq_3 ebx, int32 * dwArg04, const char * dwArg08, ptr32 & edxOut)
{
	if (eax != 0x00)
	{
		Eq_3 eax_12 = *((word32) eax + 4);
		if (eax_12 == 0x00A1D1B8)
		{
l006F6ECB:
			if (dwArg08 != null)
			{
				ptr32 edx_462;
				Eq_3 eax_39 = g_tA6CB98;
				if (eax_39 == 0x00)
				{
					word32 ecx_608;
					eax_39 = fn006F1A70(out ecx_608, out edx_462);
					g_tA6CB98 = eax_39;
					if (eax_39 == 0x00)
						goto l006F6EF5;
				}
				if (g_tA6CB9C == 0x00)
				{
					word32 ecx_610;
					Eq_3 eax_68 = fn006F1A70(out ecx_610, out edx_462);
					g_tA6CB9C = eax_68;
					if (eax_68 == 0x00)
					{
l006F6EF5:
						edxOut = edx_462;
						return 0x00;
					}
					eax_39 = g_tA6CB98;
				}
				*ebx = 0x00;
				*dwArg04 = 0x00;
				word32 ecx_609;
				ptr32 edx_104;
				Eq_3 eax_102 = fn006FBCC0(eax, eax_39, out ecx_609, out edx_104);
				if (eax_102 != 0x00)
				{
					Eq_3 eax_112 = *((word32) eax_102 + 4);
					if (eax_112 == 0x00A1B450)
					{
l006F6F5F:
						ptr32 edx_159;
						word32 ecx_611;
						if (fn006FBCC0(eax, g_tA6CB9C, out ecx_611, out edx_159) != 0x00)
						{
							if (*((word32) eax_102 + 8) > 0x0100)
							{
								ptr32 edx_398;
								word32 ecx_613;
								fn006E0F80(g_tA17E2C, 9263392, out ecx_613, out edx_398);
								edxOut = edx_398;
								return 0x00;
							}
							byte * eax_244 = (word32) eax_102 + 20;
							int32 edx_246 = ebx - ((word32) eax_102 + 20);
							do
							{
								byte cl_250 = *eax_244;
								eax_244[edx_246] = cl_250;
								++eax_244;
							} while (cl_250 != 0x00);
						}
						else
						{
							const char * eax_172 = strrchr((word32) eax_102 + 20, 0x2E);
							if (eax_172 == null)
							{
								if (dwArg08 <= eax_172)
								{
									edxOut = edx_159;
									return 0x00A163B8;
								}
								else
								{
									ptr32 edx_229;
									word32 ecx_614;
									fn006E0F80(g_tA17E2C, 0x008D58F4, out ecx_614, out edx_229);
									edxOut = edx_229;
									return 0x00;
								}
							}
							Eq_3 eax_177 = eax_172 - ((word32) eax_102 + 20);
							if (eax_177 >= 0x0100)
							{
								ptr32 edx_199;
								word32 ecx_620;
								fn006E0F80(g_tA17E2C, 9263392, out ecx_620, out edx_199);
								edxOut = edx_199;
								return 0x00;
							}
							strncpy(ebx, (word32) eax_102 + 20, eax_177);
							Mem190[eax_177 + ebx:byte] = 0x00;
						}
						int32 esi_261 = dwArg08 - (const char *) 0x01;
						if (dwArg08 > (const char *) 0x01)
						{
							do
							{
								const char * eax_279 = strrchr(ebx, 0x2E);
								if (eax_279 == null)
								{
									ptr32 edx_296;
									word32 ecx_615;
									fn006E0F80(g_tA17E2C, 9263260, out ecx_615, out edx_296);
									edxOut = edx_296;
									return 0x00;
								}
								*eax_279 = 0x00;
								--esi_261;
							} while (esi_261 > 0x00);
						}
						Eq_3 eax_314 = ebx;
						do
						{
							eax_314 = (word32) eax_621 + 1;
							eax_621 = eax_314;
						} while (*eax_621 != 0x00);
						*dwArg04 = eax_314 - ((word32) ebx + 1);
						word32 ecx_616;
						word32 esi_617;
						word32 edi_618;
						ptr32 edx_357;
						Eq_3 eax_355 = fn006FD8B0(fn006F5DA0(), ebx, out ecx_616, out edx_357, out esi_617, out edi_618);
						if (eax_355 == 0x00)
						{
							word32 ecx_619;
							fn006E15D0(g_tA18720, 0x008D58D0, out ecx_619, out edx_357);
						}
						edxOut = edx_357;
						return eax_355;
					}
					word32 ecx_612;
					if (fn006D5670(eax_112, 0x00A1B450, out ecx_612, out edx_104) != 0x00)
						goto l006F6F5F;
				}
				edxOut = edx_104;
				return 0x00A163B8;
			}
			goto l006F70B2;
		}
		word32 ecx_607;
		if (fn006D5670(eax_12, 0x00A1D1B8, out ecx_607, out edx) != 0x00)
			goto l006F6ECB;
	}
l006F70B2:
	edxOut = edx;
	return 0x00A163B8;
}

// 006F70C0: Register int32 fn006F70C0(Register out ptr32 ecxOut, Register out Eq_540 edxOut)
// Called from:
//      fn006F8AD0
int32 fn006F70C0(ptr32 & ecxOut, union Eq_540 & edxOut)
{
	Eq_3 esi_9 = *((word32) g_tA6D67C + 4);
	if (*((word32) esi_9 + 8) == 0x00)
		fn006E86F0(9262392);
	ptr32 ecx_35;
	word32 edx_58;
	word32 esi_59;
	int32 eax_34 = fn006FD8F0(*((word32) esi_9 + 8), dwArg04, 0x00A163B8, out ecx_35, out edx_58, out esi_59);
	ecxOut = ecx_35;
	edxOut.u0 = <invalid>;
	return eax_34;
}

// 006F7100: Register Eq_3 fn006F7100(Register Eq_3 eax, Register Eq_3 edi, Register out Eq_3 ecxOut, Register out ptr32 edxOut)
// Called from:
//      fn006F8440
Eq_3 fn006F7100(Eq_3 eax, Eq_3 edi, union Eq_3 & ecxOut, ptr32 & edxOut)
{
	Eq_3 esi_10 = eax;
	if (edi != 0x00A163B8)
	{
		if (eax == 0x00)
		{
			word32 edi_186;
			word32 esi_185;
			Eq_3 eax_22 = fn006FD8B0(ecx, dwArg04, out ecx, out edx, out esi_185, out edi_186);
			esi_10 = eax_22;
			if (eax_22 == 0x00)
				goto l006F716E;
		}
		Eq_3 eax_33 = *((word32) edi + 4);
		if (eax_33 != 10622400)
		{
			word32 ecx_187;
			word32 edx_188;
			if (fn006D5670(eax_33, 10622400, out ecx_187, out edx_188) == 0x00)
			{
				if (fn006DF800(edi, dwArg04, esi_10, out ecx, out edx) < 0x00)
					goto l006F714E;
				goto l006F716E;
			}
		}
		Eq_3 eax_64 = fn00717230(edi, out ecx, out edx);
		if (eax_64 == 0x00)
			goto l006F714E;
		word32 esi_189;
		if (fn006FD8F0(eax_64, dwArg04, esi_10, out ecx, out edx, out esi_189) < 0x00)
		{
l006F714E:
			ecxOut = ecx;
			edxOut = edx;
			return 0x00;
		}
	}
l006F716E:
	ecxOut = ecx;
	edxOut = edx;
	return 0x01;
}

// 006F7810: Register Eq_3 fn006F7810(Register out Eq_540 edxOut)
// Called from:
//      fn006F8050
//      fn0074F9E0
Eq_3 fn006F7810(union Eq_540 & edxOut)
{
	Eq_3 eax_5 = g_tA6CB88;
	if (eax_5 != 0x00)
	{
		word32 edi_180;
		word32 esi_179;
		word32 edx_178;
		word32 ecx_177;
		Eq_3 eax_21 = fn006FD8B0(eax_5, dwArg08, out ecx_177, out edx_178, out esi_179, out edi_180);
		if (eax_21 != 0x00)
		{
			word32 edx_181;
			Eq_3 eax_39 = fn006F63A0(dwArg04, out edx_181);
			if (eax_39 != 0x00)
			{
				word32 edx_183;
				word32 ecx_182;
				if (fn00717230(eax_39, out ecx_182, out edx_183) != 0x00 && fn006FDE40() == 0x00)
				{
					if (g_tA74AF0 != 0x00)
					{
						word32 edx_184;
						fn00716B20(out edx_184);
					}
					edxOut.u0 = <invalid>;
					return eax_39;
				}
			}
			edxOut.u0 = <invalid>;
			return 0x00;
		}
		else
		{
			edxOut.u0 = <invalid>;
			return eax_21;
		}
	}
	else
	{
		edxOut.u0 = <invalid>;
		return eax_5;
	}
}

// 006F7890: Register word32 fn006F7890(Register Eq_3 ebx, Register Eq_3 ebp, Register Eq_3 esi, Register Eq_3 edi, Register (ptr16 Eq_7) es, Register (ptr16 Eq_8) ds, Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Stack Eq_3 dwArg0C, Stack (ptr32 word32) dwArg14, Register out Eq_3 edxOut)
// Called from:
//      fn006F8440
//      fn006F8960
word32 fn006F7890(Eq_3 ebx, Eq_3 ebp, Eq_3 esi, Eq_3 edi, struct Eq_7 * es, struct Eq_8 * ds, Eq_3 dwArg04, Eq_3 dwArg08, Eq_3 dwArg0C, word32 * dwArg14, union Eq_3 & edxOut)
{
	ui32 eax_7 = g_tA14188 ^ fp - 644;
	Eq_3 eax_58 = dwArg04;
	Eq_3 ebx_1182 = dwArg08;
	Eq_3 ebp_1157 = dwArg0C;
	if (dwArg14 != null)
		*dwArg14 = 0x00;
	Eq_3 ecx_38 = dwArg04;
	struct Eq_75738 * esp_142 = fp - 660;
	do
	{
		ecx_38 = (word32) ecx_2486 + 1;
		ecx_2486 = ecx_38;
	} while (*ecx_2486 != 0x00);
	Eq_3 edx_1028;
	Eq_3 eax_1062;
	Eq_3 eax_1385;
	struct Eq_75756 * esp_119;
	if (ecx_38 - ((word32) dwArg04 + 1) > 0x0100)
	{
		eax_1385 = g_tA18598;
		esp_119 = fp - 664;
		goto l006F8020;
	}
	Eq_75762 edx_56 = fp - 600 - dwArg04;
	do
	{
		byte cl_60 = *eax_58;
		Mem62[edx_56 + eax_58:byte] = cl_60;
		eax_58 = (word32) eax_58 + 1;
	} while (cl_60 != 0x00);
	if (dwArg14 == null)
	{
l006F79EA:
		if (ebx_1182 == 0x00)
		{
			Eq_74719 ebx_293 = esp_142 + 0x0F;
			if (fn006F6A90(ebx_293) != 0x00)
			{
				Eq_74719 eax_351 = ebx_293;
				edx_1028 = dwArg0C - ebx_293;
				do
				{
					byte cl_356 = *eax_351;
					Mem358[eax_351 + edx_1028:byte] = cl_356;
					eax_351 = (word32) eax_351 + 1;
				} while (cl_356 != 0x00);
				eax_1062.u0 = 10599980;
			}
			else
			{
				Eq_3 esi_304 = esp_142 + 0x0F;
				word32 edx_2483;
				if (fn006F6CA0(esi_304, out edx_2483) == null)
				{
					struct Eq_77201 * esp_315 = esp_142 - 4;
					esp_315->dw0000 = 0x008CA548;
					word32 edx_2485;
					word32 ecx_2484;
					Eq_3 eax_324 = fn00715DD0(out ecx_2484, out edx_2485);
					esp_315->t0014 = eax_324;
					if (eax_324 == 0x00)
						goto l006F8016;
					goto l006F7BCF;
				}
				Eq_3 eax_336 = esi_304;
				edx_1028 = dwArg0C - esi_304;
				do
				{
					byte cl_341 = *eax_336;
					Mem343[eax_336 + edx_1028:byte] = cl_341;
					eax_336 = (word32) eax_336 + 1;
				} while (cl_341 != 0x00);
				eax_1062.u0 = 10599968;
			}
l006F802B:
			word32 ecx_2442;
			word32 eax_1809 = fn00694B8E(eax_1062, eax_7 ^ fp - 644, edx_1028, ebx, ebp, esi, edi, es, ds, ebx, out ecx_2442);
			edxOut = edx_1028;
			return eax_1809;
		}
		else
		{
			Eq_3 eax_365 = *((word32) ebx_1182 + 4);
			if (eax_365 == 0x00A1B450)
			{
l006F7A16:
				byte * eax_1184 = esp_142 + 0x0F;
				eax_1192 = eax_1184;
				do
				{
					byte * eax_1192;
					eax_1192 = eax_2488 + 1;
					eax_2488 = eax_1192;
				} while (*eax_2488 != 0x00);
				Eq_76248 esp_1203 = esp_142 - 4;
				*esp_1203 = ebx_1182;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_3 stackArg4 = <invalid>;
				if ((word32) (eax_1192 - (eax_1184 + 1)) + ((word32) fn006ECC00(stackArg4) + 1) >= *((word32) esp_1203 + 680))
				{
					Eq_3 edx_1380 = g_tA16F8C;
					*esp_1203 = 0x008D5C18;
					*((word32) esp_1203 - 4) = edx_1380;
l006F8021:
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_3 stackArg4 = <invalid>;
					word32 ecx_2464;
					fn006E0F80(stackArg4, dwArg04, out ecx_2464, out edx_1028);
					goto l006F8029;
				}
				*esp_1203 = ebx_1182;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_3 stackArg4 = <invalid>;
				word32 edx_2461;
				word32 ecx_2460;
				word32 esi_2462;
				Eq_3 eax_1230 = fn006ECC50(stackArg4, out ecx_2460, out edx_2461, out esi_2462);
				Eq_3 edx_1237 = dwArg0C;
				do
				{
					byte cl_1240 = *eax_1230;
					*edx_1237 = cl_1240;
					eax_1230 = (word32) eax_1230 + 1;
					edx_1237 = (word32) edx_1237 + 1;
				} while (cl_1240 != 0x00);
				struct Eq_76473 * edi_1250 = (word32) dwArg0C - 1 + 0x01;
				do
				{
					edi_1250 = edi_2489 + 1;
					edi_2489 = edi_1250;
				} while (edi_2489->w0000 != 0x00);
				edi_1250->w0000 = (word16) *g_str8A6990;
				word32 eax_1263 = esp_1203 + 0x40;
				do
				{
					eax_1263 = eax_2490 + 1;
					eax_2490 = eax_1263;
				} while (*eax_2490 != 0x00);
				word32 eax_1276 = eax_1263 - (esp_1203 + 0x40);
				word32 esi_1277 = esp_1203 + 0x40;
				struct Eq_76507 * edi_1278 = (word32) dwArg0C - 1 + 0x01;
				do
				{
					edi_1278 = edi_2491 + 1;
					edi_2491 = edi_1278;
				} while (edi_2491->dw0000 != 0x00);
				uint32 ecx_1289;
				for (ecx_1289 = eax_1276 >> 0x02; ecx_1289 != 0x00; --ecx_1289)
				{
					edi_1278->dw0000 = (word32) *esi_1277;
					esi_1277 += 4;
					edi_1278 += 4;
				}
				ui32 ecx_1294;
				for (ecx_1294 = eax_1276 & 0x03; ecx_1294 != 0x00; --ecx_1294)
				{
					edi_1278->dw0000 = (word32) *esi_1277;
					++esi_1277;
					++edi_1278;
				}
				Eq_3 eax_1301 = dwArg0C;
				word32 edx_1303 = esp_1203 + 0x40 - dwArg0C;
				do
				{
					byte cl_1307 = *eax_1301;
					Mem1309[edx_1303 + eax_1301:byte] = cl_1307;
					++eax_1301;
				} while (cl_1307 != 0x00);
				word32 edx_2474;
				if (fn006F6CA0(esp_1203 + 0x40, out edx_2474) != 0x00)
				{
					word32 eax_1352 = esp_1203 + 0x40;
					edx_1028 = dwArg0C - (esp_1203 + 0x40);
					do
					{
						byte cl_1357 = *eax_1352;
						Mem1359[eax_1352 + edx_1028:byte] = cl_1357;
						++eax_1352;
					} while (cl_1357 != 0x00);
					eax_1062.u0 = 10599968;
					goto l006F802B;
				}
				Eq_3 eax_1327 = g_tA16F8C;
				Mem1330[esp_1203 + 0x00:word32] = esp_1203 + 0x40;
				*((word32) esp_1203 - 4) = 9264068;
				*((word32) esp_1203 - 8) = eax_1327;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_3 stackArg4 = <invalid>;
				word32 ecx_2476;
				fn006E15D0(stackArg4, dwArg04, out ecx_2476, out edx_1028);
l006F8029:
				eax_1062.u0 = 0x00;
				goto l006F802B;
			}
			struct Eq_76036 * esp_368 = esp_142 - 4;
			esp_368->t0000.u0 = 0x00A1B450;
			esp_368->tFFFFFFFC = eax_365;
			word32 edx_2444;
			word32 ecx_2443;
			if (fn006D5670(esp_368->tFFFFFFFC, esp_368->t0000, out ecx_2443, out edx_2444) != 0x00)
			{
				ebx_1182 = esp_368->t0014;
				goto l006F7A16;
			}
l006F7BCF:
			Eq_3 esi_385 = esp_142[4];
			Eq_3 eax_386 = *((word32) esi_385 + 4);
			if (eax_386 == 0x00A1BAF0)
			{
l006F7BF3:
				struct Eq_76073 * esp_410 = esp_142 - 4;
				esp_410->t0000.u0 = 9262212;
				word32 ecx_2445;
				word32 edx_2446;
				Eq_3 eax_426 = fn00715DD0(out ecx_2445, out edx_2446);
				esp_410->t003C = eax_426;
				if (eax_426 != 0x00)
				{
					Eq_3 eax_436 = *((word32) eax_426 + 4);
					if (eax_436 == 0x00A1BAF0)
					{
l006F7C2C:
						esp_410->t0000.u0 = 9262192;
						word32 ecx_2449;
						word32 edx_2450;
						Eq_3 eax_472 = fn00715DD0(out ecx_2449, out edx_2450);
						esp_410->t0038 = eax_472;
						if (eax_472 != 0x00)
						{
							Eq_3 eax_482 = *((word32) eax_472 + 4);
							if (eax_482 == 0x00A1D1B8)
							{
l006F7C65:
								esp_410->t0000 = esi_385;
								// Failed to bind call argument.
								// Please report this issue at https://github.com/uxmal/reko
								Eq_3 stackArg4 = <invalid>;
								word32 ecx_2454;
								word32 edx_2455;
								Eq_3 eax_518 = fn006F2750(stackArg4, out ecx_2454, out edx_2455);
								esp_410->t0030 = eax_518;
								byte * eax_524 = (const char *) &esp_410->t003C + 4;
								struct Eq_76208 * esp_1010 = (const char *) &esp_410->t0000 + 4;
								do
								{
									eax_524 = eax_2487 + 1;
									eax_2487 = eax_524;
								} while (*eax_2487 != 0x00);
								Mem542[esp_410 + 0x28:word32] = eax_524 - (esp_410 + 0x41);
								esp_410->dw0020 = 0x00;
								if (eax_518 > 0x00)
								{
									do
									{
										Eq_3 eax_547 = esp_1010[4];
										struct Eq_76352 * esp_548 = esp_1010 - 4;
										esp_548->t0000 = esp_1010[7];
										esp_548->tFFFFFFFC = eax_547;
										// Failed to bind call argument.
										// Please report this issue at https://github.com/uxmal/reko
										Eq_3 stackArg4 = <invalid>;
										word32 ecx_2473;
										Eq_3 eax_561 = fn006F2790(stackArg4, dwArg04, out ecx_2473, out edx_1028);
										Eq_3 edi_552 = 0x00;
										Eq_3 ebx_566 = eax_561;
										if (eax_561 == 0x00)
											goto l006F8029;
										Eq_3 eax_571 = *((word32) eax_561 + 4);
										if (eax_571 != 0x00A23B20)
										{
											esp_548->t0000.u0 = 0x00A23B20;
											esp_548->tFFFFFFFC = eax_571;
											word32 ecx_2468;
											word32 edx_2469;
											if (fn006D5670(esp_548->tFFFFFFFC, esp_548->t0000, out ecx_2468, out edx_2469) != 0x00)
												goto l006F7CFB;
											Eq_3 eax_619 = *((word32) eax_561 + 4);
											if (eax_619 == 0x00A1B450)
												goto l006F7D20;
											esp_548->t0000.u0 = 0x00A1B450;
											esp_548->tFFFFFFFC = eax_619;
											esp_1010 = (struct Eq_76208 *) ((const char *) &esp_548->t0000 + 4);
											word32 ecx_2470;
											word32 edx_2471;
											if (fn006D5670(esp_548->tFFFFFFFC, esp_548->t0000, out ecx_2470, out edx_2471) == 0x00)
												goto l006F7F51;
										}
										else
										{
l006F7CFB:
											Eq_3 ecx_590 = g_tA2BD68;
											Eq_3 edx_592 = *((word32) eax_561 + 8);
											Eq_3 eax_593 = *((word32) eax_561 + 0x0C);
											esp_548->t0000.u0 = 0x00;
											esp_548->tFFFFFFFC = ecx_590;
											esp_548->tFFFFFFF8 = edx_592;
											esp_548->tFFFFFFF4 = eax_593;
											// Failed to bind call argument.
											// Please report this issue at https://github.com/uxmal/reko
											Eq_3 stackArg4 = <invalid>;
											Eq_3 eax_608 = fn00720020(stackArg4, dwArg04, dwArg08, dwArg0C, out edx_1028);
											edi_552 = eax_608;
											if (eax_608 == 0x00)
												goto l006F8029;
											ebx_566 = eax_608;
										}
l006F7D20:
										Eq_3 esi_639 = *((word32) ebx_566 + 8);
										word32 ecx_641 = esp_1010[9];
										up32 edx_642 = (word32) esi_639 + 0x0E + ecx_641;
										if (edx_642 >= esp_1010[0x00A9])
										{
											if (edi_552 != 0x00)
											{
												word32 v27_1109 = (word32) *edi_552 - 1;
												*edi_552 = v27_1109;
												if (v27_1109 == 0x00)
												{
													Eq_3 eax_1113 = *((word32) edi_552 + 4);
													struct Eq_58241 * ecx_1114 = *((word32) eax_1113 + 24);
													esp_1010->dwFFFFFFFC = (word32) edi_552;
													word32 esp_1117;
													ecx_1114();
													esp_1010 = esp_1117 + 0x04;
												}
											}
											goto l006F7F51;
										}
										struct Eq_76654 * eax_645 = (word32) ebx_566 + 20;
										struct Eq_76657 * edx_648 = ebp_1157 - eax_645;
										word24 ecx_24_8_1096 = SLICE(ecx_641, word24, 8);
										do
										{
											byte cl_653 = eax_645->t0000;
											Mem655[eax_645 + edx_648:byte] = cl_653;
											++eax_645;
										} while (cl_653 != 0x00);
										Eq_3 eax_661 = ebp_1157;
										ui32 edx_662 = (word32) ebp_1157 + 1;
										do
										{
											byte cl_665 = *eax_661;
											eax_661 = (word32) eax_661 + 1;
											word32 ecx_1097 = SEQ(ecx_24_8_1096, cl_665);
										} while (cl_665 != 0x00);
										if (eax_661 - edx_662 != esi_639)
										{
											if (edi_552 != 0x00)
											{
												word32 v28_1086 = (word32) *edi_552 - 1;
												*edi_552 = v28_1086;
												if (v28_1086 == 0x00)
												{
													Eq_3 edx_1090 = *((word32) edi_552 + 4);
													struct Eq_58241 * eax_1091 = *((word32) edx_1090 + 24);
													esp_1010->dwFFFFFFFC = (word32) edi_552;
													word32 esp_1098;
													eax_1091();
													esp_1010 = esp_1098 + 0x04;
												}
											}
											goto l006F7F51;
										}
										if (esp_1010[8] != 0x00)
										{
											word32 edx_681 = esp_1010[0x0D];
											struct Eq_76752 * esp_682 = esp_1010 - 4;
											esp_682->t0000 = esp_1010[0x0E];
											esp_682->dwFFFFFFFC = edx_681;
											// Failed to bind call argument.
											// Please report this issue at https://github.com/uxmal/reko
											Eq_3 stackArg4 = <invalid>;
											word32 ecx_697;
											word32 eax_696 = fn006F6AF0(stackArg4, dwArg04, out ecx_697, out edx_1028);
											if (eax_696 == 0x00)
											{
												if (edi_552 != 0x00)
												{
													word32 v31_708 = (word32) *edi_552 - 1;
													*edi_552 = v31_708;
													if (v31_708 == 0x00)
													{
														Eq_3 edx_712 = *((word32) edi_552 + 4);
														struct Eq_58241 * eax_713 = *((word32) edx_712 + 24);
														esp_682->t0000 = edi_552;
														eax_713();
													}
												}
												goto l006F8029;
											}
											if (eax_696 == 0x00A163B8)
												goto l006F7E27;
											esp_682->t0000 = esp_682->t002C;
											esp_682->dwFFFFFFFC = 9118380;
											esp_682->dwFFFFFFF8 = 9262124;
											esp_682->dwFFFFFFF4 = eax_696;
											// Failed to bind call argument.
											// Please report this issue at https://github.com/uxmal/reko
											Eq_3 stackArg4 = <invalid>;
											word32 ecx_1027;
											Eq_3 eax_1026 = fn007038E0(stackArg4, dwArg04, dwArg08, out ecx_1027, out edx_1028);
											esp_1010 = (struct Eq_76208 *) ((const char *) &esp_682->t0000 + 4);
											if (edi_552 != 0x00)
											{
												word32 v29_1036 = (word32) *edi_552 - 1;
												*edi_552 = v29_1036;
												if (v29_1036 == 0x00)
												{
													Eq_3 edx_1040 = *((word32) edi_552 + 4);
													struct Eq_58241 * eax_1041 = *((word32) edx_1040 + 24);
													esp_682->t0000 = edi_552;
													word32 esp_1044;
													eax_1041();
													esp_1010 = esp_1044 + 0x04;
												}
											}
											if (eax_1026 == 0x00)
												goto l006F8029;
											if (eax_1026 != 0x00A163B8)
											{
												*((word32) esp_1010[8].dwFFFFFFFC + 4) = (struct Eq_76208) eax_1026;
												eax_1062.u0 = 10599956;
												goto l006F802B;
											}
											word32 v30_1063 = (word32) *eax_1026 - 1;
											*eax_1026 = v30_1063;
											if (v30_1063 == 0x00)
											{
												Eq_3 ecx_1067 = *((word32) eax_1026 + 4);
												struct Eq_58241 * edx_1068 = *((word32) ecx_1067 + 24);
												esp_1010->dwFFFFFFFC = (word32) eax_1026;
												word32 esp_1075;
												edx_1068();
												esp_1010 = esp_1075 + 0x04;
											}
										}
										else
										{
l006F7E27:
											if (esi_639 > 0x00)
											{
												byte al_733 = Mem732[esi_639 - 0x01 + ebp_1157:byte];
												if (al_733 != 0x5C && al_733 != 0x2F)
												{
													Mem738[esi_639 + ebp_1157:byte] = 0x5C;
													esi_639 = (word32) esi_639 + 1;
												}
											}
											byte * eax_743 = esp_1010 + 0x0F;
											byte * edx_750 = (word32) esi_639 + (ebp_1157 - eax_743);
											do
											{
												byte cl_753 = *eax_743;
												Mem755[eax_743 + edx_750:byte] = cl_753;
												++eax_743;
											} while (cl_753 != 0x00);
											word32 esi_762 = esi_639 + Mem755[esp_1010 + 0x24:word32];
											struct Eq_76924 * esp_764 = esp_1010 - 4;
											esp_764->t0000 = ebp_1157;
											word32 ecx_2479;
											if (fn00656460(esp_764->t0000, out ecx_2479, out edx_1028) == 0x01)
											{
												word32 ecx_779;
												if (fn006F6BF0(ebp_1157, out ecx_779, out edx_1028) != 0x00)
												{
													if (edi_552 != 0x00)
													{
														word32 v34_794 = (word32) *edi_552 - 1;
														*edi_552 = v34_794;
														if (v34_794 == 0x00)
														{
															Eq_3 edx_798 = *((word32) edi_552 + 4);
															struct Eq_58241 * eax_799 = *((word32) edx_798 + 24);
															esp_764->t0000 = edi_552;
															eax_799();
														}
													}
													eax_1062.u0 = 10599992;
													goto l006F802B;
												}
												esp_764->t0000 = ebp_1157;
												esp_764->dwFFFFFFFC = 0x0100;
												esp_764->tFFFFFFF8.u0 = 0x008D5B90;
												esp_764->tFFFFFFF4 = (const char *) &esp_764->t0000 + 0x0144;
												sprintf(esp_764->tFFFFFFF4, esp_764->tFFFFFFF8, esp_764->dwFFFFFFFC);
												word32 edx_824 = g_dwA18EC8;
												esp_764->dwFFFFFFF0 = 0x01;
												esp_764->ptrFFFFFFEC = (const char *) &esp_764->t0000 + 0x0144;
												esp_764->dwFFFFFFE8 = edx_824;
												// Failed to bind call argument.
												// Please report this issue at https://github.com/uxmal/reko
												Eq_3 stackArg4 = <invalid>;
												if (fn006E1970(stackArg4, dwArg04, dwArg08, out edx_1028) != 0x00)
												{
													if (edi_552 != 0x00)
													{
														word32 v33_845 = (word32) *edi_552 - 1;
														*edi_552 = v33_845;
														if (v33_845 == 0x00)
														{
															Eq_3 ecx_849 = *((word32) edi_552 + 4);
															struct Eq_58241 * edx_850 = *((word32) ecx_849 + 24);
															esp_764->t0000 = edi_552;
															edx_850();
														}
													}
													goto l006F8029;
												}
											}
											Eq_3 ebx_869;
											Eq_3 ebx_862 = g_tA6CB8C;
											Eq_3 ecx_1829 = *ebx_862;
											esp_1010[5] = (struct Eq_76208) ebx_862;
											if (ecx_1829 != 0x00)
											{
												Eq_3 esi_872 = (word32) ebp_1157 + esi_762;
												while (true)
												{
													Eq_3 edx_875 = esi_872;
													do
													{
														byte al_878 = *ecx_1829;
														*edx_875 = al_878;
														ecx_1829 = (word32) ecx_1829 + 1;
														edx_875 = (word32) edx_875 + 1;
													} while (al_878 != 0x00);
													if (g_tA74AF0 > 0x01)
													{
														struct Eq_77047 * esp_890 = esp_1010 - 4;
														esp_890->t0000 = ebp_1157;
														esp_890->dwFFFFFFFC = 9264000;
														word32 edx_2481;
														fn00716B20(out edx_2481);
													}
													Eq_3 eax_913 = *((word32) ebx_862 + 4);
													if (*eax_913 == 0x55)
														eax_913.u0 = 9074500;
													struct Eq_77110 * esp_919 = esp_1010 - 4;
													esp_919->t0000 = eax_913;
													esp_919->tFFFFFFFC = ebp_1157;
													word32 ebx_2482;
													Eq_3 eax_955 = fn00659040(ebx_862, ebp_1157, esi_872, edi_552, es, ds, esp_919->tFFFFFFFC, esp_919->t0000, out edx_1028, out ebx_2482, out ebp_1157);
													esp_919->t001C = eax_955;
													ebx_869 = eax_955;
													if (eax_955 != 0x00)
														break;
													Eq_3 eax_972 = esp_919->t0018;
													ecx_1829 = *((word32) eax_972 + 0x0C);
													esp_919->t0018 = (word32) eax_972 + 0x0C;
													if (ecx_1829 == 0x00)
														break;
													ebx_862 = esp_919->t0018;
												}
											}
											else
												ebx_869 = esp_1010[6];
											if (edi_552 != 0x00)
											{
												word32 v32_986 = (word32) *edi_552 - 1;
												*edi_552 = v32_986;
												if (v32_986 == 0x00)
												{
													Eq_3 eax_990 = *((word32) edi_552 + 4);
													struct Eq_58241 * ecx_991 = *((word32) eax_990 + 24);
													esp_1010->dwFFFFFFFC = (word32) edi_552;
													word32 esp_1004;
													ecx_991();
													esp_1010 = esp_1004 + 0x04;
												}
											}
											if (ebx_869 != 0x00)
												goto l006F7FEA;
										}
l006F7F51:
										word32 eax_1129 = esp_1010[7];
										esp_1010[7] = (struct Eq_76208) (eax_1129 + 0x01);
									} while (eax_1129 + 0x01 < esp_1010[11]);
									if (esp_1010[6] != 0x00)
									{
l006F7FEA:
										edx_1028 = esp_1010[0x0C];
										*edx_1028 = esp_1010[6];
										eax_1062 = esp_1010[5];
										goto l006F802B;
									}
								}
								Eq_3 ecx_1143 = g_tA16F8C;
								struct Eq_76312 * esp_1146 = esp_1010 - 4;
								esp_1146->ptr0000 = esp_1010 + 0x0F;
								esp_1146->dwFFFFFFFC = 9263976;
								esp_1146->tFFFFFFF8 = ecx_1143;
								// Failed to bind call argument.
								// Please report this issue at https://github.com/uxmal/reko
								Eq_3 stackArg4 = <invalid>;
								word32 ecx_2466;
								fn006E15D0(stackArg4, dwArg04, out ecx_2466, out edx_1028);
								goto l006F8029;
							}
							esp_410->t0000.u0 = 0x00A1D1B8;
							esp_410->tFFFFFFFC = eax_482;
							word32 ecx_2456;
							word32 edx_2457;
							if (fn006D5670(esp_410->tFFFFFFFC, esp_410->t0000, out ecx_2456, out edx_2457) != 0x00)
								goto l006F7C65;
						}
						Eq_3 ecx_501 = g_tA16F8C;
						esp_410->t0000.u0 = 9263936;
						esp_410->tFFFFFFFC = ecx_501;
						goto l006F8021;
					}
					esp_410->t0000.u0 = 0x00A1BAF0;
					esp_410->tFFFFFFFC = eax_436;
					word32 ecx_2451;
					word32 edx_2452;
					if (fn006D5670(esp_410->tFFFFFFFC, esp_410->t0000, out ecx_2451, out edx_2452) != 0x00)
						goto l006F7C2C;
				}
				Eq_3 edx_455 = g_tA16F8C;
				esp_410->t0000.u0 = 9263888;
				esp_410->tFFFFFFFC = edx_455;
				goto l006F8021;
			}
			struct Eq_76092 * esp_389 = esp_142 - 4;
			esp_389->t0000.u0 = 0x00A1BAF0;
			esp_389->tFFFFFFFC = eax_386;
			word32 ecx_2447;
			word32 edx_2448;
			if (fn006D5670(esp_389->tFFFFFFFC, esp_389->t0000, out ecx_2447, out edx_2448) != 0x00)
				goto l006F7BF3;
l006F8016:
			esp_119 = esp_142 - 4;
			esp_119->dw0000 = 9263844;
l006F801B:
			eax_1385 = g_tA16F8C;
l006F8020:
			esp_119->tFFFFFFFC = eax_1385;
			goto l006F8021;
		}
	}
	word32 ecx_2432;
	word32 edx_2433;
	Eq_3 eax_90 = fn00715DD0(out ecx_2432, out edx_2433);
	if (eax_90 != 0x00)
	{
		Eq_3 eax_100 = *((word32) eax_90 + 4);
		if (eax_100 == 0x00A1BAF0)
		{
l006F7963:
			*eax_90 = (word32) *eax_90 + 1;
			word32 ecx_2434;
			word32 edx_2435;
			Eq_3 eax_136 = fn006F2750(eax_90, out ecx_2434, out edx_2435);
			esp_142 = fp - 660;
			Eq_3 edi_143 = 0x00;
			if (eax_136 > 0x00)
			{
				do
				{
					struct Eq_75845 * esp_147 = esp_142 - 4;
					esp_147->t0000 = edi_143;
					esp_147->tFFFFFFFC = eax_90;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_3 stackArg4 = <invalid>;
					word32 ecx_2439;
					word32 edx_2440;
					Eq_3 eax_159 = fn006F2790(stackArg4, dwArg04, out ecx_2439, out edx_2440);
					Eq_3 ecx_164 = esp_147->t0014;
					if (esp_147->t0014 == 0x00)
						ecx_164.u0 = 0x00A163B8;
					esp_147->t0000 = ecx_164;
					esp_147->tFFFFFFFC = esp_147->t002C;
					esp_147->dwFFFFFFF8 = 9223224;
					esp_147->dwFFFFFFF4 = 9262124;
					esp_147->tFFFFFFF0 = eax_159;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_3 stackArg4 = <invalid>;
					word32 ecx_191;
					Eq_3 eax_190 = fn007038E0(stackArg4, dwArg04, dwArg08, out ecx_191, out edx_1028);
					esp_142 = (struct Eq_75738 *) ((const char *) &esp_147->t0000 + 4);
					if (eax_190 == 0x00)
					{
						word32 v22_199 = (word32) *eax_90 - 1;
						*eax_90 = v22_199;
						if (v22_199 == 0x00)
						{
							Eq_3 ecx_203 = *((word32) eax_90 + 4);
							struct Eq_58241 * edx_204 = *((word32) ecx_203 + 24);
							esp_147->t0000 = eax_90;
							edx_204();
						}
						goto l006F8029;
					}
					if (eax_190 != 0x00A163B8)
					{
						union Eq_3 * ecx_217 = esp_147->ptr0024;
						*ecx_217 = (union Eq_3 *) eax_190;
						word32 v21_219 = (word32) *eax_90 - 1;
						*eax_90 = v21_219;
						if (v21_219 == 0x00)
						{
							Eq_3 edx_223 = *((word32) eax_90 + 4);
							struct Eq_58241 * eax_224 = *((word32) edx_223 + 24);
							esp_147->t0000 = eax_90;
							eax_224();
						}
						eax_1062.u0 = 10599956;
						goto l006F802B;
					}
					word32 v18_236 = (word32) *eax_190 - 1;
					*eax_190 = v18_236;
					if (v18_236 == 0x00)
					{
						Eq_3 edx_240 = *((word32) eax_190 + 4);
						esp_147->t0000 = eax_190;
						word32 esp_244;
						(*((word32) edx_240 + 24))();
						esp_142 = esp_244 + 0x04;
					}
					edi_143 = (word32) edi_143 + 1;
				} while (edi_143 < eax_136);
			}
			word32 v19_261 = (word32) *eax_90 - 1;
			*eax_90 = v19_261;
			if (v19_261 == 0x00)
			{
				Eq_3 ecx_265 = *((word32) eax_90 + 4);
				struct Eq_58241 * edx_266 = *((word32) ecx_265 + 24);
				esp_142->dwFFFFFFFC = (word32) eax_90;
				word32 esp_277;
				edx_266();
				esp_142 = esp_277 + 0x04;
			}
			ebx_1182 = esp_142[4];
			goto l006F79EA;
		}
		word32 ecx_2436;
		word32 edx_2437;
		if (fn006D5670(eax_100, 0x00A1BAF0, out ecx_2436, out edx_2437) != 0x00)
			goto l006F7963;
	}
	esp_119 = fp - 664;
	goto l006F801B;
}

// 006F8050: Register ui32 fn006F8050(Register Eq_3 edi, Register out Eq_540 edxOut)
// Called from:
//      fn006F82C0
ui32 fn006F8050(Eq_3 edi, union Eq_540 & edxOut)
{
	word32 edx_229;
	if (fn006F7810(out edx_229) == 0x00)
	{
		struct Eq_74720 * esi_158 = g_ptrA1BDB4;
		struct Eq_77247 * ecx_157 = esi_158->dw0000;
		while (ecx_157 != null)
		{
			Eq_3 eax_28 = edi;
			do
			{
				word32 eax_47;
				cu8 dl_31 = *eax_28;
				if (dl_31 != ecx_157->b0000)
				{
l006F8093:
					up32 eax_44 = 0x00 - (dl_31 < ecx_157->b0000);
					eax_47 = eax_44 - ~0x00 - (eax_44 < 0x00);
					goto l006F8098;
				}
				if (dl_31 == 0x00)
					break;
				byte dl_38 = *((word32) eax_28 + 1);
				if (dl_38 != ecx_157->b0001)
					goto l006F8093;
				eax_28 = (word32) eax_28 + 2;
				++ecx_157;
			} while (dl_38 != 0x00);
			eax_47 = 0x00;
l006F8098:
			if (eax_47 == 0x00)
			{
				if (esi_158->t0004 == 0x00)
				{
					word32 edx_231;
					word32 ecx_230;
					fn006E15D0(g_tA16F8C, 9264236, out ecx_230, out edx_231);
				}
				else
				{
					if (g_tA74AF0 != 0x00)
					{
						word32 edx_232;
						fn00716B20(out edx_232);
					}
					struct Eq_77321 * esp_105;
					esi_158->t0004();
					if (fn006E0FC0() == 0x00)
					{
						esp_105->tFFFFFFFC = edi;
						esp_105->tFFFFFFF8 = edi;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_3 stackArg4 = <invalid>;
						Eq_3 stackArg8 = <invalid>;
						word32 edx_235;
						ui32 eax_130 = (0x00 - (fn006F62D0(stackArg4, stackArg8, out edx_235) == 0x00) & 0x02) + ~0x00;
						edxOut.u0 = <invalid>;
						return eax_130;
					}
				}
				edxOut.u0 = <invalid>;
				return ~0x00;
			}
			ecx_157 = (struct Eq_77247 *) esi_158[1];
			++esi_158;
		}
		edxOut.u0 = <invalid>;
		return 0x00;
	}
	else
	{
		edxOut.u0 = <invalid>;
		return 0x01;
	}
}

// 006F82C0: Register Eq_3 fn006F82C0(Register Eq_3 eax, Register Eq_3 ecx, Register Eq_3 edx, Register Eq_3 esi, Register out ptr32 edxOut)
// Called from:
//      fn006F8440
//      fn006F8960
Eq_3 fn006F82C0(Eq_3 eax, Eq_3 ecx, Eq_3 edx, Eq_3 esi, ptr32 & edxOut)
{
	Eq_3 edi_13 = dwArg04;
	if (esi <= 0x00 || (esi > 0x02 || eax != 0x00))
	{
		ptr32 edx_104;
		if (esi <= 0x09)
		{
			switch (esi)
			{
			case 0x01:
				ptr32 edx_311;
				Eq_3 eax_312 = fn006F68F0(ecx, edx, ebp, esi, dwArg04, es, ds, dwArg04, eax, out edx_311);
				edxOut = edx_311;
				return eax_312;
			case 0x02:
				ptr32 edx_297;
				Eq_3 eax_298 = fn006F6730(out edx_297);
				edxOut = edx_297;
				return eax_298;
			case 0x03:
				ptr32 edx_284;
				Eq_3 eax_285 = fn0074F9E0(dwArg04, ecx, eax, out edx_284);
				edxOut = edx_284;
				return eax_285;
			case 0x04:
			case 0x08:
				break;
			case 0x05:
				ptr32 edx_232;
				Eq_3 eax_233 = fn006F8960(edx, ebp, esi, dwArg04, es, ds, dwArg04, ecx, out edx_232);
				edxOut = edx_232;
				return eax_233;
			case 0x06:
			case 0x07:
				if (ecx != 0x00 && *ecx != 0x00)
					edi_13 = ecx;
				int32 eax_105;
				if (esi == 0x06)
					eax_105 = fn006F8050(edi_13, out edx_104);
				else
					eax_105 = fn006F6D50(edi_13, out edx_104);
				if (eax_105 < 0x00)
					goto l006F8413;
				if (eax_105 == 0x00)
				{
					ptr32 edx_214;
					word32 ecx_490;
					fn006E15D0(g_tA16F8C, dwArg04, out ecx_490, out edx_214);
					edxOut = edx_214;
					return 0x00;
				}
				ptr32 edx_139;
				word32 ecx_487;
				word32 esi_488;
				word32 edi_489;
				Eq_3 eax_140 = fn006FD8B0(fn006F5DA0(), dwArg04, out ecx_487, out edx_139, out esi_488, out edi_489);
				if (eax_140 != 0x00)
				{
					*eax_140 = (word32) *eax_140 + 1;
					edxOut = edx_139;
					return eax_140;
				}
				else
				{
					ptr32 edx_177;
					word32 ecx_491;
					fn006E15D0(g_tA16F8C, dwArg04, out ecx_491, out edx_177);
					edxOut = edx_177;
					return 0x00;
				}
			case 0x09:
				if (edx != 0x00)
				{
					ptr32 edx_43;
					word32 ecx_485;
					Eq_3 eax_44 = fn007038E0(edx, 0x008D5404, 9118380, out ecx_485, out edx_43);
					edxOut = edx_43;
					return eax_44;
				}
				else
				{
					ptr32 edx_61;
					word32 ecx_486;
					fn006E0F80(g_tA16F8C, 9264364, out ecx_486, out edx_61);
					edxOut = edx_61;
					return 0x00;
				}
			}
		}
		word32 ecx_481;
		fn006E15D0(g_tA16F8C, 0x008D5CBC, out ecx_481, out edx_104);
l006F8413:
		edxOut = edx_104;
		return 0x00;
	}
	else
	{
		ptr32 edx_330;
		word32 ecx_480;
		fn006E15D0(g_tA17E2C, 9264492, out ecx_480, out edx_330);
		edxOut = edx_330;
		return 0x00;
	}
}

// 006F8440: Register word32 fn006F8440(Register Eq_3 ecx, Register Eq_3 ebx, Register Eq_3 ebp, Register Eq_3 esi, Register Eq_3 edi, Register (ptr16 Eq_7) es, Register (ptr16 Eq_8) ds, Stack Eq_3 dwArg04, Register out ptr32 ecxOut, Register out Eq_3 edxOut)
// Called from:
//      fn006F8AD0
//      fn006F8C70
word32 fn006F8440(Eq_3 ecx, Eq_3 ebx, Eq_3 ebp, Eq_3 esi, Eq_3 edi, struct Eq_7 * es, struct Eq_8 * ds, Eq_3 dwArg04, ptr32 & ecxOut, union Eq_3 & edxOut)
{
	ui32 eax_7 = g_tA14188 ^ fp - 0x011C;
	Eq_3 esi_20 = *((word32) g_tA6D67C + 4);
	if (*((word32) esi_20 + 8) == 0x00)
		fn006E86F0(9262392);
	Eq_3 eax_246;
	word32 ecx_472;
	word32 edi_474;
	word32 esi_473;
	Eq_3 edx_210;
	Eq_3 eax_57 = fn006FD8B0(*((word32) esi_20 + 8), dwArg04, out ecx_472, out edx_210, out esi_473, out edi_474);
	Eq_3 esi_162 = eax_57;
	if (eax_57 != 0x00)
	{
		*eax_57 = (word32) *eax_57 + 1;
		goto l006F85AA;
	}
	Eq_3 esi_81;
	if (ecx == 0x00A163B8)
		esi_81.u0 = 0x00;
	else
	{
		word32 edx_475;
		word32 edi_476;
		Eq_3 eax_76 = fn006DF760(ecx, dwArg04, out edx_475, out edi_476);
		esi_81 = eax_76;
		if (eax_76 == 0x00)
			goto l006F8524;
	}
	word32 edx_113;
	struct Eq_77592 * eax_111 = fn006F7890(edx, dwArg04, esi_81, ecx, es, ds, edx, dwArg04, fp - 0x0108, fp - 0x011C, out edx_113);
	struct Eq_77616 * esp_116 = fp - 300;
	if (esi_81 != 0x00)
	{
		word32 v15_121 = (word32) *esi_81.u0 - 1;
		*esi_81.u0 = v15_121;
		if (v15_121 == 0x00)
		{
			Eq_3 eax_125 = *((word64) esi_81.u0 + 4);
			struct Eq_58241 * ecx_126 = *((word32) eax_125 + 24);
			word32 esp_129;
			ecx_126();
			esp_116 = esp_129 + 0x04;
		}
	}
	if (eax_111 != null)
	{
		Eq_3 esi_142 = eax_111->t0008;
		Eq_3 ebx_144 = esp_116->t0010;
		Eq_3 edi_145 = esp_116->t0014;
		union Eq_3 * esp_146 = esp_116 - 4;
		*esp_146 = (union Eq_3 *) dwArg04;
		word32 edx_156;
		Eq_3 eax_154 = fn006F82C0(edi_145, (const char *) esp_146 + 40, ebx_144, esi_142, out edx_156);
		struct Eq_77644 * esp_159 = (const char *) esp_146 + 4;
		esi_162 = eax_154;
		if (ebx_144 != 0x00)
		{
			word32 v17_164 = (word32) *ebx_144 - 1;
			*ebx_144 = v17_164;
			if (v17_164 == 0x00)
			{
				Eq_3 eax_168 = *((word32) ebx_144 + 4);
				struct Eq_58241 * ecx_169 = *((word32) eax_168 + 24);
				*esp_146 = (union Eq_3 *) ebx_144;
				word32 esp_172;
				ecx_169();
				esp_159 = esp_172 + 0x04;
			}
		}
		if (edi_145 != 0x00)
		{
			union Eq_3 * esp_185 = esp_159 - 4;
			*esp_185 = (union Eq_3 *) edi_145;
			fclose(*esp_185);
		}
		Eq_3 edi_195 = esp_159->t001C;
		union Eq_3 * esp_196 = esp_159 - 4;
		*esp_196 = (union Eq_3 *) dwArg04;
		word32 ecx_209;
		if (fn006F7100(eax_154, edi_195, out ecx_209, out edx_210) == 0x00)
		{
			if (eax_154 != 0x00)
			{
				word32 v18_220 = (word32) *eax_154 - 1;
				*eax_154 = v18_220;
				if (v18_220 == 0x00)
				{
					Eq_3 edx_224 = *((word32) eax_154 + 4);
					struct Eq_58241 * eax_225 = *((word32) edx_224 + 24);
					*esp_196 = (union Eq_3 *) eax_154;
					eax_225();
				}
			}
			esi_162.u0 = 0x00;
		}
l006F85AA:
		eax_246 = esi_162;
		goto l006F85AC;
	}
	esp_116->tFFFFFFFC = g_tA16F8C;
	word32 ecx_477;
	eax_246 = fn006E1110(out ecx_477, out edx_210);
	if (eax_246 == 0x00)
	{
l006F85AC:
		ptr32 ecx_356;
		word32 eax_355 = fn00694B8E(eax_246, eax_7 ^ fp - 0x011C, edx_210, ebx, ebp, esi, edi, es, ds, ebx, out ecx_356);
		ecxOut = ecx_356;
		edxOut = edx_210;
		return eax_355;
	}
l006F8524:
	word32 ecx_478;
	fn006E1160(out ecx_478, out edx_210);
	++g_dwA163B8;
	eax_246.u0 = 0x00A163B8;
	goto l006F85AC;
}

// 006F8960: Register word32 fn006F8960(Register Eq_3 ebx, Register Eq_3 ebp, Register Eq_3 esi, Register Eq_3 edi, Register (ptr16 Eq_7) es, Register (ptr16 Eq_8) ds, Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Register out Eq_3 edxOut)
// Called from:
//      fn006F82C0
word32 fn006F8960(Eq_3 ebx, Eq_3 ebp, Eq_3 esi, Eq_3 edi, struct Eq_7 * es, struct Eq_8 * ds, Eq_3 dwArg04, Eq_3 dwArg08, union Eq_3 & edxOut)
{
	Eq_3 eax_266;
	ui32 eax_7 = g_tA14188 ^ fp - 0x0110;
	Eq_3 edx_108;
	Eq_3 eax_30 = fn006F63A0(dwArg04, out edx_108);
	Eq_3 edi_207 = 0x00;
	Eq_3 ebx_170 = eax_30;
	if (eax_30 == 0x00)
	{
		eax_266.u0 = 0x00;
		goto l006F8AB4;
	}
	if (g_tA74AF0 != 0x00)
	{
		word32 edx_461;
		fn00716B20(out edx_461);
	}
	word32 ecx_458;
	word32 edx_459;
	Eq_3 eax_64 = fn00717230(eax_30, out ecx_458, out edx_459);
	word32 ecx_460;
	Eq_3 eax_73 = fn006ECAC0(dwArg08, out ecx_460, out edx_108);
	if (eax_73 != 0x00)
	{
		word32 esi_462;
		Eq_3 eax_88 = fn006EA200(out edx_108, out esi_462);
		edi_207 = eax_88;
		if (eax_88 == 0x00)
			goto l006F8A14;
		word32 ecx_463;
		word32 esi_464;
		if (fn006FD8F0(eax_64, dwArg04, dwArg08, out ecx_463, out edx_108, out esi_464) == 0x00)
		{
			word32 ecx_465;
			word32 esi_466;
			if (fn006FD8F0(eax_64, dwArg04, dwArg08, out ecx_465, out edx_108, out esi_466) != 0x00)
				goto l006F8A14;
			word32 edx_467;
			struct Eq_77592 * eax_147 = fn006F7890(eax_30, eax_73, dwArg04, eax_88, es, ds, 9121084, dwArg04, dwArg08, null, out edx_467);
			if (eax_147 != null)
			{
				ebx_170 = fn006F82C0(0x00, fp - 0x0108, 0x00, eax_147->t0008, out edx_108);
				if (false)
					fclose(0x00);
				goto l006F8A87;
			}
			word32 ecx_468;
			if (fn006E1110(out ecx_468, out edx_108) != 0x00)
			{
				word32 ecx_469;
				fn006E1160(out ecx_469, out edx_108);
				*eax_30 = (word32) *eax_30 + 1;
l006F8A87:
				struct Eq_77863 * esp_220 = fp - 288;
				if (edi_207 != 0x00)
				{
					word32 v13_214 = (word32) *edi_207 - 1;
					*edi_207 = v13_214;
					if (v13_214 == 0x00)
					{
						Eq_3 ecx_218 = *((word32) edi_207 + 4);
						word32 esp_231;
						(*((word32) ecx_218 + 24))();
						esp_220 = esp_231 + 0x04;
					}
				}
				if (eax_73 != 0x00)
				{
					word32 v16_244 = (word32) *eax_73 - 1;
					*eax_73 = v16_244;
					if (v16_244 == 0x00)
					{
						Eq_3 eax_248 = *((word32) eax_73 + 4);
						struct Eq_58241 * ecx_249 = *((word32) eax_248 + 24);
						esp_220->tFFFFFFFC = eax_73;
						ecx_249();
					}
				}
				eax_266 = ebx_170;
l006F8AB4:
				word32 ecx_457;
				word32 eax_334 = fn00694B8E(eax_266, eax_7 ^ fp - 272, edx_108, ebx, ebp, esi, edi, es, ds, ebx, out ecx_457);
				edxOut = edx_108;
				return eax_334;
			}
		}
	}
l006F8A14:
	ebx_170.u0 = 0x00;
	goto l006F8A87;
}

// 006F8AD0: Register Eq_3 fn006F8AD0(Register Eq_3 eax, Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Stack Eq_3 dwArg0C, Stack Eq_3 dwArg10, Register out Eq_540 ecxOut, Register out Eq_3 edxOut)
// Called from:
//      fn006F8EC0
Eq_3 fn006F8AD0(Eq_3 eax, Eq_3 dwArg04, Eq_3 dwArg08, Eq_3 dwArg0C, Eq_3 dwArg10, union Eq_540 & ecxOut, union Eq_3 & edxOut)
{
	Eq_3 ebp_18 = *eax;
	Eq_3 eax_23 = strchr(ebp_18, 0x2E);
	Eq_3 ecx_24 = ebp_18;
	do
	{
		byte dl_31 = *ecx_24;
		ecx_24 = (word32) ecx_24 + 1;
		Eq_3 edx_419 = SEQ(edx_24_8, dl_31);
	} while (dl_31 != 0x00);
	if (ecx_24 - ((word32) ebp_18 + 1) == 0x00)
	{
		*dwArg04 = (word32) *dwArg04 + 1;
		eax->u0 = 0x00;
		ecxOut.u0 = <invalid>;
		edxOut = edx_419;
		return dwArg04;
	}
	Eq_3 ebx_55;
	if (eax_23 == 0x00)
	{
		*eax = eax_23;
		Eq_3 ebx_56 = ebp_18;
		do
		{
			ebx_56 = (word32) ebx_526 + 1;
			ebx_526 = ebx_56;
		} while (*ebx_526 != 0x00);
		ebx_55 = ebx_56 - ((word32) ebp_18 + 1);
	}
	else
	{
		*eax = (word32) eax_23 + 1;
		ebx_55 = eax_23 - ebp_18;
	}
	if (ebx_55 == 0x00)
	{
l006F8B6B:
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_3 stackArg8 = <invalid>;
		Eq_3 edx_333;
		word32 ecx_520;
		fn006E0F80(g_tA17E2C, stackArg8, out ecx_520, out edx_333);
		ecxOut.u0 = <invalid>;
		edxOut = edx_333;
		return 0x00;
	}
	word32 esi_79 = Mem75[dwArg10 + 0x00:word32] + dwArg0C;
	if (esi_79 != dwArg0C)
	{
		*esi_79 = 0x2E;
		esi_79 = (word32) esi_79 + 1;
	}
	Eq_3 edi_90 = (word32) ebx_55 + (esi_79 - dwArg0C);
	if (edi_90 >= 0x0100)
		goto l006F8B6B;
	strncpy(esi_79, ebp_18, ebx_55);
	Mem109[esi_79 + ebx_55:byte] = 0x00;
	*dwArg10 = edi_90;
	Eq_3 edx_119;
	union Eq_3 * ecx_117;
	Eq_3 eax_118 = fn006F8440(dwArg04, ebx_55, ebp_18, esi_79, edi_90, es, ds, dwArg0C, out ecx_117, out edx_119);
	Eq_3 edi_122 = eax_118;
	struct Eq_78063 * esp_123 = fp - 0x14;
	if (eax_118 == 0x00A163B8)
	{
		edx_119 = dwArg08;
		if (dwArg08 != dwArg04)
		{
			word32 v18_129 = (word32) *eax_118 - 1;
			*eax_118 = v18_129;
			if (v18_129 == 0x00)
			{
				Eq_3 eax_133 = *((word32) eax_118 + 4);
				struct Eq_58241 * ecx_134 = *((word32) eax_133 + 24);
				word32 esp_137;
				word32 edx_140;
				ecx_134();
				word24 edx_24_8_453 = SLICE(edx_140, word24, 8);
				esp_123 = esp_137 + 0x04;
			}
			Eq_3 ecx_147 = esp_123->t001C;
			struct Eq_78090 * esp_148 = esp_123 - 4;
			esp_148->t0000 = esi_79;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg4 = <invalid>;
			Eq_3 eax_159 = fn006F8440(ecx_147, ebx_55, ebp_18, esi_79, eax_118, es, ds, stackArg4, out ecx_117, out edx_119);
			edi_122 = eax_159;
			if (eax_159 == 0x00)
			{
l006F8C5C:
				ecxOut.u0 = <invalid>;
				edxOut = edx_119;
				return 0x00;
			}
			if (eax_159 != 0x00A163B8)
			{
				Eq_3 esi_170 = esp_148->t0024;
				esp_148->t0000 = esi_170;
				word32 ecx_174;
				if (fn006F70C0(out ecx_174, out edx_119) != 0x00)
				{
					word32 v20_274 = (word32) *eax_159 - 1;
					*eax_159 = v20_274;
					if (v20_274 == 0x00)
					{
						Eq_3 edx_278 = *((word32) eax_159 + 4);
						Eq_3 eax_279 = *((word32) edx_278 + 24);
						esp_148->t0000 = eax_159;
						eax_279();
					}
					ecxOut.u0 = <invalid>;
					edxOut = edx_119;
					return 0x00;
				}
				esp_148->t0000 = ebx_55;
				esp_148->tFFFFFFFC = ebp_18;
				esp_148->tFFFFFFF8 = esi_170;
				strncpy(esp_148->tFFFFFFF8, esp_148->tFFFFFFFC, esp_148->t0000);
				ecx_117 = esp_148->ptr0028;
				Mem191[ebx_55 + esi_170:byte] = 0x00;
				*ecx_117 = (union Eq_3 *) ebx_55;
			}
		}
	}
	ptr32 esp_201 = fp - 20;
	if (edi_122 != 0x00)
	{
		if (edi_122 != 0x00A163B8)
		{
			ecxOut.u0 = <invalid>;
			edxOut = edx_119;
			return edi_122;
		}
		word32 v19_214 = (word32) *edi_122 - 1;
		*edi_122 = v19_214;
		if (v19_214 == 0x00)
		{
			Eq_3 edx_218 = *((word32) edi_122 + 4);
			struct Eq_58241 * eax_219 = *((word32) edx_218 + 24);
			word32 esp_227;
			eax_219();
			esp_201 = esp_227 + 0x04;
		}
		Eq_3 ecx_236 = g_tA16F8C;
		struct Eq_78135 * esp_238 = esp_201 - 4;
		esp_238->t0000 = ebp_18;
		esp_238->dwFFFFFFFC = 9263976;
		esp_238->tFFFFFFF8 = ecx_236;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_3 stackArg4 = <invalid>;
		word32 ecx_525;
		fn006E15D0(stackArg4, dwArg04, out ecx_525, out edx_119);
	}
	goto l006F8C5C;
}

// 006F8C70: Register word32 fn006F8C70(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Stack Eq_3 dwArg0C, Stack Eq_3 dwArg10, Register out ptr32 ecxOut, Register out ptr32 edxOut)
// Called from:
//      fn006F8C70
//      fn006F8EC0
word32 fn006F8C70(Eq_3 dwArg04, Eq_3 dwArg08, Eq_3 dwArg0C, Eq_3 dwArg10, ptr32 & ecxOut, ptr32 & edxOut)
{
	ptr32 edx_15;
	if (fn006DF7C0(dwArg04, 0x008D5840, out edx_15) != 0x00)
	{
		ptr32 edx_143;
		word32 edx_605;
		word32 ecx_378;
		Eq_3 eax_42 = fn00703180(dwArg08, dwArg04, out ecx_378, out edx_605);
		Eq_3 esi_383 = eax_42;
		struct Eq_78257 * esp_384 = fp - 0x14;
		if (eax_42 != 0x00)
		{
			do
			{
				Eq_3 ecx_122;
				struct Eq_78278 * esp_124;
				Eq_3 eax_55 = *((word32) esi_383 + 4);
				if (eax_55 != 0x00A1B450)
				{
					struct Eq_78278 * esp_59 = esp_384 - 4;
					esp_59->t0000.u0 = 0x00A1B450;
					esp_59->tFFFFFFFC = eax_55;
					word32 edx_608;
					if (fn006D5670(esp_59->tFFFFFFFC, esp_59->t0000, out ecx_378, out edx_608) != 0x00)
						goto l006F8CE0;
					ecx_122 = g_tA16B7C;
					esp_59->t0000.u0 = 9264868;
					esp_124 = esp_59;
					goto l006F8E2A;
				}
l006F8CE0:
				struct Eq_78257 * esp_102 = esp_384;
				Eq_3 edi_80 = (word32) esi_383 + 20;
				if (*((word32) esi_383 + 20) == 0x2A)
				{
					word32 v13_265 = (word32) *esi_383 - 1;
					*esi_383 = v13_265;
					if (v13_265 == 0x00)
					{
						Eq_3 edx_269 = *((word32) esi_383 + 4);
						Eq_3 eax_270 = *((word32) edx_269 + 24);
						esp_384->dwFFFFFFFC = (word32) esi_383;
						word32 esp_273;
						eax_270();
						esp_102 = esp_273 + 0x04;
					}
					if (esp_102[0x0A] == 0x00)
					{
						Eq_3 edi_285 = esp_102[6];
						struct Eq_78422 * esp_286 = esp_102 - 4;
						esp_286->t0000.u0 = 0x008D5F08;
						esp_286->tFFFFFFFC = edi_285;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_3 stackArg4 = <invalid>;
						word32 edi_614;
						word32 edx_613;
						Eq_3 eax_297 = fn006DF760(stackArg4, dwArg04, out edx_613, out edi_614);
						esp_102 = (struct Eq_78257 *) ((const char *) &esp_286->t0000 + 4);
						if (eax_297 == 0x00)
						{
							word32 edx_618;
							word32 ecx_617;
							fn006E1160(out ecx_617, out edx_618);
						}
						else
						{
							esp_286->t0000.u0 = 0x01;
							esp_286->tFFFFFFFC = dwArg10;
							esp_286->tFFFFFFF8 = dwArg0C;
							esp_286->tFFFFFFF4 = eax_297;
							esp_286->tFFFFFFF0 = edi_285;
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							Eq_3 stackArg4 = <invalid>;
							word32 ecx_616;
							word32 eax_318 = fn006F8C70(stackArg4, dwArg04, dwArg08, dwArg0C, out ecx_616, out edx_143);
							word32 v20_323 = (word32) *eax_297 - 1;
							*eax_297 = v20_323;
							esp_102 = (struct Eq_78257 *) ((const char *) &esp_286->t0000 + 4);
							if (v20_323 == 0x00)
							{
								Eq_3 ecx_328 = *((word32) eax_297 + 4);
								Eq_3 edx_329 = *((word32) ecx_328 + 24);
								esp_286->t0000 = eax_297;
								word32 esp_332;
								edx_329();
								esp_102 = esp_332 + 0x04;
							}
							if (eax_318 == 0x00)
								goto l006F8E6A;
						}
					}
					goto l006F8DDA;
				}
				Eq_3 eax_83 = esp_384[6];
				struct Eq_78278 * esp_84 = esp_384 - 4;
				esp_84->t0000 = esi_383;
				esp_84->tFFFFFFFC = eax_83;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_3 stackArg4 = <invalid>;
				esp_102 = (struct Eq_78257 *) ((const char *) &esp_84->t0000 + 4);
				if (fn006DE3F0(stackArg4, dwArg04) == 0x00)
				{
					Eq_3 eax_106 = edi_80;
					do
					{
						eax_106 = (word32) eax_624 + 1;
						eax_624 = eax_106;
					} while (*eax_624 != 0x00);
					if (eax_106 - (edi_80 + 0x01) + dwArg10 <u 0x0100)
					{
						word32 ecx_175 = dwArg10 + dwArg0C;
						*ecx_175 = 0x2E;
						byte * ecx_177 = ecx_175 - edi_80;
						Eq_3 eax_179 = edi_80;
						do
						{
							byte cl_183 = *eax_179;
							Mem185[ecx_177 + 0x01 + eax_179:byte] = cl_183;
							++eax_179;
						} while (cl_183 != 0x00);
						Eq_3 ecx_191 = esp_84->t001C;
						esp_84->t0000 = dwArg0C;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_3 stackArg4 = <invalid>;
						word32 ecx_622;
						Eq_3 eax_202 = fn006F8440(ecx_191, dwArg10, dwArg0C, esi_383, edi_80, es, ds, stackArg4, out ecx_622, out edx_143);
						esp_102 = (struct Eq_78257 *) ((const char *) &esp_84->t0000 + 4);
						if (eax_202 == 0x00)
						{
							word32 v19_210 = (word32) *esi_383 - 1;
							*esi_383 = v19_210;
							if (v19_210 == 0x00)
							{
								Eq_3 ecx_214 = *((word32) esi_383 + 4);
								Eq_3 edx_215 = *((word32) ecx_214 + 24);
								esp_84->t0000 = esi_383;
								edx_215();
							}
							goto l006F8E6A;
						}
						word32 v16_226 = (word32) *eax_202 - 1;
						*eax_202 = v16_226;
						if (v16_226 == 0x00)
						{
							Eq_3 ecx_230 = *((word32) eax_202 + 4);
							Eq_3 edx_231 = *((word32) ecx_230 + 24);
							esp_84->t0000 = eax_202;
							word32 esp_234;
							edx_231();
							esp_102 = esp_234 + 0x04;
						}
						goto l006F8DC9;
					}
					ecx_122 = g_tA17E2C;
					esp_84->t0000.u0 = 9263392;
					esp_124 = esp_84;
l006F8E2A:
					struct Eq_78604 * esp_127 = esp_124 - 4;
					esp_127->t0000 = ecx_122;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_3 stackArg4 = <invalid>;
					word32 ecx_141;
					fn006E0F80(stackArg4, dwArg04, out ecx_141, out edx_143);
					word32 v17_147 = (word32) *esi_383 - 1;
					*esi_383 = v17_147;
					if (v17_147 != 0x00)
						goto l006F8E6A;
					Eq_3 edx_151 = *((word32) esi_383 + 4);
					Eq_3 eax_152 = *((word32) edx_151 + 24);
					esp_127->t0004 = esi_383;
					ptr32 edx_158;
					eax_152();
					ecxOut = 0x00;
					edxOut = edx_158;
					return 0x00;
				}
l006F8DC9:
				word32 v18_244 = (word32) *esi_383 - 1;
				*esi_383 = v18_244;
				if (v18_244 == 0x00)
				{
					Eq_3 eax_248 = *((word32) esi_383 + 4);
					Eq_3 ecx_249 = *((word32) eax_248 + 24);
					esp_102->dwFFFFFFFC = (word32) esi_383;
					word32 esp_257;
					ecx_249();
					esp_102 = esp_257 + 0x04;
				}
l006F8DDA:
				word32 eax_355 = esp_102[4];
				word32 edx_356 = esp_102[7];
				struct Eq_78392 * esp_359 = esp_102 - 4;
				esp_359->dw0000 = eax_355 + 0x01;
				esp_359->dwFFFFFFFC = edx_356;
				esp_359->dw0014 = eax_355 + 0x01;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_3 stackArg4 = <invalid>;
				word32 edx_611;
				Eq_3 eax_379 = fn00703180(stackArg4, dwArg04, out ecx_378, out edx_611);
				esi_383 = eax_379;
				esp_384 = (struct Eq_78257 *) (&esp_359->dw0000 + 1);
			} while (eax_379 != 0x00);
		}
		esp_384->dwFFFFFFFC = (word32) g_tA17CA4;
		word32 ecx_606;
		if (fn006E1110(out ecx_606, out edx_143) == 0x00)
		{
l006F8E6A:
			ecxOut = 0x00;
			edxOut = edx_143;
			return 0x00;
		}
		else
		{
			ptr32 edx_426;
			word32 ecx_607;
			fn006E1160(out ecx_607, out edx_426);
			ecxOut = 0x00;
			edxOut = edx_426;
			return 0x01;
		}
	}
	else
	{
		ecxOut = ecx;
		edxOut = edx_15;
		return 0x01;
	}
}

// 006F8EC0: Register word32 fn006F8EC0(Register Eq_3 ebx, Register Eq_3 ebp, Register Eq_3 esi, Register Eq_3 edi, Register (ptr16 Eq_7) es, Register (ptr16 Eq_8) ds, Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Stack Eq_3 dwArg0C, Register out ptr32 ecxOut, Register out Eq_3 edxOut)
// Called from:
//      fn006F9090
word32 fn006F8EC0(Eq_3 ebx, Eq_3 ebp, Eq_3 esi, Eq_3 edi, struct Eq_7 * es, struct Eq_8 * ds, Eq_3 dwArg04, Eq_3 dwArg08, Eq_3 dwArg0C, ptr32 & ecxOut, union Eq_3 & edxOut)
{
	ui32 eax_7 = g_tA14188 ^ fp - 0x0110;
	Eq_3 edx_32;
	Eq_3 eax_30 = fn006F6EA0(dwArg08, fp - 0x0108, fp - 0x0110, ecx, out edx_32);
	if (eax_30 == 0x00)
	{
		ptr32 ecx_457;
		word32 eax_456 = fn00694B8E(eax_30, eax_7 ^ fp - 0x0110, edx_32, ebx, ebp, esi, edi, es, ds, ebx, out ecx_457);
		ecxOut = ecx_457;
		edxOut = edx_32;
		return eax_456;
	}
	word32 ecx_108;
	Eq_3 edx_109;
	Eq_3 eax_54 = fn006F8AD0(fp - 0x010C, eax_30, dwArg04, dwArg08, dwArg0C, out ecx_108, out edx_109);
	if (eax_54 == 0x00)
	{
		ptr32 ecx_439;
		word32 eax_438 = fn00694B8E(eax_54, eax_7 ^ fp - 0x0110, edx_109, ebx, ebp, esi, edi, es, ds, ebx, out ecx_439);
		ecxOut = ecx_439;
		edxOut = edx_109;
		return eax_438;
	}
	Eq_3 eax_139;
	*eax_54 = (word32) *eax_54 + 1;
	struct Eq_78735 * esp_112 = fp - 288;
	Eq_3 esi_143 = eax_54;
	if (dwArg04 != 0x00)
	{
		esp_112 = fp - 288;
		do
		{
			struct Eq_78764 * esp_75 = esp_112 - 4;
			esp_75->t0000 = esp_112 + 4;
			esp_75->ptrFFFFFFFC = (const char *) &esp_75->t0000 + 28;
			esp_75->tFFFFFFF8 = esi_143;
			esp_75->tFFFFFFF4 = esi_143;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg4 = <invalid>;
			Eq_3 eax_91 = fn006F8AD0((const char *) &esp_75->t0000 + 24, stackArg4, dwArg04, dwArg08, dwArg0C, out ecx_108, out edx_109);
			word32 v15_97 = (word32) *esi_143 - 1;
			*esi_143 = v15_97;
			esp_112 = (struct Eq_78735 *) ((const char *) &esp_75->t0000 + 4);
			if (v15_97 == 0x00)
			{
				struct Eq_78756 * edx_102 = *((word32) esi_143 + 4);
				<anonymous> * eax_103 = edx_102->ptr0018;
				esp_75->t0000 = esi_143;
				word32 esp_106;
				eax_103();
				esp_112 = esp_106 + 0x04;
			}
			if (eax_91 == 0x00)
			{
				word32 v20_120 = (word32) *eax_54 - 1;
				*eax_54 = v20_120;
				if (v20_120 != 0x00)
					goto l006F906C;
				Eq_3 ecx_124 = *((word32) eax_54 + 4);
				Eq_3 edx_125 = *((word32) ecx_124 + 24);
				esp_112->dwFFFFFFFC = (word32) eax_54;
				edx_125();
				eax_139.u0 = 0x00;
				goto l006F9072;
			}
			esi_143 = eax_91;
		} while (esp_112[5] != 0x00);
	}
	if (esi_143 == 0x00A163B8)
	{
		word32 v16_265 = (word32) *esi_143 - 1;
		*esi_143 = v16_265;
		if (v16_265 == 0x00)
		{
			struct Eq_78795 * eax_269 = *((word32) esi_143 + 4);
			<anonymous> * ecx_270 = eax_269->ptr0018;
			esp_112->dwFFFFFFFC = (word32) esi_143;
			word32 esp_273;
			ecx_270();
			esp_112 = esp_273 + 0x04;
		}
		word32 v21_283 = (word32) *eax_54 - 1;
		*eax_54 = v21_283;
		if (v21_283 == 0x00)
		{
			Eq_3 edx_287 = *((word32) eax_54 + 4);
			Eq_3 eax_288 = *((word32) edx_287 + 24);
			esp_112->dwFFFFFFFC = (word32) eax_54;
			word32 esp_297;
			eax_288();
			esp_112 = esp_297 + 0x04;
		}
		Eq_3 ecx_306 = g_tA17E2C;
		struct Eq_79009 * esp_308 = esp_112 - 4;
		esp_308->dw0000 = 0x008D5ED0;
		esp_308->tFFFFFFFC = ecx_306;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_3 stackArg4 = <invalid>;
		word32 ecx_617;
		fn006E0F80(stackArg4, dwArg04, out ecx_617, out edx_109);
		eax_139.u0 = 0x00;
		goto l006F9072;
	}
	if (dwArg0C != 0x00 && dwArg0C != 0x00A163B8)
	{
		union Eq_3 * esp_155 = esp_112 - 4;
		*esp_155 = (union Eq_3 *) dwArg0C;
		struct Eq_78882 * esp_164 = (const char *) esp_155 + 4;
		if (fn006DEA90(*esp_155, out ecx_108, out edx_109) != 0x00)
		{
			word32 v18_169 = (word32) *eax_54 - 1;
			*eax_54 = v18_169;
			if (v18_169 == 0x00)
			{
				Eq_3 ecx_173 = *((word32) eax_54 + 4);
				Eq_3 edx_174 = *((word32) ecx_173 + 24);
				*esp_155 = (union Eq_3 *) eax_54;
				word32 esp_179;
				edx_174();
				esp_164 = esp_179 + 0x04;
			}
			word32 eax_189 = esp_164->dw0010;
			struct Eq_78928 * esp_190 = esp_164 - 4;
			esp_190->t0000.u0 = 0x00;
			esp_190->dwFFFFFFFC = eax_189;
			esp_190->ptrFFFFFFF8 = (const char *) &esp_190->t0000 + 28;
			esp_190->tFFFFFFF4 = dwArg0C;
			esp_190->tFFFFFFF0 = esi_143;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg4 = <invalid>;
			word32 ecx_208;
			if (fn006F8C70(stackArg4, dwArg04, dwArg08, dwArg0C, out ecx_208, out edx_109) == 0x00)
			{
				word32 v19_217 = (word32) *esi_143 - 1;
				*esi_143 = v19_217;
				if (v19_217 == 0x00)
				{
					struct Eq_78983 * edx_221 = *((word32) esi_143 + 4);
					<anonymous> * eax_222 = edx_221->ptr0018;
					esp_190->t0000 = esi_143;
					eax_222();
				}
l006F906C:
				eax_139.u0 = 0x00;
			}
			else
				eax_139 = esi_143;
l006F9072:
			ptr32 ecx_419;
			word32 eax_418 = fn00694B8E(eax_139, eax_7 ^ fp - 272, edx_109, ebx, ebp, esi, edi, es, ds, ebx, out ecx_419);
			ecxOut = ecx_419;
			edxOut = edx_109;
			return eax_418;
		}
	}
	word32 v17_239 = (word32) *esi_143 - 1;
	*esi_143 = v17_239;
	if (v17_239 == 0x00)
	{
		struct Eq_78905 * edx_243 = *((word32) esi_143 + 4);
		<anonymous> * eax_244 = edx_243->ptr0018;
		esp_112->dwFFFFFFFC = (word32) esi_143;
		eax_244();
	}
	eax_139 = eax_54;
	goto l006F9072;
}

// 006F9090: Register (ptr32 Eq_79040) fn006F9090(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Stack Eq_3 dwArg10, Stack Eq_3 dwArg14, Register out Eq_3 ecxOut, Register out ptr32 edxOut)
// Called from:
//      fn006F9120
//      fn0074E980
struct Eq_79040 * fn006F9090(Eq_3 dwArg04, Eq_3 dwArg08, Eq_3 dwArg10, Eq_3 dwArg14, union Eq_3 & ecxOut, ptr32 & edxOut)
{
	fn006F5C60();
	ptr32 edx_26;
	Eq_3 ecx_124;
	struct Eq_79040 * eax_24 = fn006F8EC0(ebx, ebp, esi, edi, es, ds, dwArg04, dwArg08, dwArg10, out ecx_124, out edx_26);
	ptr32 esp_29 = fp - 0x04;
	word32 eax_32 = fn0074F680();
	if (eax_32 != ~0x00)
	{
		ecx_124 = g_tA6CB90;
		if (ecx_124 != 0x00)
		{
			if (g_dwA1BDB8 != eax_32)
			{
				if (eax_24 != null)
				{
					word32 v12_48 = eax_24->dw0000 + ~0x00;
					eax_24->dw0000 = v12_48;
					if (v12_48 == 0x00)
					{
						struct Eq_79130 * eax_52 = eax_24->ptr0004;
						word32 esp_56;
						eax_52->ptr0018();
						esp_29 = esp_56 + 0x04;
					}
				}
				Eq_3 edx_65 = g_tA175E0;
				struct Eq_79101 * esp_67 = esp_29 - 4;
				esp_67->dw0000 = 9262364;
				esp_67->tFFFFFFFC = edx_65;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_3 stackArg4 = <invalid>;
				Eq_3 ecx_75;
				ptr32 edx_76;
				fn006E0F80(stackArg4, dwArg04, out ecx_75, out edx_76);
				ecxOut = ecx_75;
				edxOut = edx_76;
				return null;
			}
			word32 v11_85 = g_dwA6CB94 - 0x01;
			g_dwA6CB94 = v11_85;
			if (v11_85 == 0x00)
			{
				g_dwA1BDB8 = ~0x00;
				fn0074F570(ecx_124);
			}
		}
	}
	ecxOut = ecx_124;
	edxOut = edx_26;
	return eax_24;
}

// 006F9120: Register Eq_3 fn006F9120(Stack Eq_3 dwArg04)
// Called from:
//      fn006F92B0
Eq_3 fn006F9120(Eq_3 dwArg04)
{
	Eq_3 ebx_10 = 0x00;
	Eq_3 ebp_11 = 0x00;
	if (g_tA6CBA0 == 0x00)
	{
		word32 edx_509;
		word32 ecx_508;
		Eq_3 eax_17 = fn006F1A70(out ecx_508, out edx_509);
		g_tA6CBA8 = eax_17;
		if (eax_17 == 0x00)
			return 0x00;
		word32 ecx_510;
		word32 edx_511;
		Eq_3 eax_30 = fn006F1A70(out ecx_510, out edx_511);
		g_tA6CBA4 = eax_30;
		if (eax_30 == 0x00)
			return 0x00;
		word32 esi_531;
		word32 edx_530;
		Eq_3 eax_45 = fn006EA200(out edx_530, out esi_531);
		g_tA6CBA0 = eax_45;
		if (eax_45 == 0x00)
			return 0x00;
	}
	struct Eq_79150 * esp_118;
	Eq_3 edi_144;
	Eq_3 eax_64 = fn00708860();
	Eq_3 esi_117 = eax_64;
	if (eax_64 != 0x00)
	{
		Eq_3 eax_130 = g_tA6CBA4;
		*eax_64 = (word32) *eax_64 + 1;
		word32 edx_517;
		word32 ecx_516;
		Eq_3 eax_139 = fn00704220(eax_64, eax_130, out ecx_516, out edx_517);
		edi_144 = eax_139;
		if (eax_139 == 0x00)
			goto l006F925F;
	}
	else
	{
		word32 ecx_512;
		word32 edx_513;
		fn006E1160(out ecx_512, out edx_513);
		word32 edx_515;
		word32 ecx_514;
		Eq_3 eax_94 = fn006F9090(9245772, 0x00, 0x00, 0x00, out ecx_514, out edx_515);
		edi_144 = eax_94;
		if (eax_94 == 0x00)
			return eax_94;
		word32 edx_518;
		word32 esi_519;
		Eq_3 eax_112 = fn006EA200(out edx_518, out esi_519);
		esi_117 = eax_112;
		esp_118 = fp - 0x10;
		if (eax_112 == 0x00)
		{
l006F9274:
			if (edi_144 != 0x00)
			{
				word32 v16_294 = (word32) *edi_144 - 1;
				*edi_144 = v16_294;
				if (v16_294 == 0x00)
				{
					Eq_3 ecx_298 = *((word32) edi_144 + 4);
					Eq_3 edx_299 = *((word32) ecx_298 + 24);
					esp_118->tFFFFFFFC = edi_144;
					word32 esp_307;
					edx_299();
					esp_118 = esp_307 + 0x04;
				}
			}
			if (ebx_10 != 0x00)
			{
				word32 v17_320 = (word32) *ebx_10 - 1;
				*ebx_10 = v17_320;
				if (v17_320 == 0x00)
				{
					Eq_3 eax_324 = *((word32) ebx_10 + 4);
					Eq_3 ecx_325 = *((word32) eax_324 + 24);
					esp_118->tFFFFFFFC = ebx_10;
					ecx_325();
				}
			}
			return ebp_11;
		}
	}
	Eq_3 eax_151 = *((word32) edi_144 + 4);
	if (eax_151 != 0x00A1D1B8)
	{
		word32 edx_523;
		word32 ecx_522;
		if (fn006D5670(eax_151, 0x00A1D1B8, out ecx_522, out edx_523) == 0x00)
		{
			word32 edx_525;
			word32 ecx_524;
			ebx_10 = fn006DE330(edi_144, g_tA6CBA8, out ecx_524, out edx_525);
			goto l006F923E;
		}
	}
	word32 ecx_520;
	word32 edx_521;
	Eq_3 eax_187 = fn00704220(edi_144, g_tA6CBA8, out ecx_520, out edx_521);
	ebx_10 = eax_187;
	if (eax_187 != 0x00)
		goto l006F9245;
	word32 ecx_528;
	word32 edx_529;
	fn006E0E90(g_tA17E28, g_tA6CBA8, out ecx_528, out edx_529);
l006F923E:
	if (ebx_10 == 0x00)
		goto l006F925F;
l006F9245:
	word32 ecx_526;
	word32 edx_527;
	ebp_11 = fn00703AF0(ebx_10, out ecx_526, out edx_527);
l006F925F:
	esp_118 = fp - 0x10;
	if (esi_117 != 0x00)
	{
		word32 v14_268 = (word32) *esi_117 - 1;
		*esi_117 = v14_268;
		if (v14_268 == 0x00)
		{
			Eq_3 edx_272 = *((word32) esi_117 + 4);
			word32 esp_281;
			(*((word32) edx_272 + 24))();
			esp_118 = esp_281 + 0x04;
		}
	}
	goto l006F9274;
}

// 006F92B0: Register Eq_3 fn006F92B0(Stack Eq_3 dwArg04)
// Called from:
//      fn006E19F0
//      fn00718F10
Eq_3 fn006F92B0(Eq_3 dwArg04)
{
	word32 edx_102;
	word32 ecx_101;
	Eq_3 eax_12 = fn006ECAC0(dwArg04, out ecx_101, out edx_102);
	if (eax_12 == 0x00)
		return eax_12;
	Eq_3 eax_28 = fn006F9120(eax_12);
	word32 v10_34 = (word32) *eax_12 - 1;
	*eax_12 = v10_34;
	if (v10_34 == 0x00)
	{
		Eq_3 ecx_39 = *((word32) eax_12 + 4);
		(*((word32) ecx_39 + 24))();
	}
	return eax_28;
}

// 006F94A0: Register Eq_3 fn006F94A0(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Stack Eq_3 dwArg0C)
// Called from:
//      fn0074E980
Eq_3 fn006F94A0(Eq_3 dwArg04, Eq_3 dwArg08, Eq_3 dwArg0C)
{
	Eq_3 esi_19 = g_tA6CBB0;
	if (esi_19 != 0x00)
	{
		g_tA6CBB0 = *((word32) esi_19 + 0x0C);
		((word32) esi_19 + 4)->u0 = 10602136;
		*esi_19 = 0x01;
	}
	else
	{
		word32 ecx_138;
		word32 edx_139;
		Eq_3 eax_14 = fn006FEF30(&g_tA1C698, out ecx_138, out edx_139);
		esi_19 = eax_14;
		if (eax_14 == 0x00)
			return eax_14;
	}
	*((word32) esi_19 + 8) = dwArg04;
	if (dwArg08 != 0x00)
		*dwArg08 = (word32) *dwArg08 + 1;
	*((word32) esi_19 + 0x0C) = dwArg08;
	if (dwArg0C != 0x00)
		*dwArg0C = (word32) *dwArg0C + 1;
	*((word32) esi_19 + 16) = dwArg0C;
	Eq_3 edi_61 = esi_19 - 0x10;
	if (*((word32) edi_61 + 8) != ~0x01)
		fn006E86F0(0x008D0E04);
	((word32) edi_61 + 8)->u0 = ~0x02;
	*edi_61 = g_tA1D558;
	Eq_3 eax_80 = *((word32) g_tA1D558 + 4);
	*((word32) edi_61 + 4) = eax_80;
	*eax_80 = edi_61;
	*((word32) g_tA1D558 + 4) = edi_61;
	return esi_19;
}

// 006F9540: Register word32 fn006F9540(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Stack Eq_3 dwArg0C)
// Called from:
//      fn00708880
word32 fn006F9540(Eq_3 dwArg04, Eq_3 dwArg08, Eq_3 dwArg0C)
{
	Eq_3 eax_11 = *((word32) dwArg04 + 8);
	Eq_3 ebx_12 = *((word32) dwArg04 + 0x0C);
	Eq_3 edi_16 = *((word32) eax_11 + 4);
	Eq_3 eax_17 = *((word32) eax_11 + 8);
	if ((eax_17 & ~0x70) > 0x08)
	{
l006F96A1:
		word32 edx_525;
		fn006E1DC0(out edx_525);
		return 0x00;
	}
	else
	{
		switch (eax_17 & ~0x70)
		{
		case 0x00:
			if (dwArg0C == 0x00 || fn006FCF20(dwArg0C) == 0x00)
			{
				Eq_3 ecx_278 = *((word32) dwArg08 + 8);
				if (ecx_278 != 0x01)
				{
					word32 eax_302;
					edi_16();
					return eax_302;
				}
				else
				{
					word32 eax_321;
					edi_16();
					return eax_321;
				}
			}
			break;
		case 0x01:
			if (dwArg0C == 0x00 || fn006FCF20(dwArg0C) == 0x00)
			{
				word32 eax_246;
				edi_16();
				return eax_246;
			}
			break;
		case 0x02:
		case 0x03:
			word32 eax_205;
			edi_16();
			return eax_205;
		case 0x04:
			if (dwArg0C == 0x00 || fn006FCF20(dwArg0C) == 0x00)
			{
				if (*((word32) dwArg08 + 8) != 0x00)
				{
					word32 ecx_530;
					word32 edx_531;
					fn006E15D0(g_tA16B7C, dwArg04, out ecx_530, out edx_531);
					return 0x00;
				}
				else
				{
					word32 eax_177;
					edi_16();
					return eax_177;
				}
			}
			break;
		case 0x05:
		case 0x06:
		case 0x07:
			goto l006F96A1;
		case 0x08:
			if (dwArg0C == 0x00 || fn006FCF20(dwArg0C) == 0x00)
			{
				if (*((word32) dwArg08 + 8) != 0x01)
				{
					word32 ecx_528;
					word32 edx_529;
					fn006E15D0(g_tA16B7C, dwArg04, out ecx_528, out edx_529);
					return 0x00;
				}
				else
				{
					word32 eax_80;
					edi_16();
					return eax_80;
				}
			}
			break;
		}
		word32 edx_527;
		word32 ecx_526;
		fn006E15D0(g_tA16B7C, dwArg04, out ecx_526, out edx_527);
		return 0x00;
	}
}

// 006F9B70: void fn006F9B70()
// Called from:
//      fn006E8910
void fn006F9B70()
{
	Eq_3 eax_10 = g_tA6CBB0;
	if (eax_10 != 0x00)
	{
		union Eq_3 * esp_13 = fp;
		do
		{
			Eq_3 ecx_12 = *((word32) eax_10 + 0x0C);
			union Eq_3 * esp_14 = esp_13 - 4;
			*esp_14 = (union Eq_3 *) eax_10;
			g_tA6CBB0 = ecx_12;
			fn006FEFD0(*esp_14);
			eax_10 = g_tA6CBB0;
			esp_13 = esp_14;
		} while (eax_10 != 0x00);
	}
}

// 006F9C00: void fn006F9C00(Register Eq_3 esi)
// Called from:
//      fn006F9C70
void fn006F9C00(Eq_3 esi)
{
	Eq_3 eax_6 = *((word32) esi + 8);
	Eq_3 edx_8 = *((word32) esi + 0x0C);
	if (eax_6 != 0x00A163B8)
	{
		word32 ecx_12 = Mem0[Mem0[eax_6 + 0x04:word32] + 0x68:word32] + eax_6;
		if (*ecx_12 == esi)
			*ecx_12 = (union Eq_3 *) *((word32) esi + 24);
		Eq_3 eax_19 = *((word32) esi + 20);
		((word32) esi + 8)->u0 = 0x00A163B8;
		if (eax_19 != 0x00)
			*((word32) eax_19 + 24) = *((word32) esi + 24);
		Eq_3 eax_28 = *((word32) esi + 24);
		if (eax_28 != 0x00)
			*((word32) eax_28 + 20) = *((word32) esi + 20);
		((word32) esi + 20)->u0 = 0x00;
		((word32) esi + 24)->u0 = 0x00;
	}
	if (edx_8 != 0x00)
	{
		word32 v11_45 = (word32) *edx_8 - 1;
		*edx_8 = v11_45;
		if (v11_45 == 0x00)
		{
			Eq_3 eax_49 = *((word32) edx_8 + 4);
			word32 ecx_65;
			(*((word32) eax_49 + 24))();
		}
		((word32) esi + 0x0C)->u0 = 0x00;
	}
}

// 006F9C70: void fn006F9C70(Stack Eq_3 dwArg04)
// Called from:
//      fn006FE160
void fn006F9C70(Eq_3 dwArg04)
{
	Eq_3 edi_11 = *((word32) dwArg04 + 0x0C);
	((word32) dwArg04 + 0x0C)->u0 = 0x00;
	fn006F9C00(dwArg04);
	*((word32) dwArg04 + 0x0C) = edi_11;
}

// 006FB760: void fn006FB760()
// Called from:
//      fn006FBE60
void fn006FB760()
{
	word32 ecx_83;
	word32 edx_84;
	word32 esi_85;
	Eq_3 eax_13 = fn006DFF80(0x01, out ecx_83, out edx_84, out esi_85);
	if (eax_13 != 0x00)
	{
		word32 ecx_86;
		word32 edx_87;
		fn006E0E90(g_tA17E28, eax_13, out ecx_86, out edx_87);
		word32 v10_36 = (word32) *eax_13 - 1;
		*eax_13 = v10_36;
		if (v10_36 == 0x00)
		{
			Eq_3 edx_40 = *((word32) eax_13 + 4);
			Eq_3 eax_41 = *((word32) edx_40 + 24);
			eax_41();
		}
	}
}

// 006FBA70: Register word32 fn006FBA70(Register Eq_3 ebx, Register Eq_3 edi, Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Register out Eq_3 ecxOut, Register out ptr32 edxOut)
// Called from:
//      fn006FBD90
//      fn006FCC90
word32 fn006FBA70(Eq_3 ebx, Eq_3 edi, Eq_3 dwArg04, Eq_3 dwArg08, union Eq_3 & ecxOut, ptr32 & edxOut)
{
	struct Eq_79792 * eax_23;
	Eq_3 ecx_149;
	ptr32 edx_150;
	(*((word32) edi + 24))();
	struct Eq_79798 * esp_108 = fp - 0x08;
	if (eax_23 != null)
	{
		Eq_3 eax_33 = eax_23->t0008;
		if (eax_33 != 0x00)
		{
			eax_23->t0008 = dwArg08;
			word32 v15_85 = (word32) *eax_33 - 1;
			*eax_33 = v15_85;
			if (v15_85 == 0x00)
			{
				Eq_3 ecx_89 = *((word32) eax_33 + 4);
				word32 esp_93;
				(*((word32) ecx_89 + 24))();
				esp_108 = esp_93 + 0x04;
			}
			word32 v18_103 = (word32) *ebx - 1;
			*ebx = v18_103;
			if (v18_103 == 0x00)
			{
				Eq_3 eax_117 = *((word32) ebx + 4);
				Eq_3 ecx_118 = *((word32) eax_117 + 24);
				esp_108->tFFFFFFFC = ebx;
				Eq_3 ecx_127;
				ptr32 edx_128;
				ecx_118();
				ecxOut = ecx_127;
				edxOut = edx_128;
				return 0x00;
			}
		}
		else
		{
			if (eax_23->t0004 == 0x00)
			{
				*((word32) edi + 8) = (word32) *((word32) edi + 8) + 1;
				eax_23->t0008 = dwArg08;
				eax_23->t0004 = ebx;
				eax_23->t0000 = dwArg04;
				*((word32) edi + 0x0C) = (word32) *((word32) edi + 0x0C) + 1;
				ecxOut = dwArg04;
				edxOut = edx_150;
				return 0x00;
			}
			Eq_3 eax_39 = g_tA6CCF8;
			word32 v19_40 = (word32) *eax_39 - 1;
			*eax_39 = v19_40;
			if (v19_40 == 0x00)
			{
				Eq_3 edx_44 = *((word32) eax_39 + 4);
				word32 esp_48;
				(*((word32) edx_44 + 24))();
				esp_108 = esp_48 + 0x04;
			}
			ecx_149 = esp_108->t000C;
			eax_23->t0004 = ebx;
			eax_23->t0000 = ecx_149;
			eax_23->t0008 = dwArg08;
			*((word32) edi + 0x0C) = (word32) *((word32) edi + 0x0C) + 1;
		}
		ecxOut = ecx_149;
		edxOut = edx_150;
		return 0x00;
	}
	else
	{
		word32 v13_139 = (word32) *ebx - 1;
		*ebx = v13_139;
		if (v13_139 == 0x00)
		{
			Eq_3 edx_143 = *((word32) ebx + 4);
			word32 esp_147;
			(*((word32) edx_143 + 24))();
			esp_108 = esp_147 + 0x04;
		}
		word32 v21_157 = (word32) *dwArg08 - 1;
		*dwArg08 = v21_157;
		if (v21_157 == 0x00)
		{
			Eq_3 ecx_161 = *((word32) dwArg08 + 4);
			Eq_3 edx_162 = *((word32) ecx_161 + 24);
			esp_108->tFFFFFFFC = dwArg08;
			edx_162();
		}
		ecxOut = ecx_149;
		edxOut = edx_150;
		return ~0x00;
	}
}

// 006FBB30: Register (ptr32 Eq_79979) fn006FBB30(Register Eq_3 esi, Stack word32 dwArg04, Stack uint32 dwArg08, Stack Eq_79983 dwArg0C, Register out Eq_79983 edxOut)
// Called from:
//      fn006FBB90
struct Eq_79979 * fn006FBB30(Eq_3 esi, word32 dwArg04, uint32 dwArg08, Eq_79983 dwArg0C, union Eq_79983 & edxOut)
{
	Eq_3 edi_16 = *((word32) esi + 16);
	Eq_3 ebx_8 = *((word32) esi + 20);
	ui32 eax_18 = edi_16 & dwArg08;
	struct Eq_79979 * ecx_21 = (word32) ebx_8 + eax_18 * 0x0C;
	uint32 edx_22 = dwArg08;
	if (*((word32) ebx_8 + (eax_18 * 0x0C + 4)) != 0x00)
	{
		do
		{
			eax_18 = eax_18 + 0x01 + (edx_22 + eax_18 * 0x04);
			ecx_21 = (word32) ebx_8 + (eax_18 & edi_16) * 0x0C;
			edx_22 >>= 0x05;
		} while (ecx_21->dw0004 != 0x00);
	}
	*((word32) esi + 8) = (word32) *((word32) esi + 8) + 1;
	ecx_21->dw0004 = dwArg04;
	ecx_21->dw0000 = dwArg08;
	ecx_21->t0008 = dwArg0C;
	*((word32) esi + 0x0C) = (word32) *((word32) esi + 0x0C) + 1;
	edxOut = dwArg0C;
	return ecx_21;
}

// 006FBB90: Register int32 fn006FBB90(Register int32 eax, Stack Eq_3 dwArg04, Register out Eq_80051 ecxOut, Register out Eq_3 edxOut)
// Called from:
//      fn006FBD90
//      fn006FCC90
int32 fn006FBB90(int32 eax, Eq_3 dwArg04, union Eq_80051 & ecxOut, union Eq_3 & edxOut)
{
	int32 ebx_16 = 0x08;
	if (eax >= 0x08)
	{
		do
		{
			if (ebx_16 <= 0x00)
				goto l006FBBB0;
			ebx_16 *= 0x02;
		} while (ebx_16 <= eax);
		if (ebx_16 <= 0x00)
		{
l006FBBB0:
			Eq_80051 ecx_234;
			Eq_3 edx_235;
			fn006E1210(out ecx_234, out edx_235);
			ecxOut = ecx_234;
			edxOut = edx_235;
			return ~0x00;
		}
	}
	Eq_3 edx_112;
	Eq_3 esi_102 = *((word32) dwArg04 + 20);
	Eq_3 eax_116 = (word32) dwArg04 + 28;
	Eq_80051 ecx_107 = (uint32) (int8) (esi_102 != (word32) dwArg04 + 28);
	if (ebx_16 == 0x08)
	{
		if ((word32) dwArg04 + 28 == esi_102)
		{
			edx_112 = *((word32) dwArg04 + 8);
			if (edx_112 == *((word32) dwArg04 + 0x0C))
				goto l006FBCB5;
			word32 ecx_224;
			word32 * edi_220 = fp - 0x60;
			for (ecx_224 = 0x18; ecx_224 != 0x00; --ecx_224)
			{
				*edi_220 = (word32) *esi_102;
				esi_102 = (word32) esi_102 + 4;
				++edi_220;
			}
			esi_102 = fp - 0x60;
		}
	}
	else
	{
		ui32 eax_52 = ebx_16 * 0x03;
		Eq_3 eax_54 = eax_52 * 0x04;
		if (eax_52 * 0x04 == 0x00)
			eax_54.u0 = 0x01;
		eax_116 = malloc(eax_54);
		if (eax_116 == 0x00)
		{
			Eq_80051 ecx_76;
			Eq_3 edx_77;
			fn006E1210(out ecx_76, out edx_77);
			ecxOut = ecx_76;
			edxOut = edx_77;
			return ~0x00;
		}
	}
	ui32 ecx_105 = ebx_16 * 0x03;
	*((word32) dwArg04 + 20) = eax_116;
	edx_112 = ebx_16 - 0x01;
	*((word32) dwArg04 + 16) = edx_112;
	memset(eax_116, 0x00, ecx_105 * 0x04);
	Eq_3 ebx_124 = *((word32) dwArg04 + 8);
	((word32) dwArg04 + 0x0C)->u0 = 0x00;
	((word32) dwArg04 + 8)->u0 = 0x00;
	ecx_107 = ecx_105 * 0x04;
	struct Eq_80126 * esp_125 = fp - 0x78;
	if (ebx_124 > 0x00)
	{
		struct Eq_80166 * edi_131 = (word32) esi_102 + 4;
		esp_125 = fp - 0x78;
		do
		{
			Eq_79983 eax_135 = edi_131->dw0004;
			if (eax_135 != 0x00)
			{
				uint32 edx_166 = edi_131->dwFFFFFFFC;
				struct Eq_80180 * esp_167 = esp_125 - 4;
				esp_167->t0000 = eax_135;
				word32 eax_169 = edi_131->dw0000;
				esp_167->dwFFFFFFFC = edx_166;
				esp_167->dwFFFFFFF8 = eax_169;
				ecx_107 = fn006FBB30(dwArg04, esp_167->dwFFFFFFF8, esp_167->dwFFFFFFFC, esp_167->t0000, out edx_112);
				--ebx_124;
				esi_102 = esp_167->t0014;
				esp_125 = (struct Eq_80126 *) ((const char *) &esp_167->t0000 + 4);
			}
			else
			{
				word32 * eax_139 = edi_131->dw0000;
				if (eax_139 != null)
				{
					*eax_139 += ~0x00;
					struct Eq_80257 * eax_145 = edi_131->dw0000;
					--ebx_124;
					if (eax_145->dw0000 == 0x00)
					{
						struct Eq_80268 * ecx_150 = eax_145->ptr0004;
						<anonymous> * edx_151 = ecx_150->ptr0018;
						esp_125->dwFFFFFFFC = eax_145;
						word32 esp_158;
						edx_151();
						esp_125 = esp_158 + 0x04;
					}
				}
			}
			++edi_131;
		} while (ebx_124 > 0x00);
	}
	if (esp_125[5] != 0x00)
	{
		union Eq_3 * esp_198 = esp_125 - 4;
		*esp_198 = (union Eq_3 *) esi_102;
		free(*esp_198);
	}
l006FBCB5:
	ecxOut = ecx_107;
	edxOut = edx_112;
	return 0x00;
}

// 006FBCC0: Register Eq_3 fn006FBCC0(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Register out ptr32 ecxOut, Register out ptr32 edxOut)
// Called from:
//      fn006D6060
//      fn006EC890
//      fn006F6AF0
//      fn006F6EA0
//      fn006FCC90
//      fn006FD8B0
//      fn00707950
//      fn00708410
//      fn00708DC0
//      fn0070C1A0
//      fn0070C9E0
//      fn00725010
//      fn007276E0
//      fn00729040
//      fn00735890
//      fn0073AFB0
//      fn00747580
//      fn007475E0
//      fn00747610
//      fn00747890
//      fn00747A80
//      fn00748140
//      fn00748190
//      fn0074EB10
Eq_3 fn006FBCC0(Eq_3 dwArg04, Eq_3 dwArg08, ptr32 & ecxOut, ptr32 & edxOut)
{
	Eq_3 eax_9 = *((word32) dwArg04 + 4);
	if (eax_9 != 0x00A1D1B8)
	{
		ptr32 ecx_17;
		ptr32 edx_18;
		Eq_3 eax_16 = fn006D5670(eax_9, 0x00A1D1B8, out ecx_17, out edx_18);
		if (eax_16 == 0x00)
		{
			ecxOut = ecx_17;
			edxOut = edx_18;
			return eax_16;
		}
	}
	if (*((word32) dwArg08 + 4) != 0x00A1B450 || *((word32) dwArg08 + 0x0C) == ~0x00)
	{
		word32 edx_282;
		word32 ecx_281;
		if (fn006DE2E0(dwArg08, out ecx_281, out edx_282) == ~0x00)
			goto l006FBD72;
	}
	ptr32 edx_156;
	ptr32 ecx_155;
	struct Eq_80320 * esi_148;
	Eq_3 eax_62 = g_tA6D67C;
	if (eax_62 != 0x00 && *((word32) eax_62 + 40) != 0x00)
	{
		fn006E1130(fp - 0x04, fp - 0x08, fp + 0x04);
		struct Eq_80320 * eax_139;
		(*((word32) dwArg04 + 24))();
		fn006E0E00(dwArg04, out ecx_155, out edx_156);
		esi_148 = eax_139;
		if (eax_139 == null)
		{
			ecxOut = ecx_155;
			edxOut = edx_156;
			return 0x00;
		}
l006FBD80:
		Eq_3 eax_167 = esi_148->t0008;
		ecxOut = ecx_155;
		edxOut = edx_156;
		return eax_167;
	}
	struct Eq_80320 * eax_87;
	(*((word32) dwArg04 + 24))();
	esi_148 = eax_87;
	if (eax_87 != null)
		goto l006FBD80;
l006FBD72:
	ptr32 ecx_98;
	ptr32 edx_99;
	fn006E1160(out ecx_98, out edx_99);
	ecxOut = ecx_98;
	edxOut = edx_99;
	return 0x00;
}

// 006FBD90: Register Eq_3 fn006FBD90(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Stack Eq_3 dwArg0C, Register out Eq_3 ecxOut, Register out (ptr32 Eq_67260) edxOut, Register out Eq_540 ebxOut, Register out Eq_540 ediOut)
// Called from:
//      fn006E99A0
//      fn006EC890
//      fn006F5DD0
//      fn006F6AF0
//      fn006FCC90
//      fn006FD8F0
//      fn00707950
//      fn00708210
//      fn00708DC0
//      fn0070B600
//      fn007173A0
//      fn00726260
//      fn00726340
//      fn007276E0
//      fn00735890
//      fn007367D0
//      fn00747330
//      fn00747610
//      fn00747890
//      fn00747A80
//      fn00748190
//      fn0074EB10
Eq_3 fn006FBD90(Eq_3 dwArg04, Eq_3 dwArg08, Eq_3 dwArg0C, union Eq_3 & ecxOut, struct Eq_67260 & edxOut, union Eq_540 & ebxOut, union Eq_540 & ediOut)
{
	Eq_3 eax_8 = *((word32) dwArg04 + 4);
	if (eax_8 != 0x00A1D1B8)
	{
		word32 edx_242;
		word32 ecx_241;
		if (fn006D5670(eax_8, 0x00A1D1B8, out ecx_241, out edx_242) == 0x00)
		{
			struct Eq_67260 * edx_162;
			ecxOut = fn006E1DC0(out edx_162);
			edxOut = edx_162;
			ebxOut.u0 = <invalid>;
			ediOut.u0 = <invalid>;
			return ~0x00;
		}
	}
	Eq_3 eax_39;
	if (*((word32) dwArg08 + 4) == 0x00A1B450)
	{
		eax_39 = *((word32) dwArg08 + 0x0C);
		if (eax_39 == ~0x00)
		{
			word32 edx_244;
			word32 ecx_243;
			eax_39 = fn006DE2E0(dwArg08, out ecx_243, out edx_244);
		}
	}
	else
	{
		Eq_3 ecx_40;
		struct Eq_67260 * edx_41;
		eax_39 = fn006DE2E0(dwArg08, out ecx_40, out edx_41);
		if (eax_39 == ~0x00)
		{
			ecxOut = ecx_40;
			edxOut = edx_41;
			ebxOut.u0 = <invalid>;
			ediOut.u0 = <invalid>;
			return eax_39;
		}
	}
	Eq_3 esi_76 = *((word32) dwArg04 + 0x0C);
	*dwArg0C = (word32) *dwArg0C + 1;
	*dwArg08 = (word32) *dwArg08 + 1;
	Eq_3 ecx_105;
	struct Eq_67260 * edx_103;
	if (fn006FBA70(dwArg08, dwArg04, eax_39, dwArg0C, out ecx_105, out edx_103) == 0x00)
	{
		Eq_3 eax_99 = *((word32) dwArg04 + 0x0C);
		if (eax_99 > esi_76)
		{
			word32 ecx_102 = *((word32) dwArg04 + 16);
			Eq_3 ecx_104 = *((word32) dwArg04 + 8);
			edx_103 = ecx_102 + 0x02 + ecx_102;
			ecx_105 = ecx_104 * 0x03;
			if (ecx_104 * 0x03 >= edx_103)
			{
				Eq_80465 edx_126 = (uint32) (int8) (eax_99 <= 50000);
				Eq_3 ecx_134;
				struct Eq_67260 * edx_135;
				Eq_3 eax_133 = fn006FBB90(((word32) edx_126 + ((word32) edx_126 + 2)) *s eax_99, dwArg04, out ecx_134, out edx_135);
				ecxOut = ecx_134;
				edxOut = edx_135;
				ebxOut.u0 = <invalid>;
				ediOut.u0 = <invalid>;
				return eax_133;
			}
		}
		ecxOut = ecx_105;
		edxOut = edx_103;
		ebxOut.u0 = <invalid>;
		ediOut.u0 = <invalid>;
		return 0x00;
	}
	else
	{
		ecxOut = ecx_105;
		edxOut = edx_103;
		ebxOut.u0 = <invalid>;
		ediOut.u0 = <invalid>;
		return ~0x00;
	}
}

// 006FBE60: Register word32 fn006FBE60(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08)
// Called from:
//      fn006FD950
//      fn00708410
//      fn00708DC0
//      fn00747610
//      fn00747890
word32 fn006FBE60(Eq_3 dwArg04, Eq_3 dwArg08)
{
	Eq_3 eax_8 = *((word32) dwArg04 + 4);
	if (eax_8 != 0x00A1D1B8)
	{
		word32 edx_235;
		word32 ecx_234;
		if (fn006D5670(eax_8, 0x00A1D1B8, out ecx_234, out edx_235) == 0x00)
		{
			word32 edx_236;
			fn006E1DC0(out edx_236);
			return ~0x00;
		}
	}
	if (*((word32) dwArg08 + 4) != 0x00A1B450 || *((word32) dwArg08 + 0x0C) == ~0x00)
	{
		word32 ecx_237;
		word32 edx_238;
		if (fn006DE2E0(dwArg08, out ecx_237, out edx_238) == ~0x00)
			return ~0x00;
	}
	struct Eq_80523 * esp_66;
	struct Eq_80524 * eax_67;
	(*((word32) dwArg04 + 24))();
	struct Eq_80528 * esp_101 = (const char *) &esp_66->ptr0008 + 4;
	if (eax_67 == null)
		return ~0x00;
	if (eax_67->ptr0008 != null)
	{
		Eq_3 ecx_79 = g_tA6CCF8;
		Eq_3 edi_78 = eax_67->t0004;
		*ecx_79 = (word32) *ecx_79 + 1;
		eax_67->t0004 = ecx_79;
		struct Eq_80536 * ecx_83 = eax_67->ptr0008;
		eax_67->ptr0008 = null;
		*((word32) dwArg04 + 0x0C) = (word32) *((word32) dwArg04 + 0x0C) - 1;
		word32 v13_87 = ecx_83->dw0000 + ~0x00;
		ecx_83->dw0000 = v13_87;
		if (v13_87 == 0x00)
		{
			struct Eq_80598 * edx_91 = ecx_83->ptr0004;
			<anonymous> * eax_92 = edx_91->ptr0018;
			esp_66->ptr0008 = ecx_83;
			word32 esp_95;
			eax_92();
			esp_101 = esp_95 + 0x04;
		}
		word32 v15_105 = (word32) *edi_78 - 1;
		*edi_78 = v15_105;
		if (v15_105 == 0x00)
		{
			Eq_3 ecx_109 = *((word32) edi_78 + 4);
			Eq_3 edx_110 = *((word32) ecx_109 + 24);
			esp_101->tFFFFFFFC = edi_78;
			edx_110();
		}
		return 0x00;
	}
	else
	{
		fn006FB760();
		return ~0x00;
	}
}

// 006FBF30: Register word32 fn006FBF30(Stack Eq_3 dwArg04)
// Called from:
//      fn006F5DD0
word32 fn006FBF30(Eq_3 dwArg04)
{
	Eq_3 eax_9 = *((word32) dwArg04 + 4);
	if (eax_9 != 0x00A1D1B8)
	{
		word32 ecx_274;
		word32 edx_275;
		if (fn006D5670(eax_9, 0x00A1D1B8, out ecx_274, out edx_275) == 0x00)
			return ebp;
	}
	Eq_3 edi_109 = *((word32) dwArg04 + 20);
	Eq_3 esi_37 = *((word32) dwArg04 + 8);
	struct Eq_80639 * esp_127 = fp - 0x78;
	Eq_3 dwArg04_214 = edi_109;
	if ((uint32) (int8) (edi_109 != (word32) dwArg04 + 28) != 0x00)
	{
		memset((word32) dwArg04 + 28, 0x00, 0x60);
		((word32) dwArg04 + 8)->u0 = 0x00;
		((word32) dwArg04 + 0x0C)->u0 = 0x00;
	}
	else
	{
		if (esi_37 <= 0x00)
			goto l006FC02A;
		Eq_3 esi_58 = edi_109;
		word32 ecx_59;
		word32 * edi_60 = fp - 0x60;
		for (ecx_59 = 0x18; ecx_59 != 0x00; --ecx_59)
		{
			*edi_60 = (word32) *esi_58;
			esi_58 = (word32) esi_58 + 4;
			++edi_60;
		}
		memset((word32) dwArg04 + 28, 0x00, 0x60);
		((word32) dwArg04 + 8)->u0 = 0x00;
		((word32) dwArg04 + 0x0C)->u0 = 0x00;
		dwArg04_214 = fp - 0x60;
		edi_109 = fp - 0x60;
	}
	((word32) dwArg04 + 16)->u0 = 0x07;
	*((word32) dwArg04 + 20) = (word32) dwArg04 + 28;
	esp_127 = fp - 0x78;
	Eq_3 esi_102 = esi_37;
	if (esi_37 > 0x00)
	{
		struct Eq_80729 * edi_110 = (word32) edi_109 + 8;
		do
		{
			word32 * eax_114 = edi_110->dwFFFFFFFC;
			if (eax_114 != null)
			{
				*eax_114 += ~0x00;
				struct Eq_80745 * eax_120 = edi_110->dwFFFFFFFC;
				--esi_102;
				if (eax_120->dw0000 == 0x00)
				{
					struct Eq_80762 * ecx_125 = eax_120->ptr0004;
					<anonymous> * edx_126 = ecx_125->ptr0018;
					esp_127->ptrFFFFFFFC = eax_120;
					word32 esp_133;
					word32 edx_136;
					edx_126();
					esp_127 = esp_133 + 0x04;
				}
				word32 * eax_143 = edi_110->dw0000;
				if (eax_143 != null)
				{
					*eax_143 += ~0x00;
					struct Eq_80745 * eax_149 = edi_110->dw0000;
					if (eax_149->dw0000 == 0x00)
					{
						struct Eq_80762 * ecx_152 = eax_149->ptr0004;
						<anonymous> * edx_153 = ecx_152->ptr0018;
						esp_127->ptrFFFFFFFC = eax_149;
						word32 esp_161;
						word32 edx_164;
						edx_153();
						esp_127 = esp_161 + 0x04;
					}
				}
			}
			++edi_110;
		} while (esi_102 > 0x00);
		edi_109 = esp_127->t007C;
	}
l006FC02A:
	if (esp_127->dw0014 != 0x00)
	{
		union Eq_3 * esp_182 = esp_127 - 4;
		*esp_182 = (union Eq_3 *) edi_109;
		free(*esp_182);
	}
	ebp = esp_127->dw0008;
	return ebp;
}

// 006FC050: Register Eq_3 fn006FC050(Stack Eq_3 dwArg04, Stack (ptr32 Eq_3) dwArg08, Stack (ptr32 Eq_3) dwArg0C, Stack (ptr32 (ptr32 Eq_73053)) dwArg10, Register out Eq_3 edxOut)
// Called from:
//      fn006F5DD0
//      fn007173A0
//      fn00726340
//      fn00728AC0
//      fn00735890
//      fn00747890
//      fn00747A80
//      fn00747CA0
Eq_3 fn006FC050(Eq_3 dwArg04, union Eq_3 * dwArg08, union Eq_3 * dwArg0C, struct Eq_73053 ** dwArg10, union Eq_3 & edxOut)
{
	Eq_3 eax_8 = *((word32) dwArg04 + 4);
	if (eax_8 != 0x00A1D1B8)
	{
		word32 ecx_183;
		Eq_3 eax_15 = fn006D5670(eax_8, 0x00A1D1B8, out ecx_183, out edx);
		if (eax_15 == 0x00)
		{
			edxOut = edx;
			return eax_15;
		}
	}
	Eq_3 eax_32 = *dwArg08;
	if (eax_32 >= 0x00)
	{
		Eq_3 ecx_37 = *((word32) dwArg04 + 16);
		Eq_3 edi_43 = *((word32) dwArg04 + 20);
		if (eax_32 <= ecx_37)
		{
			struct Eq_80871 * edx_46 = (word32) edi_43 + 8 + eax_32 * 0x0C;
			while (edx_46->dw0000 == 0x00)
			{
				eax_32 = (word32) eax_32 + 1;
				++edx_46;
				if (eax_32 > ecx_37)
					break;
			}
		}
		Eq_3 edx_156 = (word32) eax_32 + 1;
		*dwArg08 = (union Eq_3 *) edx_156;
		if (eax_32 <= ecx_37)
		{
			if (dwArg0C != null)
			{
				edx_156 = *((word32) edi_43 + (eax_32 * 0x0C + 4));
				*dwArg0C = (union Eq_3 *) edx_156;
			}
			if (dwArg10 != null)
			{
				edx_156 = *((word32) edi_43 + (eax_32 * 0x0C + 8));
				*dwArg10 = (struct Eq_73053 **) edx_156;
			}
			edxOut = edx_156;
			return 0x01;
		}
		else
		{
			edxOut = edx_156;
			return 0x00;
		}
	}
	else
	{
		edxOut = edx;
		return 0x00;
	}
}

// 006FC0E0: Register Eq_3 fn006FC0E0(Stack Eq_3 dwArg04, Stack (ptr32 Eq_3) dwArg08, Stack (ptr32 word32) dwArg0C, Stack Eq_3 dwArg10, Stack (ptr32 word32) dwArg14, Register out Eq_3 ecxOut)
// Called from:
//      fn007389B0
Eq_3 fn006FC0E0(Eq_3 dwArg04, union Eq_3 * dwArg08, word32 * dwArg0C, Eq_3 dwArg10, word32 * dwArg14, union Eq_3 & ecxOut)
{
	Eq_3 eax_8 = *((word32) dwArg04 + 4);
	if (eax_8 != 0x00A1D1B8)
	{
		word32 edx_189;
		Eq_3 eax_15 = fn006D5670(eax_8, 0x00A1D1B8, out ecx, out edx_189);
		if (eax_15 == 0x00)
		{
			ecxOut = ecx;
			return eax_15;
		}
	}
	Eq_3 eax_32 = *dwArg08;
	if (eax_32 >= 0x00)
	{
		Eq_3 ecx_37 = *((word32) dwArg04 + 16);
		Eq_3 edi_43 = *((word32) dwArg04 + 20);
		if (eax_32 <= ecx_37)
		{
			struct Eq_80954 * edx_46 = (word32) edi_43 + 8 + eax_32 * 0x0C;
			while (edx_46->dw0000 == 0x00)
			{
				eax_32 = (word32) eax_32 + 1;
				++edx_46;
				if (eax_32 > ecx_37)
					break;
			}
		}
		*dwArg08 = (word32) eax_32 + 1;
		if (eax_32 <= ecx_37)
		{
			ui32 eax_68 = eax_32 * 0x03;
			*dwArg14 = (word32) *((word32) edi_43 + eax_68 * 0x04);
			struct Eq_80979 * eax_72 = (word32) edi_43 + eax_68 * 0x04;
			if (dwArg0C != null)
				*dwArg0C = eax_72->dw0004;
			if (dwArg10 != 0x00)
				*dwArg10 = eax_72->dw0008;
			ecxOut = dwArg10;
			return 0x01;
		}
		else
		{
			ecxOut = ecx_37;
			return 0x00;
		}
	}
	else
	{
		ecxOut = ecx;
		return 0x00;
	}
}

// 006FCC90: Register word32 fn006FCC90(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Stack word32 dwArg0C, Register out Eq_3 edxOut)
// Called from:
//      fn006FDE40
//      fn006FDE60
word32 fn006FCC90(Eq_3 dwArg04, Eq_3 dwArg08, word32 dwArg0C, union Eq_3 & edxOut)
{
	Eq_3 ebp_13 = dwArg04;
	if (dwArg04 != 0x00)
	{
		Eq_3 eax_17 = *((word32) dwArg04 + 4);
		if (eax_17 == 0x00A1D1B8)
		{
l006FCCBF:
			Eq_3 ebx_153 = dwArg08;
			if (dwArg08 != 0x00)
			{
				Eq_3 eax_69 = *((word32) dwArg08 + 4);
				if (eax_69 != 0x00A1D1B8)
				{
					word32 ecx_822;
					Eq_3 eax_84 = fn006D5670(eax_69, 0x00A1D1B8, out ecx_822, out edx);
					if (eax_84 == 0x00)
					{
						word32 ecx_823;
						Eq_3 eax_230 = fn007038E0(dwArg08, 0x008B0A10, eax_84, out ecx_823, out edx);
						if (eax_230 != 0x00)
						{
							word32 ecx_824;
							Eq_3 eax_243 = fn00704B00(eax_230, out ecx_824, out edx);
							word32 v13_248 = (word32) *eax_230 - 1;
							*eax_230 = v13_248;
							ptr32 esp_247 = fp - 0x14;
							if (v13_248 == 0x00)
							{
								Eq_3 eax_253 = *((word32) eax_230 + 4);
								Eq_3 ecx_254 = *((word32) eax_253 + 24);
								word32 esp_257;
								ecx_254();
								esp_247 = esp_257 + 0x04;
							}
							if (eax_243 != 0x00)
							{
								union Eq_3 * esp_270 = esp_247 - 4;
								*esp_270 = (union Eq_3 *) eax_243;
								// Failed to bind call argument.
								// Please report this issue at https://github.com/uxmal/reko
								Eq_3 stackArg4 = <invalid>;
								word32 ecx_826;
								Eq_3 eax_279 = fn00704040(stackArg4, out ecx_826, out edx);
								Eq_3 esi_283 = eax_279;
								struct Eq_81110 * esp_284 = (const char *) esp_270 + 4;
								if (eax_279 != 0x00)
								{
									do
									{
										struct Eq_81126 * esp_308;
										if (esp_284[8] == 0x00)
										{
											struct Eq_81153 * esp_292 = esp_284 - 4;
											esp_292->t0000 = esi_283;
											esp_292->tFFFFFFFC = ebp_13;
											// Failed to bind call argument.
											// Please report this issue at https://github.com/uxmal/reko
											Eq_3 stackArg4 = <invalid>;
											esp_308 = (struct Eq_81126 *) ((const char *) &esp_292->t0000 + 4);
											word32 ecx_303;
											word32 edx_829;
											if (fn006FBCC0(stackArg4, dwArg04, out ecx_303, out edx_829) == 0x00)
												goto l006FCD69;
											word32 v14_489 = (word32) *esi_283 - 1;
											*esi_283 = v14_489;
											if (v14_489 == 0x00)
											{
												Eq_3 edx_493 = *((word32) esi_283 + 4);
												Eq_3 eax_494 = *((word32) edx_493 + 24);
												esp_292->t0000 = esi_283;
												word32 esp_497;
												eax_494();
												esp_308 = esp_497 + 0x04;
											}
										}
										else
										{
l006FCD69:
											struct Eq_81132 * esp_313 = esp_284 - 4;
											esp_313->t0000 = esi_283;
											esp_313->tFFFFFFFC = ebx_153;
											// Failed to bind call argument.
											// Please report this issue at https://github.com/uxmal/reko
											Eq_3 stackArg4 = <invalid>;
											word32 ecx_324;
											Eq_3 eax_325 = fn00704220(stackArg4, dwArg04, out ecx_324, out edx);
											struct Eq_81148 * esp_330 = (const char *) &esp_313->t0000 + 4;
											if (eax_325 == 0x00)
											{
												word32 v18_334 = (word32) *eax_243 - 1;
												*eax_243 = v18_334;
												if (v18_334 == 0x00)
												{
													Eq_3 eax_338 = *((word32) eax_243 + 4);
													Eq_3 ecx_339 = *((word32) eax_338 + 24);
													esp_313->t0000 = eax_243;
													word32 esp_342;
													ecx_339();
													esp_330 = esp_342 + 0x04;
												}
												word32 v20_352 = (word32) *esi_283 - 1;
												*esi_283 = v20_352;
												if (v20_352 == 0x00)
												{
													Eq_3 edx_356 = *((word32) esi_283 + 4);
													Eq_3 eax_357 = *((word32) edx_356 + 24);
													esp_330->tFFFFFFFC = esi_283;
													eax_357();
												}
												goto l006FCE14;
											}
											word32 ecx_374 = esp_313->dw001C;
											esp_313->t0000 = eax_325;
											esp_313->tFFFFFFFC = esi_283;
											esp_313->dwFFFFFFF8 = ecx_374;
											// Failed to bind call argument.
											// Please report this issue at https://github.com/uxmal/reko
											Eq_3 stackArg4 = <invalid>;
											word32 ecx_382;
											word32 edi_834;
											word32 ebx_833;
											Eq_3 eax_383 = fn006FBD90(stackArg4, dwArg04, dwArg08, out ecx_382, out edx, out ebx_833, out edi_834);
											word32 v17_388 = (word32) *esi_283 - 1;
											*esi_283 = v17_388;
											esp_308 = (struct Eq_81126 *) ((const char *) &esp_313->t0000 + 4);
											if (v17_388 == 0x00)
											{
												Eq_3 edx_393 = *((word32) esi_283 + 4);
												Eq_3 eax_394 = *((word32) edx_393 + 24);
												esp_313->t0000 = esi_283;
												word32 esp_397;
												eax_394();
												esp_308 = esp_397 + 0x04;
											}
											Eq_3 edx_423;
											word32 v19_407 = (word32) *eax_325 - 1;
											*eax_325 = v19_407;
											if (v19_407 == 0x00)
											{
												Eq_3 ecx_411 = *((word32) eax_325 + 4);
												Eq_3 edx_412 = *((word32) ecx_411 + 24);
												esp_308->dwFFFFFFFC = (word32) eax_325;
												word32 esp_420;
												edx_412();
												esp_308 = esp_420 + 0x04;
												edx = edx_423;
											}
											if (eax_383 < 0x00)
											{
												word32 v22_434 = (word32) *eax_243 - 1;
												*eax_243 = v22_434;
												if (v22_434 != 0x00)
													goto l006FCE14;
												Eq_3 ecx_460 = *((word32) eax_243 + 4);
												Eq_3 edx_461 = *((word32) ecx_460 + 24);
												esp_308->dwFFFFFFFC = (word32) eax_243;
												Eq_3 edx_470;
												edx_461();
												edxOut = edx_470;
												return ~0x00;
											}
											ebx_153 = esp_308[7];
											ebp_13 = esp_308[6];
										}
										union Eq_3 * esp_506 = esp_308 - 4;
										*esp_506 = (union Eq_3 *) eax_243;
										// Failed to bind call argument.
										// Please report this issue at https://github.com/uxmal/reko
										Eq_3 stackArg4 = <invalid>;
										word32 ecx_831;
										Eq_3 eax_518 = fn00704040(stackArg4, out ecx_831, out edx);
										esi_283 = eax_518;
										esp_284 = (struct Eq_81110 *) ((const char *) esp_506 + 4);
									} while (eax_518 != 0x00);
								}
								word32 v16_529 = (word32) *eax_243 - 1;
								*eax_243 = v16_529;
								if (v16_529 == 0x00)
								{
									Eq_3 eax_533 = *((word32) eax_243 + 4);
									Eq_3 ecx_534 = *((word32) eax_533 + 24);
									esp_284->dwFFFFFFFC = (word32) eax_243;
									ecx_534();
								}
								if (fn006E0FC0() != 0x00)
								{
									edxOut = edx;
									return ~0x00;
								}
								goto l006FCEF8;
							}
						}
						goto l006FCE14;
					}
				}
				if (dwArg08 == dwArg04)
					goto l006FCEF8;
				Eq_3 ecx_100 = *((word32) dwArg08 + 0x0C);
				if (ecx_100 == 0x00)
				{
l006FCEF8:
					edxOut = edx;
					return 0x00;
				}
				edx = *((word32) dwArg04 + 0x0C);
				if (edx == 0x00)
					dwArg0C = 0x01;
				Eq_3 esi_113 = *((word32) dwArg04 + 16);
				if ((Mem111[dwArg04 + 0x08:word32] + ecx_100) * 0x03 >= (esi_113 + 0x02) + esi_113)
				{
					word32 ecx_835;
					if (fn006FBB90((edx + ecx_100) * 0x02, dwArg04, out ecx_835, out edx) != 0x00)
					{
l006FCE14:
						edxOut = edx;
						return ~0x00;
					}
				}
				word32 dwLoc04_695 = 0x01;
				if (*((word32) dwArg08 + 16) >= 0x00)
				{
					word32 ebp_148 = 0x00;
					do
					{
						struct Eq_81447 * esi_157 = (word32) *((word32) ebx_153 + 20) + ebp_148;
						if (esi_157->t0008 != 0x00)
						{
							if (dwArg0C == 0x00)
							{
								word32 ecx_837;
								if (fn006FBCC0(dwArg04, dwArg04, out ecx_837, out edx) == 0x00)
									goto l006FCEB7;
							}
							else
							{
l006FCEB7:
								Eq_3 eax_183 = esi_157->t0004;
								*eax_183 = (word32) *eax_183 + 1;
								Eq_3 eax_186 = esi_157->t0008;
								*eax_186 = (word32) *eax_186 + 1;
								word32 ecx_836;
								if (fn006FBA70(esi_157->t0004, dwArg04, esi_157->t0000, esi_157->t0008, out ecx_836, out edx) != 0x00)
									goto l006FCE14;
								ebx_153 = dwArg08;
							}
						}
						ebp_148 += 0x0C;
						dwLoc04_695 = dwLoc04_838 + 0x01;
						dwLoc04_838 = dwLoc04_695;
					} while (dwLoc04_838 + 0x00 <= *((word32) ebx_153 + 16));
				}
				goto l006FCEF8;
			}
			goto l006FCF00;
		}
		word32 ecx_821;
		if (fn006D5670(eax_17, 0x00A1D1B8, out ecx_821, out edx) != 0x00)
			goto l006FCCBF;
	}
l006FCF00:
	Eq_3 edx_56;
	fn006E1DC0(out edx_56);
	edxOut = edx_56;
	return ~0x00;
}

// 006FCF20: Register Eq_3 fn006FCF20(Stack Eq_3 dwArg04)
// Called from:
//      fn006E5C00
//      fn006F9540
//      fn007276E0
//      fn00728AC0
//      fn00728B50
//      fn00728BE0
//      fn00728E40
//      fn00735890
//      fn007389B0
Eq_3 fn006FCF20(Eq_3 dwArg04)
{
	if (dwArg04 != 0x00)
	{
		Eq_3 eax_11 = *((word32) dwArg04 + 4);
		if (eax_11 == 0x00A1D1B8)
			return *((word32) dwArg04 + 0x0C);
		word32 ecx_93;
		word32 edx_94;
		if (fn006D5670(eax_11, 0x00A1D1B8, out ecx_93, out edx_94) != 0x00)
			return *((word32) dwArg04 + 0x0C);
	}
	word32 edx_92;
	fn006E1DC0(out edx_92);
	return ~0x00;
}

// 006FD8B0: Register Eq_3 fn006FD8B0(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Register out (ptr32 Eq_58451) ecxOut, Register out ptr32 edxOut, Register out Eq_540 esiOut, Register out Eq_540 ediOut)
// Called from:
//      fn006E1970
//      fn006E19F0
//      fn006E7CE0
//      fn006F5DD0
//      fn006F62D0
//      fn006F63A0
//      fn006F6440
//      fn006F6490
//      fn006F6EA0
//      fn006F7100
//      fn006F7810
//      fn006F82C0
//      fn006F8440
//      fn00708C10
//      fn00708DC0
//      fn0070BCC0
//      fn00715DD0
//      fn00715DF0
//      fn00715E50
//      fn00716A00
//      fn00717280
//      fn0074EFB0
//      fn0074F9E0
Eq_3 fn006FD8B0(Eq_3 dwArg04, Eq_3 dwArg08, struct Eq_58451 & ecxOut, ptr32 & edxOut, union Eq_540 & esiOut, union Eq_540 & ediOut)
{
	struct Eq_58451 * ecx_13;
	ptr32 edx_14;
	Eq_3 eax_12 = fn006ECAC0(dwArg08, out ecx_13, out edx_14);
	if (eax_12 != 0x00)
	{
		struct Eq_58451 * ecx_32;
		ptr32 edx_33;
		Eq_3 eax_31 = fn006FBCC0(dwArg04, eax_12, out ecx_32, out edx_33);
		word32 v11_37 = (word32) *eax_12 - 1;
		*eax_12 = v11_37;
		if (v11_37 == 0x00)
		{
			Eq_3 edx_42 = *((word32) eax_12 + 4);
			(*((word32) edx_42 + 24))();
		}
		ecxOut = ecx_32;
		edxOut = edx_33;
		esiOut.u0 = <invalid>;
		ediOut.u0 = <invalid>;
		return eax_31;
	}
	else
	{
		ecxOut = ecx_13;
		edxOut = edx_14;
		esiOut.u0 = <invalid>;
		ediOut.u0 = <invalid>;
		return eax_12;
	}
}

// 006FD8F0: Register Eq_3 fn006FD8F0(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Stack Eq_3 dwArg0C, Register out Eq_540 ecxOut, Register out ptr32 edxOut, Register out Eq_540 esiOut)
// Called from:
//      fn006E9FA0
//      fn006F5DD0
//      fn006F62D0
//      fn006F63A0
//      fn006F6490
//      fn006F6D50
//      fn006F70C0
//      fn006F7100
//      fn006F8960
//      fn0070BCC0
//      fn00715E50
//      fn00717180
//      fn0073AFB0
//      fn0074E190
Eq_3 fn006FD8F0(Eq_3 dwArg04, Eq_3 dwArg08, Eq_3 dwArg0C, union Eq_540 & ecxOut, ptr32 & edxOut, union Eq_540 & esiOut)
{
	ptr32 edx_13;
	word32 ecx_131;
	Eq_3 eax_12 = fn006ECAC0(dwArg08, out ecx_131, out edx_13);
	if (eax_12 != 0x00)
	{
		word32 edx_132;
		fn006EC890(fp - 0x04, out edx_132);
		word32 ecx_43;
		word32 ebx_133;
		word32 edi_134;
		ptr32 edx_45;
		Eq_3 eax_44 = fn006FBD90(dwArg04, eax_12, dwArg08, out ecx_43, out edx_45, out ebx_133, out edi_134);
		*eax_12 = (word32) *eax_12 - 1;
		if (*eax_12 == 0x00)
		{
			Eq_3 edx_56 = *((word32) eax_12 + 4);
			(*((word32) edx_56 + 24))();
		}
		ecxOut.u0 = <invalid>;
		edxOut = edx_45;
		esiOut.u0 = <invalid>;
		return eax_44;
	}
	else
	{
		ecxOut.u0 = <invalid>;
		edxOut = edx_13;
		esiOut.u0 = <invalid>;
		return ~0x00;
	}
}

// 006FD950: Register int32 fn006FD950(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08)
// Called from:
//      fn006F6440
//      fn00715E50
int32 fn006FD950(Eq_3 dwArg04, Eq_3 dwArg08)
{
	word32 edx_111;
	word32 ecx_110;
	Eq_3 eax_12 = fn006ECAC0(dwArg08, out ecx_110, out edx_111);
	if (eax_12 == 0x00)
		return ~0x00;
	int32 eax_31 = fn006FBE60(dwArg04, eax_12);
	word32 v11_37 = (word32) *eax_12 - 1;
	*eax_12 = v11_37;
	if (v11_37 == 0x00)
	{
		Eq_3 edx_42 = *((word32) eax_12 + 4);
		(*((word32) edx_42 + 24))();
	}
	return eax_31;
}

// 006FDCC0: Register Eq_3 fn006FDCC0(Register out Eq_3 ecxOut, Register out Eq_3 edxOut)
// Called from:
//      fn006E99A0
//      fn006EC890
//      fn006F62D0
//      fn006FDE60
//      fn00707950
//      fn00708DC0
//      fn0070B600
//      fn00717180
//      fn00717230
//      fn00726260
//      fn00726340
//      fn00728E40
//      fn00736590
//      fn007367D0
//      fn0073AFB0
//      fn0073B3D0
//      fn00747330
//      fn00747CA0
//      fn00747F60
//      fn00748670
//      fn0074E980
Eq_3 fn006FDCC0(union Eq_3 & ecxOut, union Eq_3 & edxOut)
{
	if (g_tA6CCF8 == 0x00)
	{
		Eq_3 ecx_14;
		Eq_3 edx_15;
		Eq_3 eax_13 = fn006ECAC0(9266284, out ecx_14, out edx_15);
		g_tA6CCF8 = eax_13;
		if (eax_13 == 0x00)
		{
			ecxOut = ecx_14;
			edxOut = edx_15;
			return 0x00;
		}
	}
	Eq_3 esi_45;
	ui32 eax_23 = g_dwA6CCFC;
	if (eax_23 != 0x00)
	{
		esi_45 = *((const char *) g_aA6CBB4 + eax_23 * 0x04);
		g_dwA6CCFC = eax_23 - 0x01;
		*esi_45 = 0x01;
		if (*((word32) esi_45 + 8) == 0x00)
			goto l006FDD2D;
	}
	else
	{
		Eq_3 ecx_41;
		Eq_3 edx_42;
		Eq_3 eax_40 = fn006FEF30(&g_tA1D1B8, out ecx_41, out edx_42);
		esi_45 = eax_40;
		if (eax_40 == 0x00)
		{
			ecxOut = ecx_41;
			edxOut = edx_42;
			return 0x00;
		}
	}
	Eq_3 edi_71 = (word32) esi_45 + 28;
	memset(edi_71, 0x00, 0x60);
	((word32) esi_45 + 16)->u0 = 0x07;
	*((word32) esi_45 + 20) = edi_71;
	((word32) esi_45 + 0x0C)->u0 = 0x00;
	((word32) esi_45 + 8)->u0 = 0x00;
l006FDD2D:
	((word32) esi_45 + 24)->u0 = 0x006FB960;
	Eq_3 edi_82 = esi_45 - 0x10;
	if (*((word32) edi_82 + 8) != ~0x01)
		fn006E86F0(0x008D0E04);
	((word32) edi_82 + 8)->u0 = ~0x02;
	*edi_82 = g_tA1D558;
	Eq_3 ecx_100 = g_tA1D558;
	Eq_3 eax_101 = *((word32) ecx_100 + 4);
	*((word32) edi_82 + 4) = eax_101;
	*eax_101 = edi_82;
	Eq_3 edx_104 = g_tA1D558;
	*((word32) edx_104 + 4) = edi_82;
	ecxOut = ecx_100;
	edxOut = edx_104;
	return esi_45;
}

// 006FDE40: Register word32 fn006FDE40()
// Called from:
//      fn006F7810
//      fn00747CA0
word32 fn006FDE40()
{
	word32 edx_31;
	return fn006FCC90(dwArg04, dwArg08, 0x01, out edx_31);
}

// 006FDE60: Register Eq_3 fn006FDE60(Stack Eq_3 dwArg04, Register out ptr32 edxOut)
// Called from:
//      fn006F62D0
//      fn00707950
Eq_3 fn006FDE60(Eq_3 dwArg04, ptr32 & edxOut)
{
	if (dwArg04 != 0x00)
	{
		Eq_3 eax_11 = *((word32) dwArg04 + 4);
		if (eax_11 == 0x00A1D1B8)
		{
l006FDE85:
			word32 ecx_159;
			ptr32 edx_127;
			Eq_3 eax_56 = fn006FDCC0(out ecx_159, out edx_127);
			if (eax_56 != 0x00)
			{
				if (fn006FCC90(eax_56, dwArg04, 0x01, out edx_127) == 0x00)
				{
					edxOut = edx_127;
					return eax_56;
				}
				word32 v10_81 = (word32) *eax_56 - 1;
				*eax_56 = v10_81;
				if (v10_81 == 0x00)
				{
					Eq_3 eax_85 = *((word32) eax_56 + 4);
					(*((word32) eax_85 + 24))();
				}
			}
			edxOut = edx_127;
			return 0x00;
		}
		word32 edx_161;
		word32 ecx_160;
		if (fn006D5670(eax_11, 0x00A1D1B8, out ecx_160, out edx_161) != 0x00)
			goto l006FDE85;
	}
	ptr32 edx_40;
	fn006E1DC0(out edx_40);
	edxOut = edx_40;
	return 0x00;
}

// 006FE010: void fn006FE010(Register Eq_3 ebx, Register Eq_3 edi)
// Called from:
//      fn006FE400
void fn006FE010(Eq_3 ebx, Eq_3 edi)
{
	ptr32 esp_29 = fp - 4;
	Eq_3 esi_11 = *ebx;
	if (esi_11 != ebx)
	{
		do
		{
			Eq_3 eax_16;
			if (*((word32) esi_11 + 8) != 0x00)
			{
				<anonymous> * ecx_27 = *((word32) *((word32) esi_11 + 20) + 92);
				struct Eq_81886 * esp_30 = esp_29 - 4;
				esp_30->t0000 = ebx;
				esp_30->dwFFFFFFFC = 0x006FDFB0;
				ptr32 eax_28 = (word32) esi_11 + 16;
				esp_30->ptrFFFFFFF8 = eax_28;
				((word32) esi_11 + 8)->u0 = ~0x02;
				word32 esp_39;
				ecx_27();
				eax_16 = *esi_11;
				esp_29 = esp_39 + 0x0C;
			}
			else
			{
				Eq_3 ecx_15 = *((word32) esi_11 + 4);
				eax_16 = *esi_11;
				*ecx_15 = eax_16;
				*((word32) eax_16 + 4) = ecx_15;
				Eq_3 ecx_20 = *((word32) edi + 4);
				*((word32) esi_11 + 4) = ecx_20;
				*((word32) edi + 4) = esi_11;
				*ecx_20 = esi_11;
				*esi_11 = edi;
				((word32) esi_11 + 8)->u0 = ~0x03;
			}
			esi_11 = eax_16;
		} while (eax_16 != ebx);
	}
}

// 006FE070: void fn006FE070(Register Eq_3 edi, Stack Eq_3 dwArg04)
// Called from:
//      fn006FE400
void fn006FE070(Eq_3 edi, Eq_3 dwArg04)
{
	Eq_3 esi_11 = *dwArg04;
	if (esi_11 != dwArg04)
	{
		do
		{
			Eq_81934 eax_34;
			Eq_3 eax_21 = *((word32) esi_11 + 20);
			Eq_3 ebx_23 = *esi_11;
			Eq_3 ecx_24 = (word32) esi_11 + 16;
			if (eax_21 == 10611608)
			{
				eax_34 = fn0070C9E0(ecx_24) == 0x00;
				goto l006FE0CE;
			}
			if ((*((word32) eax_21 + 84) & 0x0200) != 0x00)
			{
				eax_34.u1 = (uint32) (int8) (*((word32) eax_21 + 188) != 0x00);
				goto l006FE0CE;
			}
			if (eax_21 == 10677784)
			{
				eax_34 = fn00750160(ecx_24);
l006FE0CE:
				if (eax_34 != 0x00)
				{
					Eq_3 eax_77 = *((word32) esi_11 + 4);
					Eq_3 ecx_78 = *esi_11;
					*eax_77 = ecx_78;
					*((word32) ecx_78 + 4) = eax_77;
					Eq_3 eax_82 = *((word32) edi + 4);
					*((word32) esi_11 + 4) = eax_82;
					*((word32) edi + 4) = esi_11;
					*eax_82 = esi_11;
					*esi_11 = edi;
					((word32) esi_11 + 8)->u0 = ~0x02;
				}
			}
			esi_11 = ebx_23;
		} while (ebx_23 != dwArg04);
	}
}

// 006FE160: Register word32 fn006FE160(Stack Eq_3 dwArg04)
// Called from:
//      fn006FE400
word32 fn006FE160(Eq_3 dwArg04)
{
	struct Eq_81999 * dwLoc0C_227 = fp - 0x10;
	Eq_3 ecx_8 = dwArg04;
	Eq_3 edi_12 = *dwArg04;
	word32 eax_13 = 0x00;
	if (edi_12 != dwArg04)
	{
		do
		{
			Eq_3 eax_30 = *((word32) edi_12 + 20);
			Eq_3 ebp_33 = *edi_12;
			if ((*((word32) eax_30 + 84) & 0x40) != 0x00)
			{
				struct Eq_79660 * ebx_35 = *((word32) eax_30 + 0x0068);
				if (ebx_35 > null)
				{
					word32 esi_38 = Mem29[ebx_35 + 0x10 + edi_12:word32];
					if (esi_38 != 0x00)
					{
						do
						{
							fn006F9C70(esi_38);
							if (*((word32) esi_38 + 0x0C) != 0x00 && *((word32) esi_38 - 8) != ~0x03)
							{
								*esi_38 = (word32) *esi_38 + 1;
								Eq_3 ecx_62 = *((word32) esi_38 - 0x0C);
								Eq_3 edx_63 = *((word32) esi_38 - 16);
								*ecx_62 = edx_63;
								*((word32) edx_63 + 4) = ecx_62;
								struct Eq_81999 * eax_64 = esi_38 - 0x10;
								eax_64->ptr0004 = dwLoc0C_227;
								dwLoc0C_227->ptr0000 = eax_64;
								eax_64->ptr0000 = fp - 0x10;
								dwLoc0C_227 = eax_64;
							}
							esi_38 = Mem78[ebx_35 + 0x10 + edi_12:word32];
						} while (esi_38 != 0x00);
						ecx_8 = dwArg04;
					}
				}
			}
			struct Eq_82011 * esp_104 = fp - 0x24;
			edi_12 = ebp_33;
		} while (ebp_33 != ecx_8);
		struct Eq_82098 * eax_100 = fp - 0x10;
		if (fp - 0x10 != fp - 0x10)
		{
			do
			{
				struct Eq_82107 * esp_132;
				Eq_3 ebx_102 = eax_100->dw001C;
				struct Eq_82107 * esp_105 = esp_104 - 4;
				esp_105->t0000.u0 = 0x00;
				struct Eq_82119 * edi_103 = eax_100 + 1;
				esp_105->ptrFFFFFFFC = edi_103;
				esp_105->tFFFFFFF8 = ebx_102;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_3 stackArg4 = <invalid>;
				word32 ecx_293;
				word32 edx_294;
				Eq_3 eax_117 = fn00703AF0(stackArg4, out ecx_293, out edx_294);
				esp_104 = (struct Eq_82011 *) ((const char *) &esp_105->t0000 + 4);
				if (eax_117 == 0x00)
				{
					esp_105->t0000 = ebx_102;
					fn006E1780();
					esp_132 = esp_105;
					goto l006FE23E;
				}
				word32 v15_124 = (word32) *eax_117 - 1;
				*eax_117 = v15_124;
				if (v15_124 == 0x00)
				{
					Eq_3 edx_128 = *((word32) eax_117 + 4);
					esp_105->t0000 = eax_117;
					(*((word32) edx_128 + 24))();
l006FE23E:
					esp_104 = (struct Eq_82011 *) ((const char *) &esp_132->t0000 + 4);
				}
				word32 v16_153 = edi_103->dw0000 + ~0x00;
				edi_103->dw0000 = v16_153;
				if (v16_153 == 0x00)
				{
					struct Eq_82184 * ecx_157 = edi_103->ptr0004;
					<anonymous> * edx_158 = ecx_157->ptr0018;
					esp_104->dwFFFFFFFC = edi_103;
					word32 esp_170;
					edx_158();
					esp_104 = esp_170 + 0x04;
				}
				eax_100 = esp_104->dw0014;
				if (eax_100 == eax_100)
				{
					struct Eq_82206 * eax_187 = eax_100->dw0004;
					struct Eq_82210 * ecx_188 = eax_100->dw0000;
					eax_187->ptr0000 = ecx_188;
					ecx_188->ptr0004 = eax_187;
					struct Eq_82220 * ecx_191 = esp_104->dw002C;
					struct Eq_82098 * eax_192 = ecx_191->ptr0004;
					eax_100->dw0004 = eax_192;
					ecx_191->ptr0004 = eax_100;
					eax_192->dw0000 = eax_100;
					eax_100->dw0000 = ecx_191;
					eax_100 = esp_104->dw0014;
				}
				else
					esp_104[1] = (struct Eq_82011) ((word32) esp_104[1].dwFFFFFFFC + 5);
			} while (eax_100 != &esp_104->dw0014);
		}
		eax_13 = (word32) esp_104[1];
	}
	return eax_13;
}

// 006FE2A0: Register Eq_3 fn006FE2A0(Register Eq_3 ebx, Stack Eq_3 dwArg04)
// Called from:
//      fn006FE400
Eq_3 fn006FE2A0(Eq_3 ebx, Eq_3 dwArg04)
{
	Eq_3 edi_143 = *ebx;
	if (g_tA6CD0C == 0x00)
	{
		word32 edx_247;
		Eq_3 eax_22 = fn006F2650(0x00, out edx_247);
		g_tA6CD0C = eax_22;
		if (eax_22 == 0x00)
			fn006E86F0(9266508);
	}
	ptr32 esp_107 = fp - 0x0C;
	while (edi_143 != ebx)
	{
		Eq_3 esi_49 = (word32) edi_143 + 16;
		if ((g_bA6CD04 & 0x20) == 0x00)
		{
			Eq_81934 eax_62;
			Eq_3 eax_51 = *((word32) esi_49 + 4);
			if (eax_51 == 10611608)
			{
				struct Eq_82326 * esp_79 = esp_107 - 4;
				esp_79->t0000 = g_tA6CD14;
				esp_79->tFFFFFFFC = esi_49;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_3 stackArg4 = <invalid>;
				eax_62 = fn0070C9E0(stackArg4) == 0x00;
				goto l006FE335;
			}
			if ((*((word32) eax_51 + 84) & 0x0200) != 0x00)
			{
				eax_62.u1 = (uint32) (int8) (*((word32) eax_51 + 188) != 0x00);
				goto l006FE335;
			}
			if (eax_51 != 10677784)
				goto l006FE34D;
			union Eq_3 * esp_60 = esp_107 - 4;
			*esp_60 = (union Eq_3 *) esi_49;
			eax_62 = fn00750160(*esp_60);
l006FE335:
			if (eax_62 != 0x00)
				goto l006FE339;
		}
		else
		{
l006FE339:
			Eq_3 edx_105 = g_tA6CD0C;
			struct Eq_82292 * esp_108 = esp_107 - 4;
			esp_108->t0000 = esi_49;
			esp_108->tFFFFFFFC = edx_105;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg4 = <invalid>;
			esp_107 = fp - 0x0C;
			Eq_3 ecx_124;
			word32 edx_249;
			if (fn006F2A10(stackArg4, dwArg04, out ecx_124, out edx_249) < 0x00)
				return ecx_124;
		}
l006FE34D:
		edi_143 = *edi_143;
	}
	Eq_3 ecx_150 = *ebx;
	if (ecx_150 != ebx)
	{
		Eq_3 eax_156 = *((word32) dwArg04 + 4);
		*eax_156 = ecx_150;
		*((word32) ecx_150 + 4) = eax_156;
		Eq_3 eax_159 = *((word32) ebx + 4);
		*((word32) dwArg04 + 4) = eax_159;
		*eax_159 = dwArg04;
	}
	*((word32) ebx + 4) = ebx;
	*ebx = ebx;
	return ecx_150;
}

// 006FE380: void fn006FE380(Register Eq_3 ebx, Stack Eq_3 dwArg04)
// Called from:
//      fn006FE400
void fn006FE380(Eq_3 ebx, Eq_3 dwArg04)
{
	Eq_3 esi_11 = *dwArg04;
	if (esi_11 != dwArg04)
	{
		struct Eq_82401 * esp_14 = fp - 0x0C;
		do
		{
			struct Eq_82406 * edi_22 = (word32) esi_11 + 16;
			if ((g_bA6CD04 & 0x20) != 0x00)
			{
				Eq_3 eax_60 = g_tA6CD0C;
				struct Eq_82418 * esp_61 = esp_14 - 4;
				esp_61->ptr0000 = edi_22;
				esp_61->tFFFFFFFC = eax_60;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_3 stackArg4 = <invalid>;
				word32 ecx_154;
				word32 edx_155;
				fn006F2A10(stackArg4, dwArg04, out ecx_154, out edx_155);
				esp_14 = (struct Eq_82401 *) ((const char *) &esp_61->ptr0000 + 4);
			}
			else
			{
				<anonymous> * eax_25 = edi_22->ptr0004->ptr0060;
				if (eax_25 != null)
				{
					++edi_22->dw0000;
					esp_14->dwFFFFFFFC = edi_22;
					struct Eq_82406 ** esp_37;
					word32 eax_38;
					word32 ecx_39;
					word32 edx_40;
					eax_25();
					word32 v14_44 = edi_22->dw0000 + ~0x00;
					edi_22->dw0000 = v14_44;
					esp_14 = (struct Eq_82401 *) ((const char *) esp_37 + 4);
					if (v14_44 == 0x00)
					{
						struct Eq_82409 * edx_48 = edi_22->ptr0004;
						<anonymous> * eax_49 = edx_48->ptr0018;
						*esp_37 = (struct Eq_82406 **) edi_22;
						word32 esp_52;
						word32 eax_53;
						word32 ecx_54;
						eax_49();
						esp_14 = esp_52 + 0x04;
					}
				}
			}
			if (*dwArg04 == esi_11)
			{
				Eq_3 eax_78 = *((word32) esi_11 + 4);
				Eq_3 ecx_79 = *esi_11;
				*eax_78 = ecx_79;
				*((word32) ecx_79 + 4) = eax_78;
				Eq_3 eax_84 = *((word32) ebx + 4);
				*((word32) esi_11 + 4) = eax_84;
				*((word32) ebx + 4) = esi_11;
				*eax_84 = esi_11;
				*esi_11 = ebx;
				((word32) esi_11 + 8)->u0 = ~0x02;
			}
			esi_11 = *dwArg04;
		} while (esi_11 != dwArg04);
	}
}

// 006FE400: Register word32 fn006FE400(Stack int32 dwArg04, Register out ptr32 ebpOut)
// Called from:
//      fn006FE8B0
//      fn006FEE00
word32 fn006FE400(int32 dwArg04, ptr32 & ebpOut)
{
	if (g_tA6CD14 == 0x00)
	{
		word32 edx_1249;
		word32 ecx_1248;
		Eq_3 eax_28 = fn006F1A70(out ecx_1248, out edx_1249);
		g_tA6CD14 = eax_28;
		if (eax_28 == 0x00)
			fn006E86F0(0x008D6668);
	}
	struct Eq_82537 * esp_104 = fp - 0x40;
	if ((g_bA6CD04 & 0x01) != 0x00)
	{
		Eq_3 eax_55 = g_tA6CD18;
		if (eax_55 != 0x00)
		{
			word32 ecx_1252;
			word32 edx_1253;
			Eq_3 eax_70 = fn007038E0(eax_55, 0x00, 0x00, out ecx_1252, out edx_1253);
			esp_104 = fp - 0x40;
			if (eax_70 == 0x00)
			{
				word32 edx_1256;
				word32 ecx_1255;
				fn006E1160(out ecx_1255, out edx_1256);
			}
			else
			{
				real64 rLoc1_1254;
				fn006FF3E0(eax_70, out rLoc1_1254);
				word32 v14_90 = (word32) *eax_70 - 1;
				*eax_70 = v14_90;
				esp_104 = fp - 0x40;
				if (v14_90 == 0x00)
				{
					Eq_3 eax_94 = *((word32) eax_70 + 4);
					word32 esp_98;
					(*((word32) eax_94 + 24))();
					esp_104 = esp_98 + 0x04;
				}
			}
		}
		struct Eq_82571 * esp_114 = esp_104 - 4;
		esp_114->dw0000 = dwArg04;
		esp_114->dwFFFFFFFC = 9266756;
		word32 edx_1250;
		fn00716B20(out edx_1250);
		esp_114->dwFFFFFFF8 = 9266724;
		word32 edx_1251;
		fn00716B20(out edx_1251);
		struct Eq_82593 * esi_139 = g_aA1D510;
		do
		{
			struct Eq_82593 * eax_142;
			word32 ecx_143 = 0x00;
			for (eax_142 = esi_139->dw0000; eax_142 != esi_139; eax_142 = eax_142->dw0000)
				++ecx_143;
			struct Eq_82641 * esp_158 = esp_104 - 4;
			esp_158->dw0000 = ecx_143;
			esp_158->dwFFFFFFFC = 0x008D6620;
			word32 edx_1257;
			fn00716B20(out edx_1257);
			++esi_139;
		} while (esi_139 < &g_tA1D558);
		esp_158->dw0000 = 0x008A6DE8;
		word32 edx_1258;
		fn00716B20(out edx_1258);
		esp_104 = (struct Eq_82537 *) (&esp_158->dw0000 + 1);
	}
	word32 ecx_196 = dwArg04 + 0x01;
	if (dwArg04 < 0x02)
		g_aA1D53C[dwArg04] = (struct Eq_179572) ((word32) g_aA1D53C[dwArg04].dw0000 + 1);
	if (dwArg04 >= 0x00)
	{
		struct Eq_82701 * eax_210 = g_aA1D520 + 1;
		do
		{
			eax_210->dw0000 = 0x00;
			++eax_210;
			--ecx_196;
		} while (ecx_196 != 0x00);
		if (dwArg04 > 0x00)
		{
			struct Eq_82593 * edx_226 = dwArg04 * 0x18 + 0x00A1D510;
			struct Eq_82593 * eax_227 = g_aA1D510;
			int32 edi_228 = dwArg04;
			do
			{
				struct Eq_82593 * esi_231 = eax_227->dw0000;
				if (esi_231 != eax_227)
				{
					struct Eq_82593 * ecx_235 = edx_226->dw0004;
					ecx_235->dw0000 = esi_231;
					esi_231->dw0004 = ecx_235;
					struct Eq_82593 * ecx_238 = eax_227->dw0004;
					edx_226->dw0004 = ecx_238;
					ecx_238->dw0000 = edx_226;
				}
				eax_227->dw0004 = eax_227;
				eax_227->dw0000 = eax_227;
				++eax_227;
				--edi_228;
			} while (edi_228 != 0x00);
		}
	}
	Eq_3 ebp_269;
	Eq_3 ebx_260 = dwArg04 * 0x18 + 0x00A1D510;
	if (dwArg04 < 0x02)
	{
		ebp_269 = dwArg04 * 0x18 + 10605864;
		esp_104->t0010 = ebp_269;
	}
	else
	{
		esp_104->t0010 = ebx_260;
		ebp_269 = ebx_260;
	}
	Eq_3 eax_274 = *ebx_260;
	while (eax_274 != ebx_260)
	{
		*((word32) eax_274 + 8) = *((word32) eax_274 + 16);
		eax_274 = *eax_274;
	}
	Eq_3 esi_287 = *ebx_260;
	while (esi_287 != ebx_260)
	{
		Eq_3 eax_292 = *((word32) esi_287 + 20);
		<anonymous> * edx_293 = *((word32) eax_292 + 92);
		struct Eq_82810 * esp_295 = esp_104 - 4;
		esp_295->dw0000 = 0x00;
		esp_295->dwFFFFFFFC = 0x006FDF70;
		ptr32 ecx_297 = (word32) esi_287 + 16;
		esp_295->ptrFFFFFFF8 = ecx_297;
		word32 esp_306;
		edx_293();
		esi_287 = *esi_287;
		esp_104 = esp_306 + 0x0C;
	}
	Eq_3 eax_320 = &esp_104->t0030;
	esp_104->t0034 = eax_320;
	esp_104->t0030 = eax_320;
	fn006FE010(ebx_260, eax_320);
	if (ebx_260 != ebp_269)
	{
		Eq_3 ecx_338 = *ebx_260;
		if (ecx_338 != ebx_260)
		{
			Eq_3 eax_341 = *((word32) ebp_269 + 4);
			*eax_341 = ecx_338;
			*((word32) ecx_338 + 4) = eax_341;
			Eq_3 eax_344 = *((word32) ebx_260 + 4);
			*((word32) ebp_269 + 4) = eax_344;
			*eax_344 = ebp_269;
		}
		*((word32) ebx_260 + 4) = ebx_260;
		*ebx_260 = ebx_260;
	}
	struct Eq_82834 * esp_355 = esp_104 - 4;
	esp_355->ptr0000 = (word32 *) &esp_104->t0030;
	Eq_3 edx_352 = (const char *) &esp_104->t0010 + 16;
	esp_355->t0028 = edx_352;
	esp_355->t0024 = edx_352;
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_3 stackArg4 = <invalid>;
	fn006FE070(edx_352, stackArg4);
	Eq_3 esi_384 = esp_355->t0024;
	struct Eq_82859 * esp_386 = (const char *) &esp_355->ptr0000 + 4;
	if (esi_384 != edx_352)
	{
		esp_386 = (struct Eq_82859 *) ((const char *) &esp_355->ptr0000 + 4);
		do
		{
			<anonymous> * eax_393 = *((word32) *((word32) esi_384 + 20) + 92);
			ptr32 ecx_395 = esp_386 + 8;
			struct Eq_82913 * esp_396 = esp_386 - 4;
			esp_396->ptr0000 = ecx_395;
			esp_396->dwFFFFFFFC = 0x006FE100;
			ptr32 edx_398 = (word32) esi_384 + 16;
			esp_396->ptrFFFFFFF8 = edx_398;
			word32 esp_407;
			eax_393();
			esi_384 = *esi_384;
			esp_386 = esp_407 + 0x0C;
		} while (esi_384 != esp_407 + 44);
	}
	word32 * eax_420 = esp_386[0x0C];
	word32 * ebx_423 = eax_420;
	if (eax_420 != esp_386 + 0x0C)
	{
		do
		{
			byte al_426 = g_bA6CD04;
			esp_386[0x0011] = (struct Eq_82859) ((word32) esp_386[0x0011].dwFFFFFFFC + 5);
			if ((al_426 & 0x02) != 0x00)
			{
				struct Eq_83004 * esi_436 = ebx_423 + 4;
				if ((al_426 & 0x08) != 0x00 && esi_436->t0004 == 10611608)
				{
					struct Eq_83004 * edi_458 = esi_436->ptr0008->ptr0010;
					if (edi_458 != null)
					{
						Eq_3 eax_462 = edi_458->t0004;
						if (eax_462 != 0x00A1B450)
						{
							struct Eq_83083 * esp_465 = esp_386 - 4;
							esp_465->t0000.u0 = 0x00A1B450;
							esp_465->tFFFFFFFC = eax_462;
							word32 edx_1267;
							word32 ecx_1266;
							if (fn006D5670(esp_465->tFFFFFFFC, esp_465->t0000, out ecx_1266, out edx_1267) != 0x00)
								goto l006FE694;
							goto l006FE6AB;
						}
l006FE694:
						struct Eq_83053 * esp_492 = esp_386 - 4;
						esp_492->ptr0000 = edi_458;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_3 stackArg4 = <invalid>;
						word32 ecx_1263;
						word32 esi_1265;
						word32 edx_1264;
						Eq_3 eax_503 = fn006ECC50(stackArg4, out ecx_1263, out edx_1264, out esi_1265);
						esp_492->ptr0000 = esi_436;
						esp_492->tFFFFFFFC = eax_503;
						esp_492->dwFFFFFFF8 = 0x008D6614;
						esp_492->dwFFFFFFF4 = 9266448;
					}
					else
					{
l006FE6AB:
						struct Eq_83029 * esp_481 = esp_386 - 4;
						esp_481->ptr0000 = esi_436;
						esp_481->dwFFFFFFFC = 0x008D0E38;
						esp_481->dwFFFFFFF8 = 0x008D6614;
						esp_481->dwFFFFFFF4 = 9266448;
					}
					goto l006FE6D4;
				}
				if ((al_426 & 0x10) != 0x00)
				{
					Eq_3 edx_447 = *((word32) esi_436->t0004 + 0x0C);
					struct Eq_83357 * esp_449 = esp_386 - 4;
					esp_449->ptr0000 = esi_436;
					esp_449->tFFFFFFFC = edx_447;
					esp_449->dwFFFFFFF8 = 0x008D6614;
					esp_449->dwFFFFFFF4 = 9266484;
l006FE6D4:
					word32 edx_1268;
					fn00716B20(out edx_1268);
				}
			}
			Eq_3 eax_542 = g_tA6CD18;
			if (eax_542 != 0x00 && (g_bA6CD04 & 0x01) != 0x00)
			{
				struct Eq_83386 * esp_550 = esp_386 - 4;
				esp_550->t0000.u0 = 0x00;
				esp_550->dwFFFFFFFC = 0x008ACC9C;
				esp_550->tFFFFFFF8 = eax_542;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_3 stackArg4 = <invalid>;
				Eq_3 stackArg12 = <invalid>;
				word32 edx_1285;
				word32 ecx_1284;
				Eq_3 eax_564 = fn007038E0(stackArg4, 0x00, stackArg12, out ecx_1284, out edx_1285);
				esp_386 = (struct Eq_82859 *) ((const char *) &esp_550->t0000 + 4);
				if (eax_564 == 0x00)
				{
					word32 edx_1288;
					word32 ecx_1287;
					fn006E1160(out ecx_1287, out edx_1288);
				}
				else
				{
					esp_550->t0000 = eax_564;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_3 stackArg4 = <invalid>;
					real64 rRet0;
					fn006FF3E0(stackArg4, out rRet0);
					real64 rLoc1_1104 = rRet0 - esp_550->r001C;
					word32 v22_589 = (word32) *eax_564 - 1;
					*eax_564 = v22_589;
					esp_550->r001C = rLoc1_1104;
					struct Eq_83439 * esp_588 = (const char *) &esp_550->t0000 + 4;
					if (v22_589 == 0x00)
					{
						Eq_3 eax_595 = *((word32) eax_564 + 4);
						Eq_3 ecx_596 = *((word32) eax_595 + 24);
						esp_550->t0000 = eax_564;
						word32 esp_599;
						ecx_596();
						esp_588 = esp_599 + 0x04;
					}
					struct Eq_83450 * esp_612 = esp_588 - 0x08;
					esp_612->r0000 = (real64) esp_588[6];
					esp_612->dwFFFFFFFC = 0x008D6600;
					word32 edx_1289;
					fn00716B20(out edx_1289);
					esp_386 = (struct Eq_82859 *) (&esp_612->r0000 + 1);
				}
			}
			ebx_423 = *ebx_423;
		} while (ebx_423 != esp_386 + 0x0C);
	}
	struct Eq_82938 * esp_646 = esp_386 - 4;
	esp_646->t0000 = ebp_269;
	esp_646->ptrFFFFFFFC = (word32 *) (esp_386 + 0x0C);
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_3 stackArg4 = <invalid>;
	esp_646->dw0048 += fn006FE160(stackArg4);
	esp_646->ptrFFFFFFF8 = (const char *) &esp_646->ptr0024 + 16;
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_3 stackArg4 = <invalid>;
	fn006FE380(ebp_269, stackArg4);
	word32 * eax_682 = esp_646->ptr0024;
	word32 ebp_683 = esp_646->dw0018;
	word32 * ebx_686 = eax_682;
	byte al_688 = g_bA6CD04;
	if (eax_682 != &esp_646->ptr0024)
	{
		do
		{
			++ebp_683;
			if ((al_688 & 0x04) != 0x00)
			{
				struct Eq_83131 * esi_699 = ebx_686 + 4;
				if ((al_688 & 0x08) != 0x00 && esi_699->t0004 == 10611608)
				{
					struct Eq_83131 * edi_723 = esi_699->ptr0008->ptr0010;
					if (edi_723 != null)
					{
						Eq_3 eax_727 = edi_723->t0004;
						if (eax_727 != 0x00A1B450)
						{
							struct Eq_83210 * esp_730 = esp_386 - 4;
							esp_730->t0000.u0 = 0x00A1B450;
							esp_730->tFFFFFFFC = eax_727;
							word32 edx_1274;
							word32 ecx_1273;
							if (fn006D5670(esp_730->tFFFFFFFC, esp_730->t0000, out ecx_1273, out edx_1274) != 0x00)
								goto l006FE7D1;
							goto l006FE7E8;
						}
l006FE7D1:
						struct Eq_83180 * esp_757 = esp_386 - 4;
						esp_757->ptr0000 = edi_723;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_3 stackArg4 = <invalid>;
						word32 edx_1271;
						word32 esi_1272;
						word32 ecx_1270;
						Eq_3 eax_767 = fn006ECC50(stackArg4, out ecx_1270, out edx_1271, out esi_1272);
						esp_757->ptr0000 = esi_699;
						esp_757->tFFFFFFFC = eax_767;
						esp_757->dwFFFFFFF8 = 9266672;
						esp_757->dwFFFFFFF4 = 9266448;
					}
					else
					{
l006FE7E8:
						struct Eq_83156 * esp_746 = esp_386 - 4;
						esp_746->ptr0000 = esi_699;
						esp_746->dwFFFFFFFC = 0x008D0E38;
						esp_746->dwFFFFFFF8 = 9266672;
						esp_746->dwFFFFFFF4 = 9266448;
					}
					goto l006FE811;
				}
				if ((al_688 & 0x10) != 0x00)
				{
					Eq_3 edx_711 = *((word32) esi_699->t0004 + 0x0C);
					struct Eq_83333 * esp_714 = esp_386 - 4;
					esp_714->ptr0000 = esi_699;
					esp_714->tFFFFFFFC = edx_711;
					esp_714->dwFFFFFFF8 = 9266672;
					esp_714->dwFFFFFFF4 = 9266484;
l006FE811:
					word32 edx_1275;
					fn00716B20(out edx_1275);
					al_688 = g_bA6CD04;
				}
			}
			ebx_686 = *ebx_686;
		} while (ebx_686 != esp_386 + 8);
	}
	word32 esi_819 = esp_386[0x0011];
	if ((al_688 & 0x01) != 0x00)
	{
		if (esi_819 == 0x00 && ebp_683 == 0x00)
		{
			esp_386->dwFFFFFFFC = 9266660;
			word32 edx_1278;
			fn00716B20(out edx_1278);
		}
		else
		{
			struct Eq_83262 * esp_830 = esp_386 - 4;
			esp_830->dw0000 = ebp_683;
			esp_830->dwFFFFFFFC = esi_819 + ebp_683;
			esp_830->dwFFFFFFF8 = 9266612;
			word32 edx_1277;
			fn00716B20(out edx_1277);
		}
	}
	struct Eq_83240 * esp_868 = esp_386 - 4;
	esp_868->dw0000 = (word32) esp_386[4];
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_3 stackArg4 = <invalid>;
	word32 ecx_1021 = fn006FE2A0(&esp_868->dw0004 + 8, stackArg4);
	if (fn006E0FC0() != 0x00)
	{
		Eq_3 eax_889 = g_tA6CD10;
		if (eax_889 == 0x00)
		{
			esp_868->dw0004 = 9266592;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg4 = <invalid>;
			word32 edx_1281;
			word32 ecx_1280;
			eax_889 = fn006ECAC0(stackArg4, out ecx_1280, out edx_1281);
			g_tA6CD10 = eax_889;
		}
		struct Eq_83296 * esp_904 = esp_386 + 1;
		esp_904->tFFFFFFFC = eax_889;
		ecx_1021 = fn006E1780();
		esp_904->tFFFFFFF8.u0 = 9266544;
		fn006E86F0(esp_904->tFFFFFFF8);
	}
	ebpOut = ebp;
	return ecx_1021;
}

// 006FE8B0: Register (ptr32 Eq_83483) fn006FE8B0()
// Called from:
//      fn006FEEB0
struct Eq_83483 * fn006FE8B0()
{
	int32 edx_20 = 0x02;
	struct Eq_83483 * ecx_12 = &g_tA1D554;
	do
	{
		if (ecx_12->dw0000 > ecx_12->dwFFFFFFFC)
		{
			word32 ebp_63;
			return fn006FE400(edx_20, out ebp_63);
		}
		ecx_12 -= 0x18;
		--edx_20;
	} while (ecx_12 >= g_aA1D520 + 1);
	return ecx_12;
}

// 006FEE00: Register word32 fn006FEE00()
// Called from:
//      fn006E8910
word32 fn006FEE00()
{
	if (g_dwA6CD08 != 0x00)
		return ebp;
	g_dwA6CD08 = 0x01;
	word32 ebp_11;
	fn006FE400(0x02, out ebp_11);
	g_dwA6CD08 = 0x00;
	return ebp_11;
}

// 006FEE30: Register Eq_3 fn006FEE30(Stack Eq_3 dwArg04, Register out Eq_3 edxOut)
// Called from:
//      fn00717180
//      fn0072F770
//      fn00738BB0
Eq_3 fn006FEE30(Eq_3 dwArg04, union Eq_3 & edxOut)
{
	if (*((word32) dwArg04 - 8) != ~0x01)
		fn006E86F0(0x008D0E04);
	*((word32) dwArg04 - 8) = ~0x02;
	*((word32) dwArg04 - 16) = g_tA1D558;
	Eq_3 ecx_24 = g_tA1D558;
	Eq_3 eax_25 = *((word32) ecx_24 + 4);
	*((word32) dwArg04 - 0x0C) = eax_25;
	*eax_25 = (word32) dwArg04 - 16;
	Eq_3 edx_28 = g_tA1D558;
	*((word32) edx_28 + 4) = (word32) dwArg04 - 16;
	edxOut = edx_28;
	return ecx_24;
}

// 006FEEB0: Register Eq_3 fn006FEEB0(Stack ui32 dwArg04, Register out Eq_83565 ecxOut)
// Called from:
//      fn006FEF30
//      fn006FEF50
Eq_3 fn006FEEB0(ui32 dwArg04, union Eq_83565 & ecxOut)
{
	word32 ecx_113;
	word32 edx_114;
	Eq_3 eax_13 = fn00723860(dwArg04 + 0x10, out ecx_113, out edx_114);
	if (eax_13 != 0x00)
	{
		((word32) eax_13 + 8)->u0 = ~0x01;
		Eq_83581 eax_26 = g_aA1D520[1];
		Eq_83565 ecx_27 = g_aA1D520[0];
		g_aA1D520[1] = (word192) eax_26 + 1;
		if ((word192) eax_26 + 1 > ecx_27 && (g_dwA1D55C != 0x00 && (ecx_27 != 0x00 && (g_dwA6CD08 == 0x00 && fn006E0FC0() == 0x00))))
		{
			g_dwA6CD08 = 0x01;
			ecx_27 = fn006FE8B0();
			g_dwA6CD08 = 0x00;
		}
		ecxOut = ecx_27;
		return (word32) eax_13 + 16;
	}
	else
	{
		Eq_83565 ecx_61;
		word32 edx_115;
		Eq_3 eax_60 = fn006E1210(out ecx_61, out edx_115);
		ecxOut = ecx_61;
		return eax_60;
	}
}

// 006FEF30: Register (ptr32 Eq_83625) fn006FEF30(Stack (ptr32 Eq_56268) dwArg04, Register out Eq_540 ecxOut, Register out Eq_540 edxOut)
// Called from:
//      fn006F2650
//      fn006F94A0
//      fn006FDCC0
//      fn00717180
//      fn00725010
//      fn00725DA0
//      fn0072F770
//      fn007500E0
//      fn00750380
struct Eq_83625 * fn006FEF30(struct Eq_56268 * dwArg04, union Eq_540 & ecxOut, union Eq_540 & edxOut)
{
	word32 ecx_42;
	struct Eq_83625 * eax_12 = fn006FEEB0(dwArg04->dw0010, out ecx_42);
	if (eax_12 != null)
	{
		eax_12->ptr0004 = dwArg04;
		eax_12->dw0000 = 0x01;
	}
	ecxOut.u0 = <invalid>;
	edxOut.u0 = <invalid>;
	return eax_12;
}

// 006FEF50: Register (ptr32 Eq_83625) fn006FEF50(Stack (ptr32 Eq_56268) dwArg04, Stack Eq_3 dwArg08, Register out ptr32 ecxOut, Register out Eq_540 edxOut)
// Called from:
//      fn006DFD20
//      fn0073AFB0
struct Eq_83625 * fn006FEF50(struct Eq_56268 * dwArg04, Eq_3 dwArg08, ptr32 & ecxOut, union Eq_540 & edxOut)
{
	ptr32 ecx_23;
	struct Eq_83625 * eax_22 = fn006FEEB0(dwArg04->dw0014 *s dwArg08 + 0x03 + dwArg04->dw0010 & ~0x03, out ecx_23);
	if (eax_22 != null)
	{
		eax_22->t0008 = dwArg08;
		eax_22->ptr0004 = dwArg04;
		eax_22->dw0000 = 0x01;
	}
	ecxOut = ecx_23;
	edxOut.u0 = <invalid>;
	return eax_22;
}

// 006FEF90: Register Eq_3 fn006FEF90(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Register out ptr32 edxOut)
// Called from:
//      fn006E0B00
//      fn0073AFB0
Eq_3 fn006FEF90(Eq_3 dwArg04, Eq_3 dwArg08, ptr32 & edxOut)
{
	struct Eq_83675 * eax_6 = *((word32) dwArg04 + 4);
	ptr32 edx_25;
	word32 ecx_73;
	Eq_3 eax_23 = fn00723B60((word32) dwArg04 - 16, (eax_6->dw0014 *s dwArg08 + 0x03 + eax_6->dw0010 & ~0x03) + 0x10, out ecx_73, out edx_25);
	if (eax_23 != 0x00)
	{
		*((word32) eax_23 + 24) = dwArg08;
		edxOut = edx_25;
		return (word32) eax_23 + 16;
	}
	else
	{
		ptr32 edx_44;
		word32 ecx_74;
		Eq_3 eax_43 = fn006E1210(out ecx_74, out edx_44);
		edxOut = edx_44;
		return eax_43;
	}
}

// 006FEFD0: void fn006FEFD0(Stack Eq_3 dwArg04)
// Called from:
//      fn006E0B00
//      fn006E0CA0
//      fn006F2610
//      fn006F9B70
//      fn0070E820
//      fn00738D80
//      fn0073B5E0
void fn006FEFD0(Eq_3 dwArg04)
{
	if (*((word32) dwArg04 - 8) != ~0x01)
	{
		**((word32) dwArg04 - 0x0C) = *((word32) dwArg04 - 16);
		*((word32) *((word32) dwArg04 - 16) + 4) = *((word32) dwArg04 - 0x0C);
		*((word32) dwArg04 - 16) = null;
	}
	if (g_aA1D520[1] > 0x00)
		--g_aA1D520[1];
	word32 ecx_38;
	word32 edx_39;
	fn007239C0(dwArg04 - 0x10, out ecx_38, out edx_39);
}

// 006FF010: Register Eq_3 fn006FF010(Register out (ptr32 Eq_83762) edxOut)
// Called from:
//      fn006FF060
Eq_3 fn006FF010(struct Eq_83762 & edxOut)
{
	Eq_3 eax_6 = malloc(1000);
	if (eax_6 != 0x00)
	{
		*eax_6 = g_tA6CD2C;
		g_tA6CD2C = eax_6;
		struct Eq_83762 * ecx_19 = (word32) eax_6 + 984 + 0x04;
		if ((word32) eax_6 + 984 > (word32) eax_6 + 8)
		{
			do
			{
				edx = ecx_19 - 0x10;
				ecx_19->dw0000 = edx;
				ecx_19 = edx;
			} while (edx > (word32) eax_6 + 8);
		}
		ecx_19->dw0004 = 0x00;
		edxOut = edx;
		return (word32) eax_6 + 984;
	}
	else
	{
		struct Eq_83762 * edx_41;
		word32 ecx_81;
		Eq_3 eax_39 = fn006E1210(out ecx_81, out edx_41);
		edxOut = edx_41;
		return eax_39;
	}
}

// 006FF060: Register Eq_3 fn006FF060(Stack Eq_3 rArg04, Register out Eq_3 edxOut)
// Called from:
//      fn006E9BD0
//      fn00735890
//      fn007367D0
//      fn0073D140
Eq_3 fn006FF060(Eq_3 rArg04, union Eq_3 & edxOut)
{
	Eq_3 eax_10 = g_tA6CD30;
	if (eax_10 == 0x00)
	{
		Eq_3 edx_11;
		eax_10 = fn006FF010(out edx_11);
		g_tA6CD30 = eax_10;
		if (eax_10 == 0x00)
		{
			edxOut = edx_11;
			return eax_10;
		}
	}
	Eq_3 edx_22 = *((word32) eax_10 + 4);
	*((word32) eax_10 + 8) = rArg04;
	g_tA6CD30 = edx_22;
	((word32) eax_10 + 4)->u0 = 10609848;
	*eax_10 = 0x01;
	edxOut = edx_22;
	return eax_10;
}

// 006FF3E0: Register ptr32 fn006FF3E0(Stack Eq_3 dwArg04, FpuStack out Eq_540 rLoc1Out)
// Called from:
//      fn006E5C60
//      fn006FE400
//      fn00733250
//      fn007332C0
//      fn00735890
ptr32 fn006FF3E0(Eq_3 dwArg04, union Eq_540 & rLoc1Out)
{
	if (dwArg04 == 0x00)
	{
		word32 edx_234;
		ptr32 ecx_15 = fn006E11D0(out edx_234);
		rLoc1Out.u0 = <invalid>;
		return ecx_15;
	}
	Eq_3 eax_24 = *((word32) dwArg04 + 4);
	if (eax_24 == 10609848)
	{
l006FF408:
		rLoc1Out.u0 = <invalid>;
		return ecx;
	}
	word32 edx_235;
	if (fn006D5670(eax_24, 10609848, out ecx, out edx_235) != 0x00)
		goto l006FF408;
	ptr32 ecx_104;
	struct Eq_83861 * esp_118;
	struct Eq_83862 * eax_43 = *((word32) *((word32) dwArg04 + 4) + 48);
	if (eax_43 != null)
	{
		<anonymous> * eax_47 = eax_43->ptr0050;
		if (eax_47 != null)
		{
			struct Eq_83861 * esp_56;
			Eq_3 eax_57;
			word32 edx_60;
			eax_47();
			if (eax_57 == 0x00)
				goto l006FF495;
			Eq_3 eax_67 = *((word32) eax_57 + 4);
			if (eax_67 != 10609848)
			{
				esp_56->t0000.u0 = 10609848;
				esp_56->tFFFFFFFC = eax_67;
				word32 edx_236;
				if (fn006D5670(esp_56->tFFFFFFFC, esp_56->t0000, out ecx_104, out edx_236) == 0x00)
				{
					esp_56->t0000.u0 = 9267244;
					esp_118 = esp_56;
l006FF486:
					esp_118->tFFFFFFFC = g_tA16B7C;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_3 stackArg4 = <invalid>;
					word32 edx_238;
					fn006E0F80(stackArg4, dwArg04, out ecx_104, out edx_238);
l006FF495:
					rLoc1Out.u0 = <invalid>;
					return ecx_104;
				}
			}
			word32 v11_87 = (word32) *eax_57 - 1;
			*eax_57 = v11_87;
			esp_56->t0008 = *((word32) eax_57 + 8);
			if (v11_87 == 0x00)
			{
				Eq_3 edx_97 = *((word32) eax_57 + 4);
				Eq_3 eax_98 = *((word32) edx_97 + 24);
				esp_56->t0000 = eax_57;
				eax_98();
			}
			rLoc1Out.u0 = <invalid>;
			return ecx_104;
		}
	}
	esp_118 = fp - 0x10;
	goto l006FF486;
}

// 006FF4A0: Register Eq_3 fn006FF4A0(Register Eq_3 ecx, Register Eq_3 edx, Register Eq_3 ebx, Register Eq_3 esi, Register Eq_3 edi, Register (ptr16 Eq_7) es, Register (ptr16 Eq_8) ds, Stack Eq_3 dwArg04)
// Called from:
//      fn006FF5D0
//      fn00700EC0
Eq_3 fn006FF4A0(Eq_3 ecx, Eq_3 edx, Eq_3 ebx, Eq_3 esi, Eq_3 edi, struct Eq_7 * es, struct Eq_8 * ds, Eq_3 dwArg04)
{
	ui32 eax_7 = g_tA14188 ^ fp - 0x24;
	fn00724FE0(fp - 0x24, 0x20, &g_b8D6850);
	Eq_3 esi_23 = ecx;
	Eq_3 ebp_52;
	Eq_3 edx_55;
	Eq_3 eax_115 = fn0074F280(ecx, dwArg04, fp - 0x24, *((word32) edx + 8), out edx_55, out ebp_52);
	if (*ecx == 0x2D)
		esi_23 = (word32) ecx + 1;
	if (*esi_23 != 0x00)
	{
		do
		{
			eax_115 = isdigit((word32) *esi_23);
			if (eax_115 == 0x00)
				break;
			esi_23 = (word32) esi_23 + 1;
		} while (*esi_23 != 0x00);
		if (*esi_23 != 0x00)
		{
l006FF527:
			word32 ecx_218;
			fn00694B8E(eax_115, eax_7 ^ fp - 0x24, edx_55, ebx, ebp_52, esi, edi, es, ds, esi, out ecx_218);
			return ebp_52;
		}
	}
	*esi_23 = 0x2E;
	struct Eq_84012 * esi_93 = (word32) esi_23 + 1;
	esi_93->b0000 = 0x30;
	esi_93->b0001 = 0x00;
	goto l006FF527;
}

// 006FF5D0: Register word32 fn006FF5D0(Register Eq_3 ebx, Register Eq_3 esi, Register Eq_3 edi, Register (ptr16 Eq_7) es, Register (ptr16 Eq_8) ds, Stack Eq_3 dwArg04, Stack Eq_3 dwArg08)
// Called from:
//      fn00735890
word32 fn006FF5D0(Eq_3 ebx, Eq_3 esi, Eq_3 edi, struct Eq_7 * es, struct Eq_8 * ds, Eq_3 dwArg04, Eq_3 dwArg08)
{
	return fn006FF4A0(dwArg04, dwArg08, ebx, esi, edi, es, ds, 100);
}

// 00700EC0: void fn00700EC0(Register Eq_3 ebx, Register Eq_3 ebp, Register Eq_3 esi, Register Eq_3 edi, Register (ptr16 Eq_7) es, Register (ptr16 Eq_8) ds)
// Called from:
//      fn006E8910
void fn00700EC0(Eq_3 ebx, Eq_3 ebp, Eq_3 esi, Eq_3 edi, struct Eq_7 * es, struct Eq_8 * ds)
{
	Eq_3 eax_116;
	Eq_3 eax_7 = g_tA14188 ^ fp - 0x70;
	Eq_3 edx_149 = g_tA6CD2C;
	g_tA6CD2C.u0 = 0x00;
	g_tA6CD30.u0 = 0x00;
	Eq_3 ebp_16 = 0x00;
	eax_116 = eax_7;
	if (edx_149 != 0x00)
	{
		do
		{
			eax_116 = (word32) edx_149 + 8;
			ebp_16 = (word32) ebp_16 + 1;
			word32 edi_33 = 0x00;
			Eq_3 ecx_36 = eax_116;
			word32 esi_37;
			for (esi_37 = 0x1F; esi_37 != 0x00; --esi_37)
			{
				if (*((word32) ecx_36 + 4) == 10609848 && *ecx_36 != 0x00)
					++edi_33;
				if (*((word32) ecx_36 + 20) == 10609848 && *((word32) ecx_36 + 16) != 0x00)
					++edi_33;
				ecx_36 = (word32) ecx_36 + 32;
			}
			Eq_3 esi_73 = *edx_149;
			if (edi_33 != 0x00)
			{
				*edx_149 = g_tA6CD2C;
				g_tA6CD2C = edx_149;
				word32 ecx_119;
				for (ecx_119 = 0x1F; ecx_119 != 0x00; --ecx_119)
				{
					if (*((word32) eax_116 + 4) != 10609848 || *eax_116 == 0x00)
					{
						*((word32) eax_116 + 4) = g_tA6CD30;
						g_tA6CD30 = eax_116;
					}
					if (*((word32) eax_116 + 20) != 10609848 || *((word32) eax_116 + 16) == 0x00)
					{
						*((word32) eax_116 + 20) = g_tA6CD30;
						g_tA6CD30 = (word32) eax_116 + 16;
					}
					eax_116 = (word32) eax_116 + 32;
				}
			}
			else
				free(edx_149);
			edx_149 = esi_73;
		} while (esi_73 != 0x00);
	}
	if (g_tA74AF0 != 0x00)
	{
		struct Eq_84115 * esp_251;
		struct Eq_84116 * esp_185;
		word32 eax_186;
		_iob_func();
		esp_185->tFFFFFFFC = eax_186 + 0x40;
		fprintf(esp_185->tFFFFFFFC, esp_185->t0000, 0x00);
		word32 edx_196 = esp_185->dw0018;
		if (edx_196 == 0x00)
		{
			esp_185->t0000.u0 = 0x008A6DE8;
			struct Eq_84148 * esp_255;
			word32 eax_256;
			_iob_func();
			esp_255->tFFFFFFFC = eax_256 + 0x40;
			eax_116 = fprintf(esp_255->tFFFFFFFC, esp_255->t0000, 0x00);
			esp_251 = (struct Eq_84115 *) ((const char *) &esp_255->t0000 + 4);
		}
		else
		{
			Eq_3 ecx_202 = 9070991;
			if (ebp_16 != 0x01)
				ecx_202.u0 = 9118380;
			word32 eax_207 = 9070991;
			if (edx_196 != 0x01)
				eax_207 = 9118380;
			esp_185->t0000 = ecx_202;
			esp_185->tFFFFFFFC = ebp_16;
			esp_185->dwFFFFFFF8 = ebp_16 - esp_185->dw0014;
			esp_185->dwFFFFFFF4 = eax_207;
			esp_185->dwFFFFFFF0 = edx_196;
			esp_185->dwFFFFFFEC = 9268080;
			struct Eq_84282 * esp_240;
			word32 eax_241;
			_iob_func();
			esp_240->tFFFFFFFC = eax_241 + 0x40;
			eax_116 = fprintf(esp_240->tFFFFFFFC, esp_240->t0000, 0x00);
			esp_251 = (struct Eq_84115 *) ((const char *) &esp_240->t0000 + 24);
		}
		if (g_tA74AF0 > 0x01)
		{
			eax_116 = g_tA6CD2C;
			esp_251->t0010 = eax_116;
			while (eax_116 != 0x00)
			{
				Eq_3 esi_279 = (word32) esp_251->t0010 + 8;
				word32 ebp_281;
				for (ebp_281 = 0x3E; ebp_281 != 0x00; --ebp_281)
				{
					if (*((word32) esi_279 + 4) == 10609848 && *esi_279 != 0x00)
					{
						struct Eq_84197 * esp_291 = esp_251 - 4;
						esp_291->ptr0000 = 0x0C;
						esp_291->tFFFFFFFC.u0 = 100;
						ebp_281 = fn006FF4A0(&esp_291->ptr0000 + 7, esi_279, fprintf, esi_279, _iob_func, es, ds, esp_291->tFFFFFFFC);
						Eq_3 ecx_315 = *esi_279;
						esp_291->ptr0000 = &esp_291->ptr0000 + 7;
						esp_291->tFFFFFFFC = ecx_315;
						esp_291->tFFFFFFF8 = esi_279;
						esp_291->dwFFFFFFF4 = 0x008D6B48;
						struct Eq_84236 * esp_328;
						word32 eax_329;
						_iob_func();
						esp_328->tFFFFFFFC = eax_329 + 0x40;
						fprintf(esp_328->tFFFFFFFC, esp_328->t0000, 0x00);
						esp_251 = (struct Eq_84115 *) ((const char *) &esp_328->t0000 + 16);
					}
					esi_279 = (word32) esi_279 + 16;
				}
				edx_149 = esp_251->t0010;
				eax_116 = *edx_149;
				esp_251->t0010 = eax_116;
			}
		}
	}
	word32 ecx_639;
	fn00694B8E(eax_116, eax_7 ^ fp - 112, edx_149, ebx, ebp, esi, edi, es, ds, ebx, out ecx_639);
}

