// sho_text_002E.c
// Generated by decompiling sho.exe
// using Reko decompiler version 0.10.0.0.

#include "sho.h"

// 006E1110: Register uint32 fn006E1110(Register out ptr32 ecxOut, Register out Eq_540 edxOut)
// Called from:
//      fn006E8730
//      fn006E8D90
//      fn006F3930
//      fn006F6AF0
//      fn006F8440
//      fn006F8960
//      fn006F8C70
//      fn00703B60
//      fn00704040
//      fn007040D0
//      fn00704BA0
//      fn00704DA0
//      fn00704E40
//      fn00707BD0
//      fn007081C0
//      fn00708210
//      fn00708C10
//      fn00708DC0
//      fn00720070
//      fn0073B870
//      fn00747FD0
//      fn0074E980
uint32 fn006E1110(ptr32 & ecxOut, union Eq_540 & edxOut)
{
	ptr32 ecx_14;
	word32 edx_30;
	uint32 eax_13 = fn006E0FD0(*((word32) g_tA6D67C + 40), dwArg04, out ecx_14, out edx_30);
	ecxOut = ecx_14;
	edxOut.u0 = <invalid>;
	return eax_13;
}

// 006E1130: Register Eq_3 fn006E1130(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Stack Eq_3 dwArg0C)
// Called from:
//      fn00657140
//      fn006DDFE0
//      fn006E7CE0
//      fn006E8430
//      fn006E8D90
//      fn006FBCC0
//      fn007040D0
//      fn00708590
//      fn007086B0
//      fn00708C10
//      fn00708DC0
//      fn00716A00
//      fn0073B3D0
//      fn0073B4E0
//      fn0073B870
Eq_3 fn006E1130(Eq_3 dwArg04, Eq_3 dwArg08, Eq_3 dwArg0C)
{
	Eq_3 eax_5 = g_tA6D67C;
	*dwArg04 = *((word32) eax_5 + 40);
	*dwArg08 = *((word32) eax_5 + 44);
	*dwArg0C = *((word32) eax_5 + 48);
	((word32) eax_5 + 40)->u0 = 0x00;
	((word32) eax_5 + 44)->u0 = 0x00;
	((word32) eax_5 + 48)->u0 = 0x00;
	return dwArg0C;
}

// 006E1160: Register Eq_3 fn006E1160(Register out Eq_3 ecxOut, Register out ptr32 edxOut)
// Called from:
//      fn0042DF20
//      fn00657140
//      fn006DC1B0
//      fn006DE3F0
//      fn006DF7C0
//      fn006DF870
//      fn006E1780
//      fn006E1DE0
//      fn006E5710
//      fn006E8060
//      fn006E8730
//      fn006E8D90
//      fn006EC890
//      fn006F3930
//      fn006F6490
//      fn006F6AF0
//      fn006F8440
//      fn006F8960
//      fn006F8C70
//      fn006F9120
//      fn006FBCC0
//      fn006FE400
//      fn00702C30
//      fn00703B60
//      fn00703D00
//      fn00704040
//      fn00704BA0
//      fn00704E40
//      fn00708210
//      fn00708410
//      fn00708C10
//      fn00708DC0
//      fn00716A00
//      fn00726570
//      fn00726760
//      fn0072F830
//      fn00731A20
//      fn0073B2B0
//      fn0073B310
//      fn0073B3D0
//      fn0074E980
//      fn0074F9E0
//      fn00753A60
//      fn00754FD0
Eq_3 fn006E1160(union Eq_3 & ecxOut, ptr32 & edxOut)
{
	Eq_3 eax_30 = g_tA6D67C;
	Eq_3 ecx_100 = *((word32) eax_30 + 40);
	Eq_3 esi_12 = *((word32) eax_30 + 44);
	Eq_3 edi_16 = *((word32) eax_30 + 48);
	((word32) eax_30 + 40)->u0 = 0x00;
	((word32) eax_30 + 44)->u0 = 0x00;
	((word32) eax_30 + 48)->u0 = 0x00;
	struct Eq_57487 * esp_13 = fp - 8;
	if (ecx_100 != 0x00)
	{
		word32 v10_21 = (word32) *ecx_100 - 1;
		*ecx_100 = v10_21;
		if (v10_21 == 0x00)
		{
			struct Eq_57506 * eax_25 = *((word32) ecx_100 + 4);
			word32 esp_29;
			eax_25->ptr0018();
			esp_13 = esp_29 + 0x04;
		}
	}
	if (esi_12 != 0x00)
	{
		word32 v12_42 = (word32) *esi_12 - 1;
		*esi_12 = v12_42;
		if (v12_42 == 0x00)
		{
			struct Eq_57529 * edx_46 = *((word32) esi_12 + 4);
			<anonymous> * eax_47 = edx_46->ptr0018;
			esp_13->tFFFFFFFC = esi_12;
			word32 esp_53;
			eax_47();
			esp_13 = esp_53 + 0x04;
		}
	}
	if (edi_16 != 0x00)
	{
		word32 v14_66 = (word32) *edi_16 - 1;
		*edi_16 = v14_66;
		if (v14_66 == 0x00)
		{
			struct Eq_57555 * ecx_70 = *((word32) edi_16 + 4);
			<anonymous> * edx_71 = ecx_70->ptr0018;
			esp_13->tFFFFFFFC = edi_16;
			edx_71();
		}
	}
	ecxOut = ecx_100;
	edxOut = edx;
	return eax_30;
}

// 006E11D0: Register word32 fn006E11D0(Register out ptr32 edxOut)
// Called from:
//      fn006FF3E0
//      fn00717280
//      fn00718B50
//      fn0071A550
//      fn0071A7D0
//      fn0071AAE0
//      fn0071FB20
//      fn0074EB10
word32 fn006E11D0(ptr32 & edxOut)
{
	Eq_3 edi_10 = g_tA16B7C;
	word32 ecx_78;
	ptr32 edx_46;
	Eq_3 eax_14 = fn006ECAC0(0x008D1F60, out ecx_78, out edx_46);
	word32 edx_79;
	word32 ecx_24;
	fn006E0E90(edi_10, eax_14, out ecx_24, out edx_79);
	if (eax_14 != 0x00)
	{
		word32 v10_34 = (word32) *eax_14 - 1;
		*eax_14 = v10_34;
		if (v10_34 == 0x00)
		{
			struct Eq_57598 * eax_38 = *((word32) eax_14 + 4);
			eax_38->ptr0018();
		}
	}
	edxOut = edx_46;
	return ecx_24;
}

// 006E1210: Register Eq_3 fn006E1210(Register out ptr32 ecxOut, Register out Eq_53685 edxOut)
// Called from:
//      fn006DDD30
//      fn006DDD50
//      fn006DDD80
//      fn006DFD20
//      fn006E8430
//      fn006EA9D0
//      fn006EC4F0
//      fn006EC9B0
//      fn006ECAC0
//      fn006F1AA0
//      fn006F2090
//      fn006F2590
//      fn006F2650
//      fn006F31C0
//      fn006FBB90
//      fn006FEEB0
//      fn006FEF90
//      fn006FF010
//      fn00704BA0
//      fn00705050
//      fn007105C0
//      fn00710690
//      fn00710CB0
//      fn00711280
//      fn00711330
//      fn00711400
//      fn00711F50
//      fn007120F0
//      fn00717680
//      fn00717740
//      fn007189B0
//      fn00726840
//      fn00727340
//      fn00727380
//      fn007273D0
//      fn00727420
//      fn007279E0
//      fn00727D50
//      fn00728650
//      fn007286D0
//      fn00728E40
//      fn00729300
//      fn00729810
//      fn00729F50
//      fn0072CC90
//      fn0072CEE0
//      fn0072D130
//      fn0072D3D0
//      fn0072DD60
//      fn007331D0
//      fn007367D0
//      fn00737F70
//      fn00740CC0
//      fn00740DC0
//      fn00742E70
//      fn00742EA0
//      fn00742ED0
//      fn00742F20
//      fn00742FB0
//      fn00743020
//      fn00743060
//      fn007430A0
//      fn00743100
//      fn007431B0
//      fn00743200
//      fn00743290
//      fn00743300
//      fn00743370
//      fn007433E0
//      fn00743430
//      fn00743480
//      fn007434C0
//      fn00743520
//      fn00743560
//      fn007435D0
//      fn00743640
//      fn00743680
//      fn007436E0
//      fn00743710
//      fn00743740
//      fn00743770
//      fn007437D0
//      fn00743880
//      fn00743900
//      fn00743980
//      fn00743A30
//      fn00743A70
//      fn00743AD0
//      fn00743B30
//      fn00743B70
//      fn00743BE0
//      fn00743C60
//      fn00743CC0
//      fn00743D20
//      fn00743D80
//      fn00743E30
//      fn00743EE0
//      fn00743F60
//      fn00743FC0
//      fn00744020
//      fn00744050
//      fn00744090
//      fn007440C0
//      fn00744110
//      fn00744180
//      fn007441C0
//      fn00744200
//      fn00744270
//      fn00752DC0
//      fn00752E30
Eq_3 fn006E1210(ptr32 & ecxOut, union Eq_53685 & edxOut)
{
	ptr32 ecx_15;
	Eq_53685 edx_16;
	if (fn006E0FD0(*((word32) g_tA6D67C + 40), g_tA188A8, out ecx_15, out edx_16) == 0x00)
	{
		Eq_3 eax_22 = g_tA6C578;
		if (eax_22 != 0x00)
		{
			ptr32 ecx_47;
			Eq_53685 edx_48;
			fn006E0E90(g_tA188A8, eax_22, out ecx_47, out edx_48);
			ecxOut = ecx_47;
			edxOut = edx_48;
			return <invalid>;
		}
		ecx_15 = fn006E0F10(g_tA188A8, out edx_16);
	}
	ecxOut = ecx_15;
	edxOut = edx_16;
	return <invalid>;
}

// 006E1260: void fn006E1260(Register Eq_3 ebx, Register Eq_3 ebp, Register Eq_3 esi, Register Eq_3 edi, Register (ptr16 Eq_7) es, Register (ptr16 Eq_8) ds, Stack Eq_3 dwArg04, Stack word32 dwArg08)
// Called from:
//      fn006E13F0
void fn006E1260(Eq_3 ebx, Eq_3 ebp, Eq_3 esi, Eq_3 edi, struct Eq_7 * es, struct Eq_8 * ds, Eq_3 dwArg04, word32 dwArg08)
{
	ui32 eax_7 = g_tA14188 ^ fp - 0x24;
	Eq_3 esi_23 = *_errno();
	if (esi_23 == 0x04)
	{
		Eq_3 edx_35;
		word32 ebx_417;
		word32 ebp_418;
		word32 esi_419;
		word32 edi_420;
		if (fn0072EC10(out edx_35, out ebx_417, out ebp_418, out esi_419, out edi_420) != 0x00)
		{
			word32 ecx_421;
			fn00694B8E(0x00, eax_7 ^ fp - 36, edx_35, ebx, ebp, esi, edi, es, ds, ebx, out ecx_421);
			return;
		}
	}
	else
	{
		if (esi_23 == 0x00)
			goto l006E1329;
		if (esi_23 <= 0x00)
		{
l006E12C9:
			word32 eax_66 = FormatMessageA(0x1300, null, esi_23, 0x0400, fp - 0x24, 0x00, null) + ~0x00;
			if (eax_66 == 0x00)
				sprintf(fp - 0x20, 9248660, esi_23);
			else if (eax_66 > 0x00)
			{
				do
				{
					Eq_57788 cl_78 = *eax_66;
					if (cl_78 > 0x20 && cl_78 != 0x2E)
						break;
					eax_66 -= (union Eq_57788 *) 0x01;
					*eax_66 = 0x00;
				} while (eax_66 > 0x01);
			}
l006E1329:
			Eq_3 eax_135;
			if (dwArg08 != 0x00)
			{
				word32 edx_424;
				word32 esi_425;
				eax_135 = fn006EA200(out edx_424, out esi_425);
			}
			else
			{
				word32 esi_423;
				word32 edx_422;
				eax_135 = fn006EA200(out edx_422, out esi_423);
			}
			if (eax_135 != 0x00)
			{
				word32 ecx_427;
				word32 edx_428;
				fn006E0E90(dwArg04, eax_135, out ecx_427, out edx_428);
				word32 v15_178 = (word32) *eax_135 - 1;
				*eax_135 = v15_178;
				if (v15_178 == 0x00)
				{
					struct Eq_57779 * eax_182 = *((word32) eax_135 + 4);
					eax_182->ptr0018();
				}
			}
			LocalFree(null);
			word32 ecx_426;
			fn00694B8E(0x00, eax_7 ^ fp - 0x24, 0x00, ebx, ebp, esi, edi, es, ds, ebx, out ecx_426);
			return;
		}
	}
	if (esi_23 < *__sys_nerr())
	{
		__sys_errlist();
		goto l006E1329;
	}
	goto l006E12C9;
}

// 006E13F0: void fn006E13F0()
// Called from:
//      fn006DEEA0
void fn006E13F0()
{
	fn006E1260(ebx, ebp, esi, edi, es, ds, dwArg04, 0x00);
}

// 006E1400: Register word32 fn006E1400(Register Eq_3 ebx, Register Eq_3 ebp, Register Eq_3 esi, Register Eq_3 edi, Register (ptr16 Eq_7) es, Register (ptr16 Eq_8) ds, Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Stack Eq_3 dwArg0C, Register out ptr32 edxOut)
// Called from:
//      fn006E1520
word32 fn006E1400(Eq_3 ebx, Eq_3 ebp, Eq_3 esi, Eq_3 edi, struct Eq_7 * es, struct Eq_8 * ds, Eq_3 dwArg04, Eq_3 dwArg08, Eq_3 dwArg0C, ptr32 & edxOut)
{
	ui32 eax_7 = g_tA14188 ^ fp - 0x24;
	Eq_3 esi_26 = dwArg08;
	if (dwArg08 == 0x00)
		esi_26 = GetLastError();
	word32 eax_48 = FormatMessageA(0x1300, null, esi_26, 0x0400, fp - 0x24, 0x00, null) + ~0x00;
	if (eax_48 == 0x00)
		sprintf(fp - 0x20, 9248660, esi_26);
	else if (eax_48 > 0x00)
	{
		do
		{
			Eq_57788 cl_60 = *eax_48;
			if (cl_60 > 0x20 && cl_60 != 0x2E)
				break;
			eax_48 -= (union Eq_57788 *) 0x01;
			*eax_48 = 0x00;
		} while (eax_48 > 0x01);
	}
	Eq_3 eax_113;
	if (dwArg0C != 0x00)
	{
		word32 edx_345;
		word32 esi_346;
		eax_113 = fn006EA200(out edx_345, out esi_346);
	}
	else
	{
		word32 edx_343;
		word32 esi_344;
		eax_113 = fn006EA200(out edx_343, out esi_344);
	}
	if (eax_113 != 0x00)
	{
		word32 edx_348;
		word32 ecx_347;
		fn006E0E90(dwArg04, eax_113, out ecx_347, out edx_348);
		Eq_57788 v16_156 = (word32) *eax_113 - 1;
		*eax_113 = v16_156;
		if (v16_156 == 0x00)
		{
			struct Eq_57923 * eax_160 = *((word32) eax_113 + 4);
			eax_160->ptr0018();
		}
	}
	LocalFree(null);
	word32 ecx_238;
	fn00694B8E(0x00, eax_7 ^ fp - 0x24, 0x00, ebx, ebp, esi, edi, es, ds, ebx, out ecx_238);
	edxOut = 0x00;
	return ecx_238;
}

// 006E1520: Register word32 fn006E1520(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Register out ptr32 edxOut)
// Called from:
//      fn0071A870
//      fn0071A9F0
word32 fn006E1520(Eq_3 dwArg04, Eq_3 dwArg08, ptr32 & edxOut)
{
	Eq_3 esi_15;
	if (dwArg08 != 0x00)
	{
		word32 edx_115;
		word32 ecx_114;
		esi_15 = fn006ECAC0(dwArg08, out ecx_114, out edx_115);
	}
	else
		esi_15.u0 = 0x00;
	ptr32 edx_45;
	word32 ecx_44 = fn006E1400(ebx, ebp, esi_15, edi, es, ds, g_tA17458, dwArg04, dwArg08, out edx_45);
	if (esi_15 != 0x00)
	{
		Eq_57788 v11_53 = (word32) *esi_15.u0 - 1;
		*esi_15.u0 = v11_53;
		if (v11_53 == 0x00)
		{
			Eq_3 edx_57 = *((word64) esi_15.u0 + 4);
			(*((word32) edx_57 + 24))();
		}
	}
	edxOut = edx_45;
	return ecx_44;
}

// 006E15D0: Register word32 fn006E15D0(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Register out (ptr32 Eq_51536) ecxOut, Register out (ptr32 Eq_51537) edxOut)
// Called from:
//      fn00657140
//      fn006DDEB0
//      fn006DE2E0
//      fn006DE330
//      fn006DE430
//      fn006E1DC0
//      fn006E5AD0
//      fn006E5C00
//      fn006E7660
//      fn006E9FA0
//      fn006EA420
//      fn006EA9D0
//      fn006F2090
//      fn006F62D0
//      fn006F6490
//      fn006F66E0
//      fn006F6730
//      fn006F68F0
//      fn006F6D50
//      fn006F6EA0
//      fn006F7890
//      fn006F8050
//      fn006F82C0
//      fn006F8AD0
//      fn006F9540
//      fn00701800
//      fn00701D30
//      fn007020D0
//      fn00702130
//      fn00702190
//      fn007021F0
//      fn00702250
//      fn007022B0
//      fn00702310
//      fn007023D0
//      fn00702450
//      fn007024B0
//      fn00702510
//      fn007025E0
//      fn007027D0
//      fn00702910
//      fn00702970
//      fn007029D0
//      fn00702AF0
//      fn00702C30
//      fn00703120
//      fn00703180
//      fn00703210
//      fn00703300
//      fn00703390
//      fn00703420
//      fn00703520
//      fn00703690
//      fn00703710
//      fn007038E0
//      fn00704220
//      fn00704300
//      fn00704400
//      fn007044F0
//      fn00704560
//      fn00704610
//      fn00704B00
//      fn00704E40
//      fn00706DC0
//      fn00707020
//      fn007072E0
//      fn00707810
//      fn00707950
//      fn00707BD0
//      fn007081C0
//      fn007083E0
//      fn00708DC0
//      fn0070B600
//      fn007120F0
//      fn00717CB0
//      fn00719F20
//      fn0071FB20
//      fn0071FEB0
//      fn00720070
//      fn007251F0
//      fn00726570
//      fn00726760
//      fn00727C90
//      fn00728420
//      fn0072B830
//      fn0072BDC0
//      fn0072E660
//      fn0073BBE0
//      fn0073BE10
//      fn0073BF20
//      fn0073C870
//      fn0073CAE0
//      fn0073E050
//      fn0073E590
//      fn0073E7A0
//      fn0073EF40
//      fn0073F160
//      fn0073F220
//      fn0073F2C0
//      fn0073F5B0
//      fn0073F690
//      fn0073FC30
//      fn00740160
//      fn00747610
//      fn00748190
//      fn0074EB10
//      fn0074EFB0
//      fn0074F9E0
//      fn00752B30
//      fn00753250
//      fn007537F0
word32 fn006E15D0(Eq_3 dwArg04, Eq_3 dwArg08, struct Eq_51536 & ecxOut, struct Eq_51537 & edxOut)
{
	Eq_3 eax_16 = fn006F1AA0(dwArg08, fp + 0x0C);
	struct Eq_51536 * ecx_27;
	struct Eq_51537 * edx_28;
	fn006E0E90(dwArg04, eax_16, out ecx_27, out edx_28);
	if (eax_16 != 0x00)
	{
		Eq_57788 v11_37 = (word32) *eax_16 - 1;
		*eax_16 = v11_37;
		if (v11_37 == 0x00)
		{
			Eq_3 eax_41 = *((word32) eax_16 + 4);
			(*((word32) eax_41 + 24))();
		}
	}
	ecxOut = ecx_27;
	edxOut = edx_28;
	return 0x00;
}

// 006E1780: Register word32 fn006E1780()
// Called from:
//      fn006FE160
//      fn006FE400
word32 fn006E1780()
{
	Eq_3 eax_6 = g_tA6D67C;
	Eq_3 ebp_13 = *((word32) eax_6 + 48);
	Eq_3 esi_17 = *((word32) eax_6 + 40);
	Eq_3 edi_24 = *((word32) eax_6 + 44);
	((word32) eax_6 + 40)->u0 = 0x00;
	((word32) eax_6 + 44)->u0 = 0x00;
	((word32) eax_6 + 48)->u0 = 0x00;
	word32 edx_610;
	word32 ecx_34;
	Eq_3 eax_33 = fn00715DD0(out ecx_34, out edx_610);
	struct Eq_58052 * esp_361 = fp - 0x18;
	if (eax_33 == 0x00)
	{
l006E1920:
		if (esi_17 != 0x00)
		{
			Eq_57788 v13_375 = (word32) *esi_17 - 1;
			*esi_17 = v13_375;
			if (v13_375 == 0x00)
			{
				Eq_3 ecx_379 = *((word32) esi_17 + 4);
				struct Eq_58241 * edx_380 = *((word32) ecx_379 + 24);
				esp_361->tFFFFFFFC = esi_17;
				word32 esp_388;
				edx_380();
				esp_361 = esp_388 + 0x04;
			}
		}
		if (edi_24 != 0x00)
		{
			Eq_57788 v15_401 = (word32) *edi_24 - 1;
			*edi_24 = v15_401;
			if (v15_401 == 0x00)
			{
				Eq_3 eax_405 = *((word32) edi_24 + 4);
				struct Eq_58241 * ecx_406 = *((word32) eax_405 + 24);
				esp_361->tFFFFFFFC = edi_24;
				word32 esp_414;
				ecx_406();
				esp_361 = esp_414 + 0x04;
			}
		}
		if (ebp_13 != 0x00)
		{
			Eq_57788 v16_427 = (word32) *ebp_13 - 1;
			*ebp_13 = v16_427;
			if (v16_427 == 0x00)
			{
				Eq_3 edx_431 = *((word32) ebp_13 + 4);
				struct Eq_58241 * eax_432 = *((word32) edx_431 + 24);
				esp_361->tFFFFFFFC = ebp_13;
				eax_432();
			}
		}
		return ecx_34;
	}
	word32 edx_611;
	word32 esi_612;
	word32 edi_613;
	fn00731D30(0x008D1FF8, eax_33, out edx_611, out esi_612, out edi_613);
	struct Eq_58075 * esp_300 = fp - 0x18;
	if (esi_17 == 0x00)
	{
l006E18F5:
		struct Eq_58080 * esp_319 = esp_300 - 4;
		esp_319->t0000 = eax_33;
		esp_319->dwFFFFFFFC = 0x008D1FF0;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_3 stackArg4 = <invalid>;
		Eq_3 stackArg8 = <invalid>;
		word32 edx_616;
		word32 esi_617;
		word32 edi_618;
		fn00731D30(stackArg4, stackArg8, out edx_616, out esi_617, out edi_618);
		word32 eax_338 = esp_319->dw0020;
		esp_319->dwFFFFFFF8 = 0x00;
		esp_319->tFFFFFFF4 = eax_33;
		esp_319->dwFFFFFFF0 = eax_338;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_3 stackArg4 = <invalid>;
		Eq_3 stackArg8 = <invalid>;
		Eq_3 stackArg12 = <invalid>;
		word32 ebx_625;
		word32 esi_626;
		word32 edx_624;
		fn00731B10(edi_24, es, ds, stackArg4, stackArg8, stackArg12, out edx_624, out ebx_625, out esi_626);
		esp_319->tFFFFFFEC = eax_33;
		esp_319->dwFFFFFFE8 = 9248740;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_3 stackArg4 = <invalid>;
		Eq_3 stackArg8 = <invalid>;
		word32 edx_629;
		word32 esi_630;
		word32 edi_631;
		fn00731D30(stackArg4, stackArg8, out edx_629, out esi_630, out edi_631);
		word32 edx_632;
		fn006E1160(out ecx_34, out edx_632);
		esp_361 = (struct Eq_58052 *) ((const char *) &esp_319->t0000 + 4);
		goto l006E1920;
	}
	Eq_3 eax_57 = *((word32) esi_17 + 4);
	Eq_3 edi_101 = 0x00;
	if (eax_57 != 10611048)
	{
		if (eax_57 != 0x00A15380)
		{
			word32 ecx_635;
			word32 edx_636;
			if (fn006D5670(eax_57, 0x00A15380, out ecx_635, out edx_636) == 0x00)
			{
l006E180D:
				Eq_3 eax_107 = *((word32) esi_17 + 4);
				if (eax_107 != 0x00A1B450)
				{
					word32 edx_638;
					word32 ecx_637;
					if (fn006D5670(eax_107, 0x00A1B450, out ecx_637, out edx_638) == 0x00)
						goto l006E1859;
				}
				edi_101 = (word32) esi_17 + 20;
l006E1842:
				if (edi_101 != 0x00)
				{
					const char * eax_139 = strrchr(edi_101, 0x2E);
					if (eax_139 != null)
						edi_101 = eax_139 + 1;
				}
l006E1859:
				word32 edi_640;
				word32 edx_639;
				Eq_3 eax_174 = fn006DF760(esi_17, 9209240, out edx_639, out edi_640);
				if (eax_174 == 0x00)
				{
					word32 edx_644;
					word32 esi_645;
					word32 edi_646;
					fn00731D30(0x008BF7CC, eax_33, out edx_644, out esi_645, out edi_646);
				}
				else
				{
					word32 ecx_641;
					word32 edx_642;
					word32 esi_643;
					Eq_3 eax_187 = fn006ECC50(eax_174, out ecx_641, out edx_642, out esi_643);
					if (eax_187 != 0x00)
					{
						word32 esi_653;
						word32 edi_654;
						word32 edx_652;
						fn00731D30(eax_187, eax_33, out edx_652, out esi_653, out edi_654);
						word32 edx_655;
						word32 esi_656;
						word32 edi_657;
						fn00731D30(9070992, eax_33, out edx_655, out esi_656, out edi_657);
					}
				}
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_3 stackArg4 = <invalid>;
				Eq_3 stackArg8 = <invalid>;
				word32 edx_649;
				word32 esi_650;
				word32 edi_651;
				fn00731D30(stackArg4, stackArg8, out edx_649, out esi_650, out edi_651);
				if (edi_24 != 0x00 && edi_24 != 0x00A163B8)
				{
					word32 edx_658;
					word32 esi_659;
					word32 edi_660;
					fn00731D30(0x008BAE70, eax_33, out edx_658, out esi_659, out edi_660);
					word32 edx_661;
					word32 ebx_662;
					word32 esi_663;
					fn00731B10(edi_24, es, ds, edi_24, eax_33, 0x00, out edx_661, out ebx_662, out esi_663);
				}
				esp_300 = fp - 0x18;
				if (eax_174 != 0x00)
				{
					Eq_57788 v17_294 = (word32) *eax_174 - 1;
					*eax_174 = v17_294;
					if (v17_294 == 0x00)
					{
						Eq_3 ecx_298 = *((word32) eax_174 + 4);
						word32 esp_307;
						(*((word32) ecx_298 + 24))();
						esp_300 = esp_307 + 0x04;
					}
				}
				ebp_13 = esp_300->t0014;
				goto l006E18F5;
			}
		}
		word32 ecx_633;
		word32 edx_634;
		if (fn006D5670(esi_17, g_tA169F0, out ecx_633, out edx_634) == 0x00)
			goto l006E180D;
	}
	if (*((word32) esi_17 + 4) == 10611048)
		edi_101 = (word32) *((word32) esi_17 + 16) + 20;
	else
		edi_101 = *((word32) esi_17 + 0x0C);
	goto l006E1842;
}

// 006E1970: Register word32 fn006E1970(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Stack Eq_3 dwArg0C, Register out Eq_54131 edxOut)
// Called from:
//      fn006DDFE0
//      fn006E5960
//      fn006F7890
//      fn00707020
word32 fn006E1970(Eq_3 dwArg04, Eq_3 dwArg08, Eq_3 dwArg0C, union Eq_54131 & edxOut)
{
	Eq_3 eax_5 = fn006E7CE0();
	if (eax_5 != 0x00)
	{
		word32 edx_166;
		word32 ecx_165;
		Eq_3 eax_16 = fn00717230(eax_5, out ecx_165, out edx_166);
		if (eax_16 != 0x00)
		{
			word32 esi_169;
			word32 edx_168;
			word32 ecx_167;
			word32 edi_170;
			Eq_3 eax_30 = fn006FD8B0(eax_16, 0x008D2018, out ecx_167, out edx_168, out esi_169, out edi_170);
			if (eax_30 != 0x00)
			{
				word32 ecx_171;
				Eq_54131 edx_116;
				struct Eq_58467 * eax_61 = fn00703800(eax_30, 0x008D2004, out ecx_171, out edx_116);
				if (eax_61 != null)
				{
					word32 v10_70 = eax_61->dw0000 + ~0x00;
					eax_61->dw0000 = v10_70;
					if (v10_70 == 0x00)
					{
						struct Eq_58493 * edx_74 = eax_61->ptr0004;
						edx_74->ptr0018();
					}
					edxOut = edx_116;
					return 0x00;
				}
				else
				{
					edxOut = edx_116;
					return ~0x00;
				}
			}
		}
	}
	Eq_54131 edx_104;
	fn00716B20(out edx_104);
	edxOut = edx_104;
	return 0x00;
}

// 006E19F0: Register word32 fn006E19F0(Register out ptr32 ecxOut, Register out ptr32 edxOut)
// Called from:
//      fn00747FD0
word32 fn006E19F0(ptr32 & ecxOut, ptr32 & edxOut)
{
	Eq_3 eax_13 = fn006F92B0(9248824);
	struct Eq_58509 * esp_153 = fp - 0x08;
	if (eax_13 != 0x00)
	{
		word32 esi_236;
		word32 edi_237;
		word32 ecx_232;
		word32 edx_233;
		word32 ecx_234;
		word32 edx_235;
		Eq_3 eax_36 = fn006FD8B0(fn00717230(eax_13, out ecx_232, out edx_233), 0x008D2028, out ecx_234, out edx_235, out esi_236, out edi_237);
		Eq_57788 v10_42 = (word32) *eax_13 - 1;
		*eax_13 = v10_42;
		esp_153 = fp - 0x08;
		if (v10_42 == 0x00)
		{
			Eq_3 eax_47 = *((word32) eax_13 + 4);
			word32 esp_51;
			(*((word32) eax_47 + 24))();
			esp_153 = esp_51 + 0x04;
		}
		if (eax_36 != 0x00)
		{
			Eq_3 ecx_65 = esp_153->t000C;
			word32 eax_66 = esp_153->dw0020;
			if (ecx_65 == 0x00)
				ecx_65 = g_tA18D40;
			if (eax_66 == 0x00)
				eax_66 = 0x00A163B8;
			word32 edx_80 = esp_153->dw0018;
			struct Eq_58594 * esp_81 = esp_153 - 4;
			esp_81->dw0000 = eax_66;
			esp_81->dwFFFFFFFC = esp_81->dw0020;
			word32 eax_87 = esp_81->dw0018;
			esp_81->dwFFFFFFF8 = edx_80;
			esp_81->dwFFFFFFF4 = eax_87;
			esp_81->tFFFFFFF0 = ecx_65;
			esp_81->dwFFFFFFEC = esp_81->dw0014;
			esp_81->dwFFFFFFE8 = 0x008D2020;
			esp_81->tFFFFFFE4 = eax_36;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg4 = <invalid>;
			Eq_3 stackArg8 = <invalid>;
			ptr32 edx_114;
			ptr32 ecx_113;
			struct Eq_58467 * eax_112 = fn00703800(stackArg4, stackArg8, out ecx_113, out edx_114);
			if (eax_112 != null)
			{
				word32 v13_121 = eax_112->dw0000 + ~0x00;
				eax_112->dw0000 = v13_121;
				if (v13_121 == 0x00)
				{
					struct Eq_58493 * edx_125 = eax_112->ptr0004;
					edx_125->ptr0018();
				}
				ecxOut = ecx_113;
				edxOut = edx_114;
				return 0x00;
			}
			else
			{
				ecxOut = ecx_113;
				edxOut = edx_114;
				return ~0x00;
			}
		}
	}
	struct Eq_58515 * esp_156 = esp_153 - 4;
	esp_156->dw0000 = esp_153->dw0010;
	esp_156->dwFFFFFFFC = 0x008D2008;
	ptr32 edx_166;
	ecxOut = fn00716B20(out edx_166);
	edxOut = edx_166;
	return 0x00;
}

// 006E1AB0: Register word32 fn006E1AB0(Register Eq_3 edx, Register Eq_3 ebx, Register Eq_3 ebp, Register Eq_3 esi, Register Eq_3 edi, Register (ptr16 Eq_7) es, Register (ptr16 Eq_8) ds, Stack Eq_3 dwArg04, Stack Eq_3 dwArg08)
// Called from:
//      fn006E1DE0
//      fn00728360
//      fn0073B870
word32 fn006E1AB0(Eq_3 edx, Eq_3 ebx, Eq_3 ebp, Eq_3 esi, Eq_3 edi, struct Eq_7 * es, struct Eq_8 * ds, Eq_3 dwArg04, Eq_3 dwArg08)
{
	ui32 eax_7 = g_tA14188 ^ fp - 1004;
	if (dwArg04 == 0x00 || (*dwArg04 == 0x00 || dwArg08 <= 0x00))
	{
		word32 ecx_350;
		return fn00694B8E(0x00, eax_7 ^ fp - 1004, edx, ebx, ebp, esi, edi, es, ds, edi, out ecx_350);
	}
	else
	{
		Eq_3 ebp_67;
		Eq_3 ebx_68;
		Eq_3 edx_105;
		Eq_3 eax_66 = fn00659040(ebx, ebp, esi, dwArg08, es, ds, dwArg04, 9074500, out edx_105, out ebx_68, out ebp_67);
		if (eax_66 != 0x00)
		{
			Eq_3 ebp_136 = 0x00;
			if (dwArg08 > 0x00)
			{
				Eq_3 ebx_121 = dwArg08;
				ebp_136 = dwArg08;
				do
				{
					do
						;
					while (fn00731F90(fp - 1004, 1000, eax_66, null, out edx_105) != 0x00 && (false && true));
					--ebx_121;
				} while (ebx_121 != 0x00);
			}
			fclose(eax_66);
			if (ebp_136 == dwArg08)
			{
				Eq_3 ecx_197 = fp - 1004;
				while (true)
				{
					byte al_201 = *ecx_197;
					if (al_201 != 0x20 && (al_201 != 0x09 && al_201 != 0x0C))
						break;
					ecx_197 = (word32) ecx_197 + 1;
				}
				word32 ecx_352;
				word32 ecx_353;
				Eq_3 edx_227;
				return fn00694B8E(fn006ECAC0(ecx_197, out ecx_352, out edx_227), eax_7 ^ fp - 1004, edx_227, ebx_68, ebp_67, esi, edi, es, ds, edi, out ecx_353);
			}
		}
		word32 ecx_351;
		return fn00694B8E(0x00, eax_7 ^ fp - 1004, edx_105, ebx_68, ebp_67, esi, edi, es, ds, edi, out ecx_351);
	}
}

// 006E1BD0: Register word32 fn006E1BD0(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Register out ptr32 ebpOut, Register out ptr32 esiOut, Register out ptr32 ediOut)
// Called from:
//      fn006E1DE0
//      fn006E8D90
//      fn00707020
//      fn00708DC0
word32 fn006E1BD0(Eq_3 dwArg04, Eq_3 dwArg08, ptr32 & ebpOut, ptr32 & esiOut, ptr32 & ediOut)
{
	Eq_3 ebp_12 = dwArg04;
	Eq_3 ebx_13 = *dwArg04;
	Eq_3 esi_17 = *dwArg08;
	if (ebx_13 == 0x00)
		return;
	do
	{
		Eq_3 edi_110 = 0x00;
		if (esi_17 == 0x00)
		{
			++g_dwA163B8;
			esi_17.u0 = 0x00A163B8;
		}
		Eq_3 eax_36 = *((word32) esi_17 + 4);
		if (eax_36 != 10611608)
		{
			word32 edx_654;
			word32 ecx_653;
			if (fn006D5670(eax_36, g_tA169F0, out ecx_653, out edx_654) != 0x00)
				goto l006E1C1E;
		}
		else
		{
l006E1C1E:
			edi_110 = *((word64) esi_17.u0 + 4);
			if (edi_110 == 10611608)
				edi_110 = *((word64) esi_17.u0 + 8);
		}
		struct Eq_58825 * esp_105;
		Eq_3 eax_68 = *((word32) ebx_13 + 4);
		if (eax_68 != 10611048)
		{
			if (eax_68 != 0x00A15380)
			{
				esp_105 = fp - 0x10;
				word32 ecx_657;
				word32 edx_658;
				if (fn006D5670(eax_68, 0x00A15380, out ecx_657, out edx_658) != 0x00)
					goto l006E1C53;
			}
			else
			{
l006E1C53:
				esp_105 = fp - 0x10;
				word32 edx_656;
				word32 ecx_655;
				if (fn006D5670(ebx_13, g_tA169F0, out ecx_655, out edx_656) != 0x00)
					goto l006E1C6B;
			}
			goto l006E1DB0;
		}
l006E1C6B:
		if (edi_110 != 0x00)
		{
			esp_105 = fp - 0x10;
			word32 ecx_659;
			word32 edx_660;
			if (fn00704020(out ecx_659, out edx_660) == 0x00)
				goto l006E1C81;
			if (edi_110 != ebx_13)
			{
				word32 v16_150 = (word32) *ebx_13 - 1;
				*ebx_13 = v16_150;
				if (v16_150 == 0x00)
				{
					struct Eq_59012 * edx_154 = *((word32) ebx_13 + 4);
					word32 ecx_160;
					edx_154->ptr0018();
				}
				*edi_110 = (word32) *edi_110 + 1;
				*ebp_12 = edi_110;
				*dwArg08 = esi_17;
				return;
			}
			goto l006E1DB0;
		}
l006E1C81:
		Eq_3 edi_215;
		if (esi_17 == 0x00A163B8)
		{
			word32 edx_662;
			word32 ecx_661;
			edi_215 = fn006DFD20(0x00, out ecx_661, out edx_662);
			goto l006E1CC7;
		}
		Eq_3 eax_191 = *((word64) esi_17.u0 + 4);
		if (eax_191 != 0x00A16588)
		{
			word32 ecx_667;
			word32 edx_668;
			if (fn006D5670(eax_191, 0x00A16588, out ecx_667, out edx_668) != 0x00)
				goto l006E1CC2;
			word32 edx_670;
			word32 esi_671;
			word32 ecx_669;
			edi_215 = fn006DFF80(0x01, out ecx_669, out edx_670, out esi_671);
		}
		else
		{
l006E1CC2:
			*esi_17.u0 = (word32) *esi_17.u0 + 1;
			edi_215 = esi_17;
		}
l006E1CC7:
		esp_105 = fp - 0x10;
		if (edi_215 != 0x00)
		{
			word32 edi_666;
			word32 ecx_663;
			word32 edx_664;
			word32 esi_665;
			Eq_3 eax_264 = fn00707680(ebx_13, dwArg04, dwArg08, out ecx_663, out edx_664, out esi_665, out edi_666);
			word32 v15_270 = (word32) *edi_215 - 1;
			*edi_215 = v15_270;
			esp_105 = fp - 0x10;
			if (v15_270 == 0x00)
			{
				struct Eq_58949 * eax_275 = *((word32) edi_215 + 4);
				word32 esp_279;
				word32 ecx_281;
				word32 edx_282;
				eax_275->ptr0018();
				esp_105 = esp_279 + 0x04;
			}
			if (eax_264 == 0x00)
			{
				ebp_12 = esp_105[5];
				goto l006E1CF6;
			}
			word32 v18_293 = (word32) *esi_17.u0 - 1;
			*esi_17.u0 = v18_293;
			if (v18_293 == 0x00)
			{
				struct Eq_59037 * ecx_297 = *((word64) esi_17.u0 + 4);
				<anonymous> * edx_298 = ecx_297->ptr0018;
				esp_105->dwFFFFFFFC = (word32) esi_17;
				word32 esp_305;
				word32 edx_308;
				edx_298();
				esp_105 = esp_305 + 0x04;
			}
			esi_17 = eax_264;
			ebp_12 = esp_105[5];
l006E1DB0:
			union Eq_3 * eax_320 = esp_105[6];
			*ebp_12 = ebx_13;
			*eax_320 = (union Eq_3 *) esi_17;
			return;
		}
l006E1CF6:
		word32 v20_341 = (word32) *ebx_13 - 1;
		*ebx_13 = v20_341;
		if (v20_341 == 0x00)
		{
			struct Eq_59063 * edx_345 = *((word32) ebx_13 + 4);
			<anonymous> * eax_346 = edx_345->ptr0018;
			esp_105->dwFFFFFFFC = (word32) ebx_13;
			word32 esp_354;
			word32 ecx_356;
			eax_346();
			esp_105 = esp_354 + 0x04;
		}
		word32 v21_364 = (word32) *esi_17.u0 - 1;
		*esi_17.u0 = v21_364;
		if (v21_364 == 0x00)
		{
			struct Eq_59125 * ecx_368 = *((word64) esi_17.u0 + 4);
			<anonymous> * edx_369 = ecx_368->ptr0018;
			esp_105->dwFFFFFFFC = (word32) esi_17;
			word32 esp_377;
			word32 edx_380;
			edx_369();
			esp_105 = esp_377 + 0x04;
		}
		union Eq_3 * edx_389 = esp_105[7];
		Eq_3 eax_386 = g_tA6D67C;
		Eq_3 ecx_390 = *edx_389;
		*ebp_12 = *((word32) eax_386 + 40);
		union Eq_3 * esi_394 = esp_105[6];
		*esi_394 = (union Eq_3 *) *((word32) eax_386 + 44);
		*edx_389 = (union Eq_3 *) *((word32) eax_386 + 48);
		((word32) eax_386 + 40)->u0 = 0x00;
		((word32) eax_386 + 44)->u0 = 0x00;
		((word32) eax_386 + 48)->u0 = 0x00;
		if (ecx_390 != 0x00)
		{
			if (*edx_389 == 0x00)
				*edx_389 = (union Eq_3 *) ecx_390;
			else
			{
				word32 v22_406 = (word32) *ecx_390 - 1;
				*ecx_390 = v22_406;
				if (v22_406 == 0x00)
				{
					Eq_3 eax_410 = *((word32) ecx_390 + 4);
					esp_105->dwFFFFFFFC = (word32) ecx_390;
					word32 ecx_418;
					word32 edx_419;
					(*((word32) eax_410 + 24))();
				}
			}
		}
		ebx_13 = *ebp_12;
		esi_17 = *esi_394;
	} while (ebx_13 != 0x00);
	return;
}

// 006E1DC0: Register word32 fn006E1DC0(Register out ptr32 edxOut)
// Called from:
//      fn006DFD20
//      fn006DFE20
//      fn006DFE60
//      fn006E0B00
//      fn006E5C00
//      fn006EA420
//      fn006EC4F0
//      fn006F2650
//      fn006F2750
//      fn006F2790
//      fn006F2A10
//      fn006F34B0
//      fn006F4F00
//      fn006F9540
//      fn006FBD90
//      fn006FBE60
//      fn006FCC90
//      fn006FCF20
//      fn006FDE60
//      fn007108F0
//      fn007109D0
//      fn00710B80
//      fn007114E0
//      fn00711700
//      fn00717230
//      fn00717900
//      fn00720070
//      fn00725150
//      fn007251F0
//      fn00725DA0
//      fn0072F770
//      fn0072FBB0
//      fn00734BB0
//      fn0073D450
//      fn007503F0
//      fn00750420
word32 fn006E1DC0(ptr32 & edxOut)
{
	word32 ecx_18;
	ptr32 edx_19;
	fn006E15D0(g_tA18720, 0x008D2044, out ecx_18, out edx_19);
	edxOut = edx_19;
	return ecx_18;
}

// 006E1DE0: Register word32 fn006E1DE0(Stack Eq_3 dwArg08, Register out (ptr32 Eq_59191) edxOut)
// Called from:
//      fn00747960
//      fn00747FD0
//      fn00748190
//      fn007486D0
//      fn00748810
//      fn00748E50
//      fn00752B30
//      fn00752CA0
word32 fn006E1DE0(Eq_3 dwArg08, struct Eq_59191 & edxOut)
{
	Eq_3 eax_7 = g_tA6D67C;
	Eq_3 edx_10 = *((word32) eax_7 + 44);
	Eq_3 ecx_15 = *((word32) eax_7 + 48);
	((word32) eax_7 + 40)->u0 = 0x00;
	((word32) eax_7 + 44)->u0 = 0x00;
	((word32) eax_7 + 48)->u0 = 0x00;
	word32 edi_567;
	word32 ebp_565;
	word32 esi_566;
	fn006E1BD0(fp - 0x08, fp - 0x0C, out ebp_565, out esi_566, out edi_567);
	word32 ecx_568;
	word32 edx_569;
	Eq_3 eax_45 = fn007050A0(dwArg08, out ecx_568, out edx_569);
	struct Eq_59240 * esp_108 = fp - 0x18;
	if (eax_45 == 0x00)
	{
		word32 ecx_572;
		word32 edx_573;
		fn006E1160(out ecx_572, out edx_573);
	}
	else
	{
		esp_108 = fp - 0x18;
		word32 ecx_570;
		word32 edx_571;
		if (fn006DF800(edx_10, 0x008D2094, eax_45, out ecx_570, out edx_571) != 0x00)
		{
			word32 ecx_574;
			word32 edx_575;
			fn006E1160(out ecx_574, out edx_575);
		}
		word32 v13_81 = (word32) *eax_45 - 1;
		*eax_45 = v13_81;
		if (v13_81 == 0x00)
		{
			Eq_3 eax_85 = *((word32) eax_45 + 4);
			word32 esp_93;
			(*((word32) eax_85 + 24))();
			esp_108 = esp_93 + 0x04;
		}
	}
	Eq_3 edi_110 = esp_108->t001C;
	if (edi_110 != 0x00)
	{
		struct Eq_59314 * esp_114 = esp_108 - 4;
		esp_114->t0000 = edi_110;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_3 stackArg4 = <invalid>;
		word32 edx_582;
		word32 ecx_581;
		Eq_3 eax_120 = fn006ECAC0(stackArg4, out ecx_581, out edx_582);
		ptr32 esp_126 = (const char *) &esp_114->t0000 + 4;
		if (eax_120 == 0x00)
		{
			word32 ecx_587;
			word32 edx_588;
			fn006E1160(out ecx_587, out edx_588);
		}
		else
		{
			word32 edx_130 = esp_114->dw0010;
			esp_114->t0000 = eax_120;
			esp_114->dwFFFFFFFC = 0x008D2088;
			esp_114->dwFFFFFFF8 = edx_130;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg4 = <invalid>;
			Eq_3 stackArg8 = <invalid>;
			esp_126 = (const char *) &esp_114->t0000 + 4;
			word32 ecx_585;
			word32 edx_586;
			if (fn006DF800(stackArg4, stackArg8, dwArg08, out ecx_585, out edx_586) != 0x00)
			{
				word32 edx_602;
				word32 ecx_601;
				fn006E1160(out ecx_601, out edx_602);
			}
			word32 v15_156 = (word32) *eax_120 - 1;
			*eax_120 = v15_156;
			if (v15_156 == 0x00)
			{
				Eq_3 eax_160 = *((word32) eax_120 + 4);
				struct Eq_58241 * ecx_161 = *((word32) eax_160 + 24);
				esp_114->t0000 = eax_120;
				word32 esp_168;
				ecx_161();
				esp_126 = esp_168 + 0x04;
			}
		}
		struct Eq_59365 * esp_184 = esp_126 - 4;
		esp_184->t0000 = dwArg08;
		esp_184->tFFFFFFFC = edi_110;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_3 stackArg4 = <invalid>;
		Eq_3 stackArg8 = <invalid>;
		Eq_3 eax_193 = fn006E1AB0(edx, dwArg08, ebp, eax_120, edi_110, es, ds, stackArg4, stackArg8);
		esp_108 = (struct Eq_59240 *) ((const char *) &esp_184->t0000 + 4);
		if (eax_193 != 0x00)
		{
			word32 edx_203 = esp_184->dw0010;
			esp_184->t0000 = eax_193;
			esp_184->tFFFFFFFC.u0 = 9235992;
			esp_184->dwFFFFFFF8 = edx_203;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg4 = <invalid>;
			Eq_3 stackArg8 = <invalid>;
			esp_108 = (struct Eq_59240 *) ((const char *) &esp_184->t0000 + 4);
			word32 ecx_597;
			word32 edx_598;
			if (fn006DF800(stackArg4, stackArg8, dwArg08, out ecx_597, out edx_598) != 0x00)
			{
				word32 edx_600;
				word32 ecx_599;
				fn006E1160(out ecx_599, out edx_600);
			}
			word32 v14_229 = (word32) *eax_193 - 1;
			*eax_193 = v14_229;
			if (v14_229 == 0x00)
			{
				Eq_3 eax_233 = *((word32) eax_193 + 4);
				struct Eq_58241 * ecx_234 = *((word32) eax_233 + 24);
				esp_184->t0000 = eax_193;
				word32 esp_241;
				ecx_234();
				esp_108 = esp_241 + 0x04;
			}
		}
	}
	Eq_3 edx_251 = esp_108->t000C;
	struct Eq_59290 * esp_252 = esp_108 - 4;
	esp_252->t0000.u0 = 0x00A163B8;
	esp_252->tFFFFFFFC.u0 = 9159044;
	esp_252->tFFFFFFF8 = edx_251;
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_3 stackArg4 = <invalid>;
	Eq_3 stackArg8 = <invalid>;
	word32 ecx_578;
	word32 edx_579;
	if (fn006DF800(stackArg4, stackArg8, dwArg08, out ecx_578, out edx_579) != 0x00)
	{
		word32 edx_604;
		word32 ecx_603;
		fn006E1160(out ecx_603, out edx_604);
	}
	if (esp_252->t0014 != g_tA178F4)
	{
		Eq_3 ecx_284 = esp_252->t0010;
		esp_252->t0000.u0 = 0x008D2084;
		esp_252->tFFFFFFFC = ecx_284;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_3 stackArg4 = <invalid>;
		Eq_3 stackArg8 = <invalid>;
		struct Eq_59517 * esp_299 = (const char *) &esp_252->t0000 + 4;
		word32 edx_607;
		if (fn006DF7C0(stackArg4, stackArg8, out edx_607) == 0x00)
		{
			esp_252->t0000 = esp_252->t0010;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg4 = <invalid>;
			word32 edx_612;
			word32 edi_613;
			Eq_3 eax_307 = fn006DDF70(stackArg4, out edx_612, out edi_613);
			esp_299 = (struct Eq_59517 *) ((const char *) &esp_252->t0000 + 4);
			if (eax_307 != 0x00)
			{
				Eq_3 eax_324 = esp_252->t0010;
				esp_252->t0000 = eax_307;
				esp_252->tFFFFFFFC.u0 = 0x008D2084;
				esp_252->tFFFFFFF8 = eax_324;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_3 stackArg4 = <invalid>;
				Eq_3 stackArg8 = <invalid>;
				esp_299 = (struct Eq_59517 *) ((const char *) &esp_252->t0000 + 4);
				word32 ecx_618;
				word32 edx_619;
				if (fn006DF800(stackArg4, stackArg8, dwArg08, out ecx_618, out edx_619) != 0x00)
				{
					word32 ecx_620;
					word32 edx_621;
					fn006E1160(out ecx_620, out edx_621);
				}
				word32 v16_350 = (word32) *eax_307 - 1;
				*eax_307 = v16_350;
				if (v16_350 == 0x00)
				{
					Eq_3 ecx_354 = *((word32) eax_307 + 4);
					struct Eq_58241 * edx_355 = *((word32) ecx_354 + 24);
					esp_252->t0000 = eax_307;
					word32 esp_362;
					edx_355();
					esp_299 = esp_362 + 0x04;
				}
			}
			else
			{
				word32 ecx_614;
				word32 edx_615;
				fn006E1160(out ecx_614, out edx_615);
			}
		}
		word32 eax_372 = esp_299->dw000C;
		struct Eq_59531 * esp_373 = esp_299 - 4;
		esp_373->dw0000 = 0x008D2070;
		esp_373->dwFFFFFFFC = eax_372;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_3 stackArg4 = <invalid>;
		Eq_3 stackArg8 = <invalid>;
		word32 edx_610;
		if (fn006DF7C0(stackArg4, stackArg8, out edx_610) == 0x00)
		{
			word32 ecx_391 = esp_373->dw0010;
			esp_373->dw0000 = 0x00A163B8;
			esp_373->dwFFFFFFFC = 0x008D2070;
			esp_373->dwFFFFFFF8 = ecx_391;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg4 = <invalid>;
			Eq_3 stackArg8 = <invalid>;
			word32 edx_625;
			word32 ecx_624;
			if (fn006DF800(stackArg4, stackArg8, dwArg08, out ecx_624, out edx_625) != 0x00)
			{
				word32 edx_627;
				word32 ecx_626;
				fn006E1160(out ecx_626, out edx_627);
			}
		}
	}
	word32 ecx_427;
	struct Eq_59191 * edx_428;
	fn006E0E00(ecx_15, out ecx_427, out edx_428);
	edxOut = edx_428;
	return ecx_427;
}

// 006E3770: Register word32 fn006E3770(Stack (ptr32 Eq_59662) dwArg04, Stack Eq_3 dwArg08, Register out ptr32 ecxOut, Register out ptr32 edxOut)
// Called from:
//      fn00717CB0
//      fn00719E80
word32 fn006E3770(struct Eq_59662 * dwArg04, Eq_3 dwArg08, ptr32 & ecxOut, ptr32 & edxOut)
{
	ptr32 ecx_17;
	ptr32 edx_18;
	Eq_3 eax_16 = fn00705120(dwArg08, out ecx_17, out edx_18);
	if (eax_16 != 0x00)
	{
		Eq_3 eax_26 = dwArg04->t001C;
		if (eax_26 != 0x00)
		{
			dwArg04->t001C.u0 = 0x00;
			word32 v10_31 = (word32) *eax_26 - 1;
			*eax_26 = v10_31;
			if (v10_31 == 0x00)
			{
				struct Eq_59705 * ecx_35 = *((word32) eax_26 + 4);
				ecx_35->ptr0018();
			}
		}
		dwArg04->t001C = eax_16;
		ecxOut = ecx_17;
		edxOut = edx_18;
		return 0x00;
	}
	else
	{
		ecxOut = ecx_17;
		edxOut = edx_18;
		return ~0x00;
	}
}

// 006E38B0: Register word32 fn006E38B0(Stack (ptr32 Eq_59662) dwArg04, Stack Eq_3 dwArg08, Register out ptr32 ecxOut, Register out ptr32 edxOut)
// Called from:
//      fn00717CB0
//      fn00719E80
word32 fn006E38B0(struct Eq_59662 * dwArg04, Eq_3 dwArg08, ptr32 & ecxOut, ptr32 & edxOut)
{
	ptr32 ecx_17;
	ptr32 edx_18;
	Eq_3 eax_16 = fn00705120(dwArg08, out ecx_17, out edx_18);
	if (eax_16 != 0x00)
	{
		Eq_3 eax_26 = dwArg04->t0020;
		if (eax_26 != 0x00)
		{
			dwArg04->t0020.u0 = 0x00;
			word32 v10_31 = (word32) *eax_26 - 1;
			*eax_26 = v10_31;
			if (v10_31 == 0x00)
			{
				struct Eq_59705 * ecx_35 = *((word32) eax_26 + 4);
				ecx_35->ptr0018();
			}
		}
		dwArg04->t0020 = eax_16;
		ecxOut = ecx_17;
		edxOut = edx_18;
		return 0x00;
	}
	else
	{
		ecxOut = ecx_17;
		edxOut = edx_18;
		return ~0x00;
	}
}

// 006E3900: Register word32 fn006E3900(Stack (ptr32 Eq_59662) dwArg04, Stack Eq_3 dwArg08, Register out ptr32 ecxOut, Register out ptr32 edxOut)
// Called from:
//      fn00717CB0
//      fn00719E80
word32 fn006E3900(struct Eq_59662 * dwArg04, Eq_3 dwArg08, ptr32 & ecxOut, ptr32 & edxOut)
{
	ptr32 ecx_17;
	ptr32 edx_18;
	Eq_3 eax_16 = fn006ECAC0(dwArg08, out ecx_17, out edx_18);
	if (eax_16 != 0x00)
	{
		Eq_3 eax_26 = dwArg04->t0024;
		if (eax_26 != 0x00)
		{
			dwArg04->t0024.u0 = 0x00;
			word32 v10_31 = (word32) *eax_26 - 1;
			*eax_26 = v10_31;
			if (v10_31 == 0x00)
			{
				Eq_3 ecx_35 = *((word32) eax_26 + 4);
				(*((word32) ecx_35 + 24))();
			}
		}
		dwArg04->t0024 = eax_16;
		ecxOut = ecx_17;
		edxOut = edx_18;
		return 0x00;
	}
	else
	{
		ecxOut = ecx_17;
		edxOut = edx_18;
		return ~0x00;
	}
}

// 006E3D10: Register word32 fn006E3D10(Register out ptr32 ecxOut, Register out ptr32 edxOut)
// Called from:
//      fn00719E80
word32 fn006E3D10(ptr32 & ecxOut, ptr32 & edxOut)
{
	ptr32 ecx_30;
	ptr32 edx_31;
	word32 eax_29 = fn00703870(g_tA17FB4, &g_b8D3168, out ecx_30, out edx_31);
	ecxOut = ecx_30;
	edxOut = edx_31;
	return eax_29;
}

// 006E3E50: Register word32 fn006E3E50(Register out ptr32 ecxOut, Register out ptr32 edxOut)
// Called from:
//      fn00717CB0
word32 fn006E3E50(ptr32 & ecxOut, ptr32 & edxOut)
{
	ptr32 ecx_30;
	ptr32 edx_31;
	word32 eax_29 = fn00703870(g_tA18044, &g_b8D31F8, out ecx_30, out edx_31);
	ecxOut = ecx_30;
	edxOut = edx_31;
	return eax_29;
}

// 006E52A0: void fn006E52A0()
// Called from:
//      fn006E8910
void fn006E52A0()
{
	Eq_3 eax_5 = g_tA6C578;
	if (eax_5 != 0x00)
	{
		*eax_5 = (word32) *eax_5 - 1;
		Eq_3 eax_11 = g_tA6C578;
		if (*eax_11 == 0x00)
		{
			Eq_3 ecx_14 = *((word32) eax_11 + 4);
			word32 edx_21;
			(*((word32) ecx_14 + 24))();
		}
	}
	Eq_59842 eax_27 = g_tA6C570;
	g_tA6C578.u0 = 0x00;
	_set_invalid_parameter_handler(eax_27);
}

// 006E54A0: Register word32 fn006E54A0(Register Eq_3 ebx, Register (ptr32 Eq_3) edi)
// Called from:
//      fn006E5C60
word32 fn006E54A0(Eq_3 ebx, union Eq_3 * edi)
{
	if (*edi == 0x00)
	{
		word32 edx_173;
		Eq_3 eax_11 = fn006F2650(0x00, out edx_173);
		*edi = (union Eq_3 *) eax_11;
		if (eax_11 == 0x00)
		{
			free(ebx);
			return ~0x00;
		}
	}
	Eq_3 eax_35 = fn0072E920(ebx, 0x00);
	if (eax_35 != 0x00)
	{
		word32 ecx_174;
		word32 edx_175;
		if (fn006F2A10(*edi, eax_35, out ecx_174, out edx_175) == 0x00)
		{
			word32 v14_60 = (word32) *eax_35 - 1;
			*eax_35 = v14_60;
			if (v14_60 == 0x00)
			{
				Eq_3 eax_64 = *((word32) eax_35 + 4);
				(*((word32) eax_64 + 24))();
			}
			return 0x00;
		}
		else
		{
			free(ebx);
			word32 v11_86 = (word32) *eax_35 - 1;
			*eax_35 = v11_86;
			if (v11_86 == 0x00)
			{
				Eq_3 ecx_90 = *((word32) eax_35 + 4);
				(*((word32) ecx_90 + 24))();
			}
			return ~0x00;
		}
	}
	else
	{
		free(ebx);
		return ~0x00;
	}
}

// 006E5530: Register Eq_3 fn006E5530(Register (ptr32 Eq_59972) edi, Stack word32 dwArg04, Register out Eq_59974 edxOut)
// Called from:
//      fn006E7660
Eq_3 fn006E5530(struct Eq_59972 * edi, word32 dwArg04, union Eq_59974 & edxOut)
{
	if (edi == null)
	{
		edxOut = edx;
		return <invalid>;
	}
	else
	{
		if (dwArg04 == 0x00)
		{
			int32 ebx_20 = edi->dw0008;
			int32 esi_24 = 0x00;
			if (ebx_20 > 0x00)
			{
				do
				{
					free(fn0072E9C0(edi->ptr000C[esi_24], out edx));
					++esi_24;
				} while (esi_24 < ebx_20);
			}
		}
		word32 v14_62 = edi->dw0000 + ~0x00;
		edi->dw0000 = v14_62;
		if (v14_62 == 0x00)
		{
			struct Eq_60016 * edx_66 = edi->ptr0004;
			word32 ecx_79;
			edx_66->ptr0018();
		}
		edxOut = edx;
		return <invalid>;
	}
}

// 006E5590: void fn006E5590(Register Eq_3 ecx, Register Eq_3 edx, Register Eq_3 ebx, Register Eq_3 ebp, Register Eq_3 esi, Register Eq_3 edi, Register (ptr16 Eq_7) es, Register (ptr16 Eq_8) ds, Stack Eq_3 dwArg04, Stack ui32 dwArg0C)
// Called from:
//      fn006E7660
void fn006E5590(Eq_3 ecx, Eq_3 edx, Eq_3 ebx, Eq_3 ebp, Eq_3 esi, Eq_3 edi, struct Eq_7 * es, struct Eq_8 * ds, Eq_3 dwArg04, ui32 dwArg0C)
{
	ui32 eax_7 = g_tA14188 ^ fp - 0x0208;
	Eq_3 edi_223 = ecx;
	Eq_3 esi_25 = fp - 0x0204;
	Eq_3 eax_253 = fn006E0FC0();
	if (eax_253 == 0x00)
	{
		if (ecx == 0x00)
		{
			if (dwArg0C != 0x00)
			{
				fn00724FE0(fp - 0x0204, 0x0200, &g_b8D3610);
				byte * eax_51 = fp - 0x0204;
				do
				{
					eax_51 = eax_452 + 1;
					eax_452 = eax_51;
				} while (*eax_452 != 0x00);
				esi_25 = fp - 0x0204 + (eax_51 - (fp - (byte *) 515));
			}
			Eq_3 esi_103;
			if (dwArg04 != 0x00)
			{
				fn00724FE0(esi_25, fp - (byte *) 0x04 - esi_25, &g_b8D3604);
				Eq_3 eax_122 = esi_25;
				int32 edi_124 = 0x00;
				word32 edx_127 = esi_25 + 0x01;
				do
				{
					eax_122 = (word32) eax_454 + 1;
					eax_454 = eax_122;
				} while (*eax_454 != 0x00);
				esi_103 = esi_25 + (eax_122 - edx_127);
				if (*ebx > 0x00)
				{
					while (edi_124 < 0x20 && esi_103 - (fp - (byte *) 0x0204) < (byte *) 220)
					{
						fn00724FE0(esi_103, fp - (byte *) 0x04 - esi_103, &g_b8D35F8);
						Eq_3 eax_177 = esi_103;
						word32 edx_180 = esi_103 + 0x01;
						do
						{
							eax_177 = (word32) eax_455 + 1;
							eax_455 = eax_177;
						} while (*eax_455 != 0x00);
						++edi_124;
						esi_103 += eax_177 - edx_180;
						if (*((word32) ebx + edi_124 * 0x04) <= 0x00)
							break;
					}
				}
			}
			else
			{
				fn00724FE0(esi_25, fp - (byte *) 0x04 - esi_25, &g_b8D35EC);
				Eq_3 eax_89 = esi_25;
				word32 edx_92 = esi_25 + 0x01;
				do
				{
					eax_89 = (word32) eax_453 + 1;
					eax_453 = eax_89;
				} while (*eax_453 != 0x00);
				esi_103 = esi_25 + (eax_89 - edx_92);
			}
			fn00724FE0(esi_103, fp - (byte *) 0x04 - esi_103, &g_b8D35E4);
			edi_223 = fp - (byte *) 0x0204;
		}
		word32 ecx_451;
		eax_253 = fn006E0F80(g_tA16B7C, edi_223, out ecx_451, out edx);
	}
	word32 ecx_450;
	fn00694B8E(eax_253, eax_7 ^ fp - 520, edx, ebx, ebp, esi, edi, es, ds, ebp, out ecx_450);
}

// 006E5710: Register Eq_3 fn006E5710(Stack Eq_3 dwArg04, Stack (ptr32 (ptr32 byte)) dwArg08, Stack Eq_3 dwArg14, Stack Eq_3 dwArg18, Stack Eq_3 dwArg1C, Stack word32 dwArg20, Register out (ptr32 byte) ecxOut, Register out Eq_3 edxOut)
// Called from:
//      fn006E6E70
Eq_3 fn006E5710(Eq_3 dwArg04, byte ** dwArg08, Eq_3 dwArg14, Eq_3 dwArg18, Eq_3 dwArg1C, word32 dwArg20, byte & ecxOut, union Eq_3 & edxOut)
{
	word32 esi_22 = 0x00;
	Eq_3 ebp_23 = 0x00;
	byte * dwLoc04_407 = *dwArg08;
	while (true)
	{
l006E5730:
		while (true)
		{
			int32 eax_31 = (int32) *dwLoc04_407;
			++dwLoc04_407;
			if (eax_31 != 0x28)
				break;
			if (esi_22 == 0x00)
				ebp_23 = (word32) ebp_23 + 1;
			++esi_22;
		}
		if (eax_31 == 0x29)
			break;
		if (eax_31 == 0x3A || (eax_31 == 0x3B || eax_31 == 0x00))
			goto l006E5783;
		if (esi_22 == 0x00 && isalpha(eax_31 & 0xFF) != 0x00)
			ebp_23 = (word32) ebp_23 + 1;
	}
	if (esi_22 == 0x00)
	{
l006E5783:
		Eq_3 edx_102;
		if (fn00704700(dwArg04, out edx_102) != 0x00)
		{
			Eq_3 eax_93 = *((word32) dwArg04 + 4);
			if (eax_93 != 0x00A1B450)
			{
				word32 ecx_598;
				if (fn006D5670(eax_93, 0x00A1B450, out ecx_598, out edx_102) == 0x00)
				{
					Eq_3 edx_171;
					if (fn00703120(dwArg04, out edx_171) == ebp_23)
					{
						byte * eax_177 = *dwArg08;
						Eq_3 ebx_178 = 0x00;
						if (ebp_23 > 0x00)
						{
							do
							{
								word32 ecx_599;
								word32 edx_600;
								Eq_3 eax_195 = fn00703180(dwArg04, ebx_178, out ecx_599, out edx_600);
								if (eax_195 == 0x00)
								{
									Eq_3 edx_206;
									word32 ecx_601;
									fn006E1160(out ecx_601, out edx_206);
									*dwArg14 = (word32) ebx_178 + 1;
									((word32) dwArg14 + 4)->u0 = 0x00;
									strncpy(dwArg18, 9254500, dwArg1C);
									ecxOut = eax_177;
									edxOut = edx_206;
									return dwArg18;
								}
								word32 ecx_263;
								Eq_3 edx_265;
								Eq_3 eax_264 = fn006E6E70(fp - 0x04, (word32) dwArg14 + 4, out ecx_263, out edx_265);
								word32 v14_269 = (word32) *eax_195 - 1;
								*eax_195 = v14_269;
								if (v14_269 == 0x00)
								{
									Eq_3 edx_274 = *((word32) eax_195 + 4);
									(*((word32) edx_274 + 24))();
								}
								ebx_178 = (word32) ebx_178 + 1;
								if (eax_264 != 0x00)
								{
									*dwArg14 = ebx_178;
									ecxOut = eax_177;
									edxOut = dwArg14;
									return eax_264;
								}
							} while (ebx_178 < ebp_23);
							*dwArg08 = (byte **) eax_177;
							ecxOut = eax_177;
							edxOut = edx_265;
							return 0x00;
						}
						else
						{
							*dwArg08 = (byte **) eax_177;
							ecxOut = eax_177;
							edxOut = edx_171;
							return 0x00;
						}
					}
					else
					{
						dwArg14->u0 = 0x00;
						byte * ecx_344 = &g_b8D36A0;
						if (dwArg20 == 0x00)
							ecx_344 = &g_b8D3678;
						fn00724FE0(dwArg18, dwArg1C, ecx_344);
						ecxOut = dwLoc04_407;
						edxOut = dwArg1C;
						return dwArg18;
					}
				}
			}
		}
		dwArg14->u0 = 0x00;
		if (dwArg04 != 0x00A163B8)
			edx_102 = *((word32) dwArg04 + 4);
		byte * eax_124 = &g_b8D3640;
		if (dwArg20 == 0x00)
			eax_124 = &g_b8D361C;
		fn00724FE0(dwArg18, dwArg1C, eax_124);
		ecxOut = dwLoc04_407;
		edxOut = edx_102;
		return dwArg18;
	}
	else
	{
		--esi_22;
		goto l006E5730;
	}
}

// 006E5920: Register Eq_3 fn006E5920(Register Eq_3 eax, Register Eq_3 edx, Register Eq_3 esi, Register out (ptr32 Eq_60079) ecxOut)
// Called from:
//      fn006E5C60
Eq_3 fn006E5920(Eq_3 eax, Eq_3 edx, Eq_3 esi, struct Eq_60079 & ecxOut)
{
	if (eax != 0x00A163B8)
	{
		ecxOut = fn00724FE0(esi, edx, &g_b8D36C0);
		return <invalid>;
	}
	else
	{
		ecxOut = fn00724FE0(esi, edx, &g_b8D36C0);
		return <invalid>;
	}
}

// 006E5960: Register Eq_3 fn006E5960(Register Eq_3 eax)
// Called from:
//      fn006E5C60
Eq_3 fn006E5960(Eq_3 eax)
{
	Eq_3 eax_6 = *((word32) eax + 4);
	if (eax_6 != 10609848)
	{
		word32 ecx_75;
		word32 edx_76;
		if (fn006D5670(eax_6, 10609848, out ecx_75, out edx_76) == 0x00)
			return 0x00;
	}
	word32 edx_74;
	if (fn006E1970(g_tA18A34, 0x008D36DC, 0x01, out edx_74) == 0x00)
		return 0x00;
	return 0x01;
}

// 006E59A0: Register int32 fn006E59A0(Register (ptr32 word32) ebx, Register Eq_3 edi, Stack Eq_3 dwArg04)
// Called from:
//      fn006E5C60
int32 fn006E59A0(word32 * ebx, Eq_3 edi, Eq_3 dwArg04)
{
	int32 eax_24;
	struct Eq_60439 * esi_10 = *((word32) *((word32) edi + 4) + 80);
	if (esi_10 != null && esi_10->ptr0000 != null)
	{
		<anonymous> * eax_16 = esi_10->ptr0008;
		if (eax_16 != null)
		{
			word32 eax_32;
			word32 ecx_33;
			word32 edx_34;
			eax_16();
			if (eax_32 == 0x01)
			{
				word32 edx_51;
				esi_10->ptr0000();
				if (eax_24 >= 0x00)
					return eax_24;
				*ebx = 0x008D3720;
				return eax_24;
			}
			else
			{
				*ebx = 0x008D3730;
				return ~0x00;
			}
		}
	}
	*ebx = 0x008D3704;
	eax_24 = ~0x00;
	return eax_24;
}

// 006E5AD0: Register word32 fn006E5AD0(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Stack Eq_3 dwArg0C, Stack Eq_3 dwArg10)
// Called from:
//      fn00738CB0
word32 fn006E5AD0(Eq_3 dwArg04, Eq_3 dwArg08, Eq_3 dwArg0C, Eq_3 dwArg10)
{
	Eq_3 eax_8 = *((word32) dwArg04 + 4);
	if (eax_8 != 0x00A16588)
	{
		word32 edx_341;
		word32 ecx_340;
		if (fn006D5670(eax_8, 0x00A16588, out ecx_340, out edx_341) == 0x00)
		{
			word32 edx_343;
			word32 ecx_342;
			fn006E0F80(g_tA18720, 0x008D1184, out ecx_342, out edx_343);
			return 0x00;
		}
	}
	Eq_3 edx_28 = *((word32) dwArg04 + 8);
	if (edx_28 >= dwArg0C)
	{
		if (edx_28 <= dwArg10)
		{
			if (edx_28 > 0x00)
			{
				word32 ** eax_38 = fp + 0x10 + 0x04;
				word32 * ecx_39 = (word32) dwArg04 + 0x0C;
				do
				{
					**eax_38 = *ecx_39;
					eax_38 = (word32 **) ((const char *) eax_38 + 4);
					++ecx_39;
					--edx_28;
				} while (edx_28 != 0x00);
			}
			return 0x01;
		}
		else if (dwArg08 == 0x00)
		{
			word32 ecx_350;
			word32 edx_351;
			fn006E15D0(g_tA16B7C, 0x008D3784, out ecx_350, out edx_351);
			return 0x00;
		}
		else
		{
			word32 ecx_348;
			word32 edx_349;
			fn006E15D0(g_tA16B7C, 9254844, out ecx_348, out edx_349);
			return 0x00;
		}
	}
	else if (dwArg08 == 0x00)
	{
		word32 ecx_346;
		word32 edx_347;
		fn006E15D0(g_tA16B7C, 0x008D3784, out ecx_346, out edx_347);
		return 0x00;
	}
	else
	{
		word32 ecx_344;
		word32 edx_345;
		fn006E15D0(g_tA16B7C, 9254844, out ecx_344, out edx_345);
		return 0x00;
	}
}

// 006E5C00: Register word32 fn006E5C00(Stack Eq_3 dwArg08)
// Called from:
//      fn00738CB0
word32 fn006E5C00(Eq_3 dwArg08)
{
	if (dwArg08 == 0x00)
		return 0x01;
	if (*((word32) dwArg08 + 4) == 0x00A1D1B8)
	{
		if (fn006FCF20(dwArg08) == 0x00)
			return 0x01;
		word32 ecx_94;
		word32 edx_95;
		fn006E15D0(g_tA16B7C, 0x008D37F0, out ecx_94, out edx_95);
		return 0x00;
	}
	else
	{
		word32 edx_93;
		fn006E1DC0(out edx_93);
		return 0x00;
	}
}

// 006E5C60: Register Eq_3 fn006E5C60(Register Eq_3 eax, Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Stack ui32 dwArg0C, Stack Eq_3 dwArg10, Stack Eq_3 dwArg14, Register out (ptr32 Eq_60079) ecxOut, Register out Eq_3 edxOut)
// Called from:
//      fn006E6E70
Eq_3 fn006E5C60(Eq_3 eax, Eq_3 dwArg04, Eq_3 dwArg08, ui32 dwArg0C, Eq_3 dwArg10, Eq_3 dwArg14, struct Eq_60079 & ecxOut, union Eq_3 & edxOut)
{
	byte bArg0C_3394 = (byte) dwArg0C;
	struct Eq_60079 * ebx_21 = *dwArg08;
	Eq_60642 eax_23 = (int32) ebx_21->b0000;
	struct Eq_60079 * dwLoc34_2844 = &ebx_21->b0001;
	if (eax_23 > ~0x79)
	{
l006E6D8C:
		ecxOut = fn00724FE0(dwArg10, dwArg14, &g_b8D36C0);
		edxOut = edx;
		return dwArg10;
	}
	else
	{
		Eq_3 edi_1351;
		word16 si_2595;
		Eq_3 edi_1147;
		Eq_3 esi_1171;
		Eq_3 edi_2168;
		switch ((word32) eax_23)
		{
		case 66:
			*eax = (word32) *eax + 4;
			Eq_3 edi_2707 = *((word32) *eax - 4);
			if (fn006E5960(dwArg04) == 0x00)
			{
				Eq_3 eax_2721 = fn00705340(edi_2707, dwArg04);
				byte bl_2739 = (byte) eax_2721;
				if (eax_2721 != ~0x00 || fn006E0FC0() == 0x00)
				{
					*edi_2707 = bl_2739;
					*dwArg08 = &ebx_21->b0001;
					ecxOut = (struct Eq_60079 *) &ebx_21->b0001;
					edxOut = dwArg08;
					return 0x00;
				}
			}
			break;
		case 0x43:
		case 0x45:
		case 0x46:
		case 0x47:
		case 0x4A:
		case 77:
		case 0x4E:
		case 0x50:
		case 0x51:
		case 0x52:
		case 0x54:
		case 0x56:
		case 0x57:
		case 88:
		case 0x59:
		case 0x5A:
		case 0x5B:
		case 0x5C:
		case 0x5D:
		case 0x5E:
		case 0x5F:
		case 0x60:
		case 0x61:
		case 0x67:
		case 0x6A:
		case 0x6D:
		case 111:
		case 0x70:
		case 113:
		case 114:
		case 118:
		case 0x78:
		case 121:
			goto l006E6D8C;
		case 0x44:
			*eax = (word32) *eax + 4;
			Eq_3 esi_2617 = *((word32) *eax - 4);
			struct Eq_60696 * eax_2624 = fn007332C0(fp - 0x10, dwArg04);
			Eq_3 ecx_2629 = eax_2624->t0008;
			Eq_3 edx_2630 = eax_2624->t000C;
			word32 edi_2631 = eax_2624->dw0000;
			Eq_3 ebx_2632 = eax_2624->t0004;
			if (fn006E0FC0() == 0x00)
			{
				*esi_2617 = edi_2631;
				*((word32) esi_2617 + 4) = ebx_2632;
				*((word32) esi_2617 + 8) = ecx_2629;
				*((word32) esi_2617 + 0x0C) = edx_2630;
				*dwArg08 = &ebx_21->b0001;
				ecxOut = (struct Eq_60079 *) &ebx_21->b0001;
				edxOut = dwArg08;
				return 0x00;
			}
			break;
		case 0x48:
			*eax = (word32) *eax + 4;
			edi_1351 = *((word32) *eax - 4);
			if (fn006E5960(dwArg04) == 0x00)
			{
				Eq_3 eax_2578 = fn00705340(edi_1351, dwArg04);
				si_2595 = (word16) eax_2578;
				if (eax_2578 != ~0x00 || fn006E0FC0() == 0x00)
					goto l006E5DF6;
			}
			break;
		case 0x49:
			*eax = (word32) *eax + 4;
			edi_1147 = *((word32) *eax - 4);
			if (fn006E5960(dwArg04) == 0x00)
			{
				Eq_3 eax_2527 = fn00705340(edi_1147, dwArg04);
				esi_1171 = eax_2527;
				if (eax_2527 != ~0x00 || fn006E0FC0() == 0x00)
					goto l006E5EC4;
			}
			break;
		case 0x4B:
			*eax = (word32) *eax + 4;
			Eq_3 eax_2405 = *((word32) dwArg04 + 4);
			Eq_3 edi_2408 = *((word32) *eax - 4);
			if (eax_2405 == 10610664)
			{
l006E6084:
				*edi_2408 = fn00705340(edi_2408, dwArg04);
				((word32) edi_2408 + 4)->u0 = 0x00;
				*dwArg08 = &ebx_21->b0001;
				ecxOut = (struct Eq_60079 *) &ebx_21->b0001;
				edxOut = dwArg08;
				return 0x00;
			}
			word32 edx_4020;
			word32 ecx_4019;
			if (fn006D5670(eax_2405, 10610664, out ecx_4019, out edx_4020) != 0x00)
				goto l006E6084;
			Eq_3 eax_2458 = *((word32) dwArg04 + 4);
			if (eax_2458 == 0x00A1F400)
			{
l006E6062:
				Eq_3 edx_2488;
				*edi_2408 = fn00711700(dwArg04, out edx_2488);
				*((word32) edi_2408 + 4) = edx_2488;
				*dwArg08 = &ebx_21->b0001;
				ecxOut = (struct Eq_60079 *) &ebx_21->b0001;
				edxOut = dwArg08;
				return 0x00;
			}
			word32 edx_4022;
			word32 ecx_4021;
			if (fn006D5670(eax_2458, 0x00A1F400, out ecx_4021, out edx_4022) != 0x00)
				goto l006E6062;
			break;
		case 0x4C:
			*eax = (word32) *eax + 4;
			Eq_3 edi_2360 = *eax;
			Eq_3 ebx_2361 = *((word32) edi_2360 - 4);
			Eq_3 edx_2367;
			ui32 eax_2365 = fn007114E0(ebx_2361, edi_2360, dwArg04, out edx_2367);
			if ((eax_2365 & edx_2367) != ~0x00 || fn006E0FC0() == 0x00)
			{
				*((word32) ebx_2361 + 4) = edx_2367;
				*ebx_2361 = eax_2365;
				*dwArg08 = &ebx_21->b0001;
				ecxOut = (struct Eq_60079 *) &ebx_21->b0001;
				edxOut = dwArg08;
				return 0x00;
			}
			break;
		case 0x4F:
			union Eq_3 * esi_2296;
			byte al_2228 = ebx_21->b0001;
			*eax = (word32) *eax + 4;
			if (al_2228 != 33)
			{
				if (al_2228 != 0x3F)
				{
					if (al_2228 != 0x26)
					{
						**((word32) *eax - 4) = dwArg04;
						*dwArg08 = &ebx_21->b0001;
						ecxOut = (struct Eq_60079 *) &ebx_21->b0001;
						edxOut = dwArg08;
						return 0x00;
					}
					else
					{
						Eq_3 eax_2254 = *eax;
						Eq_3 ecx_2255 = *((word32) eax_2254 - 4);
						*eax = (word32) eax_2254 + 4;
						word32 eax_2258 = *eax_2254;
						word32 eax_2267;
						word32 edx_2269;
						ecx_2255();
						dwLoc34_2844 = &ebx_21->b0001 + 1;
						if (eax_2267 == 0x00)
							goto l006E6BD6;
						goto l006E6D6E;
					}
				}
				Eq_3 eax_2292 = *eax;
				Eq_3 ecx_2293 = *((word32) eax_2292 - 4);
				*eax = (word32) eax_2292 + 4;
				word32 eax_2303;
				word32 edx_2305;
				ecx_2293();
				esi_2296 = (union Eq_3 *) *eax_2292;
				if (eax_2303 == 0x00)
					goto l006E6BD6;
l006E6B99:
				*esi_2296 = (union Eq_3 *) dwArg04;
				*dwArg08 = &ebx_21->b0001 + 1;
				ecxOut = &ebx_21->b0001 + 1;
				edxOut = dwArg08;
				return 0x00;
			}
			Eq_3 eax_2313 = *eax;
			Eq_3 ebx_2314 = *((word32) eax_2313 - 4);
			*eax = (word32) eax_2313 + 4;
			esi_2296 = (union Eq_3 *) *eax_2313;
			word32 edx_4011;
			word32 ecx_4010;
			if (fn006D5670(*((word32) dwArg04 + 4), ebx_2314, out ecx_4010, out edx_4011) != 0x00)
				goto l006E6B99;
			break;
		case 0x53:
			*eax = (word32) *eax + 4;
			Eq_3 eax_2188 = *((word32) dwArg04 + 4);
			edi_2168 = *((word32) *eax - 4);
			if (eax_2188 == 0x00A1B450)
				goto l006E6AFF;
			word32 edx_4009;
			word32 ecx_4008;
			if (fn006D5670(eax_2188, 0x00A1B450, out ecx_4008, out edx_4009) != 0x00)
				goto l006E6AFF;
			goto l006E63AE;
		case 0x55:
			*eax = (word32) *eax + 4;
			Eq_3 eax_2165 = *((word32) dwArg04 + 4);
			edi_2168 = *((word32) *eax - 4);
			if (eax_2165 != 0x00A23B20)
			{
				word32 edx_4005;
				word32 ecx_4004;
				if (fn006D5670(eax_2165, 0x00A23B20, out ecx_4004, out edx_4005) == 0x00)
					goto l006E6B39;
			}
l006E6AFF:
			*edi_2168 = dwArg04;
			*dwArg08 = &ebx_21->b0001;
			ecxOut = (struct Eq_60079 *) &ebx_21->b0001;
			edxOut = dwArg08;
			return 0x00;
		case 0x62:
			*eax = (word32) *eax + 4;
			Eq_3 edi_2081 = *((word32) *eax - 4);
			if (fn006E5960(dwArg04) == 0x00)
			{
				word32 edi_4001;
				word32 edx_3999;
				word32 esi_4000;
				word32 ecx_3998;
				Eq_3 eax_2095 = fn007051A0(edi_2081, dwArg04, out ecx_3998, out edx_3999, out esi_4000, out edi_4001);
				byte al_2110 = (byte) eax_2095;
				if (eax_2095 == ~0x00)
				{
					if (fn006E0FC0() != 0x00)
						goto l006E5CC3;
					goto l006E5CE3;
				}
				if (eax_2095 < 0x00)
				{
l006E5CE3:
					word32 edx_4003;
					word32 ecx_4002;
					fn006E0F80(g_tA18598, dwArg04, out ecx_4002, out edx_4003);
				}
				else
				{
					if (eax_2095 <= 0xFF)
					{
						*edi_2081 = al_2110;
						*dwArg08 = &ebx_21->b0001;
						ecxOut = (struct Eq_60079 *) &ebx_21->b0001;
						edxOut = dwArg08;
						return 0x00;
					}
					word32 edx_4007;
					word32 ecx_4006;
					fn006E0F80(g_tA18598, dwArg04, out ecx_4006, out edx_4007);
				}
			}
l006E5CC3:
			break;
		case 99:
			*eax = (word32) *eax + 4;
			Eq_3 eax_2022 = *((word32) dwArg04 + 4);
			Eq_3 edi_2025 = *((word32) *eax - 4);
			if (eax_2022 != 0x00A1B450)
			{
				word32 edx_3997;
				word32 ecx_3996;
				if (fn006D5670(eax_2022, 0x00A1B450, out ecx_3996, out edx_3997) != 0x00)
					goto l006E61B3;
			}
			else
			{
l006E61B3:
				if (fn006ECC00(dwArg04) == 0x01)
				{
					*edi_2025 = *((word32) dwArg04 + 20);
					*dwArg08 = &ebx_21->b0001;
					ecxOut = (struct Eq_60079 *) &ebx_21->b0001;
					edxOut = dwArg08;
					return 0x00;
				}
			}
			break;
		case 100:
			*eax = (word32) *eax + 4;
			Eq_3 edi_1984 = *((word32) *eax - 4);
			real64 rRet0;
			fn006FF3E0(dwArg04, out rRet0);
			if (fn006E0FC0() == 0x00)
			{
				edi_1984->u1 = rRet0;
				*dwArg08 = &ebx_21->b0001;
				ecxOut = (struct Eq_60079 *) &ebx_21->b0001;
				edxOut = dwArg08;
				return 0x00;
			}
			break;
		case 101:
			*eax = (word32) *eax + 4;
			if (*((word32) *eax - 4) == 0x00)
				fn00717C60();
			word32 ecx_1469;
			byte al_1463 = ebx_21->b0001;
			if (al_1463 == 115)
			{
				ecx_1469 = 0x01;
				goto l006E66E9;
			}
			if (al_1463 == 116)
			{
				ecx_1469 = 0x00;
l006E66E9:
				*eax = (word32) *eax + 4;
				dwLoc34_2844 = &ebx_21->b0001 + 1;
				if (*((word32) *eax - 4) != 0x00)
				{
					Eq_3 esi_1553;
					struct Eq_62389 * esp_1549;
					if (ecx_1469 == 0x00)
					{
						Eq_3 eax_1495 = *((word32) dwArg04 + 4);
						if (eax_1495 != 0x00A1B450)
						{
							word32 edx_4014;
							word32 ecx_4013;
							if (fn006D5670(eax_1495, 0x00A1B450, out ecx_4013, out edx_4014) != 0x00)
								goto l006E672A;
							goto l006E6772;
						}
l006E672A:
						*dwArg04 = (word32) *dwArg04 + 1;
						esp_1549 = fp - 0x44;
						esi_1553 = dwArg04;
						goto l006E6730;
					}
l006E6772:
					word32 edx_4012;
					Eq_3 eax_1527 = fn007203E0(dwArg04, out edx_4012);
					if (eax_1527 != 0x00)
					{
						word32 edx_4016;
						word32 ecx_4015;
						Eq_3 eax_1544 = fn0071FB20(eax_1527, dwArg04, dwArg08, out ecx_4015, out edx_4016);
						word32 v65_1550 = (word32) *eax_1527 - 1;
						*eax_1527 = v65_1550;
						esp_1549 = fp - 0x44;
						esi_1553 = eax_1544;
						if (v65_1550 == 0x00)
						{
							Eq_3 eax_1555 = *((word32) eax_1527 + 4);
							word32 esp_1559;
							word32 edx_1562;
							(*((word32) eax_1555 + 24))();
							esp_1549 = esp_1559 + 0x04;
						}
						if (eax_1544 != 0x00)
						{
							Eq_3 eax_1572 = *((word32) eax_1544 + 4);
							if (eax_1572 != 0x00A1B450)
							{
								struct Eq_62716 * esp_1576 = esp_1549 - 4;
								esp_1576->t0000.u0 = 0x00A1B450;
								esp_1576->tFFFFFFFC = eax_1572;
								esp_1549 = (struct Eq_62389 *) ((const char *) &esp_1576->t0000 + 4);
								word32 edx_4018;
								word32 ecx_4017;
								if (fn006D5670(esp_1576->tFFFFFFFC, esp_1576->t0000, out ecx_4017, out edx_4018) != 0x00)
									goto l006E6730;
								word32 v68_1591 = (word32) *eax_1544 - 1;
								*eax_1544 = v68_1591;
								if (v68_1591 == 0x00)
								{
									Eq_3 edx_1595 = *((word32) eax_1544 + 4);
									struct Eq_58241 * eax_1596 = *((word32) edx_1595 + 24);
									esp_1576->t0000 = eax_1544;
									eax_1596();
								}
							}
							else
							{
l006E6730:
								Eq_3 eax_1691;
								byte * ecx_1623 = esp_1549->ptr0010;
								Eq_3 ebx_1626 = *((word32) esi_1553 + 8);
								esp_1549->t0020 = ebx_1626;
								if (*ecx_1623 == 0x23)
								{
									ui32 edx_1750 = esp_1549->dw0050;
									esp_1549->t001C.u0 = 0x00;
									esp_1549->t0014.u0 = 0x00;
									esp_1549->dw0024 = edx_1750 & 0x02;
									Eq_3 eax_1751 = 0x00;
									Eq_3 ecx_1752 = 0x00;
									if ((edx_1750 & 0x02) != 0x00)
									{
										*eax = (word32) *eax + 4;
										ecx_1752 = *((word32) *eax - 4);
										esp_1549->t0014 = ecx_1752;
									}
									else
									{
										*eax = (word32) *eax + 4;
										eax_1751 = *((word32) *eax - 4);
										esp_1549->t001C = eax_1751;
									}
									++esp_1549->ptr0010;
									if (eax_1751 == 0x00 && ecx_1752 == 0x00)
									{
										word32 v64_1961 = (word32) *esi_1553 - 1;
										*esi_1553 = v64_1961;
										if (v64_1961 == 0x00)
										{
											Eq_3 edx_1965 = *((word32) esi_1553 + 4);
											struct Eq_58241 * eax_1966 = *((word32) edx_1965 + 24);
											esp_1549->tFFFFFFFC = esi_1553;
											eax_1966();
										}
									}
									else
									{
										union Eq_3 * edi_1786 = esp_1549->ptr0018;
										if (*edi_1786 == 0x00)
										{
											Eq_3 eax_1834 = (word32) ebx_1626 + 1;
											if (ebx_1626 == 0x01)
												eax_1834.u0 = 0x01;
											struct Eq_62623 * esp_1840 = esp_1549 - 4;
											esp_1840->t0000 = eax_1834;
											Eq_3 eax_1843 = malloc(esp_1840->t0000);
											*edi_1786 = (union Eq_3 *) eax_1843;
											if (eax_1843 == 0x00)
											{
												word32 v67_1943 = (word32) *esi_1553 - 1;
												*esi_1553 = v67_1943;
												if (v67_1943 == 0x00)
												{
													Eq_3 ecx_1947 = *((word32) esi_1553 + 4);
													struct Eq_58241 * edx_1948 = *((word32) ecx_1947 + 24);
													esp_1840->t0000 = esi_1553;
													word32 edx_1955;
													edx_1948();
												}
l006E6861:
											}
											else
											{
												if (fn006E54A0(eax_1843, esp_1840->ptr0060) == 0x00)
												{
l006E68C1:
													Eq_3 edi_1866 = esp_1549->t0020;
													union Eq_3 * edx_1867 = esp_1549->ptr0018;
													struct Eq_62772 * esp_1869 = esp_1549 - 4;
													esp_1869->t0000 = (word32) edi_1866 + 1;
													Eq_3 eax_1871 = *edx_1867;
													esp_1869->tFFFFFFFC = (word32) esi_1553 + 20;
													esp_1869->tFFFFFFF8 = eax_1871;
													eax_1691 = memcpy(esp_1869->tFFFFFFF8, esp_1869->tFFFFFFFC, esp_1869->t0000);
													if (esp_1869->dw0028 != 0x00)
														*esp_1869->ptr0018 = (union Eq_3 *) edi_1866;
													else
														*esp_1869->ptr0020 = (union Eq_3 *) edi_1866;
l006E69B3:
													word32 v72_1888 = (word32) *esi_1553 - 1;
													*esi_1553 = v72_1888;
													if (v72_1888 != 0x00)
														goto l006E6D6E;
													Eq_3 ecx_1892 = *((word32) esi_1553 + 4);
													struct Eq_58241 * edx_1893 = *((word32) ecx_1892 + 24);
													esp_1549->tFFFFFFFC = esi_1553;
													edx_1893();
													*dwArg08 = &ebx_21->b0001 + 1;
													ecxOut = &ebx_21->b0001 + 1;
													edxOut = dwArg08;
													return 0x00;
												}
												word32 v70_1926 = (word32) *esi_1553 - 1;
												*esi_1553 = v70_1926;
												if (v70_1926 == 0x00)
												{
													Eq_3 eax_1930 = *((word32) esi_1553 + 4);
													struct Eq_58241 * ecx_1931 = *((word32) eax_1930 + 24);
													esp_1840->t0000 = esi_1553;
													word32 edx_1937;
													ecx_1931();
												}
l006E688B:
											}
										}
										else
										{
											int32 eax_1795;
											if ((edx_1750 & 0x02) != 0x00)
												eax_1795 = (int32) *ecx_1752;
											else
												eax_1795 = (int32) *eax_1751;
											if ((word32) ebx_1626 + 1 <= eax_1795)
												goto l006E68C1;
											word32 v69_1809 = (word32) *esi_1553 - 1;
											*esi_1553 = v69_1809;
											if (v69_1809 == 0x00)
											{
												Eq_3 edx_1813 = *((word32) esi_1553 + 4);
												struct Eq_58241 * eax_1814 = *((word32) edx_1813 + 24);
												esp_1549->tFFFFFFFC = esi_1553;
												eax_1814();
											}
										}
									}
								}
								else
								{
									byte * eax_1629 = (word32) esi_1553 + 20;
									eax_1631 = eax_1629;
									do
									{
										byte * eax_1631;
										eax_1631 = eax_4025 + 1;
										eax_4025 = eax_1631;
									} while (*eax_4025 != 0x00);
									if (eax_1631 - (eax_1629 + 1) != ebx_1626)
									{
										word32 v71_1733 = (word32) *esi_1553 - 1;
										*esi_1553 = v71_1733;
										if (v71_1733 == 0x00)
										{
											Eq_3 eax_1737 = *((word32) esi_1553 + 4);
											struct Eq_58241 * ecx_1738 = *((word32) eax_1737 + 24);
											esp_1549->tFFFFFFFC = esi_1553;
											word32 edx_1744;
											ecx_1738();
										}
									}
									else
									{
										esp_1549->dw0024 = (word32) ebx_1626 + 1;
										Eq_3 eax_1643 = (word32) ebx_1626 + 1;
										if (ebx_1626 == 0x01)
											eax_1643.u0 = 0x01;
										struct Eq_62937 * esp_1651 = esp_1549 - 4;
										esp_1651->t0000 = eax_1643;
										Eq_3 eax_1654 = malloc(esp_1651->t0000);
										*esp_1651->ptr001C = (union Eq_3 *) eax_1654;
										if (eax_1654 == 0x00)
										{
											word32 v73_1711 = (word32) *esi_1553 - 1;
											*esi_1553 = v73_1711;
											if (v73_1711 != 0x00)
												goto l006E6861;
											Eq_3 eax_1715 = *((word32) esi_1553 + 4);
											struct Eq_58241 * ecx_1716 = *((word32) eax_1715 + 24);
											esp_1651->t0000 = esi_1553;
											word32 edx_1727;
											ecx_1716();
										}
										else
										{
											if (fn006E54A0(eax_1654, esp_1651->ptr0060) == 0x00)
											{
												union Eq_3 * edx_1682 = esp_1651->ptr001C;
												esp_1651->t0000 = esp_1651->t0028;
												esp_1651->tFFFFFFFC = (word32) esi_1553 + 20;
												esp_1651->tFFFFFFF8 = *edx_1682;
												eax_1691 = memcpy(esp_1651->tFFFFFFF8, esp_1651->tFFFFFFFC, esp_1651->t0000);
												goto l006E69B3;
											}
											word32 v74_1694 = (word32) *esi_1553 - 1;
											*esi_1553 = v74_1694;
											if (v74_1694 != 0x00)
												goto l006E688B;
											Eq_3 edx_1698 = *((word32) esi_1553 + 4);
											struct Eq_58241 * eax_1699 = *((word32) edx_1698 + 24);
											esp_1651->t0000 = esi_1553;
											eax_1699();
										}
									}
								}
							}
						}
					}
				}
			}
			break;
		case 0x66:
			*eax = (word32) *eax + 4;
			Eq_3 edi_1415 = *((word32) *eax - 4);
			real64 rRet0;
			fn006FF3E0(dwArg04, out rRet0);
			if (fn006E0FC0() == 0x00)
			{
				*edi_1415 = (real32) rRet0;
				*dwArg08 = &ebx_21->b0001;
				ecxOut = (struct Eq_60079 *) &ebx_21->b0001;
				edxOut = dwArg08;
				return 0x00;
			}
			break;
		case 0x68:
			*eax = (word32) *eax + 4;
			edi_1351 = *((word32) *eax - 4);
			if (fn006E5960(dwArg04) == 0x00)
			{
				word32 edi_3975;
				word32 esi_3974;
				word32 edx_3973;
				word32 ecx_3972;
				Eq_3 eax_1365 = fn007051A0(edi_1351, dwArg04, out ecx_3972, out edx_3973, out esi_3974, out edi_3975);
				si_2595 = (word16) eax_1365;
				if (eax_1365 == ~0x00)
				{
					if (fn006E0FC0() != 0x00)
						goto l006E5DA0;
					goto l006E5DF6;
				}
				if (eax_1365 < ~0x7FFF)
				{
					word32 ecx_3988;
					word32 edx_3989;
					fn006E0F80(g_tA18598, dwArg04, out ecx_3988, out edx_3989);
				}
				else
				{
					if (eax_1365 <= 0x7FFF)
					{
l006E5DF6:
						*edi_1351 = si_2595;
						*dwArg08 = &ebx_21->b0001;
						ecxOut = (struct Eq_60079 *) &ebx_21->b0001;
						edxOut = dwArg08;
						return 0x00;
					}
					word32 edx_3993;
					word32 ecx_3992;
					fn006E0F80(g_tA18598, dwArg04, out ecx_3992, out edx_3993);
				}
			}
			else
			{
l006E5DA0:
			}
			break;
		case 0x69:
			*eax = (word32) *eax + 4;
			edi_1147 = *((word32) *eax - 4);
			if (fn006E5960(dwArg04) == 0x00)
			{
				word32 edi_3971;
				word32 esi_3970;
				word32 edx_3969;
				word32 ecx_3968;
				Eq_3 eax_1301 = fn007051A0(edi_1147, dwArg04, out ecx_3968, out edx_3969, out esi_3970, out edi_3971);
				esi_1171 = eax_1301;
				if (eax_1301 == ~0x00)
				{
					if (fn006E0FC0() == 0x00)
						goto l006E5EC4;
					goto l006E5E6F;
				}
				if (eax_1301 > 0x7FFFFFFF)
				{
					word32 edx_3991;
					word32 ecx_3990;
					fn006E0F80(g_tA18598, dwArg04, out ecx_3990, out edx_3991);
				}
				else
				{
					if (eax_1301 >= 0x80000000)
						goto l006E5EC4;
					word32 edx_3995;
					word32 ecx_3994;
					fn006E0F80(g_tA18598, dwArg04, out ecx_3994, out edx_3995);
				}
			}
			else
			{
l006E5E6F:
			}
			break;
		case 0x6B:
			*eax = (word32) *eax + 4;
			Eq_3 eax_1182 = *((word32) dwArg04 + 4);
			Eq_3 edi_1185 = *((word32) *eax - 4);
			if (eax_1182 == 10610664)
			{
l006E5FAF:
				*edi_1185 = fn00705340(edi_1185, dwArg04);
				*dwArg08 = &ebx_21->b0001;
				ecxOut = (struct Eq_60079 *) &ebx_21->b0001;
				edxOut = dwArg08;
				return 0x00;
			}
			word32 edx_3965;
			word32 ecx_3964;
			if (fn006D5670(eax_1182, 10610664, out ecx_3964, out edx_3965) != 0x00)
				goto l006E5FAF;
			Eq_3 eax_1233 = *((word32) dwArg04 + 4);
			if (eax_1233 == 0x00A1F400)
			{
l006E5F90:
				*edi_1185 = fn00710B80(dwArg04);
				*dwArg08 = &ebx_21->b0001;
				ecxOut = (struct Eq_60079 *) &ebx_21->b0001;
				edxOut = dwArg08;
				return 0x00;
			}
			word32 edx_3967;
			word32 ecx_3966;
			if (fn006D5670(eax_1233, 0x00A1F400, out ecx_3966, out edx_3967) != 0x00)
				goto l006E5F90;
			break;
		case 0x6C:
		case 110:
			*eax = (word32) *eax + 4;
			edi_1147 = *((word32) *eax - 4);
			if (fn006E5960(dwArg04) == 0x00)
			{
				word32 edi_3963;
				word32 esi_3962;
				word32 edx_3961;
				word32 ecx_3960;
				Eq_3 eax_1166 = fn007051A0(edi_1147, dwArg04, out ecx_3960, out edx_3961, out esi_3962, out edi_3963);
				esi_1171 = eax_1166;
				if (eax_1166 != ~0x00 || fn006E0FC0() == 0x00)
				{
l006E5EC4:
					*edi_1147 = esi_1171;
					*dwArg08 = &ebx_21->b0001;
					ecxOut = (struct Eq_60079 *) &ebx_21->b0001;
					edxOut = dwArg08;
					return 0x00;
				}
			}
			break;
		case 115:
			if (ebx_21->b0001 == 0x23)
			{
				*eax = (word32) *eax + 4;
				Eq_3 eax_913 = *eax;
				Eq_3 ebx_914 = *((word32) eax_913 - 4);
				*eax = (word32) eax_913 + 4;
				union Eq_3 * dwLoc30_2964 = null;
				union Eq_3 * dwLoc2C_2965 = null;
				if ((dwArg0C & 0x02) != 0x00)
					dwLoc2C_2965 = (union Eq_3 *) *eax_913;
				else
					dwLoc30_2964 = (union Eq_3 *) *eax_913;
				Eq_3 eax_931 = *((word32) dwArg04 + 4);
				if (eax_931 != 0x00A1B450)
				{
					word32 edx_3983;
					word32 ecx_3982;
					if (fn006D5670(eax_931, 0x00A1B450, out ecx_3982, out edx_3983) == 0x00)
					{
						Eq_3 eax_999 = *((word32) dwArg04 + 4);
						if (eax_999 != 0x00A23B20)
						{
							word32 edx_3987;
							word32 ecx_3986;
							if (fn006D5670(eax_999, 0x00A23B20, out ecx_3986, out edx_3987) == 0x00)
							{
								Eq_3 eax_1088 = fn006E59A0(fp - 0x28, dwArg04, ebx_914);
								if (eax_1088 < 0x00)
									goto l006E6270;
								if ((dwArg0C & 0x02) == 0x00)
								{
									*dwLoc30_2964 = (union Eq_3 *) eax_1088;
									*dwArg08 = &ebx_21->b0001 + 1;
									ecxOut = &ebx_21->b0001 + 1;
									edxOut = dwArg08;
									return 0x00;
								}
								else
								{
									*dwLoc2C_2965 = (union Eq_3 *) eax_1088;
									*dwArg08 = &ebx_21->b0001 + 1;
									ecxOut = &ebx_21->b0001 + 1;
									edxOut = dwArg08;
									return 0x00;
								}
							}
						}
						word32 edx_3985;
						word32 ecx_3984;
						Eq_3 eax_1031 = fn0071FC50(dwArg04, 0x00, out ecx_3984, out edx_3985);
						if (eax_1031 == 0x00)
							goto l006E62CA;
						*ebx_914 = (word32) eax_1031 + 20;
						if ((dwArg0C & 0x02) == 0x00)
						{
							*dwLoc30_2964 = (union Eq_3 *) *((word32) eax_1031 + 8);
							*dwArg08 = &ebx_21->b0001 + 1;
							ecxOut = &ebx_21->b0001 + 1;
							edxOut = dwArg08;
							return 0x00;
						}
						else
						{
							*dwLoc2C_2965 = (union Eq_3 *) *((word32) eax_1031 + 8);
							*dwArg08 = &ebx_21->b0001 + 1;
							ecxOut = &ebx_21->b0001 + 1;
							edxOut = dwArg08;
							return 0x00;
						}
					}
				}
				*ebx_914 = (word32) dwArg04 + 20;
				if ((dwArg0C & 0x02) == 0x00)
				{
					*dwLoc30_2964 = (union Eq_3 *) *((word32) dwArg04 + 8);
					*dwArg08 = &ebx_21->b0001 + 1;
					ecxOut = &ebx_21->b0001 + 1;
					edxOut = dwArg08;
					return 0x00;
				}
				else
				{
					*dwLoc2C_2965 = (union Eq_3 *) *((word32) dwArg04 + 8);
					*dwArg08 = &ebx_21->b0001 + 1;
					ecxOut = &ebx_21->b0001 + 1;
					edxOut = dwArg08;
					return 0x00;
				}
			}
			byte * eax_829;
			*eax = (word32) *eax + 4;
			Eq_3 eax_808 = *((word32) dwArg04 + 4);
			Eq_3 edi_811 = *((word32) *eax - 4);
			if (eax_808 == 0x00A1B450)
			{
l006E63D0:
				eax_829 = (word32) dwArg04 + 20;
				goto l006E63D3;
			}
			word32 ecx_3976;
			word32 edx_3977;
			if (fn006D5670(eax_808, 0x00A1B450, out ecx_3976, out edx_3977) != 0x00)
				goto l006E63D0;
			Eq_3 eax_830 = *((word32) dwArg04 + 4);
			if (eax_830 != 0x00A23B20)
			{
				word32 edx_3981;
				word32 ecx_3980;
				if (fn006D5670(eax_830, 0x00A23B20, out ecx_3980, out edx_3981) != 0x00)
					goto l006E63B8;
l006E63AE:
			}
			else
			{
l006E63B8:
				word32 edx_3979;
				word32 ecx_3978;
				Eq_3 eax_860 = fn0071FC50(dwArg04, 0x00, out ecx_3978, out edx_3979);
				if (eax_860 == 0x00)
					goto l006E62CA;
				eax_829 = (word32) eax_860 + 20;
l006E63D3:
				*edi_811 = eax_829;
				Eq_62159 edx_875 = eax_829 + 1;
				do
				{
					eax_829 = eax_4024 + 1;
					eax_4024 = eax_829;
				} while (*eax_4024 != 0x00);
				if (eax_829 - edx_875 == fn006ECC00(dwArg04))
					goto l006E6D6E;
			}
			break;
		case 116:
			*eax = (word32) *eax + 4;
			Eq_3 eax_714 = *((word32) dwArg04 + 4);
			struct Eq_60439 * esi_715 = *((word32) eax_714 + 80);
			dwLoc34_2844 = &ebx_21->b0001 + 1;
			if (ebx_21->b0001 == 0x23)
			{
				if ((*((word32) eax_714 + 84) & 0x01) != 0x00 && (esi_715 != null && esi_715->ptr000C != null))
				{
					<anonymous> * eax_729 = esi_715->ptr0008;
					if (eax_729 == null)
						goto l006E6D82;
					struct Eq_61631 * esp_738;
					word32 eax_739;
					word32 edx_741;
					eax_729();
					if (eax_739 == 0x01)
					{
						word32 edx_747 = esp_738->dw002C;
						<anonymous> * eax_748 = esi_715->ptr000C;
						esp_738->dw0004 = edx_747;
						esp_738->dw0000 = 0x00;
						esp_738->tFFFFFFFC = dwArg04;
						int32 eax_756;
						eax_748();
						if (eax_756 < 0x00)
							goto l006E6BD6;
						*eax = (word32) *eax + 4;
						Eq_3 edi_768 = *eax;
						Eq_3 ecx_769 = 0x00;
						Eq_3 edx_770 = 0x00;
						if ((dwArg0C & 0x02) != 0x00)
							edx_770 = *((word32) edi_768 - 4);
						else
							ecx_769 = *((word32) edi_768 - 4);
						if ((dwArg0C & 0x02) == 0x00)
						{
							*ecx_769 = eax_756;
							goto l006E6D6E;
						}
						else
						{
							*edx_770 = eax_756;
							*dwArg08 = &ebx_21->b0001 + 1;
							ecxOut = &ebx_21->b0001 + 1;
							edxOut = dwArg08;
							return 0x00;
						}
					}
				}
				else
				{
l006E6D82:
				}
			}
			break;
		case 117:
			if (ebx_21->b0001 == 0x23)
			{
				*eax = (word32) *eax + 4;
				Eq_3 eax_619 = *eax;
				Eq_3 ecx_620 = *((word32) eax_619 - 4);
				*eax = (word32) eax_619 + 4;
				union Eq_3 * dwLoc2C_2918 = null;
				union Eq_3 * dwLoc28_2919 = null;
				if ((dwArg0C & 0x02) != 0x00)
					dwLoc28_2919 = (union Eq_3 *) *eax_619;
				else
					dwLoc2C_2918 = (union Eq_3 *) *eax_619;
				Eq_3 eax_638 = *((word32) dwArg04 + 4);
				if (eax_638 == 0x00A23B20)
				{
l006E6A49:
					*ecx_620 = *((word32) dwArg04 + 0x0C);
					if ((dwArg0C & 0x02) == 0x00)
					{
						*dwLoc2C_2918 = (union Eq_3 *) *((word32) dwArg04 + 8);
						*dwArg08 = &ebx_21->b0001 + 1;
						ecxOut = &ebx_21->b0001 + 1;
						edxOut = dwArg08;
						return 0x00;
					}
					else
					{
						*dwLoc28_2919 = (union Eq_3 *) *((word32) dwArg04 + 8);
						*dwArg08 = &ebx_21->b0001 + 1;
						ecxOut = &ebx_21->b0001 + 1;
						edxOut = dwArg08;
						return 0x00;
					}
				}
				word32 edx_3957;
				word32 ecx_3956;
				if (fn006D5670(eax_638, 0x00A23B20, out ecx_3956, out edx_3957) != 0x00)
					goto l006E6A49;
			}
			else
			{
				*eax = (word32) *eax + 4;
				Eq_3 eax_577 = *((word32) dwArg04 + 4);
				Eq_3 edi_580 = *((word32) *eax - 4);
				if (eax_577 == 0x00A23B20)
				{
l006E6ABE:
					*edi_580 = *((word32) dwArg04 + 0x0C);
					*dwArg08 = &ebx_21->b0001;
					ecxOut = (struct Eq_60079 *) &ebx_21->b0001;
					edxOut = dwArg08;
					return 0x00;
				}
				word32 edx_3959;
				word32 ecx_3958;
				if (fn006D5670(eax_577, 0x00A23B20, out ecx_3958, out edx_3959) != 0x00)
					goto l006E6ABE;
l006E6B39:
			}
			break;
		case 0x77:
			*eax = (word32) *eax + 4;
			struct Eq_60439 * esi_470 = *((word32) *((word32) dwArg04 + 4) + 80);
			if (esi_470 != null && esi_470->ptr0004 != null)
			{
				<anonymous> * eax_478 = esi_470->ptr0008;
				if (eax_478 == null)
					goto l006E6CB2;
				struct Eq_61504 * esp_487;
				word32 eax_488;
				word32 edx_490;
				eax_478();
				if (eax_488 == 0x01)
				{
					word32 eax_496 = esp_487->dw002C;
					<anonymous> * ecx_497 = esi_470->ptr0004;
					esp_487->dw0004 = eax_496;
					esp_487->dw0000 = 0x00;
					esp_487->tFFFFFFFC = dwArg04;
					int32 eax_505;
					word32 edx_507;
					ecx_497();
					if (eax_505 >= 0x00)
					{
						if (ebx_21->b0001 != 0x23)
							goto l006E6D6E;
						*eax = (word32) *eax + 4;
						Eq_3 edi_519 = *eax;
						Eq_3 ecx_520 = 0x00;
						Eq_3 edx_521 = 0x00;
						if ((dwArg0C & 0x02) != 0x00)
							edx_521 = *((word32) edi_519 - 4);
						else
							ecx_520 = *((word32) edi_519 - 4);
						if ((dwArg0C & 0x02) == 0x00)
						{
							*ecx_520 = eax_505;
							*dwArg08 = &ebx_21->b0001 + 1;
							ecxOut = &ebx_21->b0001 + 1;
							edxOut = dwArg08;
							return 0x00;
						}
						else
						{
							*edx_521 = eax_505;
							*dwArg08 = &ebx_21->b0001 + 1;
							ecxOut = &ebx_21->b0001 + 1;
							edxOut = dwArg08;
							return 0x00;
						}
					}
l006E6BD6:
				}
			}
			else
			{
l006E6CB2:
			}
			break;
		case 122:
			if (ebx_21->b0001 == 0x23)
			{
				*eax = (word32) *eax + 4;
				Eq_3 eax_215 = *eax;
				Eq_3 ebx_216 = *((word32) eax_215 - 4);
				*eax = (word32) eax_215 + 4;
				Eq_3 ecx_218 = 0x00;
				union Eq_3 * dwLoc2C_2862 = null;
				union Eq_3 * dwLoc30_2863 = null;
				if ((dwArg0C & 0x02) != 0x00)
					dwLoc30_2863 = (union Eq_3 *) *eax_215;
				else
					dwLoc2C_2862 = (union Eq_3 *) *eax_215;
				if (dwArg04 == 0x00A163B8)
				{
					*ebx_216 = 0x00;
					if ((dwArg0C & 0x02) == 0x00)
					{
						*dwLoc2C_2862 = (union Eq_3 *) 0x00;
						*dwArg08 = &ebx_21->b0001 + 1;
						ecxOut = &ebx_21->b0001 + 1;
						edxOut = dwArg08;
						return 0x00;
					}
					goto l006E656F;
				}
				Eq_3 eax_235 = *((word32) dwArg04 + 4);
				if (eax_235 == 0x00A1B450)
				{
l006E6563:
					*ebx_216 = (word32) dwArg04 + 20;
					if ((dwArg0C & 0x02) == 0x00)
					{
						*dwLoc2C_2862 = (union Eq_3 *) *((word32) dwArg04 + 8);
						*dwArg08 = &ebx_21->b0001 + 1;
						ecxOut = &ebx_21->b0001 + 1;
						edxOut = dwArg08;
						return 0x00;
					}
					ecx_218 = *((word32) dwArg04 + 8);
l006E656F:
					*dwLoc30_2863 = (union Eq_3 *) ecx_218;
					*dwArg08 = &ebx_21->b0001 + 1;
					ecxOut = &ebx_21->b0001 + 1;
					edxOut = dwArg08;
					return 0x00;
				}
				word32 edx_3951;
				word32 ecx_3950;
				if (fn006D5670(eax_235, 0x00A1B450, out ecx_3950, out edx_3951) != 0x00)
					goto l006E6563;
				Eq_3 eax_285 = *((word32) dwArg04 + 4);
				if (eax_285 == 0x00A23B20)
				{
l006E6503:
					word32 edx_3953;
					word32 ecx_3952;
					Eq_3 eax_317 = fn0071FC50(dwArg04, 0x00, out ecx_3952, out edx_3953);
					if (eax_317 != 0x00)
					{
						*ebx_216 = (word32) eax_317 + 20;
						if ((dwArg0C & 0x02) == 0x00)
						{
							*dwLoc2C_2862 = (union Eq_3 *) *((word32) eax_317 + 8);
							*dwArg08 = &ebx_21->b0001 + 1;
							ecxOut = &ebx_21->b0001 + 1;
							edxOut = dwArg08;
							return 0x00;
						}
						else
						{
							*dwLoc30_2863 = (union Eq_3 *) *((word32) eax_317 + 8);
							*dwArg08 = &ebx_21->b0001 + 1;
							ecxOut = &ebx_21->b0001 + 1;
							edxOut = dwArg08;
							return 0x00;
						}
					}
					goto l006E62CA;
				}
				word32 edx_3955;
				word32 ecx_3954;
				if (fn006D5670(eax_285, 0x00A23B20, out ecx_3954, out edx_3955) != 0x00)
					goto l006E6503;
				Eq_3 eax_373 = fn006E59A0(fp - 0x28, dwArg04, ebx_216);
				if (eax_373 >= 0x00)
				{
					if ((dwArg0C & 0x02) == 0x00)
					{
						*dwLoc2C_2862 = (union Eq_3 *) eax_373;
						*dwArg08 = &ebx_21->b0001 + 1;
						ecxOut = &ebx_21->b0001 + 1;
						edxOut = dwArg08;
						return 0x00;
					}
					else
					{
						*dwLoc30_2863 = (union Eq_3 *) eax_373;
						*dwArg08 = &ebx_21->b0001 + 1;
						ecxOut = &ebx_21->b0001 + 1;
						edxOut = dwArg08;
						return 0x00;
					}
				}
l006E6270:
			}
			else
			{
				*eax = (word32) *eax + 4;
				Eq_3 esi_36 = *((word32) *eax - 4);
				if (dwArg04 == 0x00A163B8)
				{
					*esi_36 = null;
					goto l006E6629;
				}
				Eq_3 eax_38 = *((word32) dwArg04 + 4);
				if (eax_38 == 0x00A1B450)
				{
l006E6624:
					*esi_36 = (word32) dwArg04 + 20;
					goto l006E6629;
				}
				word32 edx_3945;
				word32 ecx_3944;
				if (fn006D5670(eax_38, 0x00A1B450, out ecx_3944, out edx_3945) != 0x00)
					goto l006E6624;
				Eq_3 eax_60 = *((word32) dwArg04 + 4);
				if (eax_60 != 0x00A23B20)
				{
					word32 edx_3949;
					word32 ecx_3948;
					if (fn006D5670(eax_60, 0x00A23B20, out ecx_3948, out edx_3949) != 0x00)
						goto l006E660A;
				}
				else
				{
l006E660A:
					word32 edx_3947;
					word32 ecx_3946;
					Eq_3 eax_90 = fn0071FC50(dwArg04, 0x00, out ecx_3946, out edx_3947);
					if (eax_90 != 0x00)
					{
						*esi_36 = (word32) eax_90 + 20;
l006E6629:
						if (ebx_21->b0001 == 0x23)
						{
							*eax = (word32) *eax + 4;
							Eq_3 esi_152 = 0x00;
							if ((bArg0C_3394 & 0x02) == 0x00)
								esi_152 = *((word32) *eax - 4);
							if (dwArg04 != 0x00A163B8)
							{
								*esi_152 = fn006ECC00(dwArg04);
								*dwArg08 = &ebx_21->b0001 + 1;
								ecxOut = &ebx_21->b0001 + 1;
								edxOut = dwArg08;
								return 0x00;
							}
							else
							{
								esi_152->u0 = 0x00;
								*dwArg08 = &ebx_21->b0001 + 1;
								ecxOut = &ebx_21->b0001 + 1;
								edxOut = dwArg08;
								return 0x00;
							}
						}
						byte * eax_110 = *esi_36;
						if (eax_110 == null)
						{
l006E6D6E:
							*dwArg08 = dwLoc34_2844;
							ecxOut = dwLoc34_2844;
							edxOut = dwArg08;
							return 0x00;
						}
						eax_115 = eax_110;
						do
						{
							byte * eax_115;
							eax_115 = eax_4023 + 1;
							eax_4023 = eax_115;
						} while (*eax_4023 != 0x00);
						if (eax_115 - (eax_110 + 1) == fn006ECC00(dwArg04))
							goto l006E6D6E;
					}
					else
					{
l006E62CA:
					}
				}
			}
			break;
		}
		struct Eq_60079 * ecx_2823;
		Eq_3 eax_2822 = fn006E5920(dwArg04, dwArg14, dwArg10, out ecx_2823);
		ecxOut = ecx_2823;
		edxOut = dwArg14;
		return eax_2822;
	}
}

// 006E6E70: Register word32 fn006E6E70(Stack Eq_3 dwArg08, Stack Eq_3 dwArg14, Register out (ptr32 byte) ecxOut, Register out Eq_3 edxOut)
// Called from:
//      fn006E5710
//      fn006E7660
word32 fn006E6E70(Eq_3 dwArg08, Eq_3 dwArg14, byte & ecxOut, union Eq_3 & edxOut)
{
	Eq_3 edx_132;
	byte * ecx_130;
	word32 eax_127;
	byte * eax_8 = *dwArg08;
	byte * dwArg08_159 = eax_8;
	if (*eax_8 == 0x28)
	{
		eax_127 = fn006E5710(dwArg04, fp + 0x08, dwArg14, dwArg18, dwArg1C, 0x00, out ecx_130, out edx_132);
		if (eax_127 != 0x00)
			goto l006E6EC8;
		dwArg08_159 = eax_8 + 2;
	}
	else
	{
		byte * ecx_33;
		eax_127 = fn006E5C60(dwArg0C, dwArg04, fp + 0x08, dwArg10, dwArg18, dwArg1C, out ecx_33, out edx_132);
		if (eax_127 != 0x00)
		{
			*dwArg14 = 0x00;
			ecxOut = ecx_33;
			edxOut = dwArg14;
			return eax_127;
		}
	}
	*dwArg08 = dwArg08_159;
	ecx_130 = dwArg08_159;
l006E6EC8:
	ecxOut = ecx_130;
	edxOut = edx_132;
	return eax_127;
}

// 006E7660: Register word32 fn006E7660(Register Eq_3 ecx, Register Eq_3 edx, Register Eq_3 ebx, Register Eq_3 ebp, Register Eq_3 esi, Register Eq_3 edi, Register (ptr16 Eq_7) es, Register (ptr16 Eq_8) ds, Stack Eq_3 dwArg04, Stack ui32 dwArg08, Register out ptr32 ecxOut, Register out Eq_3 edxOut)
// Called from:
//      fn006E7C80
//      fn006E7CB0
word32 fn006E7660(Eq_3 ecx, Eq_3 edx, Eq_3 ebx, Eq_3 ebp, Eq_3 esi, Eq_3 edi, struct Eq_7 * es, struct Eq_8 * ds, Eq_3 dwArg04, ui32 dwArg08, ptr32 & ecxOut, union Eq_3 & edxOut)
{
	ui32 eax_7 = g_tA14188 ^ fp - 424;
	int32 ebx_16 = 0x00;
	Eq_3 edi_24 = dwArg04;
	Eq_3 ebp_177 = dwArg08 & 0x01;
	Eq_3 dwLoc01A0_879 = 0x00;
	Eq_3 dwLoc019C_880 = 0x00;
	Eq_3 dwLoc0190_881 = ~0x00;
	Eq_3 dwLoc01A8_1048 = 0x00;
l006E76C0:
	while (true)
	{
		Eq_3 esi_287 = (int32) *edi_24;
		edi_24 = (word32) edi_24 + 1;
		if (esi_287 <= 0x3B)
			break;
l006E7712:
		if (ebx_16 == 0x00)
		{
			if (esi_287 == 0x4F)
				dwLoc01A8_1048 = (word32) dwLoc01A8_1048 + 1;
			else
			{
				edx = esi_287 & 0xFF;
				if (isalpha(esi_287 & 0xFF) != 0x00)
				{
					if (esi_287 != 101)
						dwLoc01A8_1048 = (word32) dwLoc01A8_1048 + 1;
				}
				else if (esi_287 == 0x7C)
					dwLoc0190_881 = dwLoc01A8_1048;
			}
		}
	}
	switch (esi_287)
	{
	case 0x00:
		break;
	case 0x01:
	case 0x02:
	case 0x03:
	case 0x04:
	case 0x05:
	case 0x06:
	case 0x07:
	case 0x08:
	case 0x09:
	case 0x0A:
	case 11:
	case 0x0C:
	case 0x0D:
	case 0x0E:
	case 0x0F:
	case 0x10:
	case 0x11:
	case 0x12:
	case 0x13:
	case 0x14:
	case 0x15:
	case 22:
	case 0x17:
	case 0x18:
	case 0x19:
	case 0x1A:
	case 0x1B:
	case 0x1C:
	case 0x1D:
	case 0x1E:
	case 0x1F:
	case 0x20:
	case 33:
	case 0x22:
	case 0x23:
	case 0x24:
	case 0x25:
	case 0x26:
	case 0x27:
	case 0x2A:
	case 0x2B:
	case 44:
	case 0x2D:
	case 0x2E:
	case 0x2F:
	case 0x30:
	case 0x31:
	case 0x32:
	case 0x33:
	case 0x34:
	case 0x35:
	case 0x36:
	case 55:
	case 0x38:
	case 0x39:
		goto l006E7712;
	case 0x28:
		if (ebx_16 == 0x00)
			dwLoc01A8_1048 = (word32) dwLoc01A8_1048 + 1;
		++ebx_16;
		if (ebx_16 >= 0x1E)
			fn006E86F0(0x008D3EA0);
		goto l006E76C0;
	case 0x29:
		if (ebx_16 == 0x00)
			fn006E86F0(0x008D3E80);
		else
			--ebx_16;
		goto l006E76C0;
	case 0x3A:
		dwLoc01A0_879 = edi_24;
		break;
	case 0x3B:
		dwLoc019C_880 = edi_24;
		break;
	}
	if (ebx_16 != 0x00)
		fn006E86F0(9256544);
	Eq_3 ecx_135 = dwLoc0190_881;
	if (dwLoc0190_881 < 0x00)
	{
		ecx_135 = dwLoc01A8_1048;
		dwLoc0190_881 = dwLoc01A8_1048;
	}
	Eq_3 eax_407;
	Eq_3 ecx_155;
	Eq_3 ebx_348;
	Eq_3 ebx_152 = dwArg04;
	Eq_3 dwLoc0198_1056 = dwArg04;
	if ((dwArg08 & 0x01) != 0x00)
	{
		byte * dwLoc01C4_1031;
		if (dwLoc01A8_1048 == 0x00)
		{
			if (ecx != dwLoc01A8_1048)
			{
				dwLoc01C4_1031 = &g_b8D3E44;
				goto l006E77C0;
			}
			goto l006E788B;
		}
		if (ecx_135 == 0x01 && dwLoc01A8_1048 == ecx_135)
		{
			if (ecx == 0x00)
			{
				if (dwLoc01A0_879 == 0x00)
					dwLoc01C4_1031 = &g_b8D3E1C;
				else
					dwLoc01C4_1031 = &g_b8D3E1C;
l006E77C0:
				fn00724FE0(fp - 0x0104, 0x0100, dwLoc01C4_1031);
				word32 ecx_1272;
				fn006E0F80(g_tA16B7C, fp - 0x0104, out ecx_1272, out edx);
l006E7A89:
				eax_407.u0 = 0x00;
				goto l006E7A8B;
			}
			if (fn006E6E70(fp - 0x0198, fp - 388, out ecx_155, out edx) == 0x00)
				goto l006E786F;
			edx = dwLoc0184;
			ebx_348 = fp - 0x0180;
l006E78A4:
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg4 = <invalid>;
			fn006E5590(dwLoc019C_880, edx, ebx_348, ebp_177, esi_287, edi_24, es, ds, stackArg4, dwArg08 & ~0x01);
			eax_407 = fn006E5530(null, 0x00, out edx);
			goto l006E7A8B;
		}
	}
	else
	{
		ecx_155 = ecx;
		Eq_3 eax_156 = *((word32) ecx + 4);
		if (eax_156 == 0x00A16588 || fn006D5670(eax_156, 0x00A16588, out ecx_155, out edx) != 0x00)
		{
			ebp_177 = *((word32) ecx + 8);
			if (ebp_177 >= dwLoc0190_881 && dwLoc01A8_1048 >= ebp_177)
			{
				edi_24.u0 = 0x00;
				if (ebp_177 > 0x00)
				{
					esi_287 = (word32) ecx + 0x0C;
					do
					{
						if (*ebx_152 == 0x7C)
							dwLoc0198_1056 = (word32) ebx_152 + 1;
						edi_24 = (word64) edi_24.u0 + 1;
						if (fn006E6E70(dwArg04, fp - 388, out ecx_155, out edx) != 0x00)
						{
							ebx_348 = fp - 388;
							goto l006E78A4;
						}
						ebx_152 = dwLoc0198_1056;
						esi_287 = (word32) esi_287 + 4;
					} while (edi_24 < ebp_177);
				}
				byte al_356 = *ebx_152;
				if (al_356 == 0x00)
					goto l006E786F;
				edx = (word32) al_356;
				if (isalpha(edx) != 0x00)
					goto l006E786F;
				byte al_369 = *ebx_152;
				if (al_369 == 0x28 || (al_369 == 0x7C || (al_369 == 0x3A || al_369 == 0x3B)))
				{
l006E786F:
					if (false)
					{
						null = (<anonymous> ***) ((const char *) null - 1);
						if (null == null)
						{
							struct Eq_1218 * edx_573 = *(struct Eq_1218 **) 0x04;
							edx_573->ptr0018();
						}
					}
l006E788B:
					eax_407.u0 = 0x01;
					goto l006E7A8B;
				}
				word32 ecx_1273;
				word32 edx_1274;
				fn006E15D0(g_tA18720, dwArg04, out ecx_1273, out edx_1274);
				eax_407 = fn006E5530(null, 0x00, out edx);
l006E7A8B:
				ptr32 ecx_858;
				word32 eax_857 = fn00694B8E(eax_407, eax_7 ^ fp - 424, edx, ebx, ebp, esi, edi, es, ds, ebx, out ecx_858);
				ecxOut = ecx_858;
				edxOut = edx;
				return eax_857;
			}
			if (dwLoc019C_880 == 0x00)
			{
				Eq_3 ecx_190 = dwLoc0190_881;
				if (ebp_177 >= dwLoc0190_881)
					ecx_190 = dwLoc01A8_1048;
				fn00724FE0(fp - 0x0104, 0x0100, &g_b8D3D70);
			}
		}
	}
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_3 stackArg4 = <invalid>;
	Eq_3 stackArg8 = <invalid>;
	word32 ecx_1271;
	fn006E0F80(stackArg4, stackArg8, out ecx_1271, out edx);
	goto l006E7A89;
}

// 006E7C80: Register word32 fn006E7C80(Register Eq_3 ebx, Register Eq_3 ebp, Register Eq_3 esi, Register Eq_3 edi, Register (ptr16 Eq_7) es, Register (ptr16 Eq_8) ds, Stack Eq_3 dwArg04, Stack Eq_3 dwArg08)
// Called from:
//      fn006E7D90
word32 fn006E7C80(Eq_3 ebx, Eq_3 ebp, Eq_3 esi, Eq_3 edi, struct Eq_7 * es, struct Eq_8 * ds, Eq_3 dwArg04, Eq_3 dwArg08)
{
	word32 ecx_51;
	word32 edx_52;
	return fn006E7660(dwArg04, fp - 0x04, ebx, ebp, esi, edi, es, ds, dwArg08, 0x00, out ecx_51, out edx_52);
}

// 006E7CB0: Register word32 fn006E7CB0(Register out ptr32 ecxOut, Register out ptr32 edxOut)
// Called from:
//      fn00717CB0
//      fn00719F20
word32 fn006E7CB0(ptr32 & ecxOut, ptr32 & edxOut)
{
	ptr32 ecx_17;
	ptr32 edx_19;
	word32 eax_18 = fn006E7660(dwArg04, fp - 0x04, ebx, ebp, esi, edi, es, ds, dwArg08, 0x02, out ecx_17, out edx_19);
	ecxOut = ecx_17;
	edxOut = edx_19;
	return eax_18;
}

// 006E7CE0: Register Eq_3 fn006E7CE0()
// Called from:
//      fn006E1970
Eq_3 fn006E7CE0()
{
	Eq_3 eax_5 = g_tA6C620;
	if (eax_5 == 0x00)
	{
		fn006E1130(fp - 0x04, fp - 0x08, fp - 0x0C);
		word32 edx_111;
		word32 ecx_110;
		Eq_3 eax_29 = fn00715DD0(out ecx_110, out edx_111);
		if (eax_29 != 0x00)
		{
			word32 ecx_114;
			word32 edx_115;
			word32 esi_116;
			word32 edi_117;
			Eq_3 eax_43 = fn006FD8B0(eax_29, 9248824, out ecx_114, out edx_115, out esi_116, out edi_117);
			g_tA6C620 = eax_43;
			if (eax_43 != 0x00)
				*eax_43 = (word32) *eax_43 + 1;
		}
		word32 ecx_112;
		word32 edx_113;
		fn006E0E00(dwLoc0C, out ecx_112, out edx_113);
		eax_5 = g_tA6C620;
	}
	return eax_5;
}

// 006E7D90: Register Eq_3 fn006E7D90(Register Eq_3 eax, Register Eq_3 ecx, Register Eq_3 edi, Register (ptr16 Eq_7) es, Register (ptr16 Eq_8) ds, Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Stack Eq_3 dwArg0C)
// Called from:
//      fn006E8060
Eq_3 fn006E7D90(Eq_3 eax, Eq_3 ecx, Eq_3 edi, struct Eq_7 * es, struct Eq_8 * ds, Eq_3 dwArg04, Eq_3 dwArg08, Eq_3 dwArg0C)
{
	Eq_3 eax_14 = *((word32) edi + 4);
	if (eax_14 == 0x00A16588)
		return fn006E7C80(eax, dwArg04, ecx, edi, es, ds, edi, 0x008D3EEC);
	word32 ecx_663;
	word32 edx_664;
	if (fn006D5670(eax_14, 0x00A16588, out ecx_663, out edx_664) != 0x00)
		return fn006E7C80(eax, dwArg04, ecx, edi, es, ds, edi, 0x008D3EEC);
	Eq_3 edi_98;
	word32 edx_665;
	Eq_3 eax_96 = fn006DF760(edi, 0x008D2084, out edx_665, out edi_98);
	if (eax_96 == 0x00)
		return 0x00;
	*ecx = eax_96;
	Eq_3 edi_115;
	word32 edx_666;
	Eq_3 eax_113 = fn006DF760(edi_98, 0x008D2088, out edx_666, out edi_115);
	Eq_3 esi_121 = eax_113;
	if (eax_113 == 0x00)
		return 0x00;
	struct Eq_63622 * esp_138;
	if (eax_113 == 0x00A163B8)
		eax->u0 = 0x00;
	else
	{
		word32 ecx_667;
		word32 edx_668;
		Eq_3 eax_130 = fn006ECC50(eax_113, out ecx_667, out edx_668, out esi_121);
		*eax = eax_130;
		esp_138 = fp - 0x0C;
		if (eax_130 == 0x00)
			goto l006E7F2A;
	}
	word32 v14_146 = (word32) *esi_121 - 1;
	*esi_121 = v14_146;
	ptr32 esp_152 = fp - 0x0C;
	if (v14_146 == 0x00)
	{
		Eq_3 eax_150 = *((word32) esi_121 + 4);
		struct Eq_58241 * ecx_151 = *((word32) eax_150 + 24);
		word32 esp_165;
		ecx_151();
		esp_152 = esp_165 + 0x04;
	}
	struct Eq_63659 * esp_174 = esp_152 - 4;
	esp_174->t0000.u0 = 0x008D2094;
	esp_174->tFFFFFFFC = edi_115;
	Eq_3 edi_181;
	word32 edx_669;
	Eq_3 eax_179 = fn006DF760(esp_174->tFFFFFFFC, esp_174->t0000, out edx_669, out edi_181);
	if (eax_179 == 0x00)
		return 0x00;
	esp_174->t0000 = eax_179;
	word32 ecx_195;
	Eq_3 edi_197;
	Eq_3 esi_198;
	word32 edx_670;
	Eq_3 eax_194 = fn007051A0(edi_181, esp_174->t0000, out ecx_195, out edx_670, out esi_198, out edi_197);
	word32 v16_204 = (word32) *esi_198 - 1;
	*esi_198 = v16_204;
	ptr32 esp_203 = (const char *) &esp_174->t0000 + 4;
	if (v16_204 == 0x00)
	{
		Eq_3 edx_209 = *((word32) esi_198 + 4);
		struct Eq_58241 * eax_210 = *((word32) edx_209 + 24);
		esp_174->t0000 = esi_198;
		word32 esp_221;
		eax_210();
		esp_203 = esp_221 + 0x04;
	}
	if (eax_194 < 0x00 && fn006E0FC0() != 0x00)
		return 0x00;
	struct Eq_63764 * esp_239 = esp_203 - 4;
	esp_239->t0000.u0 = 9159044;
	esp_239->tFFFFFFFC = edi_197;
	*dwArg04 = eax_194;
	word32 edx_671;
	Eq_3 edi_251;
	Eq_3 eax_249 = fn006DF760(esp_239->tFFFFFFFC, esp_239->t0000, out edx_671, out edi_251);
	struct Eq_63790 * esp_258 = (const char *) &esp_239->t0000 + 4;
	if (eax_249 == 0x00)
		return 0x00;
	if (eax_249 == 0x00A163B8)
	{
		word32 * ecx_322 = esp_239->ptr0018;
		*ecx_322 = ~0x00;
		word32 v18_324 = (word32) *eax_249 - 1;
		*eax_249 = v18_324;
		if (v18_324 == 0x00)
		{
			Eq_3 edx_328 = *((word32) eax_249 + 4);
			struct Eq_58241 * eax_329 = *((word32) edx_328 + 24);
			esp_239->t0000 = eax_249;
			word32 esp_332;
			eax_329();
			esp_258 = esp_332 + 0x04;
		}
	}
	else
	{
		esp_239->t0000 = eax_249;
		Eq_3 esi_270;
		word32 ecx_672;
		word32 edx_673;
		Eq_3 eax_266 = fn007051A0(edi_251, esp_239->t0000, out ecx_672, out edx_673, out esi_270, out edi_251);
		word32 v20_276 = (word32) *esi_270 - 1;
		*esi_270 = v20_276;
		esp_258 = (struct Eq_63790 *) ((const char *) &esp_239->t0000 + 4);
		if (v20_276 == 0x00)
		{
			Eq_3 ecx_281 = *((word32) esi_270 + 4);
			struct Eq_58241 * edx_282 = *((word32) ecx_281 + 24);
			esp_239->t0000 = esi_270;
			word32 esp_299;
			edx_282();
			esp_258 = esp_299 + 0x04;
		}
		if (eax_266 < 0x00 && fn006E0FC0() != 0x00)
			return 0x00;
		*esp_258->ptr0014 = (union Eq_3 *) eax_266;
	}
	struct Eq_63849 * esp_341 = esp_258 - 4;
	esp_341->t0000.u0 = 9235992;
	esp_341->tFFFFFFFC = edi_251;
	word32 edx_674;
	word32 edi_675;
	Eq_3 eax_348 = fn006DF760(esp_341->tFFFFFFFC, esp_341->t0000, out edx_674, out edi_675);
	esi_121 = eax_348;
	if (eax_348 == 0x00)
		return 0x00;
	union Eq_3 * ecx_366;
	if (eax_348 == 0x00A163B8)
	{
		ecx_366 = esp_341->ptr001C;
		*ecx_366 = (union Eq_3 *) 0x00;
l006E7EFD:
		word32 v19_449 = (word32) *esi_121 - 1;
		*esi_121 = v19_449;
		if (v19_449 == 0x00)
		{
			Eq_3 edx_453 = *((word32) esi_121 + 4);
			struct Eq_58241 * eax_454 = *((word32) edx_453 + 24);
			esp_258->tFFFFFFFC = esi_121;
			eax_454();
		}
		return 0x01;
	}
	esp_341->t0000 = eax_348;
	word32 edx_676;
	Eq_3 eax_365 = fn006ECC50(esp_341->t0000, out ecx_366, out edx_676, out esi_121);
	*esp_341->ptr001C = (union Eq_3 *) eax_365;
	esp_138 = (struct Eq_63622 *) ((const char *) &esp_341->t0000 + 4);
	if (eax_365 != 0x00)
		goto l006E7EFD;
l006E7F2A:
	word32 v15_381 = (word32) *esi_121 - 1;
	*esi_121 = v15_381;
	if (v15_381 == 0x00)
	{
		Eq_3 eax_385 = *((word32) esi_121 + 4);
		struct Eq_58241 * ecx_386 = *((word32) eax_385 + 24);
		esp_138->tFFFFFFFC = esi_121;
		ecx_386();
	}
	return 0x00;
}

// 006E7F60: Register ptr32 fn006E7F60(Register Eq_3 eax, Register (ptr32 charconst ) ecx, Stack Eq_3 dwArg04)
// Called from:
//      fn006E8060
ptr32 fn006E7F60(Eq_3 eax, const char * ecx, Eq_3 dwArg04)
{
	const char * edi_15 = ecx;
	Eq_3 esi_19 = eax;
	if (ecx >= null)
	{
		if (ecx > null)
		{
			eax_22 = eax;
			do
			{
				Eq_3 eax_22;
				eax_22 = (word32) eax_353 + 1;
				eax_353 = eax_22;
			} while (*eax_353 != 0x00);
			if (ecx == eax_22 - ((word32) eax + 1))
				edi_15 = ecx - 0x01;
		}
		const char * eax_50 = strchr(eax, 0x0A);
		if (eax_50 != null)
		{
			while (eax_50 - esi_19 < edi_15)
			{
				esi_19 = eax_50 + 1;
				edi_15 = edi_15 - 0x01 + (esi_19 - eax_50);
				eax_50 = strchr(esi_19, 0x0A);
				if (eax_50 == null)
					break;
			}
		}
		while (true)
		{
			byte al_86 = *esi_19;
			if (al_86 != 0x20 && al_86 != 0x09)
				break;
			++esi_19;
		}
	}
	ptr32 edx_125;
	word32 edx_343;
	word32 edi_344;
	Eq_3 esi_102;
	fn00731D30(9256696, dwArg04, out edx_343, out esi_102, out edi_344);
	byte * esi_115;
	word32 edx_345;
	word32 edi_113;
	fn00731D30(esi_102, dwArg04, out edx_345, out esi_115, out edi_113);
	if (*esi_115 != 0x00)
	{
		byte * eax_124 = esi_115;
		edx_125 = esi_115 + 1;
		do
		{
			eax_124 = eax_354 + 1;
			eax_354 = eax_124;
		} while (*eax_354 != 0x00);
		if (esi_115[eax_124 - (esi_115 + 1) - 0x01] == 0x0A)
		{
l006E8011:
			if (edi_113 != ~0x00)
			{
				word32 edx_347;
				int32 edi_168;
				word32 esi_348;
				fn00731D30(9256696, dwArg04, out edx_347, out esi_348, out edi_168);
				if (edi_168 > 0x01)
				{
					do
					{
						word32 edx_351;
						int32 edi_187;
						word32 esi_352;
						fn00731D30(9070940, dwArg04, out edx_351, out esi_352, out edi_187);
					} while (edi_187 > 0x01);
				}
				word32 esi_349;
				word32 edi_350;
				fn00731D30(9256692, dwArg04, out edx_125, out esi_349, out edi_350);
			}
			return edx_125;
		}
	}
	word32 esi_346;
	fn00731D30(0x008A6DE8, dwArg04, out edx_125, out esi_346, out edi_113);
	goto l006E8011;
}

// 006E8060: void fn006E8060(Register Eq_3 ebx, Register Eq_3 ebp, Register Eq_3 esi, Register Eq_3 edi, Register (ptr16 Eq_7) es, Register (ptr16 Eq_8) ds, Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Stack Eq_3 dwArg0C)
// Called from:
//      fn006E8D90
void fn006E8060(Eq_3 ebx, Eq_3 ebp, Eq_3 esi, Eq_3 edi, struct Eq_7 * es, struct Eq_8 * ds, Eq_3 dwArg04, Eq_3 dwArg08, Eq_3 dwArg0C)
{
	Eq_3 edx_1016;
	Eq_3 eax_1007;
	struct Eq_64116 * esp_117;
	Eq_3 esi_329;
	ui32 eax_7 = g_tA14188 ^ fp - 0x30;
	word32 ecx_1309;
	word32 edx_1310;
	Eq_3 eax_31 = fn00715DD0(out ecx_1309, out edx_1310);
	*dwArg08 = (word32) *dwArg08 + 1;
	Eq_3 ebp_116 = 0x00;
	if (eax_31 == 0x00)
	{
		struct Eq_64155 * esp_906;
		word32 eax_907;
		_iob_func();
		esp_906->tFFFFFFFC = eax_907 + 0x40;
		eax_1007 = fprintf(esp_906->tFFFFFFFC, esp_906->t0000, 0x00);
		esp_117 = (struct Eq_64116 *) ((const char *) &esp_906->t0000 + 4);
		goto l006E80BA;
	}
	Eq_3 edi_344;
	Eq_3 ebx_47;
	if (fn00707640(out ebx_47, out edi_344) != 0x00)
	{
		word32 ecx_1311;
		word32 edx_1312;
		fn006E1160(out ecx_1311, out edx_1312);
	}
	struct Eq_64188 * esp_71;
	word32 eax_72;
	_iob_func();
	esp_71->dwFFFFFFFC = eax_72 + 0x20;
	struct Eq_64197 * esp_81;
	MSVCR80.dll!fflush();
	if (dwArg0C != 0x00 && dwArg0C != 0x00A163B8)
	{
		esp_81->t0000 = ebx_47;
		esp_81->tFFFFFFFC = dwArg0C;
		eax_1007 = fn0072FBB0(es, ds, esp_81->tFFFFFFFC, esp_81->t0000, out edx_1016);
		ebp_116 = eax_1007;
		esp_117 = (struct Eq_64116 *) ((const char *) &esp_81->t0000 + 4);
		if (eax_1007 != 0x00)
			goto l006E80BA;
	}
	Eq_3 esi_123 = esp_81->t0014;
	esp_81->t0000.u0 = 0x008D2070;
	esp_81->tFFFFFFFC = esi_123;
	esp_117 = (struct Eq_64116 *) ((const char *) &esp_81->t0000 + 4);
	word32 edx_1313;
	if (fn006DF7C0(esp_81->tFFFFFFFC, esp_81->t0000, out edx_1313) != 0x00)
	{
		esp_81->t0000 = &esp_81->t0030;
		esp_81->tFFFFFFFC = &esp_81->ptr0024;
		esp_81->tFFFFFFF8 = &esp_81->t0020;
		esp_117 = (struct Eq_64116 *) ((const char *) &esp_81->t0000 + 4);
		if (fn006E7D90(&esp_81->t0028, (const char *) &esp_81->t0028 + 4, esi_123, es, ds, esp_81->tFFFFFFF8, esp_81->tFFFFFFFC, esp_81->t0000) == 0x00)
		{
			word32 edx_1318;
			word32 ecx_1317;
			fn006E1160(out ecx_1317, out edx_1318);
		}
		else
		{
			esp_81->t0000 = ebx_47;
			esp_81->tFFFFFFFC.u0 = 0x008D3F18;
			word32 edi_1316;
			word32 edx_1314;
			word32 esi_1315;
			fn00731D30(esp_81->tFFFFFFFC, esp_81->t0000, out edx_1314, out esi_1315, out edi_1316);
			Eq_3 eax_185 = esp_81->t0028;
			esp_81->t0000 = ebx_47;
			if (eax_185 == 0x00)
				esp_81->tFFFFFFFC.u0 = 0x008D3F0C;
			else
				esp_81->tFFFFFFFC = eax_185;
			word32 edi_1323;
			word32 edx_1321;
			word32 esi_1322;
			fn00731D30(esp_81->tFFFFFFFC, esp_81->t0000, out edx_1321, out esi_1322, out edi_1323);
			esp_81->t0000 = ebx_47;
			esp_81->tFFFFFFFC.u0 = 0x008D3F00;
			word32 edx_1324;
			word32 esi_1325;
			word32 edi_1326;
			fn00731D30(esp_81->tFFFFFFFC, esp_81->t0000, out edx_1324, out esi_1325, out edi_1326);
			esp_81->tFFFFFFF8 = esp_81->t0020;
			esp_81->ptrFFFFFFF4 = &g_b8A8F48;
			esp_81->tFFFFFFF0.u0 = 0x0A;
			esp_81->tFFFFFFEC = (const char *) &esp_81->t0030 + 4;
			fn00724FE0(esp_81->tFFFFFFEC, esp_81->tFFFFFFF0, esp_81->ptrFFFFFFF4);
			esp_81->tFFFFFFE8 = ebx_47;
			esp_81->tFFFFFFE4 = (const char *) &esp_81->t0030 + 4;
			word32 edx_1327;
			word32 esi_1328;
			word32 edi_1329;
			fn00731D30(esp_81->tFFFFFFE4, esp_81->tFFFFFFE8, out edx_1327, out esi_1328, out edi_1329);
			esp_81->tFFFFFFE0 = ebx_47;
			esp_81->tFFFFFFDC.u0 = 0x008A6DE8;
			Eq_3 esi_260;
			word32 edi_1330;
			fn00731D30(esp_81->tFFFFFFDC, esp_81->tFFFFFFE0, out edx_1016, out esi_260, out edi_1330);
			Eq_3 eax_266 = esp_81->t0030;
			if (eax_266 != 0x00)
			{
				const char * ecx_271 = esp_81->ptr0024;
				esp_81->t0000 = ebx_47;
				edx_1016 = fn006E7F60(eax_266, ecx_271, esp_81->t0000);
			}
			word32 v16_285 = (word32) *esi_260 - 1;
			*esi_260 = v16_285;
			esp_117 = (struct Eq_64116 *) ((const char *) &esp_81->t0000 + 4);
			if (v16_285 == 0x00)
			{
				Eq_3 ecx_289 = *((word32) esi_260 + 4);
				struct Eq_58241 * edx_290 = *((word32) ecx_289 + 24);
				esp_81->t0000 = esi_260;
				word32 esp_314;
				edx_290();
				esp_117 = esp_314 + 0x04;
			}
			esp_117->t0010 = esp_117->t0028;
			eax_1007 = fn006E0FC0();
			esi_329 = esp_117->t0010;
			if (eax_1007 != 0x00)
			{
				ebp_116.u0 = ~0x00;
				goto l006E80BE;
			}
		}
		edi_344 = esp_117->t0014;
	}
	Eq_3 eax_348 = *((word32) edi_344 + 4);
	if (eax_348 != 10611048)
	{
		if (eax_348 != 0x00A15380)
		{
			struct Eq_64505 * esp_354 = esp_117 - 4;
			esp_354->t0000.u0 = 0x00A15380;
			esp_354->tFFFFFFFC = eax_348;
			word32 ecx_1333;
			word32 edx_1334;
			if (fn006D5670(esp_354->tFFFFFFFC, esp_354->t0000, out ecx_1333, out edx_1334) == 0x00)
			{
l006E81AB:
				struct Eq_64529 * esp_676 = esp_117 - 4;
				esp_676->t0000.u0 = 0x01;
				esp_676->tFFFFFFFC = ebx_47;
				esp_676->tFFFFFFF8 = edi_344;
				eax_1007 = fn00731B10(edi_344, es, ds, esp_676->tFFFFFFF8, esp_676->tFFFFFFFC, esp_676->t0000, out edx_1016, out ebx_47, out esi_329);
				esp_117 = (struct Eq_64116 *) ((const char *) &esp_676->t0000 + 4);
				goto l006E8339;
			}
		}
		struct Eq_64480 * esp_372 = esp_117 - 4;
		esp_372->t0000 = g_tA169F0;
		esp_372->tFFFFFFFC = edi_344;
		word32 ecx_1331;
		word32 edx_1332;
		if (fn006D5670(esp_372->tFFFFFFFC, esp_372->t0000, out ecx_1331, out edx_1332) == 0x00)
			goto l006E81AB;
	}
	Eq_3 eax_395;
	if (*((word32) edi_344 + 4) == 10611048)
	{
		Eq_3 eax_396 = *((word32) edi_344 + 16);
		esp_117->t0014 = (word32) eax_396 + 20;
		eax_395 = (word32) eax_396 + 20;
	}
	else
	{
		Eq_3 edx_392 = *((word32) edi_344 + 0x0C);
		esp_117->t0014 = edx_392;
		eax_395 = edx_392;
	}
	if (eax_395 != 0x00)
	{
		struct Eq_64833 * esp_405 = esp_117 - 4;
		esp_405->dw0000 = 0x2E;
		esp_405->tFFFFFFFC = eax_395;
		const char * eax_409 = strrchr(esp_405->tFFFFFFFC, esp_405->dw0000);
		if (eax_409 != null)
			esp_405->ptr0018 = eax_409 + 1;
	}
	struct Eq_64805 * esp_418 = esp_117 - 4;
	esp_418->t0000.u0 = 9209240;
	esp_418->tFFFFFFFC = edi_344;
	word32 edx_1338;
	word32 edi_1339;
	Eq_3 eax_424 = fn006DF760(esp_418->tFFFFFFFC, esp_418->t0000, out edx_1338, out edi_1339);
	esp_418->t001C = eax_424;
	if (eax_424 == 0x00)
	{
		esp_418->t0000 = ebx_47;
		esp_418->tFFFFFFFC.u0 = 0x008BF7CC;
		word32 esi_1341;
		word32 edi_1342;
		eax_1007 = fn00731D30(esp_418->tFFFFFFFC, esp_418->t0000, out edx_1016, out esi_1341, out edi_1342);
		esp_117 = (struct Eq_64116 *) ((const char *) &esp_418->t0000 + 4);
		ebp_116 = eax_1007;
	}
	else
	{
		esp_418->t0000 = eax_424;
		word32 ecx_1340;
		Eq_3 esi_443;
		eax_1007 = fn006ECC50(esp_418->t0000, out ecx_1340, out edx_1016, out esi_443);
		if (eax_1007 != 0x00)
		{
			byte * edi_452 = &g_b8D35A0;
			Eq_3 esi_453 = eax_1007;
			word32 ecx_454 = 11;
			edx_1016.u0 = 0x00;
			bool v31_1055 = true;
			while (ecx_454 != 0x00)
			{
				v31_1055 = *esi_1350 == *edi_1351;
				esi_453 = (word32) esi_1350 + 1;
				edi_452 = edi_1351 + 1;
				--ecx_454;
				esi_1350 = esi_453;
				edi_1351 = edi_452;
				if (*esi_1350 == *edi_1351)
					break;
			}
			if (!v31_1055)
			{
				esp_418->t0000 = ebx_47;
				esp_418->tFFFFFFFC = eax_1007;
				word32 edx_1343;
				word32 esi_1344;
				word32 edi_1345;
				Eq_3 eax_491 = fn00731D30(esp_418->tFFFFFFFC, esp_418->t0000, out edx_1343, out esi_1344, out edi_1345);
				esp_418->tFFFFFFF8 = ebx_47;
				esp_418->tFFFFFFF4.u0 = 9070992;
				word32 esi_1346;
				word32 edi_1347;
				eax_1007 = fn00731D30(esp_418->tFFFFFFF4, esp_418->tFFFFFFF8, out edx_1016, out esi_1346, out edi_1347);
				ebp_116 = eax_491 + eax_1007;
			}
			esi_443 = esp_117->t0018;
		}
		word32 v18_519 = (word32) *esi_443 - 1;
		*esi_443 = v18_519;
		if (v18_519 == 0x00)
		{
			Eq_3 eax_523 = *((word32) esi_443 + 4);
			struct Eq_58241 * ecx_524 = *((word32) eax_523 + 24);
			esp_117->tFFFFFFFC = esi_443;
			word32 esp_620;
			ecx_524();
			esp_117 = esp_620 + 0x04;
		}
	}
	if (ebp_116 != 0x00)
	{
l006E80BA:
		esi_329 = esp_117->t0010;
		goto l006E80BE;
	}
	Eq_3 eax_650 = esp_117->t0014;
	struct Eq_64990 * esp_653 = esp_117 - 4;
	esp_653->t0000 = ebx_47;
	if (eax_650 == 0x00)
		esp_653->tFFFFFFFC.u0 = 0x008BF7CC;
	else
		esp_653->tFFFFFFFC = eax_650;
	struct Eq_65005 * esp_661 = esp_117 - 8;
	word32 edi_1349;
	word32 esi_1348;
	eax_1007 = fn00731D30(esp_661->t0000, esp_661->t0004, out edx_1016, out esi_1348, out edi_1349);
	esi_329 = esp_661->t0018;
	esp_117 = (struct Eq_64116 *) ((const char *) &esp_661->t0004 + 4);
l006E8339:
	ebp_116 = eax_1007;
	if (eax_1007 != 0x00)
		goto l006E80BE;
	if (esi_329 == 0x00A163B8)
	{
l006E83C3:
		struct Eq_64599 * esp_883 = esp_117 - 4;
		esp_883->t0000 = ebx_47;
		esp_883->tFFFFFFFC.u0 = 0x008A6DE8;
		word32 edi_1335;
		eax_1007 = fn00731D30(esp_883->tFFFFFFFC, esp_883->t0000, out edx_1016, out esi_329, out edi_1335);
		esp_117 = (struct Eq_64116 *) ((const char *) &esp_883->t0000 + 4);
		ebp_116 = eax_1007;
		goto l006E80BE;
	}
	struct Eq_64623 * esp_714 = esp_117 - 4;
	esp_714->t0000 = esi_329;
	Eq_3 edi_718;
	eax_1007 = fn006DDF70(esp_714->t0000, out edx_1016, out edi_718);
	Eq_3 esi_725 = eax_1007;
	esp_117 = (struct Eq_64116 *) ((const char *) &esp_714->t0000 + 4);
	if (eax_1007 == 0x00)
	{
		ebp_116.u0 = ~0x00;
		goto l006E80BA;
	}
	Eq_3 eax_730 = *((word32) eax_1007 + 4);
	if (eax_730 != 0x00A1B450)
	{
		esp_714->t0000.u0 = 0x00A1B450;
		esp_714->tFFFFFFFC = eax_730;
		word32 ecx_1336;
		word32 edx_1337;
		if (fn006D5670(esp_714->tFFFFFFFC, esp_714->t0000, out ecx_1336, out edx_1337) == 0x00)
		{
l006E8384:
			struct Eq_64702 * esp_754 = esp_117 - 4;
			esp_754->t0000 = ebx_47;
			esp_754->tFFFFFFFC.u0 = 0x008BAE70;
			eax_1007 = fn00731D30(esp_754->tFFFFFFFC, esp_754->t0000, out edx_1016, out esi_725, out edi_718);
			ebp_116 = eax_1007;
			if (eax_1007 != 0x00)
				goto l006E83A6;
l006E8398:
			struct Eq_64725 * esp_777 = esp_117 - 4;
			esp_777->t0000.u0 = 0x01;
			esp_777->tFFFFFFFC = ebx_47;
			esp_777->tFFFFFFF8 = esi_725;
			eax_1007 = fn00731B10(edi_718, es, ds, esp_777->tFFFFFFF8, esp_777->tFFFFFFFC, esp_777->t0000, out edx_1016, out ebx_47, out esi_725);
			ebp_116 = eax_1007;
l006E83A6:
			word32 v17_841 = (word32) *esi_725 - 1;
			*esi_725 = v17_841;
			if (v17_841 == 0x00)
			{
				Eq_3 edx_845 = *((word32) esi_725 + 4);
				struct Eq_58241 * eax_846 = *((word32) edx_845 + 24);
				esp_117->tFFFFFFFC = esi_725;
				word32 esp_867;
				eax_846();
				esp_117 = esp_867 + 0x04;
			}
			esi_329 = esp_117->t0010;
			if (ebp_116 == 0x00)
				goto l006E83C3;
l006E80BE:
			word32 v13_924 = (word32) *esi_329 - 1;
			*esi_329 = v13_924;
			if (v13_924 == 0x00)
			{
				Eq_3 ecx_928 = *((word32) esi_329 + 4);
				struct Eq_58241 * edx_929 = *((word32) ecx_928 + 24);
				esp_117->tFFFFFFFC = esi_329;
				edx_929();
			}
			if (ebp_116 != 0x00)
			{
				word32 ecx_1320;
				eax_1007 = fn006E1160(out ecx_1320, out edx_1016);
			}
			word32 ecx_1319;
			fn00694B8E(eax_1007, eax_7 ^ fp - 48, edx_1016, ebx, ebp, esi, edi, es, ds, ebx, out ecx_1319);
			return;
		}
	}
	if (*((word32) eax_1007 + 8) == 0x00)
		goto l006E8398;
	goto l006E8384;
}

// 006E83E0: Register Eq_3 fn006E83E0(Stack Eq_3 dwArg04, Stack word32 dwArg08, Stack word32 dwArg0C)
// Called from:
//      fn006E9040
//      fn006E90B0
Eq_3 fn006E83E0(Eq_3 dwArg04, word32 dwArg08, word32 dwArg0C)
{
	Eq_3 eax_20 = fn0072E790(dwArg04, edx, ecx, eax);
	if (eax_20 == 0x00)
		return eax_20;
	word32 edx_44;
	Eq_3 eax_42 = fn0070BC90(out edx_44);
	word32 v12_48 = (word32) *eax_20 - 1;
	*eax_20 = v12_48;
	if (v12_48 == 0x00)
	{
		Eq_3 eax_53 = *((word32) eax_20 + 4);
		struct Eq_58241 * ecx_54 = *((word32) eax_53 + 24);
		ecx_54();
	}
	return eax_42;
}

// 006E8430: void fn006E8430(Register (ptr32 Eq_65082) eax, Register Eq_3 esi)
// Called from:
//      fn006E8AC0
//      fn006E8B50
void fn006E8430(struct Eq_65082 * eax, Eq_3 esi)
{
	Eq_3 ebx_163;
	struct Eq_65085 * esp_105 = fp - 0x1C;
	up32 eax_18 = eax->dw0000;
	Eq_3 ebp_20 = 0x00;
	if (eax_18 <= 0x19)
	{
		switch (eax_18)
		{
		case 11:
			ebx_163.u0 = 0x008D4050;
			break;
		case 0x0C:
			if (fn006E0FC0() != 0x00)
				return;
			word32 edx_551;
			fn006E0F10(g_tA16F88, out edx_551);
			return;
		case 0x0D:
			ebx_163.u0 = 0x008D40C0;
			break;
		case 0x0E:
			if (eax->dw0018 == 0x05)
				ebx_163.u0 = 9257224;
			else
			{
				word32 eax_212 = eax->dw0014;
				if (eax_212 == 0x05)
					ebx_163.u0 = 0x008D40F4;
				else if (eax_212 == 0x06)
					ebx_163.u0 = 0x008D40E0;
				else
					ebx_163.u0 = 0x008D40D0;
			}
			break;
		case 0x0F:
			word32 ecx_563;
			word32 edx_564;
			fn006E1210(out ecx_563, out edx_564);
			return;
		case 0x10:
		case 0x11:
			goto l006E85E7;
		case 0x12:
			ebx_163.u0 = 9256988;
			break;
		case 0x13:
			ebx_163.u0 = 0x008D4008;
			break;
		case 0x14:
			ebx_163.u0 = 9256884;
			break;
		case 0x15:
			ebx_163.u0 = 9256916;
			break;
		case 22:
			fn006E1130(fp - 0x08, fp - 0x0C, fp - 0x04);
			if (dwLoc0C != 0x00)
			{
				word32 edx_556;
				word32 edi_557;
				Eq_3 eax_52 = fn006DDF70(dwLoc0C, out edx_556, out edi_557);
				ebp_20 = eax_52;
				if (eax_52 == 0x00)
					goto l006E8579;
				word32 esi_560;
				word32 edx_559;
				word32 ecx_558;
				Eq_3 eax_65 = fn006ECC50(eax_52, out ecx_558, out edx_559, out esi_560);
				ebx_163 = eax_65;
				if (eax_65 == 0x00)
					goto l006E8579;
			}
			else
			{
l006E8579:
				ebx_163.u0 = 9256860;
			}
			esp_105 = fp - 0x1C;
			if (dwLoc08 != null)
			{
				dwLoc08->dw0000 += ~0x00;
				if (dwLoc08->dw0000 == 0x00)
				{
					struct Eq_65321 * edx_88 = dwLoc08->ptr0004;
					<anonymous> * eax_91 = edx_88->ptr0018;
					word32 esp_99;
					eax_91();
					esp_105 = esp_99 + 0x04;
				}
			}
			struct Eq_65302 * eax_109 = esp_105->ptr0010;
			if (eax_109 != null)
			{
				eax_109->dw0000 += ~0x00;
				struct Eq_65302 * eax_115 = esp_105->ptr0010;
				if (eax_115->dw0000 == 0x00)
				{
					struct Eq_65407 * ecx_118 = eax_115->ptr0004;
					<anonymous> * edx_119 = ecx_118->ptr0018;
					esp_105->ptrFFFFFFFC = eax_115;
					word32 esp_126;
					edx_119();
					esp_105 = esp_126 + 0x04;
				}
			}
			struct Eq_65302 * eax_136 = esp_105->ptr0018;
			if (eax_136 != null)
			{
				eax_136->dw0000 += ~0x00;
				struct Eq_65302 * eax_142 = esp_105->ptr0018;
				if (eax_142->dw0000 == 0x00)
				{
					struct Eq_65407 * ecx_145 = eax_142->ptr0004;
					<anonymous> * edx_146 = ecx_145->ptr0018;
					esp_105->ptrFFFFFFFC = eax_142;
					word32 esp_153;
					edx_146();
					esp_105 = esp_153 + 0x04;
				}
			}
			break;
		case 0x17:
			ebx_163.u0 = 0x008D4098;
			break;
		case 0x18:
			ebx_163.u0 = 0x008D4070;
			break;
		case 0x19:
			ebx_163.u0 = 0x008D3F64;
			break;
		}
	}
	else
	{
l006E85E7:
		struct Eq_65097 * esp_181;
		word32 eax_183;
		_iob_func();
		esp_181->tFFFFFFFC = eax_183 + 0x40;
		fprintf(esp_181->tFFFFFFFC, esp_181->t0000, 0x00);
		esp_105 = (struct Eq_65085 *) ((const char *) &esp_181->t0000 + 8);
		ebx_163.u0 = 0x008D3F40;
	}
	Eq_3 eax_249 = eax->t0010;
	Eq_3 ecx_250 = eax->t000C;
	word32 edx_251 = eax->dw0008;
	struct Eq_65155 * esp_253 = esp_105 - 4;
	esp_253->t0000 = esi;
	esp_253->tFFFFFFFC = eax_249;
	word32 eax_264 = eax->dw0004;
	esp_253->tFFFFFFF8 = ecx_250;
	esp_253->dwFFFFFFF4 = edx_251;
	esp_253->dwFFFFFFF0 = eax_264;
	esp_253->dwFFFFFFEC = 0x008D3F38;
	word32 edx_552;
	word32 esi_553;
	Eq_3 eax_278 = fn006EA200(out edx_552, out esi_553);
	Eq_3 eax_283 = eax->t0010;
	if (eax_283 != 0x00)
	{
		esp_253->tFFFFFFFC = eax_283;
		word32 ecx_549;
		word32 edx_550;
		eax_283 = fn007239C0(esp_253->tFFFFFFFC, out ecx_549, out edx_550);
		eax->t0010.u0 = 0x00;
	}
	Eq_3 edi_300 = 0x00;
	if (eax_278 != 0x00)
	{
		esp_253->tFFFFFFFC = eax_278;
		esp_253->tFFFFFFF8 = ebx_163;
		esp_253->dwFFFFFFF4 = 0x008C8040;
		word32 edx_554;
		word32 esi_555;
		eax_283 = fn006EA200(out edx_554, out esi_555);
		edi_300 = eax_283;
	}
	struct Eq_65155 * esp_337 = esp_253;
	if (ebp_20 != 0x00)
	{
		word32 v15_331 = (word32) *ebp_20 - 1;
		*ebp_20 = v15_331;
		if (v15_331 == 0x00)
		{
			Eq_3 ecx_335 = *((word32) ebp_20 + 4);
			struct Eq_58241 * edx_336 = *((word32) ecx_335 + 24);
			esp_253->tFFFFFFFC = ebp_20;
			word32 esp_345;
			edx_336();
			esp_337 = esp_345 + 0x04;
		}
	}
	if (eax_278 != 0x00)
	{
		word32 v17_358 = (word32) *eax_278 - 1;
		*eax_278 = v17_358;
		if (v17_358 == 0x00)
		{
			Eq_3 eax_362 = *((word32) eax_278 + 4);
			struct Eq_58241 * ecx_363 = *((word32) eax_362 + 24);
			esp_337->tFFFFFFFC = eax_278;
			word32 esp_371;
			ecx_363();
			esp_337 = esp_371 + 0x04;
		}
	}
	Eq_3 edx_381 = esp_337->t0010;
	struct Eq_65336 * esp_382 = esp_337 - 4;
	esp_382->t0000 = edi_300;
	esp_382->tFFFFFFFC = edx_381;
	word32 ecx_561;
	word32 edx_562;
	fn006E0E90(esp_382->tFFFFFFFC, esp_382->t0000, out ecx_561, out edx_562);
	if (edi_300 != 0x00)
	{
		word32 v19_400 = (word32) *edi_300 - 1;
		*edi_300 = v19_400;
		if (v19_400 == 0x00)
		{
			Eq_3 eax_404 = *((word32) edi_300 + 4);
			struct Eq_58241 * ecx_405 = *((word32) eax_404 + 24);
			esp_382->t0004 = edi_300;
			ecx_405();
		}
	}
}

// 006E86F0: void fn006E86F0(Stack Eq_3 dwArg04)
// Called from:
//      fn006DFD20
//      fn006E0B00
//      fn006E7660
//      fn006EC890
//      fn006F2650
//      fn006F5DA0
//      fn006F62D0
//      fn006F63A0
//      fn006F6440
//      fn006F6490
//      fn006F70C0
//      fn006F8440
//      fn006F94A0
//      fn006FDCC0
//      fn006FE2A0
//      fn006FE400
//      fn006FEE30
//      fn00706BE0
//      fn00706C20
//      fn00708DC0
//      fn007157B0
//      fn00715B80
//      fn00715BD0
//      fn00725010
//      fn00725DA0
//      fn00727290
//      fn007274B0
//      fn00727910
//      fn00729040
//      fn0072C160
//      fn00734B60
//      fn0073AFB0
//      fn0073B240
//      fn0073B280
//      fn0073B9B0
//      fn0074E980
//      fn007500E0
//      fn00750380
//      fn007540B0
//      fn007544F0
void fn006E86F0(Eq_3 dwArg04)
{
	word32 eax_16;
	_iob_func();
	fprintf(eax_16 + 0x40, 9257276, 0x00);
	OutputDebugStringA(9257252);
	OutputDebugStringA(dwArg04);
	OutputDebugStringA(0x008A6DE8);
	abort();
}

// 006E8730: void fn006E8730()
// Called from:
//      fn006E8910
void fn006E8730()
{
	word32 ecx_168;
	word32 edx_169;
	Eq_3 eax_9 = fn00715DD0(out ecx_168, out edx_169);
	if (eax_9 != 0x00)
	{
		*eax_9 = (word32) *eax_9 + 1;
		Eq_3 esi_47;
		word32 edi_172;
		word32 ecx_173;
		word32 edx_174;
		word32 edi_175;
		if (fn00707680(fn00715E50(0x00, out edi_172), 0x00, 0x00, out ecx_173, out edx_174, out esi_47, out edi_175) == 0x00)
		{
			word32 ecx_176;
			word32 edx_177;
			if (fn006E1110(out ecx_176, out edx_177) == 0x00)
			{
				word32 edx_185;
				fn00716B20(out edx_185);
			}
			word32 ebp_182;
			word32 esi_183;
			word32 edi_184;
			fn006E8D90(ebx, esi_47, edi, es, ds, out ebp_182, out esi_183, out edi_184);
		}
		word32 v10_95 = (word32) *esi_47 - 1;
		*esi_47 = v10_95;
		if (v10_95 == 0x00)
		{
			Eq_3 ecx_99 = *((word32) esi_47 + 4);
			(*((word32) ecx_99 + 24))();
		}
	}
	word32 ebx_170;
	word32 edi_171;
	if (fn00707640(out ebx_170, out edi_171) == 0x00)
		return;
	word32 ecx_186;
	word32 edx_187;
	fn006E1160(out ecx_186, out edx_187);
}

// 006E8800: Register word32 fn006E8800(Register Eq_3 edx, Register Eq_3 ebx, Register Eq_3 esi, Register Eq_3 edi, Register (ptr16 Eq_7) es, Register (ptr16 Eq_8) ds)
// Called from:
//      fn006DDEB0
//      fn006DEEA0
//      fn00706DC0
word32 fn006E8800(Eq_3 edx, Eq_3 ebx, Eq_3 esi, Eq_3 edi, struct Eq_7 * es, struct Eq_8 * ds)
{
	ptr32 eax_15 = fs->ptr0000;
	ui32 eax_23 = g_tA14188 ^ fp - 4;
	fs->ptr0000 = fp - 0x14;
	fn0082ABF0(0x2000, dwLoc34);
	fs->ptr0000 = eax_15;
	word32 ecx_101;
	return fn00694B8E(0x00, eax_23 ^ fp - 4, edx, ebx, fp - 4, esi, edi, es, ds, ebx, out ecx_101);
}

// 006E8910: void fn006E8910(Register (ptr16 Eq_7) es, Register (ptr16 Eq_8) ds)
// Called from:
//      fn006E8C30
void fn006E8910(struct Eq_7 * es, struct Eq_8 * ds)
{
	if (g_dwA6C624 == 0x00)
		return;
	fn006E8730();
	g_dwA6C624 = 0x00;
	fn0072ECF0();
	ptr32 esp_10 = fp - 4;
	Eq_3 eax_27 = g_tA6C620;
	if (eax_27 != 0x00)
	{
		word32 v9_31 = (word32) *eax_27 - 1;
		*eax_27 = v9_31;
		if (v9_31 == 0x00)
		{
			Eq_3 ecx_35 = *((word32) eax_27 + 4);
			word32 esp_39;
			word32 eax_40;
			word32 edx_42;
			(*((word32) ecx_35 + 24))();
			esp_10 = esp_39 + 0x04;
		}
	}
	g_tA6C620.u0 = 0x00;
	Eq_3 ebp_49 = fn006FEE00();
	Eq_3 esi_63;
	word32 edi_64;
	Eq_3 ebx_60 = fn006F5DD0(out esi_63, out edi_64);
	fn006F5C20();
	fn007159F0();
	struct Eq_65690 * esp_83 = esp_10 - 4;
	esp_83->t0000 = esi_63;
	fn00715A70(esp_83->t0000);
	fn006E52A0();
	esp_83->tFFFFFFFC.u0 = 0x00;
	word32 ecx_351;
	fn007158B0(esp_83->tFFFFFFFC, out ecx_351);
	esp_83->tFFFFFFF8 = esi_63;
	fn00715BD0(esp_83->tFFFFFFF8);
	fn0070E820();
	fn0073B5E0();
	fn006F9B70();
	Eq_3 edi_136;
	Eq_3 esi_137 = fn006E0CA0(esi_63, edi_64, out edi_136);
	fn006F2610();
	fn00738D80();
	fn006EC950();
	fn00706900();
	fn00700EC0(ebx_60, ebp_49, esi_137, edi_136, es, ds);
	fn0071F9C0(ebp_49);
	Eq_3 esp_145 = <invalid>;
	((word32) esp_145 - 4)->u0 = 0x00A2AC58;
	fn00737950(*((word32) esp_145 - 4));
	Eq_3 esi_210 = *((word32) esp_145 + 0x0C);
	ptr32 esp_211 = (word32) esp_145 + 16;
	int32 eax_212 = g_dwA6C62C;
	while (eax_212 > 0x00)
	{
		int32 eax_217 = eax_212 - 0x01;
		g_dwA6C62C = eax_217;
		<anonymous> * eax_220 = *((const char *) g_aA6C598 + eax_217 * 0x04);
		word32 ecx_232;
		word32 edx_233;
		eax_220();
		eax_212 = g_dwA6C62C;
	}
	struct Eq_65817 * esp_240 = esp_211 - 4;
	esp_240->t0000 = esi_210;
	esp_240->tFFFFFFFC = edi_136;
	struct Eq_65826 * esp_256;
	word32 eax_257;
	_iob_func();
	esp_256->dwFFFFFFFC = eax_257 + 0x20;
	MSVCR80.dll!fflush();
	struct Eq_65837 * esp_273;
	word32 eax_274;
	_iob_func();
	esp_273->dwFFFFFFFC = eax_274 + 0x40;
	word32 eax_284;
	word32 ecx_285;
	word32 edx_286;
	MSVCR80.dll!fflush();
}

// 006E8AC0: Register word32 fn006E8AC0(Stack word32 dwArg10)
// Called from:
//      fn006E9040
word32 fn006E8AC0(word32 dwArg10)
{
	Eq_3 eax_57 = fn00740A90(dwArg08, fp - 0x1C);
	if (eax_57 == 0x00)
	{
		fn006E8430(fp - 0x1C, eax_57);
		return 0x00;
	}
	else
	{
		word32 eax_93 = fn007403E0(edx, dwArg08, es, ds, eax_57, dwArg04);
		fn0073B7F0(eax_57);
		return eax_93;
	}
}

// 006E8B50: Register word32 fn006E8B50(Stack word32 dwArg18, Stack (ptr32 word32) dwArg1C)
// Called from:
//      fn006E90B0
//      fn006F67C0
word32 fn006E8B50(word32 dwArg18, word32 * dwArg1C)
{
	Eq_3 eax_63 = fn00740B40(dwArg04, dwArg08, dwArg10, dwArg14, fp - 0x1C);
	if (eax_63 == 0x00)
	{
		fn006E8430(fp - 0x1C, eax_63);
		if (dwArg1C != null)
			*dwArg1C = dwLoc1C;
		return 0x00;
	}
	else
	{
		word32 eax_107 = fn007403E0(dwArg20, dwArg08, es, ds, eax_63, dwArg04);
		fn0073B7F0(eax_63);
		return eax_107;
	}
}

// 006E8C30: void fn006E8C30(Stack Eq_3 dwArg04)
// Called from:
//      fn006E8D90
void fn006E8C30(Eq_3 dwArg04)
{
	fn006E8910(es, ds);
	exit(dwArg04);
}

// 006E8D90: Register Eq_3 fn006E8D90(Register Eq_3 ebx, Register Eq_3 esi, Register Eq_3 edi, Register (ptr16 Eq_7) es, Register (ptr16 Eq_8) ds, Register out Eq_3 ebpOut, Register out Eq_3 esiOut, Register out Eq_3 ediOut)
// Called from:
//      fn0042DF20
//      fn00657140
//      fn006E8730
Eq_3 fn006E8D90(Eq_3 ebx, Eq_3 esi, Eq_3 edi, struct Eq_7 * es, struct Eq_8 * ds, union Eq_3 & ebpOut, union Eq_3 & esiOut, union Eq_3 & ediOut)
{
	ptr32 esp_2 = fp;
l006E8D90:
	Eq_3 esp_7 = esp_2 - 0x18;
	*((word32) esp_7 - 4) = g_tA16E04;
	Eq_3 esp_17 = esp_7;
	word32 ecx_1130;
	word32 edx_1131;
	if (fn006E1110(out ecx_1130, out edx_1131) != 0x00)
	{
l006E8C50:
		Eq_3 esp_596 = esp_17 - 0x0C;
		*((word32) esp_596 - 4) = ebx;
		*((word32) esp_596 - 8) = edi;
		*((word32) esp_596 - 0x0C) = (word32) esp_596 + 4;
		*((word32) esp_596 - 16) = esp_596;
		*((word32) esp_596 - 20) = (word32) esp_596 + 8;
		fn006E1130(*((word32) esp_596 - 20), *((word32) esp_596 - 16), *((word32) esp_596 - 0x0C));
		word32 ebx_1132;
		Eq_3 edi_630;
		if (fn00707640(out ebx_1132, out edi_630) != 0x00)
		{
			word32 edx_1138;
			word32 ecx_1137;
			fn006E1160(out ecx_1137, out edx_1138);
		}
		struct Eq_66147 * esp_650;
		word32 eax_651;
		_iob_func();
		esp_650->dwFFFFFFFC = eax_651 + 0x20;
		struct Eq_66156 * esp_660;
		MSVCR80.dll!fflush();
		Eq_3 eax_666 = esp_660->t000C;
		struct Eq_66163 * esp_667 = (const char *) &esp_660->t0000 + 4;
		if (eax_666 == 0x00 || eax_666 == 0x00A163B8)
		{
l006E8D68:
			struct Eq_66288 * esp_835 = esp_667 - 4;
			esp_835->t0000 = esp_667->t000C;
			esp_835->tFFFFFFFC = eax_666;
			esp_835->dwFFFFFFF8 = esp_835->dw0014;
			word32 edx_1145;
			word32 ecx_1144;
			fn006E0E00(esp_835->t0000, out ecx_1144, out edx_1145);
			word32 edx_1147;
			word32 ecx_1146;
			fn006E1160(out ecx_1146, out edx_1147);
			esp_835->t0000 = edi_630;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg4 = <invalid>;
			fn006E8C30(stackArg4);
			edi = esp_835->t0000;
			ebx = esp_835->t0004;
			int3();
			int3();
			int3();
			int3();
			int3();
			int3();
			int3();
			int3();
			esp_2 = (const char *) &esp_835->t0004 + 4;
			goto l006E8D90;
		}
		struct Eq_66156 * esp_713;
		esp_660->t0000 = esi;
		if (*((word32) eax_666 + 4) != 10611608)
		{
			Eq_3 edx_681 = *((word32) eax_666 + 4);
			esp_660->tFFFFFFFC = g_tA169F0;
			esp_660->tFFFFFFF8 = edx_681;
			word32 edx_1151;
			word32 ecx_1150;
			if (fn006D5670(esp_660->tFFFFFFF8, esp_660->tFFFFFFFC, out ecx_1150, out edx_1151) == 0x00)
			{
l006E8D0C:
				esp_713 = esp_660;
				eax_666 = esp_660->t000C;
				goto l006E8D10;
			}
			eax_666 = esp_660->t000C;
		}
		esp_660->tFFFFFFFC.u0 = 9252172;
		esp_660->tFFFFFFF8 = eax_666;
		word32 edx_1149;
		Eq_3 eax_704 = fn006DF760(esp_660->tFFFFFFF8, esp_660->tFFFFFFFC, out edx_1149, out edi_630);
		esp_713 = esp_660;
		if (eax_704 != 0x00)
		{
			Eq_3 eax_720 = esp_660->t000C;
			*eax_720 = (word32) *eax_720 - 1;
			Eq_3 eax_723 = esp_660->t000C;
			if (*eax_723 == edi_630)
			{
				Eq_3 ecx_726 = *((word32) eax_723 + 4);
				<anonymous> * edx_727 = *((word32) ecx_726 + 24);
				esp_660->tFFFFFFFC = eax_723;
				word32 esp_731;
				edx_727();
				esp_713 = esp_731 + 0x04;
			}
			esp_713->t000C = eax_704;
			eax_666 = eax_704;
			if (eax_704 == 0x00A163B8)
			{
l006E8D67:
				esi = esp_713->t0000;
				esp_667 = (struct Eq_66163 *) ((const char *) &esp_713->t0000 + 4);
				goto l006E8D68;
			}
l006E8D10:
			if (*((word32) eax_666 + 4) != 10610664)
			{
				Eq_3 eax_749 = *((word32) eax_666 + 4);
				struct Eq_66526 * esp_751 = esp_713 - 4;
				esp_751->t0000.u0 = 10610664;
				esp_751->tFFFFFFFC = eax_749;
				word32 ecx_1159;
				word32 edx_1160;
				if (fn006D5670(esp_751->tFFFFFFFC, esp_751->t0000, out ecx_1159, out edx_1160) == 0x00)
				{
					esp_751->t0000.u0 = 0x01;
					struct Eq_66557 * esp_793;
					word32 eax_794;
					_iob_func();
					word32 ecx_799 = esp_793->dw0010;
					esp_793->dwFFFFFFFC = eax_794 + 0x40;
					esp_793->dwFFFFFFF8 = ecx_799;
					word32 edx_1161;
					fn006DEFC0(out edx_1161);
					esp_793->dwFFFFFFF4 = 0x008A6DE8;
					word32 edx_1162;
					fn00716B20(out edx_1162);
					esp_713 = (struct Eq_66156 *) (&esp_793->dwFFFFFFFC + 2);
					edi_630.u0 = 0x01;
l006E8D63:
					eax_666 = esp_713->t000C;
					goto l006E8D67;
				}
				eax_666 = esp_751->t0010;
			}
			union Eq_3 * esp_768 = esp_713 - 4;
			*esp_768 = (union Eq_3 *) eax_666;
			esp_713 = (struct Eq_66156 *) ((const char *) esp_768 + 4);
			word32 edx_1156;
			word32 ecx_1155;
			word32 esi_1157;
			word32 edi_1158;
			edi_630 = fn007051A0(edi_630, *esp_768, out ecx_1155, out edx_1156, out esi_1157, out edi_1158);
			goto l006E8D63;
		}
		goto l006E8D0C;
	}
	*((word32) esp_7 - 4) = (word32) esp_7 + 8;
	*((word32) esp_7 - 8) = (word32) esp_7 + 4;
	*((word32) esp_7 - 0x0C) = esp_7;
	fn006E1130(*((word32) esp_7 - 0x0C), *((word32) esp_7 - 8), *((word32) esp_7 - 4));
	if (*esp_7 == 0x00)
	{
l006E9035:
		ebpOut = ebp;
		esiOut = esi;
		ediOut = edi;
		return ebx;
	}
	*((word32) esp_7 - 4) = (word32) esp_7 + 8;
	*((word32) esp_7 - 8) = (word32) esp_7 + 4;
	*((word32) esp_7 - 0x0C) = esp_7;
	ebx = fn006E1BD0(*((word32) esp_7 - 0x0C), *((word32) esp_7 - 8), out ebp, out esi, out edi);
	Eq_3 eax_60 = *esp_7;
	if (eax_60 == 0x00)
		goto l006E9035;
	if (*((word32) esp_7 + 28) != 0x00)
	{
		*((word32) esp_7 - 4) = eax_60;
		((word32) esp_7 - 8)->u0 = 9257552;
		word32 edi_1135;
		fn00715E50(*((word32) esp_7 - 4), out edi_1135);
		*((word32) esp_7 - 0x0C) = *((word32) esp_7 + 4);
		((word32) esp_7 - 16)->u0 = 0x008D4244;
		word32 edi_1136;
		fn00715E50(*((word32) esp_7 - 0x0C), out edi_1136);
		*((word32) esp_7 - 20) = *((word32) esp_7 + 8);
		((word32) esp_7 - 24)->u0 = 9257524;
		esi = fn00715E50(*((word32) esp_7 - 20), out edi);
	}
	struct Eq_66080 * esp_172;
	*((word32) esp_7 - 4) = esi;
	*((word32) esp_7 - 8) = edi;
	((word32) esp_7 - 0x0C)->u0 = 0x008D4228;
	word32 edx_1134;
	word32 ecx_1133;
	Eq_3 eax_119 = fn00715DD0(out ecx_1133, out edx_1134);
	if (eax_119 == 0x00)
	{
		((word32) esp_7 - 0x0C)->u0 = 0x008D41D4;
		word32 edx_1139;
		fn00716B20(out edx_1139);
		Eq_3 eax_141 = *((word32) esp_7 + 4);
		Eq_3 ecx_142 = *esp_7;
		*((word32) esp_7 - 16) = *((word32) esp_7 + 8);
		*((word32) esp_7 - 20) = eax_141;
		*((word32) esp_7 - 24) = ecx_142;
		fn006E8060(ebx, ebp, eax_119, edi, es, ds, *((word32) esp_7 - 24), *((word32) esp_7 - 20), *((word32) esp_7 - 16));
		esp_172 = esp_7 - 0x08;
		goto l006E8FD3;
	}
	Eq_3 eax_174 = *((word32) esp_7 + 8);
	if (eax_174 == 0x00)
		eax_174.u0 = 0x00A163B8;
	bool v37_950;
	Eq_3 ecx_181 = *esp_7;
	*((word32) esp_7 - 0x0C) = eax_174;
	*((word32) esp_7 - 16) = *((word32) esp_7 + 4);
	*((word32) esp_7 - 20) = ecx_181;
	((word32) esp_7 - 24)->u0 = 0x03;
	Eq_3 esi_195;
	word32 ecx_1140;
	word32 edx_1141;
	Eq_3 eax_192 = fn006DFF80(*((word32) esp_7 - 24), out ecx_1140, out edx_1141, out esi_195);
	((word32) esp_7 - 28)->u0 = 0x00;
	*((word32) esp_7 - 32) = eax_192;
	*((word32) esp_7 - 36) = esi_195;
	word32 edx_1143;
	word32 ecx_1142;
	Eq_3 eax_207 = fn00707680(*((word32) esp_7 - 36), *((word32) esp_7 - 32), *((word32) esp_7 - 28), out ecx_1142, out edx_1143, out esi, out edi);
	esp_172 = esp_7 - 0x08;
	if (eax_207 == 0x00)
	{
		*((word32) esp_7 - 0x0C) = g_tA16E04;
		esp_17 = esp_7 - 0x08;
		word32 edx_1153;
		word32 ecx_1152;
		if (fn006E1110(out ecx_1152, out edx_1153) != 0x00)
			goto l006E8C50;
		*((word32) esp_7 - 0x0C) = (word32) esp_7 + 20;
		*((word32) esp_7 - 16) = (word32) esp_7 + 16;
		*((word32) esp_7 - 20) = (word32) esp_7 + 0x0C;
		fn006E1130(*((word32) esp_7 - 20), *((word32) esp_7 - 16), *((word32) esp_7 - 0x0C));
		*((word32) esp_7 - 24) = (word32) esp_7 + 20;
		*((word32) esp_7 - 28) = (word32) esp_7 + 16;
		*((word32) esp_7 - 32) = (word32) esp_7 + 0x0C;
		word32 edi_1154;
		Eq_3 esi_267;
		fn006E1BD0(*((word32) esp_7 - 32), *((word32) esp_7 - 28), out ebp, out esi_267, out edi_1154);
		if (*((word32) esp_7 + 0x0C) == 0x00)
		{
			++g_dwA163B8;
			*((word32) esp_7 + 0x0C) = 0x00A163B8;
		}
		if (*((word32) esp_7 + 16) == 0x00)
		{
			++g_dwA163B8;
			*((word32) esp_7 + 16) = 0x00A163B8;
		}
		if (fn00707640(out ebx, out edi) != 0x00)
		{
			word32 ecx_1165;
			word32 edx_1166;
			fn006E1160(out ecx_1165, out edx_1166);
		}
		struct Eq_66677 * esp_316;
		word32 eax_317;
		_iob_func();
		esp_316->dwFFFFFFFC = eax_317 + 0x20;
		struct Eq_66686 * esp_326;
		MSVCR80.dll!fflush();
		esp_326->dwFFFFFFFC = 0x008D420C;
		word32 edx_1163;
		fn00716B20(out edx_1163);
		Eq_3 ecx_342 = esp_326->t001C;
		Eq_3 edx_343 = esp_326->t0018;
		esp_326->tFFFFFFF8 = esp_326->t0020;
		esp_326->tFFFFFFF4 = ecx_342;
		esp_326->tFFFFFFF0 = edx_343;
		fn006E8060(ebx, ebp, esi_267, edi, es, ds, esp_326->tFFFFFFF0, esp_326->tFFFFFFF4, esp_326->tFFFFFFF8);
		esp_326->dwFFFFFFEC = 0x008D41F0;
		word32 edx_1164;
		fn00716B20(out edx_1164);
		Eq_3 ecx_401 = esp_326->t0010;
		Eq_3 edx_402 = esp_326->t000C;
		esp_326->tFFFFFFE8 = esp_326->t0014;
		esp_326->tFFFFFFE4 = ecx_401;
		esp_326->tFFFFFFE0 = edx_402;
		fn006E8060(ebx, ebp, esi_267, edi, es, ds, esp_326->tFFFFFFE0, esp_326->tFFFFFFE4, esp_326->tFFFFFFE8);
		Eq_3 eax_418 = esp_326->t0018;
		*eax_418 = (word32) *eax_418 - 1;
		Eq_3 eax_421 = esp_326->t0018;
		esp_172 = (struct Eq_66080 *) ((const char *) &esp_326->t0000 + 4);
		if (*eax_421 == 0x00)
		{
			Eq_3 ecx_425 = *((word32) eax_421 + 4);
			<anonymous> * edx_426 = *((word32) ecx_425 + 24);
			esp_326->t0000 = eax_421;
			word32 esp_429;
			edx_426();
			esp_172 = esp_429 + 0x04;
		}
		Eq_3 eax_439 = esp_172->t0018;
		*eax_439 = (word32) *eax_439 - 1;
		Eq_3 eax_442 = esp_172->t0018;
		if (*eax_442 == 0x00)
		{
			Eq_3 ecx_445 = *((word32) eax_442 + 4);
			<anonymous> * edx_446 = *((word32) ecx_445 + 24);
			esp_172->tFFFFFFFC = eax_442;
			word32 esp_450;
			edx_446();
			esp_172 = esp_450 + 0x04;
		}
		Eq_3 eax_460 = esp_172->t001C;
		if (eax_460 == 0x00)
		{
l006E8F9B:
			if (edi != 0x00)
			{
				word32 v18_496 = (word32) *edi - 1;
				*edi = v18_496;
				if (v18_496 == 0x00)
				{
					Eq_3 eax_500 = *((word32) edi + 4);
					<anonymous> * ecx_501 = *((word32) eax_500 + 24);
					esp_172->tFFFFFFFC = edi;
					word32 esp_506;
					ecx_501();
					esp_172 = esp_506 + 0x04;
				}
			}
l006E8FD3:
			Eq_3 eax_516 = esp_172->t0008;
			if (eax_516 != 0x00)
			{
				*eax_516 = (word32) *eax_516 - 1;
				Eq_3 eax_522 = esp_172->t0008;
				if (*eax_522 == 0x00)
				{
					Eq_3 edx_525 = *((word32) eax_522 + 4);
					esp_172->tFFFFFFFC = eax_522;
					word32 esp_530;
					(*((word32) edx_525 + 24))();
					esp_172 = esp_530 + 0x04;
				}
			}
			Eq_3 eax_540 = esp_172->t000C;
			if (eax_540 != 0x00)
			{
				*eax_540 = (word32) *eax_540 - 1;
				Eq_3 eax_546 = esp_172->t000C;
				if (*eax_546 == 0x00)
				{
					Eq_3 ecx_549 = *((word32) eax_546 + 4);
					<anonymous> * edx_550 = *((word32) ecx_549 + 24);
					esp_172->tFFFFFFFC = eax_546;
					word32 esp_554;
					edx_550();
					esp_172 = esp_554 + 0x04;
				}
			}
			Eq_3 eax_564 = esp_172->t0010;
			if (eax_564 != 0x00)
			{
				*eax_564 = (word32) *eax_564 - 1;
				Eq_3 eax_570 = esp_172->t0010;
				if (*eax_570 == 0x00)
				{
					Eq_3 ecx_573 = *((word32) eax_570 + 4);
					<anonymous> * edx_574 = *((word32) ecx_573 + 24);
					esp_172->tFFFFFFFC = eax_570;
					word32 esp_578;
					edx_574();
					esp_172 = esp_578 + 0x04;
				}
			}
			edi = esp_172->t0000;
			esi = esp_172->t0004;
			goto l006E9035;
		}
		*eax_460 = (word32) *eax_460 - 1;
		eax_207 = esp_172->t001C;
		v37_950 = *eax_207 != 0x00;
	}
	else
	{
		Eq_3 v15_220 = (word32) *eax_207 - 1;
		*eax_207 = v15_220;
		v37_950 = v15_220 != 0x00;
	}
	if (!v37_950)
	{
		Eq_3 ecx_473 = *((word32) eax_207 + 4);
		<anonymous> * edx_474 = *((word32) ecx_473 + 24);
		esp_172->tFFFFFFFC = eax_207;
		word32 esp_480;
		edx_474();
		esp_172 = esp_480 + 0x04;
	}
	goto l006E8F9B;
}

// 006E9040: Register Eq_3 fn006E9040()
// Called from:
//      fn0070BCC0
Eq_3 fn006E9040()
{
	Eq_3 ebx_10 = 0x00;
	Eq_3 eax_14 = fn00740CC0();
	if (eax_14 == 0x00)
		return eax_14;
	Eq_3 eax_41 = fn006E8AC0(dwArg14);
	if (eax_41 != 0x00)
		ebx_10 = fn006E83E0(eax_41, dwArg0C, dwArg10);
	fn00740D60(eax_14);
	return ebx_10;
}

// 006E90B0: Register Eq_3 fn006E90B0(Stack Eq_3 dwArg04, Stack Eq_3 dwArg18)
// Called from:
//      fn0070BCC0
Eq_3 fn006E90B0(Eq_3 dwArg04, Eq_3 dwArg18)
{
	Eq_3 eax_8 = fn00740CC0();
	if (eax_8 == 0x00)
		return eax_8;
	Eq_3 eax_48 = fn006E8B50(dwArg1C, null);
	if (dwArg18 != 0x00)
		fclose(dwArg04);
	if (eax_48 != 0x00)
	{
		Eq_3 eax_85 = fn006E83E0(eax_48, dwArg10, dwArg14);
		fn00740D60(eax_8);
		return eax_85;
	}
	else
	{
		fn00740D60(eax_8);
		return 0x00;
	}
}

// 006E98A0: Register Eq_3 fn006E98A0(Register Eq_3 eax, Register int32 edi)
// Called from:
//      fn006E9BD0
//      fn006EA190
Eq_3 fn006E98A0(Eq_3 eax, int32 edi)
{
	Eq_3 esi_16 = eax;
	Eq_3 eax_107 = 0x00;
	int32 edx_10 = 0x00;
	while (edx_10 > 0x00 || (int32) (*esi_16) != edi)
	{
		struct Eq_67080 * ecx_24 = (int32) *esi_16;
		if (ecx_24 <= (struct Eq_67080 *) 0x7D)
		{
			switch ((word32) ecx_24->b6E9918)
			{
			case 0x00:
				word32 ecx_136;
				word32 edx_137;
				fn006E0F80(g_tA18720, 0x008D4508, out ecx_136, out edx_137);
				eax_107.u0 = ~0x00;
				return eax_107;
			case 0x01:
			case 0x02:
			case 0x03:
			case 0x04:
			case 0x05:
			case 0x06:
			case 0x07:
			case 0x08:
			case 0x0A:
			case 11:
			case 0x0C:
			case 0x0D:
			case 0x0E:
			case 0x0F:
			case 0x10:
			case 0x11:
			case 0x12:
			case 0x13:
			case 0x14:
			case 0x15:
			case 22:
			case 0x17:
			case 0x18:
			case 0x19:
			case 0x1A:
			case 0x1B:
			case 0x1C:
			case 0x1D:
			case 0x1E:
			case 0x1F:
			case 33:
			case 0x22:
			case 0x24:
			case 0x25:
			case 0x27:
			case 0x2A:
			case 0x2B:
			case 0x2D:
			case 0x2E:
			case 0x2F:
			case 0x30:
			case 0x31:
			case 0x32:
			case 0x33:
			case 0x34:
			case 0x35:
			case 0x36:
			case 55:
			case 0x38:
			case 0x39:
			case 0x3B:
			case 0x3C:
			case 0x3D:
			case 0x3E:
			case 0x3F:
			case 0x40:
			case 0x41:
			case 66:
			case 0x43:
			case 0x44:
			case 0x45:
			case 0x46:
			case 0x47:
			case 0x48:
			case 0x49:
			case 0x4A:
			case 0x4B:
			case 0x4C:
			case 77:
			case 0x4E:
			case 0x4F:
			case 0x50:
			case 0x51:
			case 0x52:
			case 0x53:
			case 0x54:
			case 0x55:
			case 0x56:
			case 0x57:
			case 88:
			case 0x59:
			case 0x5A:
			case 0x5C:
			case 0x5E:
			case 0x5F:
			case 0x60:
			case 0x61:
			case 0x62:
			case 99:
			case 100:
			case 101:
			case 0x66:
			case 0x67:
			case 0x68:
			case 0x69:
			case 0x6A:
			case 0x6B:
			case 0x6C:
			case 0x6D:
			case 110:
			case 111:
			case 0x70:
			case 113:
			case 114:
			case 115:
			case 116:
			case 117:
			case 118:
			case 0x77:
			case 0x78:
			case 121:
			case 122:
			case 0x7C:
				goto l006E98DF;
			case 0x09:
			case 0x20:
			case 0x23:
			case 0x26:
			case 44:
			case 0x3A:
				goto l006E98E6;
			case 0x28:
			case 0x5B:
			case 0x7B:
				if (edx_10 == 0x00)
					eax_107 = (word32) eax_107 + 1;
				++edx_10;
				esi_16 = (word32) esi_16 + 1;
				break;
			case 0x29:
			case 0x5D:
			case 0x7D:
				--edx_10;
				esi_16 = (word32) esi_16 + 1;
				break;
			}
		}
		else
		{
l006E98DF:
			if (edx_10 == 0x00)
				eax_107 = (word64) eax_107.u0 + 1;
l006E98E6:
			esi_16 = (word32) esi_16 + 1;
		}
	}
	return eax_107;
}

// 006E99A0: Register Eq_3 fn006E99A0(Stack Eq_3 dwArg04, Stack int32 dwArg0C, Stack Eq_3 dwArg10)
// Called from:
//      fn006E9BD0
Eq_3 fn006E99A0(Eq_3 dwArg04, int32 dwArg0C, Eq_3 dwArg10)
{
	word32 ebp_105 = 0x00;
	if (dwArg10 < 0x00)
		return 0x00;
	word32 ecx_442;
	word32 edx_443;
	Eq_3 eax_16 = fn006FDCC0(out ecx_442, out edx_443);
	Eq_3 edx_21 = eax_16;
	if (eax_16 == 0x00)
		return 0x00;
	struct Eq_67148 * esp_114 = fp - 0x18;
	if (dwArg10 > 0x00)
	{
		do
		{
			Eq_3 edi_36 = esp_114[11];
			Eq_3 ebx_37 = esp_114[8];
			word32 eax_38 = esp_114[7];
			struct Eq_67178 * esp_39 = esp_114 - 4;
			esp_39->t0000 = edi_36;
			esp_39->tFFFFFFFC = ebx_37;
			esp_39->dwFFFFFFF8 = eax_38;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg4 = <invalid>;
			Eq_3 stackArg8 = <invalid>;
			Eq_3 stackArg12 = <invalid>;
			Eq_3 eax_49 = fn006E9BD0(stackArg4, stackArg8, stackArg12);
			Eq_3 esi_54 = eax_49;
			if (eax_49 == 0x00)
			{
				++g_dwA163B8;
				ebp_105 = 0x01;
				esi_54.u0 = 0x00A163B8;
			}
			word32 ecx_66 = esp_39->dw0020;
			esp_39->t0000 = edi_36;
			esp_39->tFFFFFFFC = ebx_37;
			esp_39->dwFFFFFFF8 = ecx_66;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg4 = <invalid>;
			Eq_3 stackArg8 = <invalid>;
			Eq_3 stackArg12 = <invalid>;
			Eq_3 eax_79 = fn006E9BD0(stackArg4, stackArg8, stackArg12);
			Eq_3 edi_84 = eax_79;
			if (eax_79 == 0x00)
			{
				++g_dwA163B8;
				ebp_105 = 0x01;
				edi_84.u0 = 0x00A163B8;
			}
			word32 edx_96 = esp_39->dw0014;
			esp_39->t0000 = edi_84;
			esp_39->tFFFFFFFC = esi_54;
			esp_39->dwFFFFFFF8 = edx_96;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg4 = <invalid>;
			Eq_3 stackArg8 = <invalid>;
			Eq_3 stackArg12 = <invalid>;
			word32 edi_456;
			word32 ebx_455;
			word32 edx_454;
			word32 ecx_453;
			Eq_3 eax_109 = fn006FBD90(stackArg4, stackArg8, stackArg12, out ecx_453, out edx_454, out ebx_455, out edi_456);
			word32 v18_115 = (word32) *esi_54.u0 - 1;
			*esi_54.u0 = v18_115;
			esp_114 = (struct Eq_67148 *) ((const char *) &esp_39->t0000 + 4);
			if (v18_115 == 0x00)
			{
				Eq_3 eax_120 = *((word64) esi_54.u0 + 4);
				<anonymous> * ecx_121 = *((word32) eax_120 + 24);
				esp_39->t0000 = esi_54;
				word32 esp_124;
				word32 edx_126;
				word32 ecx_127;
				ecx_121();
				esp_114 = esp_124 + 0x04;
			}
			word32 v19_134 = (word32) *edi_84.u0 - 1;
			*edi_84.u0 = v19_134;
			if (v19_134 == 0x00)
			{
				Eq_3 edx_138 = *((word64) edi_84.u0 + 4);
				<anonymous> * eax_139 = *((word32) edx_138 + 24);
				esp_114->dwFFFFFFFC = (word32) edi_84;
				word32 esp_147;
				word32 ecx_150;
				eax_139();
				esp_114 = esp_147 + 0x04;
			}
			if (eax_109 < 0x00 || ebp_105 != 0x00)
			{
				struct Eq_67387 * eax_167 = esp_114[4];
				word32 v20_168 = eax_167->dw0000 + ~0x00;
				eax_167->dw0000 = v20_168;
				if (v20_168 == 0x00)
				{
					struct Eq_67422 * ecx_172 = eax_167->ptr0004;
					<anonymous> * edx_173 = ecx_172->ptr0018;
					esp_114->dwFFFFFFFC = eax_167;
					word32 edx_186;
					edx_173();
				}
				return 0x00;
			}
			word32 eax_205 = esp_114[5];
			esp_114[5] = (struct Eq_67148) (eax_205 + 0x02);
		} while (eax_205 + 0x02 < esp_114[0x0A]);
		edx_21 = esp_114[4];
	}
	Eq_3 eax_214 = *dwArg04;
	ptr32 esp_211 = fp - 24;
	if ((int32) *eax_214 == dwArg0C)
	{
		if (dwArg0C != 0x00)
			*dwArg04 = (word32) eax_214 + 1;
		return edx_21;
	}
	else
	{
		word32 v17_240 = (word32) *edx_21 - 1;
		*edx_21 = v17_240;
		if (v17_240 == 0x00)
		{
			Eq_3 eax_244 = *((word32) edx_21 + 4);
			word32 esp_251;
			word32 edx_253;
			word32 ecx_254;
			(*((word32) eax_244 + 24))();
			esp_211 = esp_251 + 0x04;
		}
		Eq_3 edx_260 = g_tA18720;
		struct Eq_67305 * esp_262 = esp_211 - 4;
		esp_262->dw0000 = 0x008D4524;
		esp_262->tFFFFFFFC = edx_260;
		esp_262->dw0014 = 0x00;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_3 stackArg4 = <invalid>;
		word32 ecx_458;
		word32 edx_459;
		fn006E0F80(stackArg4, dwArg04, out ecx_458, out edx_459);
		return eax_16;
	}
}

// 006E9B00: Register Eq_3 fn006E9B00(Register Eq_3 edi, Stack Eq_3 dwArg04, Stack int32 dwArg0C)
// Called from:
//      fn006E9BD0
Eq_3 fn006E9B00(Eq_3 edi, Eq_3 dwArg04, int32 dwArg0C)
{
	word32 ebp_45 = 0x00;
	if (edi < 0x00)
		return 0x00;
	word32 edx_282;
	Eq_3 eax_18 = fn006F2650(edi, out edx_282);
	if (eax_18 == 0x00)
		return eax_18;
	Eq_3 esi_31 = 0x00;
	if (edi > 0x00)
	{
		do
		{
			Eq_3 eax_51 = fn006E9BD0(dwArg04, dwArg08, dwArg10);
			if (eax_51 == 0x00)
			{
				++g_dwA163B8;
				ebp_45 = 0x01;
				eax_51.u0 = 0x00A163B8;
			}
			*((word32) *((word32) eax_18 + 0x0C) + esi_31 * 0x04) = eax_51;
			esi_31 = (word32) esi_31 + 1;
		} while (esi_31 < edi);
		if (ebp_45 != 0x00)
		{
			Eq_3 v17_153 = (word32) *eax_18 - 1;
			*eax_18 = v17_153;
			if (v17_153 == 0x00)
			{
				Eq_3 edx_157 = *((word32) eax_18 + 4);
				word32 ecx_164;
				(*((word32) edx_157 + 24))();
			}
			return 0x00;
		}
	}
	Eq_3 eax_83 = *dwArg04;
	ptr32 esp_123 = fp - 0x0C;
	if ((int32) *eax_83 == dwArg0C)
	{
		if (dwArg0C != 0x00)
			*dwArg04 = (word32) eax_83 + 1;
		return eax_18;
	}
	else
	{
		Eq_3 v15_105 = (word32) *eax_18 - 1;
		*eax_18 = v15_105;
		if (v15_105 == 0x00)
		{
			Eq_3 ecx_109 = *((word32) eax_18 + 4);
			word32 esp_117;
			word32 edx_119;
			(*((word32) ecx_109 + 24))();
			esp_123 = esp_117 + 0x04;
		}
		Eq_3 eax_126 = g_tA18720;
		struct Eq_67490 * esp_128 = esp_123 - 4;
		esp_128->dw0000 = 0x008D4524;
		esp_128->tFFFFFFFC = eax_126;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_3 stackArg4 = <invalid>;
		word32 ecx_284;
		word32 edx_285;
		fn006E0F80(stackArg4, dwArg04, out ecx_284, out edx_285);
		return 0x00;
	}
}

// 006E9BD0: Register Eq_3 fn006E9BD0(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Stack Eq_3 dwArg0C)
// Called from:
//      fn006E99A0
//      fn006E9B00
//      fn006EA0A0
//      fn006EA190
Eq_3 fn006E9BD0(Eq_3 dwArg04, Eq_3 dwArg08, Eq_3 dwArg0C)
{
	Eq_3 eax_8 = *dwArg04;
	Eq_67568 ecx_9 = (int32) *eax_8;
	*dwArg04 = (word32) eax_8 + 1;
	struct Eq_67578 * eax_12 = ecx_9 - 0x09;
	if (ecx_9 <= 0x7B)
	{
l006E9BF0:
		switch ((word32) eax_12->b6E9F20)
		{
		case 0x00:
		case 0x17:
		case 0x23:
		case 0x31:
			Eq_3 eax_603 = *dwArg04;
			Eq_67601 ecx_604 = (int32) *eax_603;
			*dwArg04 = (word32) eax_603 + 1;
			eax_12 = ecx_604 - 0x09;
			if (ecx_604 <= 0x7B)
				goto l006E9BF0;
			break;
		case 0x01:
		case 0x02:
		case 0x03:
		case 0x04:
		case 0x05:
		case 0x06:
		case 0x07:
		case 0x08:
		case 0x09:
		case 0x0A:
		case 11:
		case 0x0C:
		case 0x0D:
		case 0x0E:
		case 0x0F:
		case 0x10:
		case 0x11:
		case 0x12:
		case 0x13:
		case 0x14:
		case 0x15:
		case 22:
		case 0x18:
		case 0x19:
		case 0x1A:
		case 0x1B:
		case 0x1C:
		case 0x1D:
		case 0x1E:
		case 0x20:
		case 33:
		case 0x22:
		case 0x24:
		case 0x25:
		case 0x26:
		case 0x27:
		case 0x28:
		case 0x29:
		case 0x2A:
		case 0x2B:
		case 44:
		case 0x2D:
		case 0x2E:
		case 0x2F:
		case 0x30:
		case 0x32:
		case 0x33:
		case 0x34:
		case 0x35:
		case 0x36:
		case 55:
		case 0x38:
		case 0x3A:
		case 0x3C:
		case 0x3D:
		case 0x3E:
		case 0x41:
		case 0x44:
		case 0x47:
		case 0x48:
		case 0x49:
		case 0x4B:
		case 0x4C:
		case 77:
		case 0x4E:
		case 0x4F:
		case 0x50:
		case 0x51:
		case 0x53:
		case 0x54:
		case 0x55:
		case 0x56:
		case 0x57:
		case 88:
		case 0x5C:
		case 0x5E:
		case 0x61:
		case 100:
		case 0x66:
		case 0x67:
		case 0x68:
		case 0x69:
		case 0x6B:
		case 0x6D:
		case 110:
		case 111:
		case 0x70:
			break;
		case 0x1F:
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg20 = <invalid>;
			return fn006EA0A0(dwArg04, dwArg04, 0x29, fn006E98A0(*dwArg04, 0x29), stackArg20);
		case 0x39:
		case 0x59:
		case 0x5F:
		case 0x60:
			*dwArg08 = (word32) *dwArg08 + 4;
			goto l006E9CA3;
		case 0x3B:
			*dwArg08 = (word32) *dwArg08 + 4;
			Eq_3 eax_512 = *((word32) *dwArg08 - 4);
			word32 edx_941;
			return fn007331D0(*eax_512, *((word32) eax_512 + 4), *((word32) eax_512 + 8), *((word32) eax_512 + 0x0C), out edx_941);
		case 0x3F:
			*dwArg08 = (word32) *dwArg08 + 4;
			word32 ecx_942;
			word32 edx_943;
			return fn007050A0(*((word32) *dwArg08 - 4), out ecx_942, out edx_943);
		case 0x40:
		case 0x62:
			*dwArg08 = (word32) *dwArg08 + 4;
			Eq_3 esi_465 = *((word32) *dwArg08 - 4);
			if (esi_465 <= fn00705040())
			{
l006E9CA3:
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_3 stackArg4 = <invalid>;
				word32 edx_956;
				word32 ecx_955;
				return fn007050A0(stackArg4, out ecx_955, out edx_956);
			}
			else
			{
				word32 edx_957;
				return fn00710730(esi_465, out edx_957);
			}
		case 66:
			*dwArg08 = (word32) *dwArg08 + 8;
			Eq_3 eax_439 = *dwArg08;
			return fn00711400(*((word32) eax_439 - 8), *((word32) eax_439 - 4));
		case 0x43:
			*dwArg08 = (word32) *dwArg08 + 8;
			Eq_3 eax_416 = *dwArg08;
			return fn00711330(*((word32) eax_416 - 8), *((word32) eax_416 - 4));
		case 0x45:
		case 0x46:
		case 0x4A:
			if (**dwArg04 == 0x26)
			{
				*dwArg08 = (word32) *dwArg08 + 4;
				Eq_3 ecx_389 = *dwArg08;
				Eq_3 edx_390 = *((word32) ecx_389 - 4);
				*dwArg08 = (word32) ecx_389 + 4;
				word32 ecx_393 = *ecx_389;
				*dwArg04 = (word32) *dwArg04 + 1;
				Eq_3 eax_401;
				word32 edx_403;
				edx_390();
				return eax_401;
			}
			*dwArg08 = (word32) *dwArg08 + 4;
			Eq_3 edi_346 = *((word32) *dwArg08 - 4);
			if (edi_346 != 0x00)
			{
				if (*((word32) *dwArg04 - 1) != 0x4E)
				{
					*edi_346 = (word32) *edi_346 + 1;
					return edi_346;
				}
			}
			else if (fn006E0FC0() == 0x00)
			{
				word32 edx_959;
				word32 ecx_958;
				fn006E0F80(g_tA18720, 0x008D4540, out ecx_958, out edx_959);
			}
			return edi_346;
		case 0x52:
			return fn006E9B00(fn006E98A0(*dwArg04, 0x5D), dwArg04, 0x5D);
		case 0x5A:
			*dwArg08 = (word32) *dwArg08 + 4;
			word32 ecx_944;
			word32 edx_945;
			return fn006EC9B0(fp + 0x04, 0x01, out ecx_944, out edx_945);
		case 0x5B:
		case 0x5D:
			*dwArg08 = (word32) *dwArg08 + 8;
			word32 edx_946;
			return fn006FF060(*((word32) *dwArg08 - 8), out edx_946);
		case 99:
		case 101:
			*dwArg08 = (word32) *dwArg08 + 4;
			word32 ecx_947;
			word32 edx_948;
			return fn007050A0(*((word32) *dwArg08 - 4), out ecx_947, out edx_948);
		case 0x6A:
		case 113:
			Eq_3 eax_139;
			*dwArg08 = (word32) *dwArg08 + 4;
			Eq_3 edi_134 = *((word32) *dwArg08 - 4);
			Eq_3 ecx_136 = *dwArg04;
			if (*ecx_136 == 0x23)
			{
				*dwArg04 = (word32) ecx_136 + 1;
				*dwArg08 = (word32) *dwArg08 + 4;
				eax_139 = *((word32) *dwArg08 - 4);
			}
			else
				eax_139.u0 = ~0x00;
			if (edi_134 == 0x00)
				goto l006E9D60;
			if (eax_139 < 0x00)
			{
				Eq_3 eax_169 = edi_134;
				do
				{
					eax_169 = (word32) eax_960 + 1;
					eax_960 = eax_169;
				} while (*eax_960 != 0x00);
				eax_139 = eax_169 - ((word32) edi_134 + 1);
				if (eax_139 > 0x7FFFFFFF)
				{
					word32 edx_952;
					word32 ecx_951;
					fn006E0F80(g_tA18598, 0x008D4564, out ecx_951, out edx_952);
					return 0x00;
				}
			}
			word32 edx_950;
			word32 ecx_949;
			return fn006EC9B0(edi_134, eax_139, out ecx_949, out edx_950);
		case 0x6C:
			Eq_3 ecx_100;
			*dwArg08 = (word32) *dwArg08 + 4;
			Eq_3 edx_60 = *((word32) *dwArg08 - 4);
			Eq_3 ecx_61 = *dwArg04;
			if (*ecx_61 == 0x23)
			{
				*dwArg04 = (word32) ecx_61 + 1;
				*dwArg08 = (word32) *dwArg08 + 4;
				ecx_100 = *((word32) *dwArg08 - 4);
			}
			else
				ecx_100.u0 = ~0x00;
			if (edx_60 != 0x00)
			{
				if (ecx_100 < 0x00)
				{
					ecx_100.u0 = 0x00;
					Eq_3 eax_86 = edx_60;
					if (*edx_60 != 0x00)
					{
						do
						{
							eax_86 = (word32) eax_86 + 2;
							ecx_100 = (word64) ecx_100.u0 + 1;
						} while (*eax_86 != 0x00);
					}
				}
				word32 edx_953;
				return fn00717A20(edx_60, ecx_100, out edx_953);
			}
			else
			{
l006E9D60:
				++g_dwA163B8;
				return 0x00A163B8;
			}
		case 114:
			return fn006E99A0(dwArg04, 0x7D, fn006E98A0(*dwArg04, 0x7D));
		}
	}
	word32 edx_939;
	word32 ecx_938;
	fn006E0F80(g_tA18720, 0x008D4588, out ecx_938, out edx_939);
	return 0x00;
}

// 006E9FA0: Register word32 fn006E9FA0(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Stack Eq_3 dwArg0C)
// Called from:
//      fn006EA080
word32 fn006E9FA0(Eq_3 dwArg04, Eq_3 dwArg08, Eq_3 dwArg0C)
{
	Eq_3 eax_8 = *((word32) dwArg04 + 4);
	if (eax_8 != 10622400)
	{
		word32 edx_248;
		word32 ecx_247;
		if (fn006D5670(eax_8, 10622400, out ecx_247, out edx_248) == 0x00)
		{
			word32 edx_250;
			word32 ecx_249;
			fn006E0F80(g_tA16B7C, 9258488, out ecx_249, out edx_250);
			return ~0x00;
		}
	}
	if (dwArg0C != 0x00)
	{
		word32 ecx_251;
		word32 edx_252;
		Eq_3 eax_40 = fn00717230(dwArg04, out ecx_251, out edx_252);
		if (eax_40 != 0x00)
		{
			word32 ecx_255;
			word32 edx_256;
			word32 esi_257;
			if (fn006FD8F0(eax_40, dwArg04, dwArg0C, out ecx_255, out edx_256, out esi_257) != 0x00)
				return ~0x00;
			word32 v12_66 = (word32) *dwArg0C - 1;
			*dwArg0C = v12_66;
			if (v12_66 == 0x00)
			{
				Eq_3 edx_70 = *((word32) dwArg0C + 4);
				word32 ecx_76;
				(*((word32) edx_70 + 24))();
			}
			return 0x00;
		}
		else
		{
			fn00717280(dwArg04);
			word32 ecx_258;
			word32 edx_259;
			fn006E15D0(g_tA18720, dwArg04, out ecx_258, out edx_259);
			return ~0x00;
		}
	}
	else
	{
		if (fn006E0FC0() == 0x00)
		{
			word32 edx_254;
			word32 ecx_253;
			fn006E0F80(g_tA16B7C, 9258444, out ecx_253, out edx_254);
		}
		return ~0x00;
	}
}

// 006EA080: Register word32 fn006EA080()
// Called from:
//      fn0074F9E0
word32 fn006EA080()
{
	word32 ecx_30;
	word32 edx_31;
	fn006ECAC0(dwArg0C, out ecx_30, out edx_31);
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_3 stackArg4 = <invalid>;
	Eq_3 stackArg8 = <invalid>;
	return fn006E9FA0(stackArg4, stackArg8, dwArg0C);
}

// 006EA0A0: Register Eq_3 fn006EA0A0(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Stack int32 dwArg0C, Stack Eq_3 dwArg10, Stack Eq_3 dwArg14)
// Called from:
//      fn006E9BD0
//      fn006EA190
Eq_3 fn006EA0A0(Eq_3 dwArg04, Eq_3 dwArg08, int32 dwArg0C, Eq_3 dwArg10, Eq_3 dwArg14)
{
	Eq_3 esi_10 = dwArg10;
	word32 dwLoc04_209 = 0x00;
	if (dwArg10 < 0x00)
		return 0x00;
	word32 ecx_324;
	word32 edx_325;
	Eq_3 eax_22 = fn006DFD20(dwArg10, out ecx_324, out edx_325);
	Eq_3 edi_106 = eax_22;
	if (eax_22 == 0x00)
		return 0x00;
	if (dwArg10 > 0x00)
	{
		word32 * edi_42 = (word32) eax_22 + 0x0C;
		do
		{
			Eq_3 eax_61 = fn006E9BD0(dwArg04, dwArg08, dwArg14);
			if (eax_61 == 0x00)
			{
				++g_dwA163B8;
				dwLoc04_209 = 0x01;
				eax_61.u0 = 0x00A163B8;
			}
			*edi_42 = (word32) eax_61;
			++edi_42;
			--esi_10;
		} while (esi_10 != 0x00);
		if (dwLoc04_209 != 0x00)
		{
			Eq_3 v17_169 = (word32) *dwArg10 - 1;
			*dwArg10 = v17_169;
			if (v17_169 == 0x00)
			{
				Eq_3 ecx_173 = *((word32) dwArg10 + 4);
				word32 edx_180;
				(*((word32) ecx_173 + 24))();
			}
			return 0x00;
		}
		edi_106 = dwArg10;
	}
	Eq_3 eax_94 = *dwArg04;
	ptr32 esp_134 = fp - 0x0C;
	if ((int32) *eax_94 == dwArg0C)
	{
		if (dwArg0C != 0x00)
			*dwArg04 = (word32) eax_94 + 1;
		return edi_106;
	}
	else
	{
		word32 v16_116 = (word32) *edi_106 - 1;
		*edi_106 = v16_116;
		if (v16_116 == 0x00)
		{
			Eq_3 eax_120 = *((word32) edi_106 + 4);
			<anonymous> * ecx_121 = *((word32) eax_120 + 24);
			word32 esp_128;
			word32 edx_131;
			ecx_121();
			esp_134 = esp_128 + 0x04;
		}
		Eq_3 edx_137 = g_tA18720;
		struct Eq_68295 * esp_139 = esp_134 - 4;
		esp_139->dw0000 = 0x008D4524;
		esp_139->tFFFFFFFC = edx_137;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_3 stackArg4 = <invalid>;
		word32 edx_328;
		word32 ecx_327;
		fn006E0F80(stackArg4, dwArg04, out ecx_327, out edx_328);
		return 0x00;
	}
}

// 006EA190: Register Eq_3 fn006EA190()
// Called from:
//      fn006EA200
//      fn006EA240
//      fn006EA260
Eq_3 fn006EA190()
{
	Eq_3 eax_14 = fn006E98A0(eax, 0x00);
	if (eax_14 < 0x00)
		return 0x00;
	if (eax_14 != 0x00)
	{
		if (eax_14 != 0x01)
		{
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg20 = <invalid>;
			return fn006EA0A0(fp - 0x04, fp - 0x08, 0x00, eax_14, stackArg20);
		}
		else
		{
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_3 stackArg12 = <invalid>;
			return fn006E9BD0(fp - 0x04, fp - 0x08, stackArg12);
		}
	}
	else
	{
		++g_dwA163B8;
		return 0x00A163B8;
	}
}

// 006EA200: Register word32 fn006EA200(Register out Eq_540 edxOut, Register out ptr32 esiOut)
// Called from:
//      fn00651DD0
//      fn006E1260
//      fn006E1400
//      fn006E8430
//      fn006F8960
//      fn006F9120
//      fn00728360
//      fn0072EC10
//      fn0073B830
//      fn0073B870
//      fn0073C100
//      fn0073CAE0
//      fn0073DBD0
//      fn0073EB70
//      fn0073F9D0
//      fn0073FAF0
//      fn0073FC30
word32 fn006EA200(union Eq_540 & edxOut, ptr32 & esiOut)
{
	word32 eax_15 = fn006EA190();
	edxOut.u0 = <invalid>;
	esiOut = esi;
	return eax_15;
}

// 006EA240: void fn006EA240()
// Called from:
//      fn00703800
//      fn007038E0
void fn006EA240()
{
	fn006EA190();
}

// 006EA260: void fn006EA260()
// Called from:
//      fn00703870
void fn006EA260()
{
	fn006EA190();
}

// 006EA420: Register word32 fn006EA420(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Stack Eq_3 dwArg0C, Register out ptr32 edxOut)
// Called from:
//      fn006ECC00
//      fn006ECC50
//      fn006F1AA0
//      fn0070BCC0
word32 fn006EA420(Eq_3 dwArg04, Eq_3 dwArg08, Eq_3 dwArg0C, ptr32 & edxOut)
{
	if (dwArg08 == 0x00)
	{
		ptr32 edx_162;
		fn006E1DC0(out edx_162);
		edxOut = edx_162;
		return ~0x00;
	}
	Eq_3 esi_14 = dwArg04;
	Eq_3 eax_15 = *((word32) dwArg04 + 4);
	if (eax_15 != 0x00A1B450)
	{
		word32 ecx_251;
		if (fn006D5670(eax_15, 0x00A1B450, out ecx_251, out edx) == 0x00)
		{
			Eq_3 eax_33 = *((word32) dwArg04 + 4);
			if (eax_33 != 0x00A23B20)
			{
				word32 ecx_253;
				word32 edx_254;
				if (fn006D5670(eax_33, 0x00A23B20, out ecx_253, out edx_254) == 0x00)
				{
					ptr32 edx_144;
					word32 ecx_255;
					fn006E15D0(g_tA16B7C, 0x008D484C, out ecx_255, out edx_144);
					edxOut = edx_144;
					return ~0x00;
				}
			}
			word32 ecx_252;
			Eq_3 eax_60 = fn0071FC50(dwArg04, 0x00, out ecx_252, out edx);
			esi_14 = eax_60;
			if (eax_60 == 0x00)
				goto l006EA4F4;
		}
	}
	byte * eax_76 = (word32) esi_14 + 20;
	*dwArg08 = eax_76;
	if (dwArg0C != 0x00)
	{
		*dwArg0C = *((word32) esi_14 + 8);
		goto l006EA4C1;
	}
	edx = eax_76 + 1;
	eax_82 = eax_76;
	do
	{
		byte * eax_82;
		eax_82 = eax_257 + 1;
		eax_257 = eax_82;
	} while (*eax_257 != 0x00);
	if (eax_82 - (eax_76 + 1) == *((word32) esi_14 + 8))
	{
l006EA4C1:
		edxOut = edx;
		return 0x00;
	}
	word32 ecx_256;
	fn006E0F80(g_tA16B7C, dwArg04, out ecx_256, out edx);
l006EA4F4:
	edxOut = edx;
	return ~0x00;
}

// 006EA9D0: Register Eq_3 fn006EA9D0(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Register out (ptr32 Eq_68595) edxOut)
// Called from:
//      fn006EC440
Eq_3 fn006EA9D0(Eq_3 dwArg04, Eq_3 dwArg08, union Eq_68595 & edxOut)
{
	Eq_3 eax_8 = *((word32) dwArg08 + 4);
	if (eax_8 != 0x00A1B450)
	{
		word32 ecx_448;
		if (fn006D5670(eax_8, 0x00A1B450, out ecx_448, out edx) == 0x00)
		{
			Eq_3 eax_253 = *((word32) dwArg08 + 4);
			if (eax_253 != 0x00A23B20)
			{
				word32 ecx_449;
				word32 edx_450;
				if (fn006D5670(eax_253, 0x00A23B20, out ecx_449, out edx_450) == 0x00)
				{
					union Eq_68595 * edx_307;
					word32 ecx_451;
					fn006E15D0(g_tA16B7C, 0x008D48D0, out ecx_451, out edx_307);
					edxOut = edx_307;
					return 0x00;
				}
			}
			union Eq_68595 * edx_286;
			Eq_3 eax_284 = fn00721290(dwArg04, dwArg08, out edx_286);
			edxOut = edx_286;
			return eax_284;
		}
	}
	Eq_3 eax_36 = *((word32) dwArg04 + 8);
	if ((eax_36 == 0x00 || *((word32) dwArg08 + 8) == 0x00) && (*((word32) dwArg04 + 4) == 0x00A1B450 && *((word32) dwArg08 + 4) == 0x00A1B450))
	{
		if (eax_36 != 0x00)
		{
			*dwArg04 = (word32) *dwArg04 + 1;
			edxOut = edx;
			return dwArg04;
		}
		else
		{
			*dwArg08 = (word32) *dwArg08 + 1;
			edxOut = edx;
			return dwArg08;
		}
	}
	else
	{
		word32 ebp_64 = Mem59[dwArg08 + 0x08:word32] + eax_36;
		if (ebp_64 >= 0x00)
		{
			word32 ecx_452;
			word32 edx_453;
			Eq_3 eax_71 = fn00723860((word32) ebp_64 + 24, out ecx_452, out edx_453);
			if (eax_71 != 0x00)
			{
				*((word32) eax_71 + 8) = ebp_64;
				((word32) eax_71 + 4)->u0 = 0x00A1B450;
				*eax_71 = 0x01;
				((word32) eax_71 + 0x0C)->u0 = ~0x00;
				*((word32) eax_71 + 16) = 0x00;
				Eq_3 eax_89 = *((word32) dwArg04 + 8);
				word32 ecx_102 = eax_71 + 0x14;
				if (eax_89 >= 0x10)
					memcpy(eax_71 + 0x14, dwArg04 + 0x14, eax_89);
				else if (eax_89 > 0x00)
				{
					word32 edx_98 = dwArg04 + 0x14 - (eax_71 + 0x14);
					Eq_3 ebp_100 = eax_89;
					do
					{
						*ecx_102 = ecx_102[edx_98];
						++ecx_102;
						--ebp_100;
					} while (ebp_100 != 0x00);
				}
				Eq_3 ecx_128 = *((word32) dwArg08 + 8);
				Eq_3 eax_132 = (word32) eax_71 + ((word32) (*((word32) dwArg04 + 8)) + 20);
				word32 edx_133 = dwArg08 + 0x14;
				if (ecx_128 < 0x10)
				{
					if (ecx_128 > 0x00)
					{
						edx_133 = dwArg08 + 0x14 - eax_132;
						Eq_3 edi_141 = ecx_128;
						do
						{
							Mem146[eax_132 + 0x00:byte] = Mem144[edx_133 + eax_132:byte];
							++eax_132;
							--edi_141;
						} while (edi_141 != 0x00);
					}
					Mem157[eax_71 + 0x14 + ebp_64:byte] = 0x00;
					edxOut = edx_133;
					return eax_71;
				}
				else
				{
					memcpy(eax_132, dwArg08 + 0x14, ecx_128);
					Mem179[eax_71 + 0x14 + ebp_64:byte] = 0x00;
					edxOut = dwArg08 + 0x14;
					return eax_71;
				}
			}
			else
			{
				union Eq_68595 * edx_203;
				word32 ecx_455;
				Eq_3 eax_201 = fn006E1210(out ecx_455, out edx_203);
				edxOut = edx_203;
				return eax_201;
			}
		}
		else
		{
			union Eq_68595 * edx_215;
			word32 ecx_454;
			fn006E0F80(g_tA18598, 0x008D48B0, out ecx_454, out edx_215);
			edxOut = edx_215;
			return 0x00;
		}
	}
}

// 006EC440: Register word32 fn006EC440(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08)
// Called from:
//      fn006EC4C0
//      fn00708410
word32 fn006EC440(Eq_3 dwArg04, Eq_3 dwArg08)
{
	Eq_3 eax_8 = *dwArg04;
	if (eax_8 == 0x00)
		return edx;
	if (dwArg08 != 0x00)
	{
		Eq_3 eax_19 = *((word32) eax_8 + 4);
		if (eax_19 == 0x00A1B450)
		{
l006EC470:
			word32 edx_100;
			Eq_3 eax_80 = fn006EA9D0(*dwArg04, dwArg08, out edx_100);
			Eq_3 eax_86 = *dwArg04;
			*eax_86 = (word32) *eax_86 - 1;
			Eq_3 eax_89 = *dwArg04;
			if (*eax_89 == 0x00)
			{
				Eq_3 ecx_93 = *((word32) eax_89 + 4);
				(*((word32) ecx_93 + 24))();
			}
			*dwArg04 = eax_80;
			return edx_100;
		}
		word32 ecx_194;
		if (fn006D5670(eax_19, 0x00A1B450, out ecx_194, out edx) != 0x00)
			goto l006EC470;
	}
	Eq_3 eax_39 = *dwArg04;
	*eax_39 = (word32) *eax_39 - 1;
	Eq_3 eax_42 = *dwArg04;
	if (*eax_42 == 0x00)
	{
		Eq_3 ecx_45 = *((word32) eax_42 + 4);
		(*((word32) ecx_45 + 24))();
	}
	dwArg04->u0 = 0x00;
	return edx;
}

// 006EC4C0: Register word32 fn006EC4C0(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08)
// Called from:
//      fn0073D660
word32 fn006EC4C0(Eq_3 dwArg04, Eq_3 dwArg08)
{
	word32 edx_17 = fn006EC440(dwArg04, dwArg08);
	if (dwArg08 != 0x00)
	{
		word32 v9_24 = (word32) *dwArg08 - 1;
		*dwArg08 = v9_24;
		if (v9_24 == 0x00)
		{
			Eq_3 ecx_28 = *((word32) dwArg08 + 4);
			(*((word32) ecx_28 + 24))();
		}
	}
	return edx_17;
}

// 006EC4F0: Register word32 fn006EC4F0(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Register out Eq_3 ecxOut, Register out Eq_68854 edxOut)
// Called from:
//      fn006F1AA0
//      fn006F2090
//      fn00708410
//      fn007189B0
//      fn0071A060
//      fn0071A9F0
//      fn007286D0
//      fn007288B0
//      fn0072A350
//      fn00735640
word32 fn006EC4F0(Eq_3 dwArg04, Eq_3 dwArg08, union Eq_3 & ecxOut, union Eq_68854 & edxOut)
{
	Eq_3 esi_11 = *dwArg04;
	Eq_3 eax_12 = *((word32) esi_11 + 4);
	if (eax_12 != 0x00A1B450)
	{
		word32 ecx_205;
		word32 edx_206;
		if (fn006D5670(eax_12, 0x00A1B450, out ecx_205, out edx_206) == 0x00)
		{
l006EC56D:
			dwArg04->u0 = 0x00;
			word32 v12_48 = (word32) *esi_11 - 1;
			*esi_11 = v12_48;
			ptr32 esp_54 = fp - 0x0C;
			if (v12_48 == 0x00)
			{
				Eq_3 ecx_52 = *((word32) esi_11 + 4);
				word32 esp_61;
				(*((word32) ecx_52 + 24))();
				esp_54 = esp_61 + 0x04;
			}
			struct Eq_68958 * esp_70 = esp_54 - 4;
			esp_70->dw0000 = 0x100D;
			esp_70->dwFFFFFFFC = 9259132;
			Eq_68854 edx_81;
			ecxOut = fn006E1DC0(out edx_81);
			edxOut = edx_81;
			return ~0x00;
		}
	}
	if (*esi_11 == 0x01 && (dwArg08 >= 0x00 && *((word32) esi_11 + 16) == 0x00))
	{
		Eq_3 ecx_100;
		Eq_68854 edx_101;
		Eq_3 eax_99 = fn00723B60(esi_11, (word32) dwArg08 + 24, out ecx_100, out edx_101);
		*dwArg04 = eax_99;
		if (eax_99 != 0x00)
		{
			*eax_99 = 0x01;
			Eq_3 eax_112 = *dwArg04;
			*((word32) eax_112 + 8) = dwArg08;
			*((word32) dwArg08 + ((word32) eax_112 + 20)) = 0x00;
			((word32) eax_112 + 0x0C)->u0 = ~0x00;
			ecxOut = ecx_100;
			edxOut = edx_101;
			return 0x00;
		}
		else
		{
			word32 ecx_207;
			word32 edx_208;
			fn007239C0(esi_11, out ecx_207, out edx_208);
			Eq_3 ecx_138;
			Eq_68854 edx_139;
			fn006E1210(out ecx_138, out edx_139);
			ecxOut = ecx_138;
			edxOut = edx_139;
			return ~0x00;
		}
	}
	goto l006EC56D;
}

// 006EC890: Register word32 fn006EC890(Stack Eq_3 dwArg04, Register out Eq_54861 edxOut)
// Called from:
//      fn006DE430
//      fn006EC9B0
//      fn006ECAC0
//      fn006F1A70
//      fn006F1AA0
//      fn006F2090
//      fn006FD8F0
//      fn00734B60
//      fn00734BB0
//      fn007367D0
//      fn0073C870
//      fn0074EB10
word32 fn006EC890(Eq_3 dwArg04, union Eq_54861 & edxOut)
{
	Eq_3 esi_11 = *dwArg04;
	if (esi_11 != 0x00)
	{
		Eq_3 eax_15 = *((word32) esi_11 + 4);
		if (eax_15 == 0x00A1B450 || fn006D5670(eax_15, 0x00A1B450, out ecx, out edx) != 0x00)
		{
l006EC8C5:
			if (*((word32) esi_11 + 4) == 0x00A1B450 && *((word32) esi_11 + 16) == 0x00)
			{
				Eq_3 eax_50 = g_tA6C638;
				if (eax_50 == 0x00)
				{
					word32 edx_267;
					word32 ecx_266;
					eax_50 = fn006FDCC0(out ecx_266, out edx_267);
					g_tA6C638 = eax_50;
					if (eax_50 == 0x00)
					{
						word32 ecx_172;
						Eq_54861 edx_173;
						fn006E1160(out ecx_172, out edx_173);
						edxOut = edx_173;
						return ecx_172;
					}
				}
				word32 ecx_151;
				Eq_54861 edx_152;
				Eq_3 eax_85 = fn006FBCC0(eax_50, dwArg04, out ecx_151, out edx_152);
				if (eax_85 != 0x00)
				{
					*eax_85 = (word32) *eax_85 + 1;
					Eq_3 eax_139 = *dwArg04;
					*eax_139 = (word32) *eax_139 - 1;
					Eq_3 eax_142 = *dwArg04;
					if (*eax_142 == 0x00)
					{
						Eq_3 ecx_145 = *((word32) eax_142 + 4);
						(*((word32) ecx_145 + 24))();
					}
					*dwArg04 = eax_85;
					edxOut = edx_152;
					return ecx_151;
				}
				word32 ebx_268;
				word32 edi_269;
				if (fn006FBD90(g_tA6C638, dwArg04, esi_11, out ecx, out edx, out ebx_268, out edi_269) < 0x00)
				{
					word32 ecx_131;
					Eq_54861 edx_132;
					fn006E1160(out ecx_131, out edx_132);
					edxOut = edx_132;
					return ecx_131;
				}
				*esi_11 = (word32) *esi_11 - 2;
				((word32) esi_11 + 16)->u0 = 0x01;
			}
			edxOut = edx;
			return ecx;
		}
	}
	fn006E86F0(0x008D4C0C);
	goto l006EC8C5;
}

// 006EC950: void fn006EC950()
// Called from:
//      fn006E8910
void fn006EC950()
{
	struct Eq_69119 ** esi_35 = g_aA6C640;
	do
	{
		struct Eq_69119 * eax_10 = *esi_35;
		if (eax_10 != null)
		{
			eax_10->dw0000 += ~0x00;
			struct Eq_69119 * eax_16 = *esi_35;
			if (eax_16->dw0000 == 0x00)
			{
				struct Eq_69145 * ecx_19 = eax_16->ptr0004;
				word32 edx_28;
				ecx_19->ptr0018();
			}
		}
		*esi_35 = (struct Eq_69119 **) null;
		esi_35 = (struct Eq_69119 **) ((const char *) esi_35 + 4);
	} while (esi_35 < &g_ptrA6CA40);
	Eq_3 eax_38 = g_tA6C63C;
	if (eax_38 != 0x00)
	{
		word32 v13_45 = (word32) *eax_38 - 1;
		*eax_38 = v13_45;
		if (v13_45 == 0x00)
		{
			Eq_3 ecx_49 = *((word32) eax_38 + 4);
			word32 edx_57;
			(*((word32) ecx_49 + 24))();
		}
	}
	g_tA6C63C.u0 = 0x00;
}

// 006EC9B0: Register Eq_3 fn006EC9B0(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Register out Eq_54866 ecxOut, Register out Eq_67795 edxOut)
// Called from:
//      fn006E9BD0
//      fn007120F0
//      fn007189B0
//      fn0071A060
//      fn0071A9F0
//      fn00726150
//      fn00726930
//      fn00728650
//      fn0072A740
//      fn0072A940
//      fn007367D0
//      fn0073C870
//      fn0073D2A0
//      fn0073D450
//      fn00748470
//      fn0074E0B0
//      fn007533F0
Eq_3 fn006EC9B0(Eq_3 dwArg04, Eq_3 dwArg08, union Eq_54866 & ecxOut, union Eq_67795 & edxOut)
{
	if (dwArg08 == 0x00)
	{
		Eq_3 eax_32 = g_tA6C63C;
		if (eax_32 != 0x00)
		{
			*eax_32 = (word32) *eax_32 + 1;
			ecxOut = ecx;
			edxOut = edx;
			return eax_32;
		}
	}
	else if (dwArg08 == 0x01 && dwArg04 != 0x00)
	{
		Eq_3 eax_21 = *((const char *) g_aA6C640 + (word32) (*dwArg04) * 0x04);
		if (eax_21 != 0x00)
		{
			Mem26[eax_21 + 0x00:word32] = Mem10[eax_21 + 0x00:word32] + dwArg08;
			ecxOut = ecx;
			edxOut = edx;
			return eax_21;
		}
	}
	Eq_54866 ecx_129;
	Eq_67795 edx_133;
	Eq_3 eax_45 = fn00723860((word32) dwArg08 + 24, out ecx_129, out edx_133);
	word24 edx_24_8_235 = SLICE(edx_133, word24, 8);
	if (eax_45 != 0x00)
	{
		*((word32) eax_45 + 8) = dwArg08;
		((word32) eax_45 + 4)->u0 = 0x00A1B450;
		*eax_45 = 0x01;
		((word32) eax_45 + 0x0C)->u0 = ~0x00;
		((word32) eax_45 + 16)->u0 = 0x00;
		if (dwArg04 != 0x00)
		{
			byte * eax_67 = (word32) eax_45 + 20;
			if (dwArg08 >= 0x10)
				memcpy((word32) eax_45 + 20, dwArg04, dwArg08);
			else if (dwArg08 > 0x00)
			{
				ecx_129 = dwArg04 - ((word32) eax_45 + 20);
				Eq_3 ebp_80 = dwArg08;
				do
				{
					byte dl_84 = Mem83[ecx_129 + eax_67:byte];
					*eax_67 = dl_84;
					++eax_67;
					--ebp_80;
					edx_133 = SEQ(edx_24_8_235, dl_84);
				} while (ebp_80 != 0x00);
			}
		}
		*((word32) dwArg08 + ((word32) eax_45 + 20)) = 0x00;
		if (dwArg08 != 0x00)
		{
			if (dwArg08 == 0x01 && dwArg04 != 0x00)
			{
				word32 edx_283;
				ecx_129 = fn006EC890(fp + 0x08, out edx_283);
				edx_133 = (word32) *dwArg04;
				*((const char *) g_aA6C640 + edx_133 * 0x04) = (struct Eq_69119 **) eax_45;
				Mem138[eax_45 + 0x00:word32] = Mem135[eax_45 + 0x00:word32] + dwArg08;
			}
			ecxOut = ecx_129;
			edxOut = edx_133;
			return eax_45;
		}
		else
		{
			Eq_67795 edx_157;
			Eq_54866 ecx_156 = fn006EC890(fp + 0x08, out edx_157);
			*eax_45 = (word32) *eax_45 + 1;
			g_tA6C63C = eax_45;
			ecxOut = ecx_156;
			edxOut = edx_157;
			return eax_45;
		}
	}
	else
	{
		Eq_54866 ecx_181;
		Eq_67795 edx_182;
		Eq_3 eax_180 = fn006E1210(out ecx_181, out edx_182);
		ecxOut = ecx_181;
		edxOut = edx_182;
		return eax_180;
	}
}

// 006ECAC0: Register Eq_3 fn006ECAC0(Stack Eq_3 dwArg04, Register out Eq_3 ecxOut, Register out Eq_53808 edxOut)
// Called from:
//      fn006DDEB0
//      fn006E0F80
//      fn006E11D0
//      fn006E1520
//      fn006E1AB0
//      fn006E1DE0
//      fn006E3900
//      fn006EA080
//      fn006F1A70
//      fn006F2790
//      fn006F6490
//      fn006F8960
//      fn006F92B0
//      fn006FD8B0
//      fn006FD8F0
//      fn006FD950
//      fn006FDCC0
//      fn006FE400
//      fn00703B60
//      fn00703D00
//      fn00717180
//      fn007272E0
//      fn00728BE0
//      fn0072B360
//      fn0072D830
//      fn0072E660
//      fn00731D30
//      fn00738BB0
//      fn0074E140
Eq_3 fn006ECAC0(Eq_3 dwArg04, union Eq_3 & ecxOut, union Eq_53808 & edxOut)
{
	Eq_3 dwLoc04_245 = ecx;
	Eq_3 eax_11 = dwArg04;
	do
	{
		eax_11 = (word32) eax_343 + 1;
		eax_343 = eax_11;
	} while (*eax_343 != 0x00);
	Eq_3 eax_25 = eax_11 - ((word32) dwArg04 + 1);
	if (eax_25 <= 0x7FFFFFFF)
	{
		if (eax_25 == 0x00)
		{
			Eq_3 eax_50 = g_tA6C63C;
			if (eax_50 != 0x00)
			{
				*eax_50 = (word32) *eax_50 + 1;
				ecxOut = ecx;
				edxOut = (word32) dwArg04 + 1;
				return eax_50;
			}
		}
		else if (eax_25 == 0x01)
		{
			Eq_3 eax_36 = *((const char *) g_aA6C640 + (word32) (*dwArg04) * 0x04);
			if (eax_36 != 0x00)
			{
				Mem41[eax_36 + 0x00:word32] = Mem14[eax_36 + 0x00:word32] + eax_25;
				ecxOut = ecx;
				edxOut = (word32) dwArg04 + 1;
				return eax_36;
			}
		}
		word32 ecx_342;
		Eq_53808 edx_150;
		Eq_3 eax_64 = fn00723860((word32) eax_25 + 24, out ecx_342, out edx_150);
		if (eax_64 != 0x00)
		{
			*((word32) eax_64 + 8) = eax_25;
			((word32) eax_64 + 4)->u0 = 0x00A1B450;
			*eax_64 = 0x01;
			((word32) eax_64 + 0x0C)->u0 = ~0x00;
			((word32) eax_64 + 16)->u0 = 0x00;
			byte * eax_101 = (word32) eax_64 + 20;
			if (eax_25 >= 0x0F)
				memcpy((word32) eax_64 + 20, dwArg04, (word32) eax_25 + 1);
			else if (eax_25 > 0x01)
			{
				edx_150 = dwArg04 - ((word32) eax_64 + 20);
				up32 ebp_106 = (word32) eax_25 + 1;
				do
				{
					Mem104[eax_101 + 0x00:byte] = Mem102[edx_150 + eax_101:byte];
					++eax_101;
					--ebp_106;
				} while (ebp_106 != 0x00);
			}
			if (eax_25 != 0x00)
			{
				if (eax_25 == 0x01)
				{
					fn006EC890(fp - 0x04, out edx_150);
					*((const char *) g_aA6C640 + (word32) (*dwArg04) * 0x04) = (struct Eq_69119 **) eax_64;
					Mem158[eax_64 + 0x00:word32] = Mem155[eax_64 + 0x00:word32] + eax_25;
					dwLoc04_245 = eax_64;
				}
				ecxOut = dwLoc04_245;
				edxOut = edx_150;
				return eax_64;
			}
			else
			{
				Eq_53808 edx_180;
				fn006EC890(fp - 0x04, out edx_180);
				*eax_64 = (word32) *eax_64 + 1;
				g_tA6C63C = eax_64;
				ecxOut = eax_64;
				edxOut = edx_180;
				return eax_64;
			}
		}
		else
		{
			Eq_3 ecx_207;
			Eq_53808 edx_209;
			Eq_3 eax_208 = fn006E1210(out ecx_207, out edx_209);
			ecxOut = ecx_207;
			edxOut = edx_209;
			return eax_208;
		}
	}
	else
	{
		Eq_53808 edx_232;
		word32 ecx_341;
		fn006E0F80(g_tA18598, 9260092, out ecx_341, out edx_232);
		ecxOut = ecx;
		edxOut = edx_232;
		return 0x00;
	}
}

// 006ECC00: Register Eq_3 fn006ECC00(Stack Eq_3 dwArg04)
// Called from:
//      fn006E5C60
//      fn006F7890
//      fn0071A9F0
//      fn00726930
//      fn00735550
//      fn00735640
//      fn0073D2A0
//      fn00755020
Eq_3 fn006ECC00(Eq_3 dwArg04)
{
	Eq_3 eax_11 = *((word32) dwArg04 + 4);
	if (eax_11 == 0x00A1B450)
		return *((word32) dwArg04 + 8);
	word32 ecx_106;
	word32 edx_107;
	if (fn006D5670(eax_11, 0x00A1B450, out ecx_106, out edx_107) != 0x00)
		return *((word32) dwArg04 + 8);
	word32 edx_108;
	if (fn006EA420(dwArg04, fp - 0x04, fp + 0x04, out edx_108) == 0x00)
		return dwArg04;
	return ~0x00;
}

// 006ECC50: Register Eq_69544 fn006ECC50(Stack Eq_3 dwArg04, Register out Eq_540 ecxOut, Register out ptr32 edxOut, Register out Eq_540 esiOut)
// Called from:
//      fn00656570
//      fn00657140
//      fn006E1780
//      fn006E7D90
//      fn006E8060
//      fn006E8430
//      fn006F2090
//      fn006F7890
//      fn006FE400
//      fn00707750
//      fn00707950
//      fn007081C0
//      fn007083E0
//      fn0070B600
//      fn0070BCC0
//      fn00717280
//      fn007173A0
//      fn00726150
//      fn00726930
//      fn0072F830
//      fn0072FB30
//      fn00735550
//      fn0073D2A0
//      fn00748190
//      fn00752B30
//      fn007533F0
//      fn007537F0
//      fn00753A60
//      fn00755020
Eq_69544 fn006ECC50(Eq_3 dwArg04, union Eq_540 & ecxOut, ptr32 & edxOut, union Eq_540 & esiOut)
{
	Eq_3 eax_11 = *((word32) dwArg04 + 4);
	if (eax_11 != 0x00A1B450)
	{
		word32 ecx_103;
		if (fn006D5670(eax_11, 0x00A1B450, out ecx_103, out edx) == 0x00)
		{
			ptr32 edx_49;
			Eq_69544 eax_56 = ~(0x00 - (fn006EA420(dwArg04, fp + 0x04, fp - 0x04, out edx_49) == 0x00)) & dwArg04;
			ecxOut.u0 = <invalid>;
			edxOut = edx_49;
			esiOut.u0 = <invalid>;
			return eax_56;
		}
	}
	ecxOut.u0 = <invalid>;
	edxOut = edx;
	esiOut.u0 = <invalid>;
	return (word32) dwArg04 + 20;
}

<anonymous> g_t6ED090 = <code>; // 006ED090
